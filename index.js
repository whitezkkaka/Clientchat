import makeWASocket from 'whaileys';
import {
  downloadContentFromMessage,
  generateWAMessageFromContent,
  generateWAMessage,
  getContentType,
  useMultiFileAuthState,
  DisconnectReason,
  fetchLatestBaileysVersion,
  makeCacheableSignalKeyStore
} from 'whaileys';
import { exec, execSync, spawn } from 'child_process';
import { promisify } from 'util';

const execAsync = promisify(exec);
import { parseHTML } from 'linkedom';
import axios from 'axios';
import pathz from 'path';
import fs from 'fs';
import os from 'os';
import https from 'https';
import crypto from 'crypto';
import cron from 'node-cron';
import { fileURLToPath } from 'url';

import { PerformanceOptimizer, getPerformanceOptimizer } from './utils/performanceOptimizer.js';
import { recalcEquipmentBonuses } from './utils/equipment.js';
import * as ia from './funcs/private/ia.js';
import * as vipCommandsManager from './utils/vipCommandsManager.js';
import { getInfo as gdriveGetInfo } from './funcs/utils/gdrive.js';
import { getInfo as mediafireGetInfo } from './funcs/utils/mediafire.js';
import { getInfo as twitterGetInfo } from './funcs/utils/twitter.js';
import { search, searchNews } from './funcs/utils/search.js';
import { removeBg, upscale } from './funcs/utils/imagetools.js';
import spotifyModule from './funcs/downloads/spotify.js';
import captchaIndex, { initCaptchaIndex, addCaptcha, removeCaptcha, getCaptcha, hasPendingCaptcha } from './utils/captchaIndex.js';
import fsPromises from 'fs/promises';
import {
  formatUptime,
  normalizar,
  isGroupId,
  isUserId,
  isValidLid,
  isValidJid,
  getUserName,
  getLidFromJid,
  buildUserId,
  getBotId,
  ensureDirectoryExists,
  ensureJsonFileExists,
  loadJsonFile,
  initJidLidCache,
  saveJidLidCache,
  getLidFromJidCached,
  normalizeUserId,
  convertIdsToLid,
  idsMatch,
  idInArray
} from './utils/helpers.js';
import {
  loadMsgPrefix,
  saveMsgPrefix,
  loadMsgBotOn,
  saveMsgBotOn,
  loadCmdNotFoundConfig,
  saveCmdNotFoundConfig,
  validateMessageTemplate,
  formatMessageWithFallback,
  loadCustomReacts,
  saveCustomReacts,
  loadReminders,
  saveReminders,
  addCustomReact,
  deleteCustomReact,
  loadDivulgacao,
  saveDivulgacao,
  loadDonoDivulgacao,
  saveDonoDivulgacao,
  loadSubdonos,
  saveSubdonos,
  isSubdono,
  addSubdono,
  removeSubdono,
  getSubdonos,
  loadRentalData,
  saveRentalData,
  isRentalModeActive,
  setRentalMode,
  getGroupRentalStatus,
  setGroupRental,
  loadActivationCodes,
  saveActivationCodes,
  generateActivationCode,
  validateActivationCode,
  useActivationCode,
  extendGroupRental,
  isModoLiteActive,
  loadParceriasData,
  saveParceriasData,
  calculateNextLevelXp,
  getPatent,
  loadEconomy,
  saveEconomy,
  getEcoUser,
  parseAmount,
  fmt,
  timeLeft,
  applyShopBonuses,
  PICKAXE_TIER_MULT,
  PICKAXE_TIER_ORDER,
  SHOP_ITEMS,
  getActivePickaxe,
  ensureEconomyDefaults,
  giveMaterial,
  generateDailyChallenge,
  ensureUserChallenge,
  updateChallenge,
  isChallengeCompleted,
  updateQuestProgress,
  diagnosticDatabase,
  SKILL_LIST,
  ensureUserSkills,
  skillXpForNext,
  addSkillXP,
  getSkillBonus,
  endOfWeekTimestamp,
  endOfMonthTimestamp,
  generateWeeklyChallenge,
  generateMonthlyChallenge,
  ensureUserPeriodChallenges,
  updatePeriodChallenge,
  isPeriodCompleted,
  checkLevelUp,
  checkLevelDown,
  loadCustomAutoResponses,
  saveCustomAutoResponses,
  loadGroupAutoResponses,
  saveGroupAutoResponses,
  addAutoResponse,
  deleteAutoResponse,
  processAutoResponse,
  sendAutoResponse,
  loadCustomCommands,
  saveCustomCommands,
  removeCustomCommand,
  findCustomCommand,
  loadNoPrefixCommands,
  saveNoPrefixCommands,
  loadCommandAliases,
  saveCommandAliases,
  loadGlobalBlacklist,
  saveGlobalBlacklist,
  addGlobalBlacklist,
  removeGlobalBlacklist,
  getGlobalBlacklist,
  loadMenuDesign,
  saveMenuDesign,
  getMenuDesignWithDefaults,
  setSupportMode,
  findSupportTicketById,
  createSupportTicket,
  acceptSupportTicket,
  loadCommandLimits,
  saveCommandLimits,
  addCommandLimit,
  removeCommandLimit,
  getCommandLimits,
  checkCommandLimit,
  formatTimeLeft,
  runDatabaseSelfTest,
  // Fun√ß√µes de seguran√ßa
  loadJsonFileSafe,
  saveJsonFileSafe,
  loadLevelingSafe,
  saveLevelingSafe,
  getLevelingUser,
  validateLevelingUser,
  validateEconomyUser,
  // Fun√ß√µes de normaliza√ß√£o de par√¢metros
  normalizeParam,
  compareParams,
  findKeyIgnoringAccents,
  matchParam,
  resolveParamAlias,
  // Sistema de Personaliza√ß√£o de Grupo
  loadGroupCustomization,
  isGroupCustomizationEnabled,
  setGroupCustomizationEnabled,
  getGroupCustomization,
  setGroupCustomName,
  setGroupCustomPhoto,
  removeGroupCustomName,
  removeGroupCustomPhoto,
  // Sistema de √Åudio do Menu
  loadMenuAudio,
  isMenuAudioEnabled,
  getMenuAudioPath,
  setMenuAudio,
  removeMenuAudio,
  // Sistema de Ler Mais do Menu
  isMenuLerMaisEnabled,
  setMenuLerMais,
  getMenuLerMaisText
} from './utils/database.js';
import { parseCustomCommandMeta, buildUsageFromParams, parseArgsFromString, escapeRegExp, validateParamValue } from './utils/helpers.js';
import {
  PACKAGE_JSON_PATH,
  CONFIG_FILE,
  DATABASE_DIR,
  GRUPOS_DIR,
  USERS_DIR,
  DONO_DIR,
  PARCERIAS_DIR,
  TMP_DIR,
  LEVELING_FILE,
  CUSTOM_AUTORESPONSES_FILE,
  DIVULGACAO_FILE,
  NO_PREFIX_COMMANDS_FILE,
  COMMAND_ALIASES_FILE,
  GLOBAL_BLACKLIST_FILE,
  MENU_DESIGN_FILE,
  ECONOMY_FILE,
  MSGPREFIX_FILE,
  CUSTOM_REACTS_FILE,
  REMINDERS_FILE,
  CMD_NOT_FOUND_FILE,
  ANTIFLOOD_FILE,
  ANTIPV_FILE,
  GLOBAL_BLOCKS_FILE,
  CMD_LIMIT_FILE,
  CMD_USER_LIMITS_FILE,
  ANTISPAM_FILE,
  BOT_STATE_FILE,
  AUTO_HORARIOS_FILE,
  AUTO_MENSAGENS_FILE,
  MODO_LITE_FILE,
  JID_LID_CACHE_FILE,
  MASS_MENTION_LIMIT_FILE,
  MASS_MENTION_CONFIG_FILE
} from './utils/paths.js';

const __filename = fileURLToPath(import.meta.url);
const __dirname = pathz.dirname(__filename);
const OWNER_ONLY_MESSAGE = 'üö´ Este comando √© apenas para o dono do bot!';

// Fun√ß√£o para formatar respostas de IA para WhatsApp (converte ** para *)
const formatAIResponse = (text) => {
  if (!text || typeof text !== 'string') return text;
  return text
    .replace(/\*\*\*([^*]+)\*\*\*/g, '*$1*')  // ***text*** -> *text*
    .replace(/\*\*([^*]+)\*\*/g, '*$1*')      // **text** -> *text*
    .replace(/_{2,}([^_]+)_{2,}/g, '_$1_')    // __text__ -> _text_
    .replace(/```[\s\S]*?```/g, '')           // Remove blocos de c√≥digo
    .replace(/`([^`]+)`/g, '$1')              // Remove inline code
    .replace(/^#{1,6}\s+/gm, '')              // Remove headers markdown
    .replace(/\n{3,}/g, '\n\n')               // Limita quebras de linha
    .trim();
};

const writeJsonFile = (filePath, data) => {
  try {
    // Valida√ß√£o de entrada
    if (data === undefined || data === null) {
      console.error(`‚ùå writeJsonFile: Tentativa de salvar dados nulos em ${filePath}`);
      return false;
    }
    
    // Testa se dados s√£o serializ√°veis
    let jsonString;
    try {
      jsonString = JSON.stringify(data, null, 2);
    } catch (stringifyError) {
      console.error(`‚ùå writeJsonFile: Dados n√£o serializ√°veis para ${filePath}:`, stringifyError.message);
      return false;
    }
    
    // Valida JSON gerado
    try {
      JSON.parse(jsonString);
    } catch (validateError) {
      console.error(`‚ùå writeJsonFile: JSON inv√°lido gerado para ${filePath}`);
      return false;
    }
    
    ensureDirectoryExists(pathz.dirname(filePath));
    
    // Escreve em arquivo tempor√°rio primeiro (opera√ß√£o at√¥mica)
    const tempPath = filePath + '.tmp';
    fs.writeFileSync(tempPath, jsonString, 'utf-8');
    
    // Verifica integridade do arquivo tempor√°rio
    try {
      const writtenContent = fs.readFileSync(tempPath, 'utf-8');
      JSON.parse(writtenContent);
    } catch (verifyError) {
      console.error(`‚ùå writeJsonFile: Verifica√ß√£o falhou para ${filePath}`);
      try { fs.unlinkSync(tempPath); } catch (e) {}
      return false;
    }
    
    // Move arquivo tempor√°rio para destino (at√¥mico)
    fs.renameSync(tempPath, filePath);
    return true;
  } catch (error) {
    console.error(`‚ùå Erro ao escrever JSON em ${filePath}:`, error.message);
    // Tenta limpar arquivo tempor√°rio
    try {
      const tempPath = filePath + '.tmp';
      if (fs.existsSync(tempPath)) fs.unlinkSync(tempPath);
    } catch (e) {}
    return false;
  }
};

/**
 * Vers√£o ass√≠ncrona do writeJsonFile - n√£o bloqueia o event loop
 * @param {string} filePath - Caminho do arquivo
 * @param {object} data - Dados a serem salvos
 * @returns {Promise<boolean>}
 */
const writeJsonFileAsync = async (filePath, data) => {
  try {
    if (data === undefined || data === null) {
      console.error(`‚ùå writeJsonFileAsync: Tentativa de salvar dados nulos em ${filePath}`);
      return false;
    }
    
    let jsonString;
    try {
      jsonString = JSON.stringify(data, null, 2);
    } catch (stringifyError) {
      console.error(`‚ùå writeJsonFileAsync: Dados n√£o serializ√°veis para ${filePath}:`, stringifyError.message);
      return false;
    }
    
    // Valida JSON gerado
    try {
      JSON.parse(jsonString);
    } catch (validateError) {
      console.error(`‚ùå writeJsonFileAsync: JSON inv√°lido gerado para ${filePath}`);
      return false;
    }
    
    await fsPromises.mkdir(pathz.dirname(filePath), { recursive: true });
    
    // Escreve em arquivo tempor√°rio primeiro (opera√ß√£o at√¥mica)
    const tempPath = filePath + '.tmp';
    await fsPromises.writeFile(tempPath, jsonString, 'utf-8');
    
    // Verifica integridade
    try {
      const writtenContent = await fsPromises.readFile(tempPath, 'utf-8');
      JSON.parse(writtenContent);
    } catch (verifyError) {
      console.error(`‚ùå writeJsonFileAsync: Verifica√ß√£o falhou para ${filePath}`);
      try { await fsPromises.unlink(tempPath); } catch (e) {}
      return false;
    }
    
    // Move arquivo tempor√°rio para destino (at√¥mico)
    await fsPromises.rename(tempPath, filePath);
    return true;
  } catch (error) {
    console.error(`‚ùå Erro ao escrever JSON async em ${filePath}:`, error.message);
    try {
      const tempPath = filePath + '.tmp';
      await fsPromises.unlink(tempPath).catch(() => {});
    } catch (e) {}
    return false;
  }
};

/**
 * Leitura ass√≠ncrona de arquivo JSON
 * @param {string} filePath - Caminho do arquivo
 * @param {object} defaultValue - Valor padr√£o se arquivo n√£o existir
 * @returns {Promise<object>}
 */
const readJsonFileAsync = async (filePath, defaultValue = {}) => {
  try {
    const content = await fsPromises.readFile(filePath, 'utf-8');
    return JSON.parse(content);
  } catch (error) {
    if (error.code !== 'ENOENT') {
      console.error(`‚ùå Erro ao ler JSON async de ${filePath}:`, error.message);
    }
    return defaultValue;
  }
};

/**
 * Verifica se arquivo existe (ass√≠ncrono)
 * @param {string} filePath - Caminho do arquivo
 * @returns {Promise<boolean>}
 */
const fileExistsAsync = async (filePath) => {
  try {
    await fsPromises.access(filePath);
    return true;
  } catch {
    return false;
  }
};

// ==================== PROTE√á√ÉO ANTI-BAN: Rate Limit para Men√ß√µes em Massa ====================
// Sistema controlado pelo dono: pode ativar/desativar prote√ß√£o por grupo
const MASS_MENTION_THRESHOLD = 150; // Membros m√≠nimos para aplicar prote√ß√£o (quando ativa)
const MASS_MENTION_MAX_USES = 2;    // M√°ximo de usos permitidos
const MASS_MENTION_COOLDOWN = 5 * 60 * 60 * 1000; // 5 horas em milissegundos

// Cache em mem√≥ria para rate limit (persistido em arquivo)
let massMentionLimitCache = null;
let massMentionConfigCache = null;

const loadMassMentionConfig = () => {
  if (massMentionConfigCache) return massMentionConfigCache;
  try {
    if (fs.existsSync(MASS_MENTION_CONFIG_FILE)) {
      massMentionConfigCache = JSON.parse(fs.readFileSync(MASS_MENTION_CONFIG_FILE, 'utf-8'));
    } else {
      massMentionConfigCache = {}; // Vazio = desativado por padr√£o
    }
  } catch (e) {
    console.error('Erro ao carregar massMentionConfig:', e.message);
    massMentionConfigCache = {};
  }
  return massMentionConfigCache;
};

const saveMassMentionConfig = (data) => {
  massMentionConfigCache = data;
  try {
    ensureDirectoryExists(pathz.dirname(MASS_MENTION_CONFIG_FILE));
    fs.writeFileSync(MASS_MENTION_CONFIG_FILE, JSON.stringify(data, null, 2), 'utf-8');
  } catch (e) {
    console.error('Erro ao salvar massMentionConfig:', e.message);
  }
};

const loadMassMentionLimit = () => {
  if (massMentionLimitCache) return massMentionLimitCache;
  try {
    if (fs.existsSync(MASS_MENTION_LIMIT_FILE)) {
      massMentionLimitCache = JSON.parse(fs.readFileSync(MASS_MENTION_LIMIT_FILE, 'utf-8'));
    } else {
      massMentionLimitCache = {};
    }
  } catch (e) {
    console.error('Erro ao carregar massMentionLimit:', e.message);
    massMentionLimitCache = {};
  }
  return massMentionLimitCache;
};

const saveMassMentionLimit = (data) => {
  massMentionLimitCache = data;
  try {
    ensureDirectoryExists(pathz.dirname(MASS_MENTION_LIMIT_FILE));
    fs.writeFileSync(MASS_MENTION_LIMIT_FILE, JSON.stringify(data, null, 2), 'utf-8');
  } catch (e) {
    console.error('Erro ao salvar massMentionLimit:', e.message);
  }
};

/**
 * Verifica se o grupo pode usar comandos de men√ß√£o em massa
 * @param {string} groupId - ID do grupo
 * @param {number} memberCount - N√∫mero de membros do grupo
 * @returns {{ allowed: boolean, remainingUses: number, resetTime: number|null, message: string|null }}
 */
const checkMassMentionLimit = (groupId, memberCount) => {
  // Verifica se a prote√ß√£o est√° ativada para este grupo
  const config = loadMassMentionConfig();
  if (!config[groupId] || !config[groupId].enabled) {
    return { allowed: true, remainingUses: -1, resetTime: null, message: null };
  }
  
  // Se grupo tem menos de 150 membros, n√£o aplica limite mesmo se ativo
  if (memberCount < MASS_MENTION_THRESHOLD) {
    return { allowed: true, remainingUses: -1, resetTime: null, message: null };
  }

  const data = loadMassMentionLimit();
  const now = Date.now();
  
  // Inicializa dados do grupo se n√£o existir
  if (!data[groupId]) {
    data[groupId] = { uses: [], lastReset: now };
  }
  
  const groupData = data[groupId];
  
  // Remove usos antigos (mais de 5 horas)
  groupData.uses = groupData.uses.filter(timestamp => (now - timestamp) < MASS_MENTION_COOLDOWN);
  
  // Verifica se atingiu o limite
  if (groupData.uses.length >= MASS_MENTION_MAX_USES) {
    const oldestUse = Math.min(...groupData.uses);
    const resetTime = oldestUse + MASS_MENTION_COOLDOWN;
    const timeLeft = resetTime - now;
    const hours = Math.floor(timeLeft / (60 * 60 * 1000));
    const minutes = Math.floor((timeLeft % (60 * 60 * 1000)) / (60 * 1000));
    
    return {
      allowed: false,
      remainingUses: 0,
      resetTime: resetTime,
      message: `‚ö†Ô∏è *Prote√ß√£o Anti-Ban Ativada pelo Dono*\n\n` +
               `Este grupo tem ${memberCount} membros. Para evitar banimento do n√∫mero do bot pela Meta, ` +
               `o dono ativou uma prote√ß√£o que limita comandos de marca√ß√£o em massa a *${MASS_MENTION_MAX_USES} usos a cada 5 horas*.\n\n` +
               `‚è∞ Pr√≥ximo uso dispon√≠vel em: *${hours}h ${minutes}min*`
    };
  }
  
  saveMassMentionLimit(data);
  
  return {
    allowed: true,
    remainingUses: MASS_MENTION_MAX_USES - groupData.uses.length,
    resetTime: null,
    message: null
  };
};

/**
 * Registra um uso de men√ß√£o em massa
 * @param {string} groupId - ID do grupo
 */
const registerMassMentionUse = (groupId) => {
  const data = loadMassMentionLimit();
  const now = Date.now();
  
  if (!data[groupId]) {
    data[groupId] = { uses: [], lastReset: now };
  }
  
  // Remove usos antigos antes de adicionar novo
  data[groupId].uses = data[groupId].uses.filter(timestamp => (now - timestamp) < MASS_MENTION_COOLDOWN);
  data[groupId].uses.push(now);
  
  saveMassMentionLimit(data);
};

// ==================== FIM: Prote√ß√£o Anti-Ban ====================

let performanceOptimizerInstance = null;
let performanceOptimizerInitPromise = null;

async function initializePerformanceOptimizer() {
  if (performanceOptimizerInstance) {
    return performanceOptimizerInstance;
  }

  if (!performanceOptimizerInitPromise) {
    performanceOptimizerInitPromise = (async () => {
      try {
        const instance = new PerformanceOptimizer();
        await instance.initialize();
        performanceOptimizerInstance = instance;
        return instance;
      } catch (error) {
        console.error('Falha ao inicializar PerformanceOptimizer:', error.message || error);
        performanceOptimizerInstance = null;
        return null;
      }
    })();
  }

  const instance = await performanceOptimizerInitPromise;
  if (!instance) {
    performanceOptimizerInitPromise = null;
  }
  return instance;
}

initializePerformanceOptimizer().catch(err => {
  console.error('Erro inesperado ao iniciar PerformanceOptimizer:', err.message || err);
});

let databaseSelfTestResult = null;
const ensureDatabaseIntegrity = ({ log = false, force = false } = {}) => {
  if (force || log || !databaseSelfTestResult) {
    databaseSelfTestResult = runDatabaseSelfTest({ log });
  }

  if (log && databaseSelfTestResult && !databaseSelfTestResult.ok) {
    const summary = databaseSelfTestResult.results
      .filter(result => !result.ok)
      .map(result => `${result.name}: ${result.issues.join('; ')}`)
      .join(' | ');

    if (summary) {
      console.warn(`‚ö†Ô∏è Inconsist√™ncias em arquivos de banco de dados: ${summary}`);
    }
  }

  return databaseSelfTestResult;
};

ensureDatabaseIntegrity();

const buildGroupFilePath = (groupId) => pathz.join(GRUPOS_DIR, `${groupId}.json`);


let packageJson = {};
try {
  packageJson = JSON.parse(fs.readFileSync(PACKAGE_JSON_PATH, 'utf-8'));
} catch (e) {
  console.error('Erro ao ler package.json:', e.message);
}
const botVersion = packageJson.version;

// Inicializa o cache JID‚ÜíLID
initJidLidCache(JID_LID_CACHE_FILE);

// Salva cache periodicamente (a cada 5 minutos)
setInterval(() => {
  saveJidLidCache();
}, 5 * 60 * 1000);
  
async function NazuninhaBotExec(nazu, info, store, messagesCache, rentalExpirationManager = null) {
  // Log de in√≠cio de processamento para debug paralelo
  const msgId = info?.key?.id?.slice(-6) || 'unknown';
  const from = info?.key?.remoteJid || 'unknown';

  let config = loadJsonFile(CONFIG_FILE, {});
  ensureDatabaseIntegrity({ log: Boolean(config?.debug) });
  
  // Verifica√ß√£o e corre√ß√£o do prefixo reservado $ ao inicializar
  if (config.prefixo === '$') {
    config.prefixo = '/';
    writeJsonFile(CONFIG_FILE, config);
    
    // Notifica o dono sobre a mudan√ßa autom√°tica
    const ownerJid = `${config.numerodono}@s.whatsapp.net`;
    try {
      await nazu.sendMessage(ownerJid, {
        text: `‚ö†Ô∏è *PREFIXO AUTOM√ÅTICO CORRIGIDO*\n\n‚ùå O s√≠mbolo "$" √© reservado e n√£o pode ser usado como prefixo.\n\n‚úÖ O prefixo foi alterado automaticamente para "/" ao iniciar o bot.\n\nüí° Use ${config.prefixo}prefix para alterar para outro s√≠mbolo v√°lido.`
      });
    } catch (notifyError) {
      console.log('Aviso: N√£o foi poss√≠vel notificar o dono sobre a mudan√ßa de prefixo:', notifyError.message);
    }
  }
  
  // Log de debug aprimorado para rastreamento de IDs
  const debugLog = (msg, data = null) => {
    if (config?.debug) {
      console.log(`[DEBUG] ${msg}`, data || '');
    }
  };

  const normalizeMessageTimestamp = (timestamp) => {
    if (!timestamp) return null;
    if (typeof timestamp === 'number') return timestamp;
    if (typeof timestamp === 'string') {
      const parsed = Number(timestamp);
      return Number.isFinite(parsed) ? parsed : null;
    }
    if (typeof timestamp === 'object') {
      if (typeof timestamp.toNumber === 'function') return timestamp.toNumber();
      if (typeof timestamp.low === 'number') return timestamp.low;
    }
    return null;
  };

  const getLastMessageInChat = (jid) => {
    if (!messagesCache || messagesCache.size === 0) return null;

    let lastMsg = null;
    let lastTimestamp = 0;

    for (const cachedMsg of messagesCache.values()) {
      if (!cachedMsg?.key?.remoteJid || cachedMsg.key.remoteJid !== jid) continue;
      const ts = normalizeMessageTimestamp(cachedMsg.messageTimestamp);
      if (!ts) continue;

      if (!lastMsg || ts > lastTimestamp) {
        lastMsg = cachedMsg;
        lastTimestamp = ts;
      }
    }

    if (!lastMsg?.key || !lastTimestamp) return null;
    return {
      key: lastMsg.key,
      messageTimestamp: lastTimestamp
    };
  };

  const deleteChatByLastMessage = async (jid) => {
    if (!nazu?.chatModify) return false;

    const lastMsgInChat = getLastMessageInChat(jid);
    if (lastMsgInChat?.key && lastMsgInChat?.messageTimestamp) {
      await nazu.chatModify({
        delete: true,
        lastMessages: [
          {
            key: lastMsgInChat.key,
            messageTimestamp: lastMsgInChat.messageTimestamp
          }
        ]
      }, jid);
      return true;
    }

    await nazu.chatModify({ delete: true }, jid);
    return true;
  };

  const clearChatHistorySafe = async (jid) => {
    if (!nazu?.chatModify) return false;
    try {
      await nazu.chatModify({ clear: 'all' }, jid);
      return true;
    } catch (e) {
      if (typeof e?.message === 'string' && e.message.toLowerCase().includes('not supported')) {
        await deleteChatByLastMessage(jid);
        return true;
      }
      throw e;
    }
  };
  
  async function getCachedGroupMetadata(groupId) {
    try {
      const optimizer = await initializePerformanceOptimizer();
      if (optimizer?.modules?.cacheManager) {
        const cached = await optimizer.modules.cacheManager.getIndexGroupMeta(groupId);
        if (cached) {
          return cached;
        }

        const freshData = await nazu.groupMetadata(groupId).catch(() => ({}));
        await optimizer.modules.cacheManager.setIndexGroupMeta(groupId, freshData);
        return freshData;
      }

      return await nazu.groupMetadata(groupId).catch(() => ({}));
    } catch (error) {
      return await nazu.groupMetadata(groupId).catch(() => ({}));
    }
  }

  const numerodono = config.numerodono;
  const nomedono = config.nomedono;
  const nomebot = config.nomebot;
  const prefixo = config.prefixo;
  const debug = config.debug;
  const lidowner = config.lidowner;

  // Sistema de degrada√ß√£o autom√°tica de pets
  function applyPetDegradation(pets) {
    if (!Array.isArray(pets) || pets.length === 0) return { changed: false };
    
    const now = Date.now();
    const oneHour = 3600000; // 1 hora em ms
    const oneDayInHours = 24; // Degrada√ß√£o total em 24 horas se n√£o cuidar
    
    let changed = false;
    
    pets.forEach(pet => {
      // Inicializa lastUpdate se n√£o existir
      if (!pet.lastUpdate) {
        pet.lastUpdate = now;
        changed = true;
        return;
      }
      
      const timePassed = now - pet.lastUpdate;
      const hoursPassed = timePassed / oneHour;
      
      // S√≥ degrada se passou mais de 1 hora
      if (hoursPassed >= 1) {
        // Calcula degrada√ß√£o proporcional ao tempo
        const hungerDegrade = Math.floor(hoursPassed * (100 / oneDayInHours)); // ~4.17 por hora
        const moodDegrade = Math.floor(hoursPassed * (100 / (oneDayInHours * 2))); // ~2.08 por hora (degrada mais devagar)
        
        // Aplica degrada√ß√£o
        const oldHunger = pet.hunger || 100;
        const oldMood = pet.mood || 100;
        
        pet.hunger = Math.max(0, oldHunger - hungerDegrade);
        pet.mood = Math.max(0, oldMood - moodDegrade);
        
        // Se fome est√° muito baixa, humor degrada mais r√°pido
        if (pet.hunger < 30) {
          pet.mood = Math.max(0, pet.mood - Math.floor(hoursPassed * 5));
        }
        
        // Se fome chegou a 0, pet perde HP gradualmente
        if (pet.hunger === 0 && hoursPassed >= 2) {
          const hpLoss = Math.floor(hoursPassed * (pet.maxHp * 0.02)); // 2% do HP m√°ximo por hora
          pet.hp = Math.max(1, (pet.hp || pet.maxHp) - hpLoss); // Nunca deixa morrer (m√≠nimo 1 HP)
        }
        
        // Atualiza timestamp
        pet.lastUpdate = now;
        changed = true;
      }
    });
    
    return { changed };
  }

  // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
  // FUN√á√ïES AUXILIARES DO SISTEMA RPG
  // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê

  // Multiplicadores de picareta por tier
  const PICKAXE_TIER_MULT = {
    'bronze': 1.0,
    'ferro': 1.5,
    'diamante': 2.5
  };

  // Formata valores monet√°rios
  function fmt(num) {
    if (!isFinite(num) || num == null) return '0';
    const n = Math.floor(num);
    return n.toString().replace(/\B(?=(\d{3})+(?!\d))/g, '.');
  }

  // Calcula tempo restante de cooldown
  function timeLeft(timestamp) {
    const diff = Math.max(0, timestamp - Date.now());
    const mins = Math.floor(diff / 60000);
    const secs = Math.floor((diff % 60000) / 1000);
    if (mins > 0) return `${mins}min ${secs}s`;
    return `${secs}s`;
  }

  // Parse de quantidade (suporta "all", "max", "tudo", etc)
  function parseAmount(str, max) {
    if (!str) return 0;
    const s = str.toString().toLowerCase().trim();
    if (['all', 'tudo', 'max', 'todo', 'todos'].includes(s)) {
      return Math.floor(max);
    }
    const num = parseFloat(s.replace(/[^\d.-]/g, ''));
    return isFinite(num) ? Math.max(0, Math.floor(num)) : 0;
  }

  // Obt√©m picareta ativa do usu√°rio
  function getActivePickaxe(user) {
    if (!user || !user.tools || !user.tools.pickaxe) return null;
    const pk = user.tools.pickaxe;
    // Verifica se n√£o est√° quebrada
    if (pk.dur <= 0) return null;
    return pk;
  }

  // Aplica b√¥nus de itens da loja
  function applyShopBonuses(user, econ) {
    let mineBonus = 0;
    let workBonus = 0;
    let bankCapacity = 10000; // Capacidade padr√£o
    let fishBonus = 0;
    let exploreBonus = 0;
    let huntBonus = 0;
    let forgeBonus = 0;

    // Verifica itens no invent√°rio
    for (const [itemKey, qty] of Object.entries(user.inventory || {})) {
      if (qty <= 0) continue;
      const item = econ.shop?.[itemKey];
      if (!item || !item.effect) continue;

      // Aplica efeitos dos itens (multiplicando pela quantidade)
      if (item.effect.mineBonus) mineBonus += item.effect.mineBonus * qty;
      if (item.effect.workBonus) workBonus += item.effect.workBonus * qty;
      if (item.effect.bankCapacity) bankCapacity += item.effect.bankCapacity * qty;
      if (item.effect.fishBonus) fishBonus += item.effect.fishBonus * qty;
      if (item.effect.exploreBonus) exploreBonus += item.effect.exploreBonus * qty;
      if (item.effect.huntBonus) huntBonus += item.effect.huntBonus * qty;
      if (item.effect.forgeBonus) forgeBonus += item.effect.forgeBonus * qty;
    }

    // Verifica ferramenta equipada (picareta)
    if (user.tools?.pickaxe) {
      const pk = user.tools.pickaxe;
      const pkItem = econ.shop?.[pk.key];
      if (pkItem?.effect) {
        if (pkItem.effect.mineBonus) mineBonus += pkItem.effect.mineBonus;
      }
    }

    return {
      mineBonus,
      workBonus,
      bankCapacity,
      fishBonus,
      exploreBonus,
      huntBonus,
      forgeBonus
    };
  }

  // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
  // FIM DAS FUN√á√ïES AUXILIARES DO RPG
  // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê


  async function handleAutoDownload(nazu, from, url, info) {
    try {
      
      // Detectar tipo de URL e usar o m√≥dulo espec√≠fico
      const urlLower = url.toLowerCase();
      let downloadModule = null;
      let platformName = '';
      
      // YouTube
      if (urlLower.includes('youtube.com') || urlLower.includes('youtu.be')) {
        downloadModule = youtube;
        platformName = 'YouTube';
      }
      // TikTok
      else if (urlLower.includes('tiktok.com') || urlLower.includes('vt.tiktok.com')) {
        downloadModule = tiktok;
        platformName = 'TikTok';
      }
      // Instagram
      else if (urlLower.includes('instagram.com') || urlLower.includes('instagr.am')) {
        downloadModule = igdl;
        platformName = 'Instagram';
      }
      // Facebook
      else if (urlLower.includes('facebook.com') || urlLower.includes('fb.watch')) {
        downloadModule = facebook;
        platformName = 'Facebook';
      }
      // Pinterest
      else if (urlLower.includes('pinterest.com') || urlLower.includes('pin.it')) {
        downloadModule = pinterest;
        platformName = 'Pinterest';
      }
      // Spotify
      else if (urlLower.includes('spotify.com') || urlLower.includes('open.spotify.com')) {
        downloadModule = spotify;
        platformName = 'Spotify';
      }
      // SoundCloud
      else if (urlLower.includes('soundcloud.com')) {
        downloadModule = soundcloud;
        platformName = 'SoundCloud';
      }
      else {
        // URL n√£o suportada
        return false;
      }
      
      // Processar download baseado na plataforma
      let result = null;
      
      // YouTube - baixar apenas √°udio (MP3)
      if (platformName === 'YouTube') {
        result = await youtube.mp3(url, 128);
        if (result && result.ok) {
          await nazu.sendMessage(from, {
            audio: result.buffer,
            mimetype: 'audio/mpeg',
            fileName: result.filename || 'audio.mp3'
          }, { quoted: info });
          return true;
        }
      }
      
      // TikTok
      else if (platformName === 'TikTok') {
        result = await tiktok.dl(urls);
        if (result && result.ok && result.urls && result.urls.length > 0) {
          const videoUrl = result.urls[0];
          if (videoUrl) {
            await nazu.sendMessage(from, {
              video: { url: videoUrl },
              caption: `üì± *TikTok*`,
              mimetype: 'video/mp4'
            }, { quoted: info });
            return true;
          }
        }
      }
      
      // Instagram
      else if (platformName === 'Instagram') {
        result = await igdl.dl(url);
        if (result && result.ok && result.data && result.data.length > 0) {
          const media = result.data[0];
          if (media.type === 'video') {
            await nazu.sendMessage(from, {
              video: media.buff,
              caption: 'üì∏ *Instagram*',
              mimetype: 'video/mp4'
            }, { quoted: info });
          } else {
            await nazu.sendMessage(from, {
              image: media.buff,
              caption: 'üì∏ *Instagram*'
            }, { quoted: info });
          }
          return true;
        }
      }
      
      // Facebook
      else if (platformName === 'Facebook') {
        result = await facebook.downloadHD(url);
        if (result && result.ok && result.buffer) {
          await nazu.sendMessage(from, {
            video: result.buffer,
            caption: `üìò *Facebook* - ${result.resolution || 'HD'}`,
            mimetype: 'video/mp4'
          }, { quoted: info });
          return true;
        }
      }
      
      // Pinterest
      else if (platformName === 'Pinterest') {
        result = await pinterest.dl(url);
        if (result && result.ok && result.urls && result.urls.length > 0) {
          const mediaUrl = result.urls[0];
          if (result.type === 'video') {
            await nazu.sendMessage(from, {
              video: { url: mediaUrl },
              caption: 'üìå *Pinterest*',
              mimetype: 'video/mp4'
            }, { quoted: info });
          } else {
            await nazu.sendMessage(from, {
              image: { url: mediaUrl },
              caption: 'üìå *Pinterest*'
            }, { quoted: info });
          }
          return true;
        }
      }
      
      // Spotify - baixar √°udio
      else if (platformName === 'Spotify') {
        result = await spotify.download(url);
        if (result && result.ok && result.buffer) {
          await nazu.sendMessage(from, {
            audio: result.buffer,
            mimetype: 'audio/mpeg',
            fileName: result.filename || `${result.title || 'audio'}.mp3`
          }, { quoted: info });
          return true;
        }
      }
      
      // SoundCloud - baixar √°udio
      else if (platformName === 'SoundCloud') {
        result = await soundcloud.download(url);
        if (result && result.ok && result.buffer) {
          await nazu.sendMessage(from, {
            audio: result.buffer,
            mimetype: 'audio/mpeg',
            fileName: result.filename || `${result.title || 'audio'}.mp3`
          }, { quoted: info });
          return true;
        }
      }
      
      else {
        // Mapeamento de m√©todos para cada plataforma
        const methodMap = {
          'Instagram': 'dl',
          'Facebook': 'downloadHD',
          'TikTok': 'dl',
          'Pinterest': 'dl'
        };
        
        const methodName = methodMap[platformName] || 'download';
        
        if (downloadModule && typeof downloadModule[methodName] === 'function') {
          result = await downloadModule[methodName](url);
          if (result && result.data) {
            const videoUrl = result.data.video || result.data.videoUrl || result.data.url;
            if (videoUrl) {
              await nazu.sendMessage(from, {
                video: { url: videoUrl },
                caption: `üé¨ *${platformName}*`,
                mimetype: 'video/mp4'
              }, { quoted: info });
              return true;
            }
          }
        }
      }
      
      return false;
      
    } catch (e) {
      console.error('Erro no autodl:', e);
      return false;
    }
  }
  const { default: menus } = await import('./menus/index.js');
  const {
    menu,
    menudown,
    menuadm,
    menubn,
    menuDono,
    menuMembros,
    menuFerramentas,
    menuSticker,
    menuIa,
    menuAlterador,
    menuLogos,
    menuTopCmd,
    menuRPG,
    menuVIP,
    menuBuscas,
    menuBrawlStars
  } = menus;
  const prefix = prefixo;
  const numerodonoStr = String(numerodono);
  const modules = await import('./funcs/exports.js');
  const {
    youtube,
    tiktok,
    pinterest,
    igdl,
    sendSticker,
    styleText,
    emojiMix,
    upload,
    mcPlugin,
    tictactoe,
    toolsJson,
    vabJson,
    Lyrics,
    commandStats,
    ia,
    VerifyUpdate,
    temuScammer,
    relationshipManager,
    spotify,
    soundcloud,
    facebook,
    // Novos m√≥dulos
    connect4,
    uno,
    memoria,
    achievements,
    gifts,
    reputation,
    qrcode,
    notes,
    calculator,
    audioEdit,
    antitoxic,
    iaExpanded,
    antipalavra,
    transmissao
  } = modules.default;
  // Otimiza√ß√£o: Cache de dados est√°ticos com TTL
  const optimizer = getPerformanceOptimizer();
  
  const antipvData = await optimizer.getCachedFile(
    DATABASE_DIR + '/antipv.json',
    30000, // 30 segundos
    (path) => loadJsonFile(path)
  );
  const premiumListaZinha = await optimizer.getCachedFile(
    DONO_DIR + '/premium.json',
    60000, // 1 minuto
    (path) => loadJsonFile(path)
  );
  const banGpIds = await optimizer.getCachedFile(
    DONO_DIR + '/bangp.json',
    30000, // 30 segundos
    (path) => loadJsonFile(path)
  );
  const antifloodData = await optimizer.getCachedFile(
    DATABASE_DIR + '/antiflood.json',
    30000, // 30 segundos
    (path) => loadJsonFile(path)
  );
  
  const antiSpamGlobal = await optimizer.getCachedFile(
    DATABASE_DIR + '/antispam.json',
    30000, // 30 segundos
    (path) => loadJsonFile(path, {
      enabled: false,
      limit: 5,
      interval: 10,
      blockTime: 600,
      users: {},
      blocks: {}
    })
  );
  const globalBlocks = await optimizer.getCachedFile(
    DATABASE_DIR + '/globalBlocks.json',
    30000, // 30 segundos
    (path) => loadJsonFile(path, {
      commands: {},
      users: {}
    })
  );
  const botState = await optimizer.getCachedFile(
    DATABASE_DIR + '/botState.json',
    30000, // 30 segundos
    (path) => loadJsonFile(path, {
      status: 'on'
    })
  );
  const modoLiteFile = DATABASE_DIR + '/modolite.json';
  let modoLiteGlobal = await optimizer.getCachedFile(
    modoLiteFile,
    30000, // 30 segundos
    (path) => loadJsonFile(path, {
      status: false
    })
  );
  if (!fs.existsSync(modoLiteFile)) {
    writeJsonFile(modoLiteFile, modoLiteGlobal);
  };
  
  if (typeof global.autoStickerMode === 'undefined') {
    global.autoStickerMode = 'default';
  }
  try {
    var r;
    const from = info.key.remoteJid;
    const isGroup = from?.endsWith('@g.us') || false;
    if (!info.key.participant && !info.key.remoteJid) return;
    let sender;
    if (isGroup) {
      // Prioriza participant, depois busca por LID, com fallback para JID
      sender = info.key.participant || info.message?.participant;
      
      if (!sender) {
        const participants = Object.keys(info.key).filter(k => k.startsWith("participant")).map(k => info.key[k]).filter(Boolean);
        if (participants.length) {
          sender = participants.find(p => p.includes("@lid")) || participants.find(p => p.includes("@s.whatsapp.net")) || participants[0];
        }
      }
      
      // Se ainda n√£o encontrou, tenta extrair do contextInfo
      if (!sender && info.message?.extendedTextMessage?.contextInfo?.participant) {
        sender = info.message.extendedTextMessage.contextInfo.participant;
      }
      
      // Se for JID, converte para LID usando cache
      if (sender && isValidJid(sender)) {
        sender = await getLidFromJidCached(nazu, sender);
      }
    } else {
      sender = info.key.remoteJid;
      
      // Se for JID no PV, converte para LID usando cache
      if (sender && isValidJid(sender)) {
        sender = await getLidFromJidCached(nazu, sender);
      }
    }
    
    // Debug: log do sender identificado
    debugLog('Sender identificado:', { sender, isGroup, from: from?.substring(0, 20) });
    
    // Se sender ainda for undefined, ignora a mensagem (ex: mensagens de sistema, stubs, etc)
    if (!sender) {
      debugLog('Sender n√£o identificado, ignorando mensagem');
      return;
    }
    
    const pushname = info.pushName || '';
    const isStatus = from?.endsWith('@broadcast') || false;
    const nmrdn = buildUserId(numerodono, config);
    const subDonoList = loadSubdonos();
    const isSubOwner = isSubdono(sender);
    const ownerJid = `${numerodono}@s.whatsapp.net`;
    const botId = getBotId(nazu);
    const isBotSender = sender === botId || sender === nazu.user?.id?.split(':')[0] + '@s.whatsapp.net' || sender === nazu.user?.id?.split(':')[0] + '@lid';
    
    const senderBase = sender.split('@')[0];
    const ownerBase = String(numerodono);
    const lidOwnerBase = lidowner ? lidowner.split('@')[0] : null;
    
    const isOwner = senderBase === ownerBase || 
                    sender === nmrdn || 
                    sender === ownerJid || 
                    (lidowner && sender === lidowner) || 
                    (lidOwnerBase && senderBase === lidOwnerBase) ||
                    info.key.fromMe || 
                    isBotSender;
    
    const isOwnerOrSub = isOwner || isSubOwner;
    
    // Debug: log das verifica√ß√µes de permiss√£o
    debugLog('Verifica√ß√µes de permiss√£o:', { 
      sender: sender?.substring(0, 30), 
      senderBase, 
      ownerBase, 
      isOwner, 
      isSubOwner 
    });
    
    const type = getContentType(info.message);
    
    // ==================== PROCESSAMENTO DE SOLICITA√á√ïES DE ENTRADA NO GRUPO ====================
    // Fallback: Solicita√ß√µes tamb√©m podem vir via messageStubType (backup do evento 'group.join-request')
    if (isGroup && info.message?.messageStubType && info.message.messageStubType === 172) { // GROUP_MEMBERSHIP_JOIN_APPROVAL_REQUEST_NON_ADMIN_ADD
      try {
        const groupFile = buildGroupFilePath(from);
        let groupSettings = {};
        
        // Carrega de forma ass√≠ncrona para n√£o bloquear
        groupSettings = await readJsonFileAsync(groupFile, {});
        
        // Extrai dados da solicita√ß√£o dos par√¢metros do stub
        const messageStubParameters = info.message.messageStubParameters || [];
        
        if (debug) {
          console.log('[DEBUG STUB 172] messageStubParameters:', messageStubParameters);
        }
        
        // O primeiro par√¢metro √© o JID do participante
        const participantJid = messageStubParameters[0];
        // Para novas solicita√ß√µes, assumimos 'created' se n√£o houver segundo par√¢metro
        const action = messageStubParameters[1] || 'created';
        
        if (!participantJid) {
          console.warn('[JOIN REQUEST] Par√¢metros de solicita√ß√£o inv√°lidos:', messageStubParameters);
          return;
        }
        
        if (debug) {
          console.log('[DEBUG JOIN REQUEST] Processando solicita√ß√£o:', {
            participantJid,
            action,
            autoAcceptRequests: groupSettings.autoAcceptRequests,
            captchaEnabled: groupSettings.captchaEnabled,
            x9: groupSettings.x9
          });
        }
        
        console.log(`[JOIN REQUEST] Nova solicita√ß√£o detectada: ${participantJid} (a√ß√£o: ${action})`);
        
        // Processa apenas novas solicita√ß√µes (action === 'created')
        if (action === 'created') {
          // Auto-aceitar (com ou sem captcha)
          if (groupSettings.autoAcceptRequests) {
            if (groupSettings.captchaEnabled) {
              // Pega o nome do grupo
              const groupMetadata = await nazu.groupMetadata(from).catch(() => null);
              const groupNameCaptcha = groupMetadata?.subject || 'Desconhecido';
              
              // Gera captcha e envia para o usu√°rio
              const num1 = Math.floor(Math.random() * 10) + 1;
              const num2 = Math.floor(Math.random() * 10) + 1;
              const correctAnswer = num1 + num2;
              
              const captchaMessage = `ü§ñ *Verifica√ß√£o de Entrada no Grupo*\n\n` +
                `Voc√™ solicitou entrada no grupo *${groupNameCaptcha}*.\n\n` +
                `Para confirmar que voc√™ √© humano, resolva esta conta:\n\n` +
                `‚ùì *${num1} + ${num2} = ?*\n\n` +
                `Responda apenas com o n√∫mero da resposta.`;
              
              // Salva captcha pendente
              groupSettings.pendingCaptchas = groupSettings.pendingCaptchas || {};
              groupSettings.pendingCaptchas[participantJid] = {
                answer: correctAnswer,
                groupId: from,
                expiresAt: Date.now() + (5 * 60 * 1000) // 5 minutos
              };
              
              // Adiciona ao √≠ndice de captcha para busca r√°pida
              const groupFileName = `${from.replace('@g.us', '')}.json`;
              addCaptcha(participantJid, from, correctAnswer, Date.now() + (5 * 60 * 1000), groupFileName);
              
              // Salva arquivo de forma ass√≠ncrona para n√£o bloquear
              writeJsonFileAsync(groupFile, groupSettings).catch(err => 
                console.error('Erro ao salvar captcha no arquivo:', err)
              );
              
              if (debug) {
                console.log('[DEBUG CAPTCHA] Captcha salvo:', {
                  participantJid,
                  num1,
                  num2,
                  correctAnswer,
                  groupId: from
                });
              }
              
              try {
                await nazu.sendMessage(participantJid, { text: captchaMessage });
                console.log(`[JOIN REQUEST] Captcha enviado para ${participantJid}`);
              } catch (err) {
                console.error(`[JOIN REQUEST] Erro ao enviar captcha para ${participantJid}:`, err);
              }
            } else {
              // Auto-aceitar sem captcha
              try {
                await nazu.groupRequestParticipantsUpdate(from, [participantJid], 'approve');
                console.log(`[JOIN REQUEST] ‚úÖ Aprovado automaticamente: ${participantJid}`);
                
                // Notifica√ß√£o X9
                if (groupSettings.x9) {
                  await nazu.sendMessage(from, {
                    text: `‚úÖ *X9 Report:* @${participantJid.split('@')[0]} foi aprovado automaticamente (auto-aceitar ativo).`,
                    mentions: [participantJid],
                  }).catch(err => console.error(`‚ùå Erro ao enviar X9: ${err.message}`));
                }
              } catch (err) {
                console.error(`[JOIN REQUEST] Erro ao aprovar ${participantJid}:`, err);
              }
            }
          } else {
            // Auto-aceitar desativado - apenas notifica se X9 ativo
            if (groupSettings.x9) {
              try {
                await nazu.sendMessage(from, {
                  text: `üì¨ *X9 Report:* Nova solicita√ß√£o de entrada detectada.\nüë§ Usu√°rio: @${participantJid.split('@')[0]}\n\nAprova√ß√£o manual necess√°ria.`,
                  mentions: [participantJid],
                }).catch(err => console.error(`‚ùå Erro ao enviar X9: ${err.message}`));
              } catch (err) {
                console.error(`[JOIN REQUEST] Erro ao enviar notifica√ß√£o X9:`, err);
              }
            }
          }
        } else if (action === 'revoked' || action === 'rejected') {
          // Solicita√ß√£o cancelada ou recusada - limpa captcha se existir
          if (groupSettings.pendingCaptchas && groupSettings.pendingCaptchas[participantJid]) {
            delete groupSettings.pendingCaptchas[participantJid];
            // Remove do √≠ndice de captcha
            removeCaptcha(participantJid);
            // Salva de forma ass√≠ncrona
            writeJsonFileAsync(groupFile, groupSettings).catch(err => 
              console.error('Erro ao salvar ap√≥s remover captcha:', err)
            );
          }
          
          // Notifica X9 se ativo
          if (groupSettings.x9) {
            const statusText = action === 'revoked' ? 'cancelou a solicita√ß√£o' : 'teve a solicita√ß√£o recusada';
            try {
              await nazu.sendMessage(from, {
                text: `üîî *X9 Report:* @${participantJid.split('@')[0]} ${statusText}.`,
                mentions: [participantJid],
              }).catch(err => console.error(`‚ùå Erro ao enviar X9: ${err.message}`));
            } catch (err) {
              console.error(`[JOIN REQUEST] Erro ao enviar notifica√ß√£o X9:`, err);
            }
          }
        }
      } catch (error) {
        console.error('[JOIN REQUEST] Erro ao processar solicita√ß√£o de entrada:', error);
      }
      
      // Retorna aqui para n√£o processar como mensagem normal
      return;
    }
    // ==================== FIM: PROCESSAMENTO DE SOLICITA√á√ïES ====================
    
    const isMedia = ["imageMessage", "videoMessage", "audioMessage"].includes(type);
    const isImage = type === 'imageMessage';
    const isVideo = type === 'videoMessage';
    const isVisuU2 = type === 'viewOnceMessageV2';
    const isVisuU = type === 'viewOnceMessage';
    const ROLE_GOING_BASE = 'üôã';
    const ROLE_NOT_GOING_BASE = 'ü§∑';
    const isGoingEmoji = (emoji) => typeof emoji === 'string' && emoji.includes(ROLE_GOING_BASE);
    const isNotGoingEmoji = (emoji) => typeof emoji === 'string' && emoji.includes(ROLE_NOT_GOING_BASE);
    const isButtonMessage = info.message.interactiveMessage || info.message.templateButtonReplyMessage || info.message.buttonsMessage || info.message.interactiveResponseMessage || info.message.listResponseMessage || info.message.buttonsResponseMessage ? true : false;
    const isStatusMention = JSON.stringify(info.message).includes('groupStatusMentionMessage');
    const getMessageText = message => {
      if (!message) return '';
      
      if (message.interactiveResponseMessage) {
        const interactiveResponse = message.interactiveResponseMessage;
        
        if (interactiveResponse.nativeFlowResponseMessage?.paramsJson) {
          try {
            const params = JSON.parse(interactiveResponse.nativeFlowResponseMessage.paramsJson);
            return params.id || '';
          } catch (error) {
            console.error('Erro ao processar resposta de single_select:', error);
          }
        }
        
        if (interactiveResponse.body?.text) {
          return interactiveResponse.body.text;
        }
        
        if (interactiveResponse.selectedDisplayText) {
          return interactiveResponse.selectedDisplayText;
        }
        
        if (typeof interactiveResponse === 'string') {
          return interactiveResponse;
        }
      }
      
      if (message.listResponseMessage?.singleSelectReply?.selectedRowId) {
        return message.listResponseMessage.singleSelectReply.selectedRowId;
      }
      
      if (message.buttonsResponseMessage?.selectedButtonId) {
        return message.buttonsResponseMessage.selectedButtonId;
      }
      
      return message.conversation || message.extendedTextMessage?.text || message.imageMessage?.caption || message.videoMessage?.caption || message.documentWithCaptionMessage?.message?.documentMessage?.caption || message.viewOnceMessage?.message?.imageMessage?.caption || message.viewOnceMessage?.message?.videoMessage?.caption || message.viewOnceMessageV2?.message?.imageMessage?.caption || message.viewOnceMessageV2?.message?.videoMessage?.caption || message.editedMessage?.message?.protocolMessage?.editedMessage?.extendedTextMessage?.text || message.editedMessage?.message?.protocolMessage?.editedMessage?.imageMessage?.caption || '';
    };
    const body = getMessageText(info.message) || info?.text || '';

    let args = body.trim().split(/ +/).slice(1);
    let q = args.join(' ');
    const budy2 = normalizar(body);
    const menc_prt = info.message?.extendedTextMessage?.contextInfo?.participant;
    const menc_jid2 = info.message?.extendedTextMessage?.contextInfo?.mentionedJid;
    const menc_os2 = (menc_jid2 && menc_jid2.length > 0) ? menc_jid2[0] : menc_prt;
    const sender_ou_n = (menc_jid2 && menc_jid2.length > 0) ? menc_jid2[0] : menc_prt || sender;
  const groupFile = buildGroupFilePath(from);
    // Otimiza√ß√£o: Carregar groupData com cache (TTL curto de 5 segundos)
    let groupData = {};
    if (isGroup) {
      try {
        groupData = await optimizer.getGroupDataCached(
          from,
          async () => {
            try {
              // Usa leitura ass√≠ncrona para n√£o bloquear event loop
              return await readJsonFileAsync(groupFile, {});
            } catch (e) {
              console.error(`Erro ao ler groupFile ${groupFile}:`, e);
              return {};
            }
          },
          5000 // 5 segundos TTL
        );
      } catch (e) {
        console.error('Erro ao carregar groupData com cache:', e);
        try {
          // Fallback ass√≠ncrono
          groupData = await readJsonFileAsync(groupFile, {});
        } catch (e2) {
          console.error('Erro ao carregar groupData sem cache:', e2);
          groupData = {};
        }
      }
    }

    // ==== Helpers de Rol√™ (definidos fora de blocos para uso global dentro da fun√ß√£o) ====
    function ensureRoleParticipants(roleData) {
      if (!roleData.participants || typeof roleData.participants !== 'object') {
        roleData.participants = {};
      }
      if (!Array.isArray(roleData.participants.going)) {
        roleData.participants.going = [];
      }
      if (!Array.isArray(roleData.participants.notGoing)) {
        roleData.participants.notGoing = [];
      }
      return roleData.participants;
    }

    const MAX_MENTIONS_IN_ANNOUNCE = 25;

    function buildRoleAnnouncementText(code, roleData, groupPrefix = prefix) {
      const participants = ensureRoleParticipants(roleData);
      const going = participants.going || [];
      const notGoing = participants.notGoing || [];
      const lines = [];
      lines.push('ü™© *Rol√™*');
      lines.push(`üé´ C√≥digo: *${code}*`);
      if (roleData.title) lines.push(`üìõ T√≠tulo: ${roleData.title}`);
      if (roleData.when) lines.push(`üóìÔ∏è Quando: ${roleData.when}`);
      if (roleData.where) lines.push(`üìç Onde: ${roleData.where}`);
      if (roleData.description) lines.push(`üìù Descri√ß√£o: ${roleData.description}`);
      lines.push('');
      const goingCount = going.length;
      lines.push(`üôã Confirmados (${goingCount}):`);
      if (goingCount > 0) {
        const goingPreview = going.slice(0, MAX_MENTIONS_IN_ANNOUNCE);
        lines.push(goingPreview.map(id => `‚Ä¢ @${getUserName(id)}`).join('\n'));
        if (goingCount > goingPreview.length) lines.push(`‚Ä¶ e mais ${goingCount - goingPreview.length}`);
      } else {
        lines.push('‚Ä¢ ‚Äî');
      }
      const notGoingCount = notGoing.length;
      lines.push('');
      lines.push(`ü§∑ Desistiram (${notGoingCount}):`);
      if (notGoingCount > 0) {
        const notGoingPreview = notGoing.slice(0, MAX_MENTIONS_IN_ANNOUNCE);
        lines.push(notGoingPreview.map(id => `‚Ä¢ @${getUserName(id)}`).join('\n'));
        if (notGoingCount > notGoingPreview.length) lines.push(`‚Ä¶ e mais ${notGoingCount - notGoingPreview.length}`);
      } else {
        lines.push('‚Ä¢ ‚Äî');
      }
      lines.push('');
      lines.push(`üôã Reaja com ${ROLE_GOING_BASE} ou use ${groupPrefix}role.vou ${code}`);
      lines.push(`ü§∑ Reaja com ${ROLE_NOT_GOING_BASE} ou use ${groupPrefix}role.nvou ${code}`);
      return lines.join('\n');
    }

    async function refreshRoleAnnouncement(code, roleData) {
      try {
        if (!roleData || !roleData.announcementKey || !roleData.announcementKey.id) return;
        try {
          await nazu.sendMessage(from, {
            delete: {
              remoteJid: from,
              fromMe: roleData.announcementKey.fromMe !== undefined ? roleData.announcementKey.fromMe : true,
              id: roleData.announcementKey.id,
              participant: roleData.announcementKey.participant || undefined
            }
          });
        } catch (e) {
          console.warn('N√£o consegui remover a divulga√ß√£o antiga do rol√™ (rea√ß√£o):', e.message || e);
        }
        const announcementText = buildRoleAnnouncementText(code, roleData, prefix);
        const goingList = roleData.participants?.going || [];
        const notGoingList = roleData.participants?.notGoing || [];
        const mentions = [
          ...goingList.slice(0, MAX_MENTIONS_IN_ANNOUNCE),
          ...notGoingList.slice(0, MAX_MENTIONS_IN_ANNOUNCE)
        ];
        const sentMessage = await nazu.sendMessage(from, { text: announcementText, mentions });
        if (sentMessage?.key?.id) {
          if (!groupData.roleMessages || typeof groupData.roleMessages !== 'object') {
            groupData.roleMessages = {};
          }
          delete groupData.roleMessages[roleData.announcementKey.id];
          groupData.roleMessages[sentMessage.key.id] = code;
          roleData.announcementKey = {
            id: sentMessage.key.id,
            fromMe: sentMessage.key.fromMe ?? true,
            participant: sentMessage.key.participant || null
          };
          if (!groupData.roles || typeof groupData.roles !== 'object') {
            groupData.roles = {};
          }
          groupData.roles[code] = roleData;
          persistGroupData();
        }
      } catch (e) {
        console.error('Erro ao atualizar an√∫ncio do rol√™:', e);
      }
    }
    const groupMetadata = !isGroup ? {} : await getCachedGroupMetadata(from).catch(() => ({}));
    const groupName = groupMetadata?.subject || '';
    if (isGroup) {
      // Otimiza√ß√£o: Verificar exist√™ncia com cache
      const fileExists = await optimizer.fileExists(groupFile);
      if (!fileExists) {
        writeJsonFile(groupFile, {
          mark: {},
          createdAt: new Date().toISOString(),
          groupName: groupName
        });
        // Invalida cache de exists ap√≥s criar arquivo
        optimizer.invalidateJson(groupFile);
      }
      try {
        // Carregamento seguro e ass√≠ncrono de dados do grupo
        let rawContent = '';
        try {
          rawContent = await fsPromises.readFile(groupFile, 'utf-8');
        } catch (readError) {
          if (readError.code !== 'ENOENT') {
            console.error(`‚ùå Erro ao ler arquivo do grupo ${from}:`, readError.message);
          }
          rawContent = '';
        }
        
        if (!rawContent || rawContent.trim() === '') {
          console.warn(`‚ö†Ô∏è Arquivo de grupo vazio para ${from}, criando novo`);
          groupData = { mark: {}, createdAt: new Date().toISOString() };
        } else {
          // Remove BOM e caracteres inv√°lidos
          rawContent = rawContent.replace(/^\uFEFF/, '').replace(/[\x00-\x08\x0B\x0C\x0E-\x1F\x7F]/g, '');
          
          try {
            groupData = JSON.parse(rawContent);
          } catch (parseError) {
            console.error(`‚ùå JSON inv√°lido no grupo ${from}, tentando recuperar:`, parseError.message);
            
            // Tenta remover trailing commas e parsear novamente
            try {
              rawContent = rawContent.replace(/,\s*([\]}])/g, '$1');
              groupData = JSON.parse(rawContent);
              console.log(`‚úÖ Dados do grupo ${from} recuperados ap√≥s sanitiza√ß√£o`);
            } catch (retryError) {
              console.error(`‚ùå Falha na recupera√ß√£o do grupo ${from}, usando dados padr√£o`);
              groupData = { mark: {}, createdAt: new Date().toISOString(), recovered: true };
            }
          }
        }
        
        // Valida√ß√£o b√°sica
        if (!groupData || typeof groupData !== 'object') {
          groupData = { mark: {} };
        }
      } catch (error) {
        console.error(`‚ùå Erro cr√≠tico ao carregar dados do grupo ${from}:`, error.message);
        groupData = { mark: {}, error: true };
      };
  // default flags
  groupData.modorpg = typeof groupData.modorpg === 'boolean' ? groupData.modorpg : false;
      groupData.minMessage = groupData.minMessage || null;
      groupData.moderators = groupData.moderators || [];
      groupData.allowedModCommands = groupData.allowedModCommands || [];
      groupData.mutedUsers = groupData.mutedUsers || {};
      groupData.mutedUsers2 = groupData.mutedUsers2 || {};
      groupData.levelingEnabled = groupData.levelingEnabled || false;
      groupData.adminWhitelist = groupData.adminWhitelist || {};
      if (!groupData.roles || typeof groupData.roles !== 'object') {
        groupData.roles = {};
      }
      if (!groupData.roleMessages || typeof groupData.roleMessages !== 'object') {
        groupData.roleMessages = {};
      }

      if (groupName && groupData.groupName !== groupName) {
        groupData.groupName = groupName;
  // Salva de forma ass√≠ncrona para n√£o bloquear
  writeJsonFileAsync(groupFile, groupData).then(() => {
    // Otimiza√ß√£o: Invalida cache quando groupData √© salvo
    if (isGroup) {
      optimizer.invalidateGroup(from);
    }
  }).catch(err => console.error('Erro ao salvar groupData:', err));
      };
    };
    // Otimiza√ß√£o: Cache de parcerias
    let parceriasData = {};
    if (isGroup) {
      parceriasData = await optimizer.memoize(
        `parcerias:${from}`,
        () => Promise.resolve(loadParceriasData(from)),
        10000 // 10 segundos
      );
    }
    /**
     * Persiste dados do grupo de forma ass√≠ncrona
     * N√£o bloqueia o event loop durante a escrita
     */
    const persistGroupData = () => {
      if (isGroup) {
        // Usa escrita ass√≠ncrona em background
        writeJsonFileAsync(groupFile, groupData).then(() => {
          // Otimiza√ß√£o: Invalida cache quando groupData √© salvo
          optimizer.invalidateGroup(from);
        }).catch(err => console.error('Erro ao persistir groupData:', err));
      }
    };
    
    // Fun√ß√£o para verificar se um usu√°rio est√° na whitelist para determinado anti
    const isUserWhitelisted = (userId, antiType) => {
      if (!groupData.adminWhitelist || typeof groupData.adminWhitelist !== 'object') {
        return false;
      }
      
      const userWhitelist = groupData.adminWhitelist[userId];
      if (!userWhitelist || !Array.isArray(userWhitelist.antis)) {
        return false;
      }
      
      return userWhitelist.antis.includes(antiType);
    };
    
    // Helpers para mutar usu√°rios (suporte a LID/JID)
    const isUserInMap = (map, userId) => {
      if (!map || !userId) return false;
      if (map[userId]) return true;
      const keys = Object.keys(map);
      return keys.some(key => idsMatch(key, userId));
    };
    const removeUserFromMap = (map, userId) => {
      if (!map || !userId) return false;
      let removed = false;
      if (map[userId]) {
        delete map[userId];
        removed = true;
      }
      for (const key of Object.keys(map)) {
        if (idsMatch(key, userId)) {
          delete map[key];
          removed = true;
        }
      }
      return removed;
    };
    const groupPrefix = groupData.customPrefix || prefixo;
    var isCmd = body.trim().startsWith(groupPrefix);
    
    // Suporte para "! comando" (com espa√ßo ap√≥s o prefixo)
    const bodyWithoutPrefix = body.trim().slice(groupPrefix.length).trimStart();
    
    const aliases = loadCommandAliases();
    const matchedAlias = aliases.find(item => normalizar(bodyWithoutPrefix.split(/ +/).shift().trim()) === item.alias);
    
    // Se encontrou um alias, aplicar par√¢metros fixos
    if (matchedAlias && matchedAlias.fixedParams) {
      const userArgs = bodyWithoutPrefix.split(/ +/).slice(1).join(' ');
      const combinedParams = matchedAlias.fixedParams + (userArgs ? ' ' + userArgs : '');
      q = combinedParams;
      args.length = 0;
      args.push(...combinedParams.split(/ +/));
    }
    
    var command = isCmd ? matchedAlias ? matchedAlias.command : normalizar(bodyWithoutPrefix.split(/ +/).shift().trim()).replace(/\s+/g, '') : null;
    
    // Recalcular args usando bodyWithoutPrefix para suportar "! comando" (com espa√ßo)
    if (isCmd && !matchedAlias) {
      const newArgs = bodyWithoutPrefix.split(/ +/).slice(1);
      args.length = 0;
      args.push(...newArgs);
      q = newArgs.join(' ');
    }
    
    const isPremium = premiumListaZinha[sender] || premiumListaZinha[from] || isOwner;
    
    // Verifica√ß√£o de captcha para solicita√ß√µes de entrada em grupos (DEVE vir ANTES de antipv)
    // Otimizado: usa √≠ndice de captcha em vez de varrer todos os arquivos
    if (!isGroup && !info.key.fromMe) { // Ignora mensagens do pr√≥prio bot
      const captchaData = getCaptcha(sender);
      
      if (captchaData) {
        if (debug) {
          console.log('[DEBUG CAPTCHA] Captcha pendente encontrado via √≠ndice:', {
            sender,
            body: body.trim(),
            expectedAnswer: captchaData.answer,
            groupId: captchaData.groupId
          });
        }
        
        const userAnswer = parseInt(body.trim());
        
        if (debug) {
          console.log('[DEBUG CAPTCHA] Resposta do usu√°rio:', userAnswer, '√â n√∫mero?', !isNaN(userAnswer));
        }
        
        if (isNaN(userAnswer)) {
          await reply('‚ùå Resposta inv√°lida! Por favor, envie apenas o n√∫mero da resposta.');
          return;
        }
        
        const groupPath = pathz.join(GRUPOS_DIR, captchaData.groupFile || `${captchaData.groupId.replace('@g.us', '')}.json`);
        
        if (userAnswer === captchaData.answer) {
          // Resposta correta - aprovar no grupo
          try {
            if (debug) {
              console.log('[DEBUG CAPTCHA] ‚úÖ Resposta correta! Aprovando no grupo:', captchaData.groupId);
            }
            await nazu.groupRequestParticipantsUpdate(captchaData.groupId, [sender], 'approve');
            await reply('‚úÖ *Correto!* Voc√™ foi aprovado no grupo. Bem-vindo! üéâ');
            
            // Limpar captcha pendente do √≠ndice
            removeCaptcha(sender);
            
            // Tamb√©m limpa do arquivo do grupo (async para n√£o bloquear)
            readJsonFileAsync(groupPath, {}).then(async groupDataCaptcha => {
              if (groupDataCaptcha.pendingCaptchas?.[sender]) {
                delete groupDataCaptcha.pendingCaptchas[sender];
                await writeJsonFileAsync(groupPath, groupDataCaptcha);
              }
              
              // Notifica√ß√£o X9
              if (groupDataCaptcha.x9) {
                await nazu.sendMessage(captchaData.groupId, {
                  text: `‚úÖ *X9 Report:* @${sender.split('@')[0]} passou na verifica√ß√£o de captcha e foi aprovado automaticamente.`,
                  mentions: [sender],
                }).catch(err => console.error(`‚ùå Erro ao enviar X9: ${err.message}`));
              }
            }).catch(err => console.error('Erro ao limpar captcha do arquivo:', err));
            
          } catch (err) {
            await reply('‚ùå Erro ao aprovar sua solicita√ß√£o. Tente novamente mais tarde.');
            console.error('Erro ao aprovar ap√≥s captcha:', err);
          }
        } else {
          // Resposta incorreta - recusar
          try {
            if (debug) {
              console.log('[DEBUG CAPTCHA] ‚ùå Resposta incorreta! Recusando no grupo:', captchaData.groupId);
            }
            await nazu.groupRequestParticipantsUpdate(captchaData.groupId, [sender], 'reject');
            await reply('‚ùå *Resposta incorreta!* Sua solicita√ß√£o foi recusada. Voc√™ pode tentar solicitar novamente.');
            
            // Limpar captcha pendente do √≠ndice
            removeCaptcha(sender);
            
            // Tamb√©m limpa do arquivo do grupo (async)
            readJsonFileAsync(groupPath, {}).then(async groupDataCaptcha => {
              if (groupDataCaptcha.pendingCaptchas?.[sender]) {
                delete groupDataCaptcha.pendingCaptchas[sender];
                await writeJsonFileAsync(groupPath, groupDataCaptcha);
              }
            }).catch(err => console.error('Erro ao limpar captcha do arquivo:', err));
            
          } catch (err) {
            await reply('‚ùå Resposta incorreta!');
            console.error('Erro ao recusar ap√≥s captcha:', err);
          }
        }
        return;
      }
    }
    
    if (!isGroup) {
      // Exce√ß√£o para comandos de transmiss√£o que devem funcionar no PV
      const tm2Commands = ['inscrevertm', 'inscrevertm2', 'desinscrever', 'desinscrevertm', 'cancelartm'];
      const supportAdminCommands = ['ticketaceitar', 'aceitarticket', 'suporteaceitar', 'ticket.aceitar'];
      const isSupportAdminCommand = supportAdminCommands.some(cmd => command === cmd);
      const isTm2Command = tm2Commands.some(cmd => command === cmd) || isSupportAdminCommand;
      
      if (antipvData.mode === 'antipv' && !isOwner && !isPremium && !isTm2Command) {
        return;
      };
      if (antipvData.mode === 'antipv2' && isCmd && !isOwner && !isPremium && !isTm2Command) {
        await reply(antipvData.message || 'üö´ Este comando s√≥ funciona em grupos!');
        return;
      };
      if (antipvData.mode === 'antipv3' && isCmd && !isOwner && !isPremium && !isTm2Command) {
        await nazu.updateBlockStatus(sender, 'block');
        await reply('üö´ Voc√™ foi bloqueado por usar comandos no privado!');
        return;
      };
      if (antipvData.mode === 'antipv4' && !isOwner && !isPremium && !isTm2Command) {
        await reply(antipvData.message || 'üö´ Este comando s√≥ funciona em grupos!');
        return;
      };
    };
    if (isGroup && banGpIds[from] && !isOwner && !isPremium) {
      return;
    };
    // Enhanced participant ID extraction with both LID and JID support
    const extractParticipantId = (participant) => {
      if (!participant) return null;
      // Retorna LID se dispon√≠vel, sen√£o retorna o ID padr√£o
      let id = participant.lid || participant.id || null;
      
      // Remove :XX se existir (ex: 267955023654984:13@lid -> 267955023654984@lid)
      if (id && id.includes(':')) {
        const suffix = id.includes('@lid') ? '@lid' : '@s.whatsapp.net';
        id = id.split(':')[0] + suffix;
      }
      
      return id;
    };

    // Helper para normalizar nomes de cl√£ - remove acentos e caracteres n√£o alfanum√©ricos
    function normalizeClanName(name) {
      if (!name) return '';
      const n = name.normalize('NFD').replace(/\p{Diacritic}/gu, '');
      return n.replace(/[^a-zA-Z0-9 ]/g, '').trim().toLowerCase();
    }
    
    // Helper para normalizar comandos - remove acentos mas mant√©m espa√ßos
    function normalizeCommand(cmd) {
      if (!cmd) return '';
      const n = cmd.normalize('NFD').replace(/\p{Diacritic}/gu, '');
      return n.replace(/[^a-zA-Z0-9\s]/g, '').trim().toLowerCase();
    }

    // Extrai IDs dos membros (pode estar em JID)
    const rawMembers = !isGroup ? [] :
      groupMetadata.participants?.map(extractParticipantId).filter(Boolean) || [];
    
    // Extrai IDs dos admins (pode estar em JID)
    const rawAdmins = !isGroup ? [] :
      groupMetadata.participants?.filter(p => p.admin === 'admin' || p.admin === 'superadmin').map(extractParticipantId).filter(Boolean) || [];

    // Converte todos os membros e admins para LID (usando cache)
    const AllgroupMembers = await convertIdsToLid(nazu, rawMembers);
    const groupAdmins = await convertIdsToLid(nazu, rawAdmins);
    
    // Debug log
    debugLog('Membros e Admins convertidos:', {
      totalMembros: AllgroupMembers.length,
      totalAdmins: groupAdmins.length,
      admins: groupAdmins.map(a => a?.substring(0, 20))
    });

    // Robust bot ID extraction with multiple fallback mechanisms
    const getBotNumber = (nazu) => {
      try {
        // Tenta pegar LID primeiro
        if (nazu.user?.lid) {
          // Remove o sufixo `:XX` se existir (ex: 267955023654984:13@lid -> 267955023654984@lid)
          const lid = nazu.user.lid;
          const cleanLid = lid.includes(':') ? lid.split(':')[0] + '@lid' : lid;
          return cleanLid;
        }
        
        // Fallback para ID padr√£o
        if (nazu.user?.id) {
          const botId = nazu.user.id.split(':')[0];
          return `${botId}@s.whatsapp.net`;
        }

        // Usa helper se dispon√≠vel
        if (typeof getBotId === 'function') {
          return getBotId(nazu);
        }

        console.warn('Unable to determine bot number - user object:', nazu.user);
        return null;
      } catch (error) {
        console.error('Error extracting bot number:', error);
        return null;
      }
    };

    const botNumber = getBotNumber(nazu);
    
    // Converte o botNumber para LID se for JID
    const botNumberLid = botNumber && isValidJid(botNumber) 
      ? await getLidFromJidCached(nazu, botNumber) 
      : botNumber;
    
    const isBotAdmin = !isGroup || !botNumberLid ? false : idInArray(botNumberLid, groupAdmins);
    
    let isGroupAdmin = false;
    if (isGroup) {
      const isModeratorActionAllowed = groupData.moderators?.includes(sender) && groupData.allowedModCommands?.includes(command);
      
      // Usa a fun√ß√£o idsMatch para compara√ß√£o robusta
      const isAdminMatch = idInArray(sender, groupAdmins);
      
      isGroupAdmin = isAdminMatch || isOwner || isModeratorActionAllowed;
      
      // Debug: log das verifica√ß√µes de admin
      debugLog('Verifica√ß√£o de admin:', { 
        sender: sender?.substring(0, 30),
        senderBase: sender?.split('@')[0],
        groupAdminsCount: groupAdmins.length,
        groupAdmins: groupAdmins.map(a => a?.substring(0, 20)),
        isAdminMatch,
        isGroupAdmin,
        isModerator: isModeratorActionAllowed,
        isBotAdmin,
        botNumber: botNumberLid?.substring(0, 30)
      });
    }
    const isModoBn = groupData.modobrincadeira;
    const isOnlyAdmin = groupData.soadm;
    const soadmBypassCommands = ['suporte', 'ticketsuporte', 'suporteticket', 'ticket'];
    
    // Se modo soadm ativo e n√£o √© admin, ignorar aliases silenciosamente
    if (isGroup && isOnlyAdmin && !isGroupAdmin && !isOwner && matchedAlias) {
      return; // Ignora silenciosamente o alias para n√£o-admins
    }
    
    const isAntiPorn = groupData.antiporn;
    const isMuted = isUserInMap(groupData.mutedUsers, sender);
    const isMuted2 = isUserInMap(groupData.mutedUsers2, sender);
    const isAntiLinkGp = groupData.antilinkgp;
    const isAntiLinkCanal = groupData.antilinkcanal;
    const isAntiLinkSoft = groupData.antilinksoft;
    const isAntiDel = groupData.antidel;
    const isAntiBtn = groupData.antibtn;
    const isAntiStatus = groupData.antistatus;
    const isAutoRepo = groupData.autorepo;
    const isAssistente = groupData.assistente;
    const isModoLite = isGroup && isModoLiteActive(groupData, modoLiteGlobal);
    
    if (type === 'reactionMessage') {
      await processReactionMessage();
      return;
    }
    
    if (isGroup && groupData.minMessage && (isImage || isVideo || isVisuU || isVisuU2) && !isGroupAdmin && !isOwner) {
  let caption = '';
  if (isImage) {
    caption = info.message.imageMessage?.caption || '';
  } else if (isVideo) {
    caption = info.message.videoMessage?.caption || '';
  } else if (isVisuU) {
    caption = info.message.viewOnceMessage?.message?.imageMessage?.caption || info.message.viewOnceMessage?.message?.videoMessage?.caption || '';
  } else if (isVisuU2) {
    caption = info.message.viewOnceMessageV2?.message?.imageMessage?.caption || info.message.viewOnceMessageV2?.message?.videoMessage?.caption || '';
  }
  if (caption.length < groupData.minMessage.minDigits) {
    try {
      await nazu.sendMessage(from, { delete: info.key });
      if (groupData.minMessage.action === 'ban') {
        if (isBotAdmin) {
          await nazu.groupParticipantsUpdate(from, [sender], 'remove');
          await reply(`üö´ Usu√°rio removido por enviar m√≠dia sem legenda suficiente (m√≠nimo: ${groupData.minMessage.minDigits} caracteres).`);
        } else {
          await reply(`‚ö†Ô∏è M√≠dia sem legenda suficiente detectada, mas n√£o sou admin para remover o usu√°rio.`);
        }
      } else { // adv
        await reply(`‚ö†Ô∏è Advert√™ncia: Envie m√≠dias com pelo menos ${groupData.minMessage.minDigits} caracteres na legenda para evitar remo√ß√£o.`);
      }
    } catch (error) {
      console.error('Erro ao processar minMessage:', error);
    }
  }
};

    if (isGroup && isStatusMention && isAntiStatus && !isGroupAdmin) {
      if (!isUserWhitelisted(sender, 'antistatus')) {
        if (isBotAdmin) {
          await nazu.sendMessage(from, {
            delete: {
              remoteJid: from,
              fromMe: false,
              id: info.key.id,
              participant: sender
            }
          });
          await nazu.groupParticipantsUpdate(from, [sender], 'remove');
        } else {
          await reply("‚ö†Ô∏è N√£o posso remover o usu√°rio porque n√£o sou administrador.");
        }
      }
    }
    if (isGroup && isButtonMessage && isAntiBtn && !isGroupAdmin) {
      if (!isUserWhitelisted(sender, 'antibtn')) {
        if (isBotAdmin) {
          await nazu.sendMessage(from, {
            delete: {
              remoteJid: from,
              fromMe: false,
              id: info.key.id,
              participant: sender
            }
          });
          await nazu.groupParticipantsUpdate(from, [sender], 'remove');
        } else {
          await reply("‚ö†Ô∏è N√£o posso remover o usu√°rio porque n√£o sou administrador.");
        }
      }
    }
    if (isGroup && isCmd && isOnlyAdmin && !isGroupAdmin && !soadmBypassCommands.includes(command)) {
      return;
    }
    if (isGroup && info.message.protocolMessage && info.message.protocolMessage.type === 0 && isAntiDel) {
      const deletedMsgKey = info.message.protocolMessage.key;
      const cacheKey = `${deletedMsgKey.remoteJid || from}_${deletedMsgKey.id}`;
      const cachedInfo = messagesCache.get(cacheKey);
      
      if (!cachedInfo || !cachedInfo.message) return;

      const msgOriginal = cachedInfo.message;
      
      const clone = JSON.parse(
          JSON.stringify(msgOriginal)
              .replaceAll('conversation', 'text')
              .replaceAll('Message', '')
      );
      
      for (const key in clone) {
          const media = clone[key];
          if (media && typeof media === 'object' && media.url) {
              clone[key] = {
                  url: media.url
              };
              for (const subkey in media) {
                  if (subkey !== 'url') {
                      clone[subkey] = media[subkey];
                  }
              }
          }
      }

      
      const participant = cachedInfo.key.participant || info.message.protocolMessage.key.participant; 
      const fromGroup = cachedInfo.key.remoteJid; 
      
      if (!participant) return;
      
      let userName = 'Usu√°rio Desconhecido';
      let profilePic = 'https://telegra.ph/file/b5427ea4b8701bc47e751.jpg';
      const pushNameFromMsg = cachedInfo?.pushName || ''; 
      
      if (pushNameFromMsg) {
          userName = pushNameFromMsg;
      } else {
          try {
              const fetchedName = await nazu.getName(fromGroup, participant); 
              const numeroLimpoFallback = participant.split('@')[0];
              
              if (fetchedName && fetchedName !== numeroLimpoFallback) {
                  userName = fetchedName;
              } else {
                  userName = numeroLimpoFallback;
              }
          } catch (e) {
              userName = participant.split('@')[0];
          }
      }
      
      try {
          profilePic = await nazu.profilePictureUrl(participant, 'image');
      } catch (e) {
      }
      
      clone.contextInfo = {
          isForwarded: false,
          mentionedJid: [participant],
          externalAdReply: {
              title: `MENSAGEM APAGADA POR: ${userName}`,            
              body: `N√∫mero: ${participant.split("@")[0]}`, 
              thumbnailUrl: profilePic,
              sourceUrl: '',
              mediaType: 1,
              renderLargerThumbnail: false,
          },
      };
      
      try {
          await nazu.sendMessage(fromGroup, clone);
      } catch (err) {
          console.error('ERRO CR√çTICO AO REENVIAR MENSAGEM:', err);
      }
    }
    if (isGroup && isCmd && !isGroupAdmin && groupData.blockedCommands && groupData.blockedCommands[command]) {
      await reply('‚õî Este comando foi bloqueado pelos administradores do grupo.');
      return;
    };

    if (isCmd && antiSpamGlobal?.enabled && !isOwnerOrSub) {
      try {
        const cfg = antiSpamGlobal;
        cfg.users = cfg.users || {};
        cfg.blocks = cfg.blocks || {};
        const now = Date.now();
        const blockInfo = cfg.blocks[sender];
        if (blockInfo && blockInfo.until && now < blockInfo.until) {
          const msLeft = blockInfo.until - now;
          const secs = Math.ceil(msLeft / 1000);
          const m = Math.floor(secs / 60), s = secs % 60;
          return reply(`üö´ Voc√™ est√° temporariamente bloqueado de usar comandos por anti-spam.
‚è≥ Aguarde ${m > 0 ? `${m}m ${s}s` : `${secs}s`}.`);
        } else if (blockInfo && blockInfo.until && now >= blockInfo.until) {
          delete cfg.blocks[sender];
        }
        const intervalMs = (cfg.interval || 10) * 1000;
        const limit = Math.max(1, parseInt(cfg.limit || 5));
        const arr = (cfg.users[sender]?.times || []).filter(ts => now - ts <= intervalMs);
        arr.push(now);
        cfg.users[sender] = { times: arr };
        if (arr.length > limit) {
          const blockMs = Math.max(1, parseInt(cfg.blockTime || 600)) * 1000;
          cfg.blocks[sender] = { until: now + blockMs, at: new Date().toISOString(), count: arr.length };
          writeJsonFile(DATABASE_DIR + '/antispam.json', cfg);
          return reply(`üö´ Anti-spam: voc√™ excedeu o limite de ${limit} comandos em ${cfg.interval}s.
üîí Bloqueado por ${Math.floor(blockMs/60000)} min.`);
        }
        writeJsonFile(DATABASE_DIR + '/antispam.json', cfg);
      } catch (e) {
        console.error('Erro no AntiSpam Global:', e);
      }
    }
    if (isGroup && groupData.afkUsers && groupData.afkUsers[sender]) {
      try {
        const afkReason = groupData.afkUsers[sender].reason;
        const afkSince = new Date(groupData.afkUsers[sender].since || Date.now()).toLocaleString('pt-BR', {
          timeZone: 'America/Sao_Paulo'
        });
        delete groupData.afkUsers[sender];
    writeJsonFile(groupFile, groupData);
  // Otimiza√ß√£o: Invalida cache quando groupData √© salvo
  if (isGroup) {
    optimizer.invalidateGroup(from);
  }
        await reply(`üëã *Bem-vindo(a) de volta!*\nSeu status AFK foi removido.\nVoc√™ estava ausente desde: ${afkSince}`);
      } catch (error) {
        console.error("Erro ao processar remo√ß√£o de AFK:", error);
      }
    }
    if (isGroup && isMuted && !isGroupAdmin && !isOwner) {
      try {
        await nazu.sendMessage(from, {
          text: `ü§´ *Usu√°rio mutado detectado*\n\n@${getUserName(sender)}, voc√™ est√° tentando falar enquanto est√° mutado neste grupo. Voc√™ ser√° removido conforme as regras.`,
          mentions: [sender]
        }, {
          quoted: info
        });
        await nazu.sendMessage(from, {
          delete: {
            remoteJid: from,
            fromMe: false,
            id: info.key.id,
            participant: sender
          }
        });
        if (isBotAdmin) {
          await nazu.groupParticipantsUpdate(from, [sender], 'remove');
        } else {
          await reply("‚ö†Ô∏è N√£o posso remover o usu√°rio porque n√£o sou administrador.");
        }
        removeUserFromMap(groupData.mutedUsers, sender);
        writeJsonFile(groupFile, groupData);
        // Otimiza√ß√£o: Invalida cache quando groupData √© salvo
        if (isGroup) {
          optimizer.invalidateGroup(from);
        }
        return;
      } catch (error) {
        console.error("Erro ao processar usu√°rio mutado:", error);
      }
    }
    if (isGroup && isMuted2 && !isGroupAdmin && !isOwner) {
      try {
        await nazu.sendMessage(from, {
          delete: {
            remoteJid: from,
            fromMe: false,
            id: info.key.id,
            participant: sender
          }
        });
      } catch (error) {
        console.error("Erro ao deletar mensagem de usu√°rio mutado2:", error);
      }
      return;
    }
    const rentalModeOn = isRentalModeActive();
    let groupHasActiveRental = false;
    let rentalStatusChecked = false;
    if (isGroup && rentalModeOn) {
      const rentalStatus = getGroupRentalStatus(from);
      groupHasActiveRental = rentalStatus.active;
      rentalStatusChecked = true;
      const allowedCommandsBypass = ['modoaluguel', 'addaluguel', 'gerarcodigo', 'addsubdono', 'remsubdono', 'listasubdonos'];
      if (!groupHasActiveRental && isCmd && !isOwnerOrSub && !allowedCommandsBypass.includes(command)) {
        await reply("‚è≥ O aluguel deste grupo expirou ou n√£o est√° ativo. Para usar os comandos, ative com um c√≥digo ou solicite ao dono a renova√ß√£o.");
        return;
      }
    }
    if (isGroup && !isCmd && body && /\b[A-F0-9]{8}\b/.test(body.toUpperCase())) {
      const potentialCode = body.match(/\b[A-F0-9]{8}\b/)[0].toUpperCase();
      const validation = validateActivationCode(potentialCode);
      if (validation.valid) {
        try {
          const activationResult = useActivationCode(potentialCode, from, sender);
          await reply(activationResult.message);
          if (activationResult.success) {
            return;
          }
        } catch (e) {
          console.error(`Erro ao tentar usar c√≥digo de ativa√ß√£o ${potentialCode} no grupo ${from}:`, e);
        }
      }
    }
    if (isGroup) {
      try {
        groupData.contador = groupData.contador || [];
        const userIndex = groupData.contador.findIndex(user => user.id === sender);
        if (userIndex !== -1) {
          const userData = groupData.contador[userIndex];
          if (isCmd) {
            userData.cmd = (userData.cmd || 0) + 1;
          } else if (type === "stickerMessage") {
            userData.figu = (userData.figu || 0) + 1;
          } else {
            userData.msg = (userData.msg || 0) + 1;
          }
          if (pushname && userData.pushname !== pushname) {
            userData.pushname = pushname;
          }
          userData.lastActivity = new Date().toISOString();
        } else {
          groupData.contador.push({
            id: sender,
            msg: isCmd ? 0 : 1,
            cmd: isCmd ? 1 : 0,
            figu: type === "stickerMessage" ? 1 : 0,
            pushname: pushname || 'Usu√°rio Desconhecido',
            firstSeen: new Date().toISOString(),
            lastActivity: new Date().toISOString()
          });
    }
    writeJsonFile(groupFile, groupData);
  // Otimiza√ß√£o: Invalida cache quando groupData √© salvo
  if (isGroup) {
    optimizer.invalidateGroup(from);
  }
      } catch (error) {
        console.error("Erro no sistema de contagem de mensagens:", error);
      }
    }
    if (isGroup && groupData.levelingEnabled) {
      try {
        const levelingData = loadLevelingSafe();
        const userData = getLevelingUser(levelingData, sender);
        
        // Atualiza contadores
        userData.messages = (userData.messages || 0) + 1;
        if (isCmd) {
          userData.commands = (userData.commands || 0) + 1;
          userData.xp = (userData.xp || 0) + 10;
        } else {
          userData.xp = (userData.xp || 0) + 5;
        }
        userData.lastMessage = Date.now();
        
        // Verifica level up e salva
        checkLevelUp(sender, userData, levelingData, nazu, from);
        saveLevelingSafe(levelingData);
      } catch (levelingError) {
        console.error('‚ùå Erro no sistema de leveling:', levelingError.message);
      }
    }
    async function reply(text, options = {}) {
      try {
        const {
          mentions = [],
          noForward = false,
          noQuote = false
        } = options;
        const messageContent = {
          text: text.trim(),
          mentions: mentions
        };
        const sendOptions = {
          sendEphemeral: true
        };
        if (!noForward) {
          sendOptions.contextInfo = {
            forwardingScore: 50,
            isForwarded: true,
            externalAdReply: {
              showAdAttribution: true
            }
          };
        }
        if (!noQuote) {
          sendOptions.quoted = info;
        }
        const result = await nazu.sendMessage(from, messageContent, sendOptions);
        return result;
      } catch (error) {
        console.error("Erro ao enviar mensagem:", error);
        return null;
      }
    }
    nazu.reply = reply;
    const reagir = async (emj, options = {}) => {
      try {
        const messageKey = options.key || info.key;
        const delay = options.delay || 500;
        if (!messageKey) {
          console.error("Chave de mensagem inv√°lida para rea√ß√£o");
          return false;
        }
        if (typeof emj === 'string') {
          if (emj.length < 1 || emj.length > 5) {
            console.warn("Emoji inv√°lido para rea√ß√£o:", emj);
            return false;
          }
          await nazu.sendMessage(from, {
            react: {
              text: emj,
              key: messageKey
            }
          });
          return true;
        } else if (Array.isArray(emj) && emj.length > 0) {
          for (const emoji of emj) {
            if (typeof emoji !== 'string' || emoji.length < 1 || emoji.length > 5) {
              console.warn("Emoji inv√°lido na sequ√™ncia:", emoji);
              continue;
            }
            await nazu.sendMessage(from, {
              react: {
                text: emoji,
                key: messageKey
              }
            });
            if (delay > 0 && emj.indexOf(emoji) < emj.length - 1) {
              await new Promise(resolve => setTimeout(resolve, delay));
            }
          }
          return true;
        }
        return false;
      } catch (error) {
        console.error("Erro ao reagir com emoji:", error);
        return false;
      }
    };
    nazu.react = reagir;

    
    async function processReactionMessage() {
      try {
        if (!isGroup) {
          return;
        }

        const reaction = info.message?.reactionMessage;
        if (!reaction || !reaction.key || !reaction.key.id) {
          return;
        }

        const targetMessageId = reaction.key.id;
        const emoji = reaction.text || '';
        const actorId = sender;

        if (!actorId) {
          return;
        }

        const roleCode = groupData.roleMessages?.[targetMessageId];
        if (roleCode && groupData.roles && groupData.roles[roleCode]) {
          const roleData = groupData.roles[roleCode];
          roleData.participants = roleData.participants && typeof roleData.participants === 'object' ? roleData.participants : {};
          const goingSet = new Set(Array.isArray(roleData.participants.going) ? roleData.participants.going : []);
          const notGoingSet = new Set(Array.isArray(roleData.participants.notGoing) ? roleData.participants.notGoing : []);
          let changed = false;

          if (!emoji) {
            if (goingSet.delete(actorId) || notGoingSet.delete(actorId)) {
              changed = true;
            }
          } else if (isGoingEmoji(emoji)) {
            if (!goingSet.has(actorId)) {
              changed = true;
            }
            goingSet.add(actorId);
            if (notGoingSet.delete(actorId)) {
              changed = true;
            }
          } else if (isNotGoingEmoji(emoji)) {
            if (!notGoingSet.has(actorId)) {
              changed = true;
            }
            notGoingSet.add(actorId);
            if (goingSet.delete(actorId)) {
              changed = true;
            }
          } else {
            return;
          }

          if (changed) {
            roleData.participants.going = Array.from(goingSet);
            roleData.participants.notGoing = Array.from(notGoingSet);
            roleData.participants.updatedAt = new Date().toISOString();
            persistGroupData();

            try {
              if (emoji) {
                const confirmationText = isGoingEmoji(emoji)
                  ? `üôã Presen√ßa confirmada no rol√™ *${roleData.title || roleCode}*.`
                  : `ü§∑ Voc√™ sinalizou que n√£o vai mais no rol√™ *${roleData.title || roleCode}*.`;
                await nazu.sendMessage(actorId, {
                  text: `${confirmationText}
C√≥digo: *${roleCode}*`,
                  mentions: [actorId]
                });
              }
            } catch (dmError) {
              console.warn('N√£o foi poss√≠vel enviar confirma√ß√£o de rea√ß√£o:', dmError.message || dmError);
            }

            // Atualiza a mensagem principal do rol√™ com as novas listas
            await refreshRoleAnnouncement(roleCode, roleData);
          }
          return;
        }
      } catch (reactionError) {
        console.error('Erro ao processar rea√ß√£o de rol√™/resenha:', reactionError);
      }
    }
    const parsePipeArgs = (input) => (input || '').split('|').map(part => part.trim()).filter(Boolean);
    const sanitizeRoleCode = (code) => normalizar(code || '', true).replace(/[^0-9a-z]/gi, '').toUpperCase();
    
    const formatRoleSummary = (code, roleData, index = null) => {
      const participants = ensureRoleParticipants(roleData);
      const goingCount = participants.going.length;
      const notGoingCount = participants.notGoing.length;
      const lines = [];
      if (index !== null) {
        lines.push(`*${index + 1}.*`);
      }
      lines.push(`üé´ *C√≥digo:* ${code}`);
      if (roleData.title) {
        lines.push(`üìõ *T√≠tulo:* ${roleData.title}`);
      }
      if (roleData.when) {
        lines.push(`üóìÔ∏è *Quando:* ${roleData.when}`);
      }
      if (roleData.where) {
        lines.push(`üìç *Onde:* ${roleData.where}`);
      }
      if (roleData.description) {
        lines.push(`üìù *Descri√ß√£o:* ${roleData.description}`);
      }
      lines.push(`üôã *Confirmados:* ${goingCount}`);
      lines.push(`ü§∑ *Desist√™ncias:* ${notGoingCount}`);
      return lines.join('\n');
    };
    const formatMentionList = (ids) => ids.map(id => `@${getUserName(id)}`).join(' ');
    const parseTimeToMinutes = (timeStr) => {
      if (typeof timeStr !== 'string') return null;
      
      // Validate basic format
      const m = timeStr.match(/^([01]?\d|2[0-3]):([0-5]\d)$/);
      if (!m) return null;
      
      const h = parseInt(m[1]);
      const mi = parseInt(m[2]);
      
      // Validate hour range
      if (h < 0 || h > 23) return null;
      
      // Validate minute range
      if (mi < 0 || mi > 59) return null;
      
      return h * 60 + mi;
    };
    
    // Enhanced time validation function
    const validateTimeFormat = (timeStr) => {
      if (!timeStr || typeof timeStr !== 'string') {
        return { valid: false, error: 'Hor√°rio inv√°lido. O hor√°rio n√£o pode ser vazio.' };
      }
      
      // Check for valid format
      const isValidFormat = /^([01]?\d|2[0-3]):([0-5]\d)$/.test(timeStr);
      if (!isValidFormat) {
        return { valid: false, error: 'Formato inv√°lido. Use HH:MM (24 horas).' };
      }
      
      // Parse and validate components
      const [hours, minutes] = timeStr.split(':').map(Number);
      
      if (hours < 0 || hours > 23) {
        return { valid: false, error: 'Hora inv√°lida. Use entre 00 e 23.' };
      }
      
      if (minutes < 0 || minutes > 59) {
        return { valid: false, error: 'Minuto inv√°lido. Use entre 00 e 59.' };
      }
      
      // Check for edge cases
      if (timeStr === '24:00') {
        return { valid: false, error: 'Use 23:59 como hor√°rio m√°ximo.' };
      }
      
      return { valid: true, timeStr };
    };
    const normalizeScheduleTime = (timeStr) => {
      if (typeof timeStr !== 'string') return null;
      const trimmed = timeStr.trim();
      const match = trimmed.match(/^([01]?\d|2[0-3]):([0-5]\d)$/);
      if (!match) return null;
      const hours = String(parseInt(match[1], 10)).padStart(2, '0');
      const minutes = match[2];
      return `${hours}:${minutes}`;
    };
    const hasRunForScheduleToday = (entry, today, targetTime) => {
      if (!entry) return false;
      if (typeof entry === 'string') {
        return entry === today;
      }
      if (typeof entry === 'object') {
        const { date, time } = entry;
        if (!date || date !== today) return false;
        if (!targetTime) return true;
        if (!time) return true;
        return time === targetTime;
      }
      return false;
    };
    const recordScheduleRun = (schedule, key, today, targetTime) => {
      if (!schedule || typeof schedule !== 'object') return;
      schedule.lastRun = typeof schedule.lastRun === 'object' && schedule.lastRun !== null ? schedule.lastRun : {};
      schedule.lastRun[key] = {
        date: today,
        time: targetTime
      };
    };
    const formatScheduleLastRun = (entry) => {
      if (!entry) return '‚Äî';
      if (typeof entry === 'string') return entry;
      if (typeof entry === 'object') {
        const date = entry.date || '‚Äî';
        if (entry.time) {
          return `${date} ${entry.time}`;
        }
        return date;
      }
      return '‚Äî';
    };
    const getNowMinutes = () => {
      // Use Brazil/Sao_Paulo timezone for accurate time comparisons
      const now = new Date();
      const saoPauloTime = new Date(now.toLocaleString("en-US", {timeZone: "America/Sao_Paulo"}));
      return saoPauloTime.getHours() * 60 + saoPauloTime.getMinutes();
    };
    const getTodayStr = () => {
      // Use Brazil/Sao_Paulo timezone for consistent date handling
      const d = new Date();
      const saoPauloDate = new Date(d.toLocaleString("en-US", {timeZone: "America/Sao_Paulo"}));
      const y = saoPauloDate.getFullYear();
      const m = String(saoPauloDate.getMonth() + 1).padStart(2, '0');
      const day = String(saoPauloDate.getDate()).padStart(2, '0');
      return `${y}-${m}-${day}`;
    };

    const tzFormat = (date) => new Date(date).toLocaleString('pt-BR');
    const parseAbsoluteDateTime = (str) => {
      if (!str) return null;
      const cleaned = str.toLowerCase().replace(/\s+√†s\s+/g, ' ').replace(/\s+as\s+/g, ' ').trim();
      let m = cleaned.match(/\b(\d{1,2})[\/](\d{1,2})(?:[\/](\d{2,4}))?\s+(\d{1,2}):(\d{2})\b/);
      if (m) {
        let [ , d, mo, y, h, mi ] = m;
        d = parseInt(d); mo = parseInt(mo); h = parseInt(h); mi = parseInt(mi);
        y = y ? parseInt(y) : new Date().getFullYear();
        if (y < 100) y += 2000;
        const dt = new Date(y, mo - 1, d, h, mi, 0, 0);
        if (!isNaN(dt.getTime())) return dt.getTime();
      }
      m = cleaned.match(/\b(\d{1,2}):(\d{2})\s+(\d{1,2})[\/](\d{1,2})(?:[\/](\d{2,4}))?\b/);
      if (m) {
        let [ , h, mi, d, mo, y ] = m;
        d = parseInt(d); mo = parseInt(mo); h = parseInt(h); mi = parseInt(mi);
        y = y ? parseInt(y) : new Date().getFullYear();
        if (y < 100) y += 2000;
        const dt = new Date(y, mo - 1, d, h, mi, 0, 0);
        if (!isNaN(dt.getTime())) return dt.getTime();
      }
      m = cleaned.match(/\bhoje\b\s*(\d{1,2}):(\d{2})/);
      if (m) {
        const now = new Date();
        const h = parseInt(m[1]); const mi = parseInt(m[2]);
        const dt = new Date(now.getFullYear(), now.getMonth(), now.getDate(), h, mi, 0, 0);
        return dt.getTime();
      }
      m = cleaned.match(/\bamanh[√£a]\b\s*(\d{1,2}):(\d{2})/);
      if (m) {
        const now = new Date();
        const h = parseInt(m[1]); const mi = parseInt(m[2]);
        const dt = new Date(now.getFullYear(), now.getMonth(), now.getDate() + 1, h, mi, 0, 0);
        return dt.getTime();
      }
      return null;
    };
    const parseRelative = (str) => {
      if (!str) return null;
      const m = str.toLowerCase().match(/\bem\s+(\d{1,5})\s*(m|min|mins|minutos?|h|hora?s?|d|dias?)\b/);
      if (!m) return null;
      const n = parseInt(m[1]);
      const unit = m[2];
      let ms = 0;
      if (/^m(in|ins|inutos?)?$/.test(unit)) ms = n * 60 * 1000;
      else if (/^h|hora/.test(unit)) ms = n * 60 * 60 * 1000;
      else if (/^d|dia/.test(unit)) ms = n * 24 * 60 * 60 * 1000;
      else return null;
      return Date.now() + ms;
    };
    const parseReminderInput = (text) => {
      if (!text) return null;
      const relTs = parseRelative(text);
      if (relTs) {
        const after = text.toLowerCase().replace(/\bem\s+\d{1,5}\s*(m|min|mins|minutos?|h|hora?s?|d|dias?)\b\s*/,'');
        const msg = after.trim();
        return { at: relTs, message: msg || 'Seu lembrete!' };
      }
      let m = text.toLowerCase().replace(/\s+√†s\s+/g, ' ').match(/(\d{1,2}[\/]\d{1,2}(?:[\/]\d{2,4})?\s+\d{1,2}:\d{2})/);
      if (!m) m = text.toLowerCase().match(/(\d{1,2}:\d{2}\s+\d{1,2}[\/]\d{1,2}(?:[\/]\d{2,4})?)/);
      if (!m) {
        let hm = text.toLowerCase().match(/(hoje\s*\d{1,2}:\d{2}|amanh[√£a]\s*\d{1,2}:\d{2})/);
        if (hm) {
          const ts = parseAbsoluteDateTime(hm[1]);
          const msg = text.toLowerCase().replace(hm[1], '').replace(/\s+√†s\s+/g, ' ').trim();
          if (ts) return { at: ts, message: msg || 'Seu lembrete!' };
        }
        return null;
      }
      const whenStr = m[1];
      const ts = parseAbsoluteDateTime(whenStr);
      if (!ts) return null;
      const msg = text.toLowerCase().replace(whenStr, '').replace(/\s+√†s\s+/g, ' ').trim();
      return { at: ts, message: msg || 'Seu lembrete!' };
    };

    let remindersWorkerStarted = global.remindersWorkerStarted || false;
    const startRemindersWorker = (nazuInstance) => {
      try {
        if (remindersWorkerStarted) return;
        remindersWorkerStarted = true;
        global.remindersWorkerStarted = true;
        setInterval(async () => {
          try {
            // Otimiza√ß√£o: Cache de reminders
            const list = await optimizer.memoize(
              'reminders:all',
              () => Promise.resolve(loadReminders()),
              5000 // 5 segundos
            );
            if (!Array.isArray(list) || list.length === 0) return;
            const now = Date.now();
            let changed = false;
            for (const r of list) {
              if (!r || r.status === 'sent') continue;
              if (typeof r.at !== 'number') continue;
              if (r.at <= now) {
                const textMsg = `‚è∞ Lembrete${r.createdByName ? ` de ${r.createdByName}` : ''}: ${r.message}`;
                try {
                  if (r.chatId && String(r.chatId).endsWith('@g.us')) {
                    await nazuInstance.sendMessage(r.chatId, { text: textMsg, mentions: r.userId ? [r.userId] : [] });
                  } else {
                    const dest = r.chatId || r.userId;
                    if (dest) await nazuInstance.sendMessage(dest, { text: textMsg });
                  }
                  r.status = 'sent';
                  r.sentAt = new Date().toISOString();
                  changed = true;
                } catch (e) {
                }
              }
            }
            if (changed) {
              saveReminders(list);
          // Invalida cache ap√≥s salvar
          optimizer.clearStatic('reminders:all');
              // Invalida cache ap√≥s salvar
              optimizer.clearStatic('reminders:all');
            }
          } catch (err) {
          }
        }, 30 * 1000);
      } catch (e) {
      }
    };
    startRemindersWorker(nazu);
    // GP schedule using cron jobs (daily execution)
    let gpScheduleWorkerStarted = global.gpScheduleWorkerStarted || false;
    const gpCronJobs = {}; // key: `${groupId}:${type}` where type is 'open'|'close'

    const unscheduleGroupJob = (groupId, type) => {
      const key = `${groupId}:${type}`;
      const j = gpCronJobs[key];
      if (j && typeof j.stop === 'function') {
        try { j.stop(); } catch (e) {}
      }
      delete gpCronJobs[key];
    };

    const scheduleGroupJob = (groupId, type, timeStr, nazuInstance) => {
      if (!groupId || !timeStr) return;
      const normalized = normalizeScheduleTime(timeStr);
      if (!normalized) return;
      const [hh, mm] = normalized.split(':');
      if (typeof hh === 'undefined' || typeof mm === 'undefined') return;
      const key = `${groupId}:${type}`;
      // unschedule previous if exists
      unscheduleGroupJob(groupId, type);

      const cronExpr = `${parseInt(mm, 10)} ${parseInt(hh, 10)} * * *`;
      try {
        const task = cron.schedule(cronExpr, async () => {
          try {
            const filePath = buildGroupFilePath(groupId);
            if (!fs.existsSync(filePath)) return;
            let data = {};
            try { data = JSON.parse(fs.readFileSync(filePath, 'utf8')) || {}; } catch (e) { data = {}; }
            data.schedule = data.schedule || {};
            const schedule = data.schedule;

            if (type === 'open') {
              try {
                await nazuInstance.groupSettingUpdate(groupId, 'not_announcement');
                await nazuInstance.sendMessage(groupId, { text: 'üîì Grupo aberto automaticamente pelo agendamento di√°rio.' });
                console.log(`[Cron] ‚úÖ Grupo ABERTO automaticamente: ${groupId.substring(0, 15)}... √†s ${normalized}`);
              } catch (e) {
                console.error(`[Cron Error] open ${groupId}:`, e);
              }
            } else {
              try {
                await nazuInstance.groupSettingUpdate(groupId, 'announcement');
                await nazuInstance.sendMessage(groupId, { text: 'üîí Grupo fechado automaticamente pelo agendamento di√°rio.' });
                console.log(`[Cron] ‚úÖ Grupo FECHADO automaticamente: ${groupId.substring(0, 15)}... √†s ${normalized}`);
              } catch (e) {
                console.error(`[Cron Error] close ${groupId}:`, e);
              }
            }

            // record run and persist
            recordScheduleRun(schedule, type, getTodayStr(), normalized);
            data.schedule = schedule;
            try { writeJsonFile(filePath, data); } catch (e) { console.error('[Cron] Failed to write schedule run:', e); }
          } catch (e) {
            console.error('[Cron] Unexpected error in scheduled job:', e);
          }
        }, { timezone: 'America/Sao_Paulo' });

        gpCronJobs[key] = task;
      } catch (e) {
        console.error('[Cron] Failed to schedule job', cronExpr, e);
      }
    };

    const loadAllGroupSchedules = (nazuInstance) => {
      try {
        if (!ensureDirectoryExists(GRUPOS_DIR)) return;
        const files = fs.readdirSync(GRUPOS_DIR).filter(f => f.endsWith('.json'));
        let loadedCount = 0;
        for (const f of files) {
          const groupId = f.replace(/\.json$/, '');
          if (!groupId.endsWith('@g.us')) continue;
          const filePath = pathz.join(GRUPOS_DIR, f);
          let data = {};
          try { data = JSON.parse(fs.readFileSync(filePath, 'utf8')) || {}; } catch (e) { continue; }
          const schedule = data.schedule && typeof data.schedule === 'object' ? data.schedule : {};
          if (schedule.openTime) {
            scheduleGroupJob(groupId, 'open', schedule.openTime, nazuInstance);
            console.log(`[Cron] ‚úÖ Agendamento ABRIR carregado: Grupo ${groupId.substring(0, 15)}... √†s ${schedule.openTime}`);
            loadedCount++;
          }
          if (schedule.closeTime) {
            scheduleGroupJob(groupId, 'close', schedule.closeTime, nazuInstance);
            console.log(`[Cron] ‚úÖ Agendamento FECHAR carregado: Grupo ${groupId.substring(0, 15)}... √†s ${schedule.closeTime}`);
            loadedCount++;
          }
        }
        if (loadedCount > 0) {
          console.log(`[Cron] üìÖ Total de ${loadedCount} agendamento(s) carregado(s) com sucesso`);
        }
      } catch (e) {
        console.error('[Cron] Failed to load group schedules:', e);
      }
    };

    const startGpScheduleWorker = (nazuInstance) => {
      try {
        if (gpScheduleWorkerStarted) return;
        gpScheduleWorkerStarted = true;
        global.gpScheduleWorkerStarted = true;
        // load existing schedules and create cron jobs
        loadAllGroupSchedules(nazuInstance);
      } catch (e) {
        console.error('[Cron] startGpScheduleWorker error:', e);
      }
    };
    startGpScheduleWorker(nazu);

    let autoHorariosWorkerStarted = global.autoHorariosWorkerStarted || false;
    const startAutoHorariosWorker = (nazuInstance) => {
      try {
        if (autoHorariosWorkerStarted) return;
        autoHorariosWorkerStarted = true;
        global.autoHorariosWorkerStarted = true;
        
        setInterval(async () => {
          try {
            const now = new Date();
            const minutes = now.getMinutes();
            const seconds = now.getSeconds();
            
            if (minutes !== 0 || seconds > 30) return;
            
            const autoSchedulesPath = './dados/database/autohorarios.json';
            if (!fs.existsSync(autoSchedulesPath)) return;
            
            let autoSchedules = {};
            try {
              autoSchedules = JSON.parse(fs.readFileSync(autoSchedulesPath, 'utf8'));
            } catch (e) {
              return;
            }
            
            const currentHour = now.getHours();
            
            for (const [chatId, config] of Object.entries(autoSchedules)) {
              if (!config.enabled) continue;
              if (!chatId.endsWith('@g.us')) continue;
              
              try {
                const currentTime = new Date();
                const currentBrazilTime = new Date(currentTime.getTime() - (3 * 60 * 60 * 1000));
                
                const games = [
                  { name: "üéØ FORTUNE TIGER", hours: [9, 11, 14, 16, 18, 20, 22] },
                  { name: "üêÇ FORTUNE OX", hours: [8, 10, 13, 15, 17, 19, 21] },
                  { name: "üê≠ FORTUNE MOUSE", hours: [7, 12, 14, 16, 19, 21, 23] },
                  { name: "üê∞ FORTUNE RABBIT", hours: [6, 9, 11, 15, 18, 20, 22] },
                  { name: "üêâ FORTUNE DRAGON", hours: [8, 10, 12, 16, 18, 21, 23] },
                  { name: "üíé GATES OF OLYMPUS", hours: [7, 9, 13, 17, 19, 22, 0] },
                  { name: "‚ö° GATES OF AZTEC", hours: [6, 11, 14, 16, 20, 22, 1] },
                  { name: "üç≠ SWEET BONANZA", hours: [8, 12, 15, 17, 19, 21, 23] },
                  { name: "üè∫ HAND OF MIDAS", hours: [7, 10, 13, 16, 18, 20, 0] },
                  { name: "üåü STARLIGHT PRINCESS", hours: [6, 9, 12, 15, 19, 22, 1] },
                  { name: "üî• FIRE PORTALS", hours: [8, 11, 14, 17, 20, 23, 2] },
                  { name: "‚≠ê STAR CLUSTERS", hours: [7, 10, 12, 16, 18, 21, 0] },
                  { name: "üåä AQUA MILLIONS", hours: [6, 9, 13, 15, 19, 22, 1] },
                  { name: "üé™ CIRCUS LAUNCH", hours: [8, 11, 14, 16, 20, 23, 2] },
                  { name: "üèñÔ∏è CASH PATROL", hours: [7, 10, 13, 17, 19, 21, 0] },
                  { name: "üéä PARTY FEVER", hours: [6, 12, 15, 18, 20, 22, 1] },
                  { name: "üé≠ MYSTERY JOKER", hours: [8, 10, 14, 16, 19, 23, 2] },
                  { name: "üé∞ SPIN PARTY", hours: [7, 9, 13, 15, 18, 21, 0] },
                  { name: "üí∞ MONEY MAKER", hours: [6, 11, 12, 17, 20, 22, 1] }
                ];
                
                let responseText = `‚îè‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îì\n`;
                responseText += `‚îÉ    üé∞ *HOR√ÅRIOS PAGANTES*   ‚îÉ\n`;
                responseText += `‚îó‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îõ\n\n`;
                responseText += `üïê *Atualizado automaticamente:*\n`;
                responseText += `üìÖ ${currentBrazilTime.toLocaleDateString('pt-BR')}\n`;
                responseText += `‚è∞ ${currentBrazilTime.toLocaleTimeString('pt-BR', { hour: '2-digit', minute: '2-digit' })}\n\n`;
                
                games.forEach(game => {
                  const todayHours = game.hours.map(baseHour => {
                    const variation = Math.floor(Math.random() * 21) - 10;
                    const finalHour = baseHour + Math.floor(variation / 60);
                    const finalMinutes = Math.abs(variation % 60);
                    
                    const displayHour = finalHour < 0 ? 24 + finalHour : finalHour > 23 ? finalHour - 24 : finalHour;
                    return `${displayHour.toString().padStart(2, '0')}:${finalMinutes.toString().padStart(2, '0')}`;
                  });
                  
                  responseText += `${game.name}\n`;
                  responseText += `üïê ${todayHours.join(' ‚Ä¢ ')}\n\n`;
                });
                
                if (config.link) {
                  responseText += `‚îè‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îì\n`;
                  responseText += `‚îÉ      üîó *LINK DE APOSTAS*     ‚îÉ\n`;
                  responseText += `‚îó‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îõ\n\n`;
                  responseText += `${config.link}\n\n`;
                }
                
                responseText += `‚ö†Ô∏è *AVISOS IMPORTANTES:*\n`;
                responseText += `üîû *Conte√∫do para maiores de 18 anos*\n`;
                responseText += `üìä Estes s√£o hor√°rios estimados\n`;
                responseText += `üéØ Jogue com responsabilidade\n`;
                responseText += `üí∞ Nunca aposte mais do que pode perder\n`;
                responseText += `üÜò Procure ajuda se tiver v√≠cio em jogos\n`;
                responseText += `‚öñÔ∏è Apostas podem causar depend√™ncia\n\n`;
                responseText += `‚îè‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îì\n`;
                responseText += `‚îÉ  üçÄ *BOA SORTE E JOGUE*    ‚îÉ\n`;
                responseText += `‚îÉ     *CONSCIENTEMENTE!* üçÄ  ‚îÉ\n`;
                responseText += `‚îó‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îõ`;
                
                await nazuInstance.sendMessage(chatId, { text: responseText });
                
                config.lastSent = Date.now();
                
              } catch (e) {
                console.error(`Erro ao enviar auto hor√°rios para ${chatId}:`, e);
              }
            }
            
            try {
              writeJsonFile(autoSchedulesPath, autoSchedules);
            } catch (e) {
              console.error('Erro ao salvar auto schedules:', e);
            }
            
          } catch (err) {
            console.error('Erro no auto hor√°rios worker:', err);
          }
        }, 60 * 1000);
        
      } catch (e) {
        console.error('Erro ao iniciar auto hor√°rios worker:', e);
      }
    };
    startAutoHorariosWorker(nazu);

    // Auto Mensagens Worker usando cron jobs (executa conforme hor√°rios programados)
    let autoMensagensWorkerStarted = global.autoMensagensWorkerStarted || false;
    const autoMsgCronJobs = global.autoMsgCronJobs || {}; // key: `${groupId}:${msgId}`
    global.autoMsgCronJobs = autoMsgCronJobs; // Garantir persist√™ncia global

    const unscheduleAutoMessage = (groupId, msgId) => {
      const key = `${groupId}:${msgId}`;
      const j = autoMsgCronJobs[key];
      if (j && typeof j.stop === 'function') {
        try { j.stop(); } catch (e) {}
      }
      delete autoMsgCronJobs[key];
    };

    const scheduleAutoMessage = (groupId, msgConfig, nazuInstance) => {
      if (!groupId || !msgConfig || !msgConfig.id || !msgConfig.time) return;
      
      const normalized = normalizeScheduleTime(msgConfig.time);
      if (!normalized) return;
      
      const [hh, mm] = normalized.split(':');
      if (typeof hh === 'undefined' || typeof mm === 'undefined') return;
      
      const key = `${groupId}:${msgConfig.id}`;
      
      // Remover agendamento anterior se existir
      unscheduleAutoMessage(groupId, msgConfig.id);

      const cronExpr = `${parseInt(mm, 10)} ${parseInt(hh, 10)} * * *`;
      
      try {
        const task = cron.schedule(cronExpr, async () => {
          try {
            // Recarregar dados do arquivo para pegar vers√£o mais recente
            const filePath = pathz.join(GRUPOS_DIR, `${groupId}.json`);
            if (!fs.existsSync(filePath)) {
              console.warn(`[AutoMsg] Arquivo do grupo n√£o encontrado: ${groupId}`);
              return;
            }
            
            let groupFileData = {};
            try {
              groupFileData = JSON.parse(fs.readFileSync(filePath, 'utf8'));
            } catch (e) {
              console.error(`[AutoMsg] Erro ao ler arquivo do grupo ${groupId}:`, e);
              return;
            }
            
            const autoMessages = groupFileData.autoMessages || [];
            const currentMsg = autoMessages.find(m => m.id === msgConfig.id);
            
            if (!currentMsg) {
              console.warn(`[AutoMsg] Mensagem ${msgConfig.id} n√£o encontrada no arquivo`);
              return;
            }
            
            if (!currentMsg.enabled) {
              console.log(`[AutoMsg] Mensagem ${msgConfig.id} est√° desativada, pulando envio`);
              return;
            }
            
            // Construir e enviar a mensagem
            const messageContent = {};
            
            if (currentMsg.type === 'text') {
              messageContent.text = currentMsg.content;
            } else if (currentMsg.type === 'image') {
              messageContent.image = { url: currentMsg.mediaPath };
              if (currentMsg.caption) messageContent.caption = currentMsg.caption;
            } else if (currentMsg.type === 'video') {
              messageContent.video = { url: currentMsg.mediaPath };
              if (currentMsg.caption) messageContent.caption = currentMsg.caption;
            } else if (currentMsg.type === 'document') {
              messageContent.document = { url: currentMsg.mediaPath };
              messageContent.fileName = currentMsg.fileName || 'documento.pdf';
              if (currentMsg.caption) messageContent.caption = currentMsg.caption;
            } else if (currentMsg.type === 'sticker') {
              messageContent.sticker = { url: currentMsg.mediaPath };
            } else if (currentMsg.type === 'audio') {
              messageContent.audio = { url: currentMsg.mediaPath };
              messageContent.mimetype = 'audio/mp4';
            }
            
            await nazuInstance.sendMessage(groupId, messageContent);
            console.log(`[AutoMsg] ‚úÖ Mensagem enviada automaticamente: Grupo ${groupId.substring(0, 15)}... ID ${msgConfig.id} √†s ${normalized}`);
            
          } catch (e) {
            console.error(`[AutoMsg Error] ${groupId}:${msgConfig.id}:`, e);
          }
        }, { 
          scheduled: true,
          timezone: 'America/Sao_Paulo' 
        });

        // Iniciar a task imediatamente
        task.start();
        autoMsgCronJobs[key] = task;
        console.log(`[AutoMsg] üîî Agendamento criado para ${key} em ${cronExpr} (timezone: America/Sao_Paulo)`);
      } catch (e) {
        console.error('[AutoMsg] Failed to schedule message', cronExpr, e);
      }
    };

    const loadAllAutoMessages = (nazuInstance) => {
      try {
        if (!ensureDirectoryExists(GRUPOS_DIR)) return;
        const files = fs.readdirSync(GRUPOS_DIR).filter(f => f.endsWith('.json'));
        let loadedCount = 0;
        
        for (const f of files) {
          const groupId = f.replace(/\.json$/, '');
          if (!groupId.endsWith('@g.us')) continue;
          
          const filePath = pathz.join(GRUPOS_DIR, f);
          let data = {};
          try { data = JSON.parse(fs.readFileSync(filePath, 'utf8')) || {}; } catch (e) { continue; }
          
          const autoMessages = data.autoMessages && Array.isArray(data.autoMessages) ? data.autoMessages : [];
          
          for (const msgConfig of autoMessages) {
            if (msgConfig.enabled && msgConfig.time) {
              scheduleAutoMessage(groupId, msgConfig, nazuInstance);
              console.log(`[AutoMsg] ‚úÖ Mensagem agendada: Grupo ${groupId.substring(0, 15)}... ID ${msgConfig.id} √†s ${msgConfig.time}`);
              loadedCount++;
            }
          }
        }
        
        if (loadedCount > 0) {
          console.log(`[AutoMsg] üì® Total de ${loadedCount} mensagem(ns) autom√°tica(s) carregada(s) com sucesso`);
        }
      } catch (e) {
        console.error('[AutoMsg] Failed to load auto messages:', e);
      }
    };

    const startAutoMensagensWorker = (nazuInstance) => {
      try {
        if (autoMensagensWorkerStarted) return;
        autoMensagensWorkerStarted = true;
        global.autoMensagensWorkerStarted = true;
        
        // Carregar mensagens existentes e criar cron jobs
        loadAllAutoMessages(nazuInstance);

        // Recarregar periodicamente para garantir que os agendamentos permane√ßam ativos
        if (!global.autoMensagensRefreshTimer) {
          global.autoMensagensRefreshTimer = setInterval(() => {
            try {
              loadAllAutoMessages(nazuInstance);
            } catch (e) {
              console.error('[AutoMsg] refresh error:', e);
            }
          }, 6 * 60 * 60 * 1000); // a cada 6 horas
        }
      } catch (e) {
        console.error('[AutoMsg] startAutoMensagensWorker error:', e);
      }
    };
    
    startAutoMensagensWorker(nazu);

    // ============== DIVULGA√á√ÉO DO DONO (NOVO SISTEMA) ==============
    let donoDivulgacaoWorkerStarted = global.donoDivulgacaoWorkerStarted || false;
    let donoDivulgacaoCronJob = global.donoDivulgacaoCronJob || null;

    const unscheduleDonoDivulgacaoJob = () => {
      if (donoDivulgacaoCronJob && typeof donoDivulgacaoCronJob.stop === 'function') {
        try { donoDivulgacaoCronJob.stop(); } catch (e) {}
      }
      donoDivulgacaoCronJob = null;
      global.donoDivulgacaoCronJob = null;
    };

    const runDonoDivulgacaoSend = async (nazuInstance, messageText, source = 'manual') => {
      const config = loadDonoDivulgacao();
      const groups = Array.isArray(config.groups) ? config.groups : [];
      const text = (messageText || config.message || '').trim();

      if (!text) {
        return { success: false, message: '‚ùå Nenhuma mensagem configurada para divulgar.' };
      }
      if (groups.length === 0) {
        return { success: false, message: '‚ùå Nenhum grupo registrado para divulga√ß√£o.' };
      }

      let sent = 0;
      let failed = 0;

      for (const groupId of groups) {
        if (!isGroupId(groupId)) {
          failed++;
          continue;
        }
        try {
          await nazuInstance.sendMessage(groupId, { text });
          sent++;
        } catch (e) {
          failed++;
        }
      }

      config.stats = config.stats || { totalSent: 0, lastManual: null, lastAuto: null };
      config.stats.totalSent = (config.stats.totalSent || 0) + sent;
      if (source === 'auto') {
        config.stats.lastAuto = new Date().toISOString();
      } else {
        config.stats.lastManual = new Date().toISOString();
      }

      saveDonoDivulgacao(config);

      return { success: true, sent, failed };
    };

    const scheduleDonoDivulgacaoJob = (timeStr, nazuInstance) => {
      const normalized = normalizeScheduleTime(timeStr);
      if (!normalized) return false;
      const [hh, mm] = normalized.split(':');
      if (typeof hh === 'undefined' || typeof mm === 'undefined') return false;

      unscheduleDonoDivulgacaoJob();

      const cronExpr = `${parseInt(mm, 10)} ${parseInt(hh, 10)} * * *`;
      try {
        const task = cron.schedule(cronExpr, async () => {
          try {
            const config = loadDonoDivulgacao();
            const schedule = config.schedule || {};

            if (!schedule.enabled || !schedule.time) return;
            const targetTime = normalizeScheduleTime(schedule.time);
            if (!targetTime) return;

            const today = getTodayStr();
            if (hasRunForScheduleToday(schedule.lastRun, today, targetTime)) return;

            const result = await runDonoDivulgacaoSend(nazuInstance, null, 'auto');
            if (result.success) {
              schedule.lastRun = { date: today, time: targetTime };
              config.schedule = schedule;
              saveDonoDivulgacao(config);
            }
          } catch (e) {
            console.error('[DivDono] Erro no agendamento:', e);
          }
        }, { timezone: 'America/Sao_Paulo' });

        task.start();
        donoDivulgacaoCronJob = task;
        global.donoDivulgacaoCronJob = task;
        return true;
      } catch (e) {
        console.error('[DivDono] Falha ao agendar job', cronExpr, e);
        return false;
      }
    };

    const startDonoDivulgacaoWorker = (nazuInstance) => {
      try {
        if (donoDivulgacaoWorkerStarted) return;
        donoDivulgacaoWorkerStarted = true;
        global.donoDivulgacaoWorkerStarted = true;

        const config = loadDonoDivulgacao();
        if (config.schedule?.enabled && config.schedule?.time) {
          scheduleDonoDivulgacaoJob(config.schedule.time, nazuInstance);
        }
      } catch (e) {
        console.error('[DivDono] Erro ao iniciar worker:', e);
      }
    };

    startDonoDivulgacaoWorker(nazu);

    const getFileBuffer = async (mediakey, mediaType, options = {}) => {
      try {
        if (!mediakey) {
          throw new Error('Chave de m√≠dia inv√°lida');
        }
        const stream = await downloadContentFromMessage(mediakey, mediaType);
        let buffer = Buffer.from([]);
        const MAX_BUFFER_SIZE = 50 * 1024 * 1024;
        let totalSize = 0;
        for await (const chunk of stream) {
          buffer = Buffer.concat([buffer, chunk]);
          totalSize += chunk.length;
          if (totalSize > MAX_BUFFER_SIZE) {
            throw new Error(`Tamanho m√°ximo de buffer excedido (${MAX_BUFFER_SIZE / (1024 * 1024)}MB)`);
          }
        }
        if (options.saveToTemp) {
          try {
            const tempDir = pathz.join(__dirname, '..', 'database', 'tmp');
            ensureDirectoryExists(tempDir);
            const fileName = options.fileName || `${Date.now()}_${Math.floor(Math.random() * 10000)}`;
            const extensionMap = {
              image: '.jpg',
              video: '.mp4',
              audio: '.mp3',
              document: '.bin'
            };
            const extension = extensionMap[mediaType] || '.dat';
            const filePath = pathz.join(tempDir, fileName + extension);
            fs.writeFileSync(filePath, buffer);
            return filePath;
          } catch (fileError) {
            console.error('Erro ao salvar arquivo tempor√°rio:', fileError);
          }
        }
        return buffer;
      } catch (error) {
        console.error(`Erro ao obter buffer de ${mediaType}:`, error);
        throw error;
      }
    };
    const getMediaInfo = message => {
      if (!message) return null;
      if (message.imageMessage) return {
        media: message.imageMessage,
        type: 'image'
      };
      if (message.videoMessage) return {
        media: message.videoMessage,
        type: 'video'
      };
      if (message.viewOnceMessage?.message?.imageMessage) return {
        media: message.viewOnceMessage.message.imageMessage,
        type: 'image'
      };
      if (message.viewOnceMessage?.message?.videoMessage) return {
        media: message.viewOnceMessage.message.videoMessage,
        type: 'video'
      };
      if (message.viewOnceMessageV2?.message?.imageMessage) return {
        media: message.viewOnceMessageV2.message.imageMessage,
        type: 'image'
      };
      if (message.viewOnceMessageV2?.message?.videoMessage) return {
        media: message.viewOnceMessageV2.message.videoMessage,
        type: 'video'
      };
      return null;
    };
    
    /**
     * Processa uma imagem usando ffmpeg para formato adequado para foto de perfil
     * Redimensiona para 640x640 (m√°ximo) e converte para JPEG
     */
    const processImageForProfile = async (imageBuffer) => {
      const tempDir = pathz.join(__dirname, '..', 'database', 'tmp');
      ensureDirectoryExists(tempDir);
      
      const inputFile = pathz.join(tempDir, `input_${Date.now()}.jpg`);
      const outputFile = pathz.join(tempDir, `output_${Date.now()}.jpg`);
      
      try {
        // Salva o buffer de entrada
        fs.writeFileSync(inputFile, imageBuffer);
        
        // Processa com ffmpeg: redimensiona para 640x640 mantendo propor√ß√£o e converte para JPEG
        const cmd = `ffmpeg -hide_banner -loglevel error -i "${inputFile}" -vf "scale=640:640:force_original_aspect_ratio=decrease,pad=640:640:(ow-iw)/2:(oh-ih)/2:color=white" -q:v 5 -y "${outputFile}"`;
        
        await execAsync(cmd, { timeout: 15000 });
        
        // L√™ o arquivo processado
        const processedBuffer = fs.readFileSync(outputFile);
        
        // Limpa arquivos tempor√°rios
        try {
          fs.unlinkSync(inputFile);
          fs.unlinkSync(outputFile);
        } catch (cleanupError) {
          console.warn('Aviso: Erro ao limpar arquivos tempor√°rios:', cleanupError.message);
        }
        
        return processedBuffer;
      } catch (error) {
        // Limpa arquivos tempor√°rios em caso de erro
        try {
          if (fs.existsSync(inputFile)) fs.unlinkSync(inputFile);
          if (fs.existsSync(outputFile)) fs.unlinkSync(outputFile);
        } catch (cleanupError) {
          // Ignora erros de limpeza
        }
        throw new Error(`Erro ao processar imagem: ${error.message}`);
      }
    };
    
    if (isGroup && info.message?.extendedTextMessage?.contextInfo?.mentionedJid) {
      const mentioned = info.message.extendedTextMessage.contextInfo.mentionedJid;
      if (groupData.afkUsers) {
        for (const jid of mentioned) {
          if (groupData.afkUsers[jid]) {
            const afkData = groupData.afkUsers[jid];
            const afkSince = new Date(afkData.since).toLocaleString('pt-BR', {
              timeZone: 'America/Sao_Paulo'
            });
            let afkMsg = `üò¥ @${getUserName(jid)} est√° AFK desde ${afkSince}.`;
            if (afkData.reason) {
              afkMsg += `\nMotivo: ${afkData.reason}`;
            }
            await reply(afkMsg, {
              mentions: [jid]
            });
          }
        }
      }
    }
    if (isGroup && isAntiPorn && !info.key.fromMe) {
      if (!isGroupAdmin && !isUserWhitelisted(sender, 'antiporn')) {
        const mediaInfo = getMediaInfo(info.message);
        if (mediaInfo && mediaInfo.type === 'image') {
          try {
            const imageBuffer = await getFileBuffer(mediaInfo.media, 'image');
            const mediaURL = await upload(imageBuffer, true);
            if (mediaURL) {
              const apiResponse = await axios.get(`https://nsfw-demo.sashido.io/api/image/classify?url=${encodeURIComponent(mediaURL)}`);
              let scores = {
                Porn: 0,
                Hentai: 0
              };
              if (Array.isArray(apiResponse.data)) {
                scores = apiResponse.data.reduce((acc, item) => {
                  if (item && typeof item.className === 'string' && typeof item.probability === 'number') {
                    if (item.className === 'Porn' || item.className === 'Hentai') {
                      acc[item.className] = Math.max(acc[item.className] || 0, item.probability);
                    }
                  }
                  return acc;
                }, {
                  Porn: 0,
                  Hentai: 0
                });
              } else {
                console.warn("Anti-porn API response format unexpected:", apiResponse.data);
              }
              const pornThreshold = 0.7;
              const hentaiThreshold = 0.7;
              const isPorn = scores.Porn >= pornThreshold;
              const isHentai = scores.Hentai >= hentaiThreshold;
              if (isPorn || isHentai) {
                const reason = isPorn ? 'Pornografia' : 'Hentai';
                await reply(`üö® Conte√∫do impr√≥prio detectado! (${reason})`);
                if (isBotAdmin) {
                  try {
                    await nazu.sendMessage(from, {
                      delete: info.key
                    });
                    await nazu.groupParticipantsUpdate(from, [sender], 'remove');
                    await reply(`üîû @${getUserName(sender)}, conte√∫do impr√≥prio detectado. Voc√™ foi removido do grupo.`, {
                      mentions: [sender]
                    });
                  } catch (adminError) {
                    console.error(`Erro ao remover usu√°rio por anti-porn: ${adminError}`);
                    await reply(`‚ö†Ô∏è N√£o consegui remover @${getUserName(sender)} automaticamente ap√≥s detectar conte√∫do impr√≥prio. Admins, por favor, verifiquem!`, {
                      mentions: [sender]
                    });
                  }
                } else {
                  await reply(`@${getUserName(sender)} enviou conte√∫do impr√≥prio (${reason}), mas n√£o posso remov√™-lo sem ser admin.`, {
                    mentions: [sender]
                  });
                }
              }
            } else {
              console.warn("Falha no upload da imagem para verifica√ß√£o anti-porn.");
            }
          } catch (error) {
            console.error("Erro na verifica√ß√£o anti-porn:", error);
          }
        }
      }
    }
    if (isGroup && groupData.antiloc && !isGroupAdmin && type === 'locationMessage') {
      if (!isUserWhitelisted(sender, 'antiloc')) {
        await nazu.sendMessage(from, {
          delete: {
            remoteJid: from,
            fromMe: false,
            id: info.key.id,
            participant: sender
          }
        });
        await nazu.groupParticipantsUpdate(from, [sender], 'remove');
        await reply(`üó∫Ô∏è @${getUserName(sender)}, localiza√ß√£o n√£o permitida. Voc√™ foi removido do grupo.`, {
          mentions: [sender]
        });
      }
    }
    if (isGroup && antifloodData[from]?.enabled && isCmd && !isGroupAdmin) {
      antifloodData[from].users = antifloodData[from].users || {};
      const now = Date.now();
      const lastCmd = antifloodData[from].users[sender]?.lastCmd || 0;
      const interval = antifloodData[from].interval * 1000;
      if (now - lastCmd < interval) {
        return reply(`‚è≥ Aguarde ${Math.ceil((interval - (now - lastCmd)) / 1000)} segundos antes de usar outro comando.`);
      }
      antifloodData[from].users[sender] = {
        lastCmd: now
      };
      // Nota: N√£o salvamos em disco aqui para evitar race conditions.
      // O cache ser√° salvo periodicamente pelo optimizer.
    }
    if (isGroup && groupData.antidoc && !isGroupAdmin && (type === 'documentMessage' || type === 'documentWithCaptionMessage')) {
      if (!isUserWhitelisted(sender, 'antidoc')) {
        await nazu.sendMessage(from, {
          delete: {
            remoteJid: from,
            fromMe: false,
            id: info.key.id,
            participant: sender
          }
        });
        await nazu.groupParticipantsUpdate(from, [sender], 'remove');
        await reply(`üìÑ @${getUserName(sender)}, documentos n√£o s√£o permitidos. Voc√™ foi removido do grupo.`, {
          mentions: [sender]
        });
      }
    }
    
    if (isGroup && groupData.autodl && budy2.includes('http') && !isCmd) {
      const urlMatch = body.match(/(https?:\/\/[^\s]+)/g);
      if (urlMatch && urlMatch.length > 0) {
        // Processa apenas o primeiro link encontrado
        try {
          handleAutoDownload(nazu, from, urlMatch[0], info)
            .then(() => null)
            .catch((e) => {
              console.error('Erro no autodl:', e);
            });
        } catch (e) {
          console.error('Erro no autodl:', e);
        }
      }
    }
    if (isGroup && groupData.autoSticker && !info.key.fromMe) {
      try {
        const mediaImage = info.message?.imageMessage || info.message?.viewOnceMessageV2?.message?.imageMessage || info.message?.viewOnceMessage?.message?.imageMessage;
        const mediaVideo = info.message?.videoMessage || info.message?.viewOnceMessageV2?.message?.videoMessage || info.message?.viewOnceMessage?.message?.videoMessage;
        if (mediaImage || mediaVideo) {
          const isVideo = !!mediaVideo;
          if (isVideo && mediaVideo.seconds > 9.9) {
            return;
          }
          const buffer = await getFileBuffer(isVideo ? mediaVideo : mediaImage, isVideo ? 'video' : 'image');
          const shouldForceSquare = global.autoStickerMode === 'square';
          await sendSticker(nazu, from, {
            sticker: buffer,
            author: `„Äé${pushname}„Äè\n„Äé${nomebot}„Äè\n„Äé${nomedono}„Äè\n„Äécognima.com.br„Äè`,
            packname: 'üë§ Usuario(a)·ÆÄ€ü‚ùÅ‚ÄôÔø´\nü§ñ Bot·ÆÄ€ü‚ùÅ‚ÄôÔø´\nüëë Dono·ÆÄ€ü‚ùÅ‚ÄôÔø´\nüåê Site·ÆÄ€ü‚ùÅ‚ÄôÔø´',
            type: isVideo ? 'video' : 'image',
            forceSquare: shouldForceSquare
          }, {
            quoted: info
          });
        }
      } catch (e) {
        console.error("Erro ao converter m√≠dia em figurinha autom√°tica:", e);
      }
    }
    let quotedMessageContent = null;
    if (type === 'extendedTextMessage' && info.message?.extendedTextMessage?.contextInfo?.quotedMessage) {
      quotedMessageContent = info.message.extendedTextMessage.contextInfo.quotedMessage;
    }
    const isQuotedMsg = !!quotedMessageContent?.conversation;
    const isQuotedMsg2 = !!quotedMessageContent?.extendedTextMessage?.text;
    const isQuotedImage = !!quotedMessageContent?.imageMessage;
    const isQuotedVisuU = !!quotedMessageContent?.viewOnceMessage;
    const isQuotedVisuU2 = !!quotedMessageContent?.viewOnceMessageV2;
    const isQuotedVideo = !!quotedMessageContent?.videoMessage;
    const isQuotedDocument = !!quotedMessageContent?.documentMessage;
    const isQuotedDocW = !!quotedMessageContent?.documentWithCaptionMessage;
    const isQuotedAudio = !!quotedMessageContent?.audioMessage;
    const isQuotedSticker = !!quotedMessageContent?.stickerMessage;
    const isQuotedContact = !!quotedMessageContent?.contactMessage;
    const isQuotedLocation = !!quotedMessageContent?.locationMessage;
    const isQuotedProduct = !!quotedMessageContent?.productMessage;
    if (body.startsWith('$')) {
      if (!isOwner) return;
      try {
        exec(q, (err, stdout) => {
          if (err) {
            return reply(`‚ùå *Erro na execu√ß√£o*\n\n${err}`);
          }
          if (stdout) {
            reply(`‚úÖ *Resultado do comando*\n\n${stdout}`);
          }
        });
      } catch (error) {
        reply(`‚ùå *Erro ao executar comando*\n\n${error}`);
      }
    }
    if (body.startsWith('>>')) {
      if (!isOwner) return;
      try {
        (async () => {
          try {
            const codeLines = body.slice(2).trim().split('\n');
            if (codeLines.length > 1) {
              if (!codeLines[codeLines.length - 1].includes('return')) {
                
                codeLines[codeLines.length - 1] = 'return ' + codeLines[codeLines.length - 1];
              }
            } else {
              if (!codeLines[0].includes('return')) {
                
                codeLines[0] = 'return ' + codeLines[0];
              }
            }
            const result = await eval(`(async () => { ${codeLines.join('\n')} })()`);
            let output;
            if (typeof result === 'object' && result !== null) {
              
              output = JSON.stringify(result, null, 2);
            } else if (typeof result === 'function') {
              
              output = result.toString();
            } else {
              
              output = String(result);
            }
            return reply(`‚úÖ *Resultado da execu√ß√£o*\n\n${output}`).catch(e => reply(String(e)));
          } catch (e) {
            return reply(`‚ùå *Erro na execu√ß√£o*\n\n${String(e)}`);
          }
        })();
      } catch (e) {
        reply(`‚ùå *Erro cr√≠tico*\n\n${String(e)}`);
      }
    }

    // Verifica se o usu√°rio √© um parceiro registrado
    const isParceiro = !!(parceriasData?.active && parceriasData?.partners?.[sender]);

    if (isGroup && isAntiLinkGp && !isGroupAdmin && !isParceiro) {
      if (!isUserWhitelisted(sender, 'antilinkgp')) {
        let foundGroupLink = false;
        let link_dgp = null;
        try {
          if (budy2.includes('chat.whatsapp.com')) {
            foundGroupLink = true;
            link_dgp = await nazu.groupInviteCode(from);
            if (budy2.includes(link_dgp)) foundGroupLink = false;
          }
          if (!foundGroupLink && info.message?.requestPaymentMessage) {
            const paymentText = info.message.requestPaymentMessage?.noteMessage?.extendedTextMessage?.text || '';
            if (paymentText.includes('chat.whatsapp.com')) {
              foundGroupLink = true;
              link_dgp = link_dgp || await nazu.groupInviteCode(from);
              if (paymentText.includes(link_dgp)) foundGroupLink = false;
            }
          }
          if (foundGroupLink) {
            if (isOwner) return;
            if (!AllgroupMembers.includes(sender)) return;
            if (isBotAdmin) {
              await nazu.groupParticipantsUpdate(from, [sender], 'remove');
              await nazu.sendMessage(from, {
                delete: {
                  remoteJid: from,
                  fromMe: false,
                  id: info.key.id,
                  participant: sender
                }
              });
              await reply(`üîó @${getUserName(sender)}, links de outros grupos n√£o s√£o permitidos. Voc√™ foi removido do grupo.`, {
                mentions: [sender]
              });
            } else {
              await nazu.sendMessage(from, {
                delete: {
                  remoteJid: from,
                  fromMe: false,
                  id: info.key.id,
                  participant: sender
                }
              });
              await reply(`üîó Aten√ß√£o, @${getUserName(sender)}! Links de outros grupos n√£o s√£o permitidos. N√£o consigo remover voc√™, mas evite compartilhar esses links.`, {
                mentions: [sender]
              });
            }
            return;
          }
        } catch (error) {
          console.error("Erro no sistema antilink de grupos:", error);
        }
      }
    }
    if (isGroup && isAntiLinkCanal && !isGroupAdmin && !isParceiro) {
      if (!isUserWhitelisted(sender, 'antilinkcanal')) {
        let foundChannelLink = false;
        try {
          if (budy2.includes('whatsapp.com/channel/')) {
            foundChannelLink = true;
          }
          if (!foundChannelLink && info.message?.requestPaymentMessage) {
            const paymentText = info.message.requestPaymentMessage?.noteMessage?.extendedTextMessage?.text || '';
            if (paymentText.includes('whatsapp.com/channel/')) {
              foundChannelLink = true;
            }
          }
          if (foundChannelLink) {
            if (isOwner) return;
            if (!AllgroupMembers.includes(sender)) return;
            if (isBotAdmin) {
              await nazu.groupParticipantsUpdate(from, [sender], 'remove');
              await nazu.sendMessage(from, {
                delete: {
                  remoteJid: from,
                  fromMe: false,
                  id: info.key.id,
                  participant: sender
                }
              });
              await reply(`üì¢ @${getUserName(sender)}, links de canais n√£o s√£o permitidos. Voc√™ foi removido do grupo.`, {
                mentions: [sender]
              });
            } else {
              await nazu.sendMessage(from, {
                delete: {
                  remoteJid: from,
                  fromMe: false,
                  id: info.key.id,
                  participant: sender
                }
              });
              await reply(`üì¢ Aten√ß√£o, @${getUserName(sender)}! Links de canais n√£o s√£o permitidos. N√£o consigo remover voc√™, mas evite compartilhar esses links.`, {
                mentions: [sender]
              });
            }
            return;
          }
        } catch (error) {
          console.error("Erro no sistema antilink de canais:", error);
        }
      }
    }
    if (isGroup && isAntiLinkSoft && !isGroupAdmin && !isParceiro && budy2.includes('http') && !isOwner) {
      if (!isUserWhitelisted(sender, 'antilinksoft')) {
        try {
          await nazu.sendMessage(from, {
            delete: {
              remoteJid: from,
              fromMe: false,
              id: info.key.id,
              participant: sender
            }
          });
          return;
        } catch (error) {
          console.error("Erro no sistema antilinksoft:", error);
        }
      }
    }
    // AntiLink Hard - Remove qualquer link compartilhado
    if (isGroup && groupData.antilinkhard && !isGroupAdmin && !isOwner && !isParceiro) {
      const linkRegex = /(https?:\/\/|www\.)[^\s]+|([a-zA-Z0-9-]+\.)+[a-zA-Z]{2,}(\/[^\s]*)?/gi;
      const hasLink = linkRegex.test(budy2);
      
      if (hasLink && !isUserWhitelisted(sender, 'antilinkhard')) {
        try {
          if (isBotAdmin) {
            await nazu.groupParticipantsUpdate(from, [sender], 'remove');
            await nazu.sendMessage(from, {
              delete: {
                remoteJid: from,
                fromMe: false,
                id: info.key.id,
                participant: sender
              }
            });
            await reply(`üîó @${getUserName(sender)}, links n√£o s√£o permitidos. Voc√™ foi removido do grupo.`, {
              mentions: [sender]
            });
          } else {
            await nazu.sendMessage(from, {
              delete: {
                remoteJid: from,
                fromMe: false,
                id: info.key.id,
                participant: sender
              }
            });
            await reply(`üîó Aten√ß√£o, @${getUserName(sender)}! Links n√£o s√£o permitidos. N√£o consigo remover voc√™, mas evite enviar links.`, {
              mentions: [sender]
            });
          }
          return;
        } catch (error) {
          console.error("Erro no sistema antilink hard:", error);
        }
      }
    }
  const botStateFile = pathz.join(DATABASE_DIR, 'botState.json');
    if (botState.status === 'off' && !isOwner) return;
    if (botState.viewMessages) nazu.readMessages([info.key]);
    try {
      if (budy2 && budy2.length > 1) {
        const timestamp = new Date().toLocaleTimeString('pt-BR', {
          hour12: false,
          timeZone: 'America/Sao_Paulo'
        });
        const messageType = isCmd ? 'COMANDO' : 'MENSAGEM';
        const context = isGroup ? 'GRUPO' : 'PRIVADO';
        const messagePreview = isCmd ? `${prefix}${command}${q ? ` ${q.substring(0, 25)}${q.length > 25 ? '...' : ''}` : ''}` : budy2.substring(0, 35) + (budy2.length > 35 ? '...' : '');
        console.log('‚îè‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îì');
        console.log(`‚îÉ ${messageType} [${context}]${' '.repeat(36 - messageType.length - context.length)}`);
        console.log('‚î£‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚î´');
        console.log(`‚îÉ üìú Conte√∫do: ${messagePreview.padEnd(28)}`);
        if (isGroup) {
          console.log(`‚îÉ üë• Grupo: ${(groupName || 'Desconhecido').padEnd(28)}`);
          console.log(`‚îÉ üë§ Usu√°rio: ${(pushname || 'Sem Nome').padEnd(28)}`);
        } else {
          console.log(`‚îÉ üë§ Usu√°rio: ${(pushname || 'Sem Nome').padEnd(28)}`);
          console.log(`‚îÉ üì± N√∫mero: ${getUserName(sender).padEnd(28)}`);
        }
        console.log('‚î£‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚î´');
        console.log(`‚îÉ üïí Data/Hora: ${timestamp.padEnd(27)}`);
        console.log('‚îó‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îõ\n');
      }
    } catch (error) {
      console.error('‚îÉ üö® Erro ao gerar logs:', error, '');
    }
    if (isGroup) {
      try {
        if (relationshipManager && relationshipManager.hasPendingRequest && relationshipManager.processResponse) {
          try {
            if (relationshipManager.hasPendingRequest(from) && body) {
              const relResponse = relationshipManager.processResponse(from, sender, body);
              if (relResponse) {
                // Apenas envia mensagem se for sucesso, ignora respostas inv√°lidas
                if (relResponse.success && relResponse.message) {
                  await nazu.sendMessage(from, {
                    text: relResponse.message,
                    mentions: relResponse.mentions || []
                  });
                }
              }
            }

            // Processa resposta de trai√ß√£o
            if (relationshipManager.hasPendingBetrayal && relationshipManager.processBetrayalResponse) {
              if (relationshipManager.hasPendingBetrayal(from) && body) {
                const betrayalResponse = relationshipManager.processBetrayalResponse(from, sender, body, groupPrefix);
                if (betrayalResponse) {
                  // Apenas envia mensagem se for sucesso, ignora respostas inv√°lidas
                  if (betrayalResponse.success && betrayalResponse.message) {
                    await nazu.sendMessage(from, {
                      text: betrayalResponse.message,
                      mentions: betrayalResponse.mentions || []
                    });
                  }
                }
              }
            }
          } catch (relError) {
            console.warn('[RELATIONSHIP] Error processing relationship response:', relError.message);
          }
        }
        
        if (tictactoe.hasPendingInvitation(from) && budy2) {
          const normalizedResponse = budy2.toLowerCase().trim();
          const result = tictactoe.processInvitationResponse(from, sender, normalizedResponse);
          if (result.success) {
            await nazu.sendMessage(from, {
              text: result.message,
              mentions: result.mentions || []
            });
          }
        }
        if (tictactoe.hasActiveGame(from) && budy2) {
          if (['tttend', 'rv', 'fimjogo'].includes(budy2)) {
            if (!isGroupAdmin) {
              await reply("‚ö†Ô∏è Apenas administradores podem encerrar um jogo da velha em andamento.");
              return;
            }
            const result = tictactoe.endGame(from);
            await reply(result.message);
            return;
          }
          const position = parseInt(budy2.trim());
          if (!isNaN(position)) {
            const result = tictactoe.makeMove(from, sender, position);
            if (result.success) {
              await nazu.sendMessage(from, {
                text: result.message,
                mentions: result.mentions || [sender]
              });
            } else if (result.message) {
              await reply(result.message);
            }
          }
          return;
        }

        // Processamento de respostas para Connect4
        if (connect4 && connect4.hasPendingInvitation && connect4.hasPendingInvitation(from) && budy2) {
          const normalizedResponse = budy2.toLowerCase().trim();
          const result = connect4.processInvitationResponse(from, sender, normalizedResponse);
          if (result.success) {
            await nazu.sendMessage(from, {
              text: result.message,
              mentions: result.mentions || []
            });
          }
        }
        if (connect4 && connect4.hasActiveGame && connect4.hasActiveGame(from) && budy2) {
          if (['c4end', 'fimc4'].includes(budy2.toLowerCase())) {
            if (!isGroupAdmin) {
              await reply("‚ö†Ô∏è Apenas administradores podem encerrar um Connect4 em andamento.");
              return;
            }
            const result = connect4.endGame(from);
            await reply(result.message);
            return;
          }
          const column = parseInt(budy2.trim());
          if (!isNaN(column) && column >= 1 && column <= 7) {
            const result = connect4.makeMove(from, sender, column);
            if (result.success) {
              await nazu.sendMessage(from, {
                text: result.message,
                mentions: result.mentions || [sender]
              });
            } else if (result.message) {
              await reply(result.message);
            }
            return;
          }
        }

        // Processamento do antitoxic
        if (antitoxic && antitoxic.isEnabled && antitoxic.isEnabled(from) && body && ia) {
          // Fun√ß√£o wrapper para a IA do antitoxic
          const aiFunction = (prompt) => {
            return ia.makeCognimaRequest('qwen/qwen3-235b-a22b', prompt, null)
              .then(response => response?.data?.choices?.[0]?.message?.content || '');
          };
          
          antitoxic.analyzeMessage(body, aiFunction).then(toxicResult => {
            if (toxicResult.isToxic) {
              const action = antitoxic.getGroupAction ? antitoxic.getGroupAction(from) : 'avisar';
              if (action === 'apagar') {
                nazu.sendMessage(from, { delete: info.key }).then(() => {
                  nazu.sendMessage(from, {
                    text: `‚ö†Ô∏è @${sender.split('@')[0]}, sua mensagem foi removida por conte√∫do t√≥xico.\n\n_Este sistema usa IA e pode cometer erros._`,
                    mentions: [sender]
                  });
                });
              } else if (action === 'avisar') {
                nazu.sendMessage(from, {
                  text: `‚ö†Ô∏è @${sender.split('@')[0]}, evite mensagens t√≥xicas!\n\n_Este sistema usa IA e pode cometer erros._`,
                  mentions: [sender]
                });
              }
              // Para 'mute', precisaria implementar sistema de mute
            }
          }).catch(toxicErr => {
            console.warn('[ANTITOXIC] Error:', toxicErr.message);
          });
        }

        // Processamento do antipalavra (verifica blacklist de palavras)
        if (isGroup && antipalavra && body && !isCmd) {
          try {
            // Verifica se o sistema est√° ativo no grupo
            if (!antipalavra.isActive(from)) {
              // Sistema desativado, n√£o processa
            } else if (!isGroupAdmin) {
              // Apenas verifica mensagens de n√£o-admins
              const detectionResult = antipalavra.checkMessage(from, body);
              
              if (detectionResult && detectionResult.detected) {
                console.log(`[ANTIPALAVRA] Palavra detectada: "${detectionResult.palavra}" de @${sender.split('@')[0]}`);
                
                // Verifica se o bot √© admin antes de tentar remover
                if (!isBotAdmin) {
                  await nazu.sendMessage(from, {
                    text: `‚ö†Ô∏è *ANTIPALAVRA - DETEC√á√ÉO*\n\n` +
                          `üë§ @${sender.split('@')[0]} usou uma palavra proibida!\n` +
                          `‚ö†Ô∏è Palavra: "${detectionResult.palavra}"\n\n` +
                          `‚ùå N√£o posso banir pois n√£o sou administrador!`,
                    mentions: [sender]
                  }).catch(err => console.error('[ANTIPALAVRA] Erro ao enviar notifica√ß√£o:', err.message));
                  return;
                }
                
                // Deleta a mensagem
                await nazu.sendMessage(from, { delete: info.key }).catch(err => 
                  console.error('[ANTIPALAVRA] Erro ao deletar mensagem:', err.message)
                );
                
                // Remove o usu√°rio do grupo
                await nazu.groupParticipantsUpdate(from, [sender], 'remove').catch(err => 
                  console.error('[ANTIPALAVRA] Erro ao remover usu√°rio:', err.message)
                );
                
                // Registra o banimento
                antipalavra.registerBan(from, sender, detectionResult.palavra);
                
                // Envia notifica√ß√£o
                await nazu.sendMessage(from, {
                  text: `üö´ *ANTIPALAVRA - BANIMENTO AUTOM√ÅTICO*\n\n` +
                        `üë§ Usu√°rio: @${sender.split('@')[0]}\n` +
                        `‚ö†Ô∏è Palavra detectada: "${detectionResult.palavra}"\n` +
                        `üî® A√ß√£o: Banimento autom√°tico\n\n` +
                        `_O sistema antipalavra protege este grupo._`,
                  mentions: [sender]
                }).catch(err => console.error('[ANTIPALAVRA] Erro ao enviar notifica√ß√£o:', err.message));
                
                // Para o processamento da mensagem
                return;
              }
            }
          } catch (antipalavraErr) {
            console.error('[ANTIPALAVRA] Erro ao processar:', antipalavraErr.message);
          }
        }
      } catch (error) {

      }
    }
    if (isGroup && groupData.blockedUsers && (groupData.blockedUsers[sender] || groupData.blockedUsers[getUserName(sender)]) && isCmd) {
      return reply(`üö´ Voc√™ n√£o tem permiss√£o para usar comandos neste grupo.\nMotivo: ${groupData.blockedUsers[sender] ? groupData.blockedUsers[sender].reason : groupData.blockedUsers[getUserName(sender)].reason}`);
    };

    const globalBlacklist = loadGlobalBlacklist();
    if (isCmd && sender && globalBlacklist.users && (globalBlacklist.users[sender] || globalBlacklist.users[getUserName(sender)])) {
      const blacklistEntry = globalBlacklist.users[sender] || globalBlacklist.users[getUserName(sender)];
      return reply(`üö´ Voc√™ est√° na blacklist global e n√£o pode usar comandos.\nMotivo: ${blacklistEntry.reason}\nAdicionado por: ${blacklistEntry.addedBy}\nData: ${new Date(blacklistEntry.addedAt).toLocaleString('pt-BR', { timeZone: 'America/Sao_Paulo' })}`);
    };
    
    if (isGroup && isCmd && groupData.blacklist && (groupData.blacklist[sender] || groupData.blacklist[getUserName(sender)])) {
      const blacklistEntry = groupData.blacklist[sender] || groupData.blacklist[getUserName(sender)];
      return reply(`üö´ Voc√™ est√° na blacklist deste grupo e n√£o pode usar comandos.\nMotivo: ${blacklistEntry.reason}\nData: ${new Date(blacklistEntry.timestamp).toLocaleString('pt-BR', { timeZone: 'America/Sao_Paulo' })}`);
    }
    if (sender && sender.includes('@') && globalBlocks.users && (globalBlocks.users[sender] || globalBlocks.users[getUserName(sender)]) && isCmd) {
      return reply(`üö´ Parece que voc√™ est√° bloqueado de usar meus comandos globalmente.\nMotivo: ${globalBlocks.users[sender] ? globalBlocks.users[sender].reason : globalBlocks.users[getUserName(sender)].reason}`);
    }
    if (isCmd && globalBlocks.commands && globalBlocks.commands[command]) {
      return reply(`üö´ O comando *${command}* est√° temporariamente desativado globalmente.\nMotivo: ${globalBlocks.commands[command].reason}`);
    }
    if (isCmd && commandStats && commandStats.trackCommandUsage && command && command.length > 0) {
      commandStats.trackCommandUsage(command, sender);
    }
    if (budy2.match(/^(\d+)d(\d+)$/)) reply(+budy2.match(/^(\d+)d(\d+)$/)[1] > 50 || +budy2.match(/^(\d+)d(\d+)$/)[2] > 100 ? "‚ùå Limite: max 50 dados e 100 lados" : "üé≤ Rolando " + budy2.match(/^(\d+)d(\d+)$/)[1] + "d" + budy2.match(/^(\d+)d(\d+)$/)[2] + "...\nüéØ Resultados: " + (r = [...Array(+budy2.match(/^(\d+)d(\d+)$/)[1])].map(_ => 1 + Math.floor(Math.random() * +budy2.match(/^(\d+)d(\d+)$/)[2]))).join(", ") + "\nüìä Total: " + r.reduce((a, b) => a + b, 0));

    const _botShort = (nazu && nazu.user && (nazu.user.id || nazu.user.lid)) ? String((nazu.user.id || nazu.user.lid).split(':')[0]) : '';
    // N√£o processar pela assistente se a mensagem veio do PRO (evita loop infinito)
    if (!info.key.fromMe && isAssistente && !isCmd && !info._fromPro && ((_botShort && budy2.includes(_botShort)) || (menc_os2 && menc_os2 == botNumber))) {
      if (budy2.replaceAll('@' + _botShort, '').length > 2) {
        // Detectar tipo de m√≠dia da mensagem atual
        const tipoMidiaAtual = info.message?.imageMessage ? 'imagem' : 
                              info.message?.videoMessage ? 'video' : 
                              info.message?.audioMessage ? 'audio' : 
                              info.message?.stickerMessage ? 'sticker' : 
                              info.message?.documentMessage ? 'documento' : null;
        
        // Detectar tipo de m√≠dia marcada
        // Checar tamb√©m pttMessage (mensagem de voz) que pode vir separado
        const tipoMidiaMarcada = quotedMessageContent?.imageMessage ? 'imagem' : 
                                 quotedMessageContent?.videoMessage ? 'video' : 
                                 quotedMessageContent?.audioMessage ? 'audio' : 
                                 quotedMessageContent?.pttMessage ? 'audio' :
                                 quotedMessageContent?.stickerMessage ? 'sticker' : 
                                 quotedMessageContent?.documentMessage ? 'documento' : null;
        
        // Detectar men√ß√µes na mensagem
        const mencoesNaMensagem = info.message?.extendedTextMessage?.contextInfo?.mentionedJid || [];
        
        // Obter todos os poss√≠veis identificadores do bot para filtrar
        const botLid = nazu.user?.lid ? nazu.user.lid.split(':')[0] : null;
        const botJid = nazu.user?.id ? nazu.user.id.split(':')[0] : null;
        const botIdentifiers = [_botShort, botLid, botJid, botNumber].filter(Boolean);
        
        
        // Filtrar men√ß√£o do bot das men√ß√µes (usando todos os identificadores poss√≠veis)
        const mencoesFiltradas = mencoesNaMensagem.filter(m => {
          const mNumber = m.split('@')[0].split(':')[0]; // Pega s√≥ o n√∫mero
          return !botIdentifiers.some(id => {
            const idNumber = id.split('@')[0].split(':')[0];
            return mNumber === idNumber;
          });
        });
        
        const primeiraMencao = mencoesFiltradas.length > 0 ? mencoesFiltradas[0] : null;
        
        const jSoNzIn = {
          texto: budy2.replaceAll('@' + _botShort, '').trim(),
          id_enviou: sender,
          nome_enviou: pushname,
          id_grupo: isGroup ? from : false,
          nome_grupo: isGroup ? groupName : false,
          tem_midia: isMedia,
          tipo_midia: tipoMidiaAtual,
          marcou_mensagem: false,
          marcou_sua_mensagem: false,
          mensagem_marcada: false,
          id_enviou_marcada: false,
          tem_midia_marcada: !!tipoMidiaMarcada,
          tipo_midia_marcada: tipoMidiaMarcada,
          mencoes: mencoesFiltradas,
          primeira_mencao: primeiraMencao,
          tem_mencao: mencoesFiltradas.length > 0,
          id_mensagem: info.key.id,
          data_atual: new Date().toLocaleString('pt-BR', {
            timeZone: 'America/Sao_Paulo'
          }),
          data_mensagem: new Date(info.messageTimestamp * 1000).toLocaleString('pt-BR', {
            timeZone: 'America/Sao_Paulo'
          })
        };
        let {
          participant,
          quotedMessage
        } = info.message?.extendedTextMessage?.contextInfo || {};
        let jsonO = {
          participant,
          quotedMessage,
          texto: quotedMessage?.conversation || quotedMessage?.extendedTextMessage?.text || quotedMessage?.imageMessage?.caption || quotedMessage?.videoMessage?.caption || quotedMessage?.documentMessage?.caption || ""
        };
        if (jsonO && jsonO.participant && jsonO.texto && jsonO.texto.length > 0) {
          jSoNzIn.marcou_mensagem = true;
          jSoNzIn.mensagem_marcada = jsonO.texto;
          jSoNzIn.id_enviou_marcada = jsonO.participant;
          jSoNzIn.marcou_sua_mensagem = jsonO.participant == getBotId(nazu);
        }
        // Se marcou mensagem com m√≠dia mas sem texto, ainda assim √© marcou_mensagem
        if (jsonO && jsonO.participant && tipoMidiaMarcada && !jSoNzIn.marcou_mensagem) {
          jSoNzIn.marcou_mensagem = true;
          jSoNzIn.id_enviou_marcada = jsonO.participant;
        }
        
        // Add null check for ia object
        if (!ia || typeof ia.makeAssistentRequest !== 'function') {
          console.warn('[IA] makeAssistentRequest not available');
          reply('ü§ñ Sistema de IA temporariamente indispon√≠vel. Tente novamente em alguns minutos.');
          return;
        }
        
        // Obter a personalidade atual do grupo
        const personality = groupData.assistentePersonality || 'nazuna';
        
        ia.makeAssistentRequest({
          mensagens: [jSoNzIn]
        }, nazu, nmrdn, personality).then((respAssist) => {
          if (respAssist.erro === 'Sistema de IA temporariamente desativado') {
            return;
          }
          
          // Tratamento especial para personalidade 'pro' (interpretador de comandos)
          if (respAssist.isPro) {
            if (respAssist.isCommand && respAssist.command) {
              // Se falta algo para executar o comando, avisa o usu√°rio
              if (respAssist.falta) {
                reply(`‚ö†Ô∏è Para executar *${prefix}${respAssist.command}*, preciso que voc√™ informe: ${respAssist.falta}`);
                return;
              }
              
              console.log(`ü§ñ [PRO] Comando identificado: ${respAssist.command} ${respAssist.args || ''}`);
              
              // Simular execu√ß√£o do comando reutilizando o objeto info original
              const simulatedCommand = respAssist.command.toLowerCase();
              let simulatedArgs = respAssist.args || '';
              
              // Obter men√ß√µes originais da mensagem e filtrar a men√ß√£o do bot
              const originalMentions = info.message?.extendedTextMessage?.contextInfo?.mentionedJid || [];
              
              // Usar os mesmos identificadores do bot para filtrar
              const botLidPro = nazu.user?.lid ? nazu.user.lid.split(':')[0] : null;
              const botJidPro = nazu.user?.id ? nazu.user.id.split(':')[0] : null;
              const botIdentifiersPro = [_botShort, botLidPro, botJidPro, botNumber].filter(Boolean);
              
              const mentionsWithoutBot = originalMentions.filter(m => {
                const mNumber = m.split('@')[0].split(':')[0];
                return !botIdentifiersPro.some(id => {
                  const idNumber = id.split('@')[0].split(':')[0];
                  return mNumber === idNumber;
                });
              });
              const targetMention = mentionsWithoutBot.length > 0 ? mentionsWithoutBot[0] : null;
              
              // Se n√£o tem men√ß√£o no texto, pode ter marcado mensagem de algu√©m (resposta)
              const quotedParticipant = info.message?.extendedTextMessage?.contextInfo?.participant;
              // Verificar se o quotedParticipant n√£o √© o pr√≥prio bot
              const isQuotedBot = quotedParticipant ? botIdentifiersPro.some(id => {
                const idNumber = id.split('@')[0].split(':')[0];
                const qNumber = quotedParticipant.split('@')[0].split(':')[0];
                return qNumber === idNumber;
              }) : true;
              const mentionOrQuoted = targetMention || (quotedParticipant && !isQuotedBot ? quotedParticipant : null);
              
              console.log(`ü§ñ [PRO] Men√ß√µes originais: ${JSON.stringify(originalMentions)}`);
              console.log(`ü§ñ [PRO] Men√ß√µes sem bot: ${JSON.stringify(mentionsWithoutBot)}`);
              console.log(`ü§ñ [PRO] Target men√ß√£o: ${targetMention}`);
              console.log(`ü§ñ [PRO] Quoted participant: ${quotedParticipant}`);
              console.log(`ü§ñ [PRO] Men√ß√£o ou quoted final: ${mentionOrQuoted}`);
              
              // Lista de comandos que precisam de men√ß√£o (@user)
              const commandsNeedMention = ['ban', 'ban2', 'kick', 'promover', 'rebaixar', 'mute', 'desmute', 
                'mute2', 'desmute2', 'adv', 'rmadv', 'userinfo', 'perfil', 'rep', 'presente', 'denunciar',
                'blockuser', 'unblockuser', 'addblacklist', 'delblacklist', 'addmod', 'delmod'];
              
              // Se o comando precisa de men√ß√£o e temos uma men√ß√£o/quoted, adiciona ao args
              if (commandsNeedMention.includes(simulatedCommand) && mentionOrQuoted && !simulatedArgs.includes('@')) {
                // Adicionar a men√ß√£o ao in√≠cio dos argumentos
                const mentionNumber = mentionOrQuoted.split('@')[0];
                simulatedArgs = `@${mentionNumber} ${simulatedArgs}`.trim();
              }
              
              const simulatedBody = `${prefix}${simulatedCommand} ${simulatedArgs}`.trim();
              
              // Clonar o objeto info original mantendo estrutura completa
              const fakeMessage = JSON.parse(JSON.stringify(info));
              
              // Atualizar timestamp para o momento atual
              fakeMessage.messageTimestamp = Math.floor(Date.now() / 1000);
              
              // Marcar como mensagem processada pelo PRO para evitar loop infinito
              fakeMessage._fromPro = true;
              
              // Determinar o tipo de m√≠dia original para preservar
              const hasImage = !!info.message?.imageMessage;
              const hasVideo = !!info.message?.videoMessage;
              const hasAudio = !!info.message?.audioMessage;
              const hasDocument = !!info.message?.documentMessage;
              const hasSticker = !!info.message?.stickerMessage;
              const hasQuotedImage = !!quotedMessageContent?.imageMessage;
              const hasQuotedVideo = !!quotedMessageContent?.videoMessage;
              const hasQuotedAudio = !!quotedMessageContent?.audioMessage;
              const hasQuotedSticker = !!quotedMessageContent?.stickerMessage;
              const hasQuotedDocument = !!quotedMessageContent?.documentMessage;
              
              // Preservar contexto de m√≠dia e men√ß√µes
              if (fakeMessage.message) {
                // Se tem imagem com legenda, preservar imagem e mudar legenda
                if (hasImage && fakeMessage.message.imageMessage) {
                  fakeMessage.message.imageMessage.caption = simulatedBody;
                  // Limpar outros tipos de mensagem de texto
                  delete fakeMessage.message.conversation;
                  delete fakeMessage.message.extendedTextMessage;
                }
                // Se tem v√≠deo com legenda, preservar v√≠deo e mudar legenda
                else if (hasVideo && fakeMessage.message.videoMessage) {
                  fakeMessage.message.videoMessage.caption = simulatedBody;
                  delete fakeMessage.message.conversation;
                  delete fakeMessage.message.extendedTextMessage;
                }
                // Se tem √°udio, preservar √°udio e adicionar comando como extendedTextMessage
                else if (hasAudio && fakeMessage.message.audioMessage) {
                  // √Åudio n√£o tem caption, ent√£o criamos extendedTextMessage junto
                  fakeMessage.message.extendedTextMessage = {
                    text: simulatedBody,
                    contextInfo: info.message?.extendedTextMessage?.contextInfo || {}
                  };
                  delete fakeMessage.message.conversation;
                }
                // Se tem documento, preservar e mudar caption
                else if (hasDocument && fakeMessage.message.documentMessage) {
                  fakeMessage.message.documentMessage.caption = simulatedBody;
                  delete fakeMessage.message.conversation;
                  delete fakeMessage.message.extendedTextMessage;
                }
                // Se tem sticker, preservar sticker e adicionar texto
                else if (hasSticker && fakeMessage.message.stickerMessage) {
                  const stickerMentions = (info.message?.extendedTextMessage?.contextInfo?.mentionedJid || [])
                    .filter(m => m !== botNumber && !m.includes(_botShort));
                  // Adicionar men√ß√£o do alvo se n√£o estiver na lista
                  if (mentionOrQuoted && !stickerMentions.includes(mentionOrQuoted)) {
                    stickerMentions.push(mentionOrQuoted);
                  }
                  fakeMessage.message.extendedTextMessage = {
                    text: simulatedBody,
                    contextInfo: {
                      ...info.message?.extendedTextMessage?.contextInfo,
                      mentionedJid: stickerMentions
                    }
                  };
                  delete fakeMessage.message.conversation;
                }
                // Se tem mensagem marcada com m√≠dia, preservar o contextInfo
                else if (info.message?.extendedTextMessage?.contextInfo?.quotedMessage) {
                  const originalContext = info.message.extendedTextMessage.contextInfo;
                  // Filtrar men√ß√£o do bot e adicionar men√ß√£o do alvo
                  const quotedMentions = (originalContext.mentionedJid || [])
                    .filter(m => m !== botNumber && !m.includes(_botShort));
                  // Se temos um alvo e ele n√£o est√° na lista, adiciona
                  if (mentionOrQuoted && !quotedMentions.includes(mentionOrQuoted)) {
                    quotedMentions.push(mentionOrQuoted);
                  }
                  fakeMessage.message.extendedTextMessage = {
                    text: simulatedBody,
                    contextInfo: {
                      ...originalContext,
                      // Preservar men√ß√µes filtradas + alvo
                      mentionedJid: quotedMentions,
                      // Preservar mensagem marcada
                      quotedMessage: originalContext.quotedMessage,
                      participant: originalContext.participant,
                      stanzaId: originalContext.stanzaId
                    }
                  };
                  delete fakeMessage.message.conversation;
                  delete fakeMessage.message.imageMessage;
                  delete fakeMessage.message.videoMessage;
                  delete fakeMessage.message.audioMessage;
                  delete fakeMessage.message.documentMessage;
                  delete fakeMessage.message.stickerMessage;
                }
                // Mensagem de texto simples
                else {
                  // Preservar men√ß√µes se existirem (sem a men√ß√£o do bot)
                  const mentionedJid = info.message?.extendedTextMessage?.contextInfo?.mentionedJid || [];
                  const filteredMentions = mentionedJid.filter(m => m !== botNumber && !m.includes(_botShort));
                  
                  // Se temos men√ß√£o de um alvo (n√£o bot), adicionar ao mentionedJid
                  const targetMentionsForContext = mentionOrQuoted && !filteredMentions.includes(mentionOrQuoted) 
                    ? [...filteredMentions, mentionOrQuoted] 
                    : filteredMentions;
                  
                  if (targetMentionsForContext.length > 0) {
                    fakeMessage.message.extendedTextMessage = {
                      text: simulatedBody,
                      contextInfo: {
                        mentionedJid: targetMentionsForContext
                      }
                    };
                    delete fakeMessage.message.conversation;
                  } else {
                    fakeMessage.message.conversation = simulatedBody;
                    delete fakeMessage.message.extendedTextMessage;
                  }
                  
                  delete fakeMessage.message.imageMessage;
                  delete fakeMessage.message.videoMessage;
                  delete fakeMessage.message.audioMessage;
                  delete fakeMessage.message.documentMessage;
                  delete fakeMessage.message.stickerMessage;
                }
              } else {
                fakeMessage.message = { conversation: simulatedBody };
              }
              
              // Feedback visual antes de executar
              const mediaInfo = hasImage ? 'üñºÔ∏è' : hasVideo ? 'üé¨' : hasAudio ? 'üéµ' : hasSticker ? 'üé≠' : 
                               hasQuotedImage ? 'üñºÔ∏è (marcado)' : hasQuotedVideo ? 'üé¨ (marcado)' : 
                               hasQuotedAudio ? 'üéµ (marcado)' : hasQuotedSticker ? 'üé≠ (marcado)' : '';
              
              nazu.sendMessage(from, { 
                text: `ü§ñ *Executando:* ${prefix}${simulatedCommand}${simulatedArgs ? ' ' + simulatedArgs : ''}${mediaInfo ? '\nüìé M√≠dia: ' + mediaInfo : ''}`
              }, { quoted: info }).then(() => {
                // Emitir novamente o evento de mensagem com o objeto completo
                nazu.ev.emit('messages.upsert', {
                  messages: [fakeMessage],
                  type: 'notify'
                });
              });
            }
            // Se n√£o √© comando, n√£o responde nada (comportamento esperado do pro)
            return;
          }
          
          if (respAssist.resp && Array.isArray(respAssist.resp) && respAssist.resp.length > 0) {
            const processResponses = (index) => {
              if (index >= respAssist.resp.length) return;
              const msgza = respAssist.resp[index];
              const processNext = () => processResponses(index + 1);
              
              if (msgza && msgza.react) {
                nazu.react(msgza.react.replaceAll(' ', '').replaceAll('\n', ''), {
                  key: info.key
                }).then(() => {
                  if (msgza.resp && typeof msgza.resp === 'string' && msgza.resp.length > 0) {
                    reply(msgza.resp).then(processNext);
                  } else {
                    processNext();
                  }
                }).catch(err => {
                  console.error('Erro ao reagir:', err);
                  if (msgza.resp && typeof msgza.resp === 'string' && msgza.resp.length > 0) {
                    reply(msgza.resp).then(processNext);
                  } else {
                    processNext();
                  }
                });
              } else if (msgza && msgza.resp && typeof msgza.resp === 'string' && msgza.resp.length > 0) {
                reply(msgza.resp).then(processNext);
              } else {
                console.warn(`‚ö†Ô∏è [${personality}] Resposta inv√°lida no √≠ndice ${index}:`, JSON.stringify(msgza));
                processNext();
              }
            };
            processResponses(0);
          } else {
            console.warn(`‚ö†Ô∏è [${personality}] Nenhuma resposta v√°lida retornada pela IA. respAssist.resp:`, respAssist.resp);
          }
        }).catch((assistentError) => {
          console.error('Erro no assistente virtual:', assistentError.message);
          reply('ü§ñ Erro t√©cnico no assistente virtual. Tente novamente em alguns minutos.');
        });
      }
    }
    //ANTI FLOOD DE MENSAGENS
    if (isGroup && groupData.messageLimit?.enabled && !isGroupAdmin && !isOwnerOrSub && !info.key.fromMe) {
      try {
        groupData.messageLimit.warnings = groupData.messageLimit.warnings || {};
        groupData.messageLimit.users = groupData.messageLimit.users || {};
        const now = Date.now();
        const userData = groupData.messageLimit.users[sender] || {
          count: 0,
          lastReset: now
        };
        if (now - userData.lastReset >= groupData.messageLimit.interval * 1000) {
          userData.count = 0;
          userData.lastReset = now;
        }
        userData.count++;
        groupData.messageLimit.users[sender] = userData;
        if (userData.count > groupData.messageLimit.limit) {
          if (groupData.messageLimit.action === 'ban' && isBotAdmin) {
            await nazu.groupParticipantsUpdate(from, [sender], 'remove');
            await reply(`üö® @${getUserName(sender)} foi banido por exceder o limite de ${groupData.messageLimit.limit} mensagens em ${groupData.messageLimit.interval}s!`, {
              mentions: [sender]
            });
            delete groupData.messageLimit.users[sender];
          } else if (groupData.messageLimit.action === 'adv') {
            groupData.messageLimit.warnings[sender] = (groupData.messageLimit.warnings[sender] || 0) + 1;
            const warnings = groupData.messageLimit.warnings[sender];
            if (warnings >= 3 && isBotAdmin) {
              await nazu.groupParticipantsUpdate(from, [sender], 'remove');
              await reply(`üö® @${getUserName(sender)} foi banido por exceder o limite de mensagens (${groupData.messageLimit.limit} em ${groupData.messageLimit.interval}s) 3 vezes!`, {
                mentions: [sender]
              });
              delete groupData.messageLimit.warnings[sender];
              delete groupData.messageLimit.users[sender];
            } else {
              await reply(`‚ö†Ô∏è @${getUserName(sender)}, voc√™ excedeu o limite de ${groupData.messageLimit.limit} mensagens em ${groupData.messageLimit.interval}s! Advert√™ncia ${warnings}/3.`, {
                mentions: [sender]
              });
            }
          }
        }
  writeJsonFile(groupFile, groupData);
  // Otimiza√ß√£o: Invalida cache quando groupData √© salvo
  if (isGroup) {
    optimizer.invalidateGroup(from);
  }
      } catch (e) {
        console.error("Erro no sistema de limite de mensagens:", e);
      }
    }
    //SISTEMA DE PARCERIA
    if (isGroup && parceriasData.active && !isGroupAdmin && body.includes('chat.whatsapp.com') && !info.key.fromMe) {
      if (parceriasData.partners[sender]) {
        const partnerData = parceriasData.partners[sender];
        if (partnerData.count < partnerData.limit) {
          partnerData.count++;
          saveParceriasData(from, parceriasData);
        } else {
          await nazu.sendMessage(from, {
            delete: info.key
          });
          await reply(`@${getUserName(sender)}, voc√™ atingiu o limite de ${partnerData.limit} links de grupos.`, {
            mentions: [sender]
          });
        }
      } else {
        await nazu.sendMessage(from, {
          delete: info.key
        });
        await reply(`@${getUserName(sender)}, voc√™ n√£o √© um parceiro e n√£o pode enviar links de grupos.`, {
          mentions: [sender]
        });
      }
    }
    //ANTI FIGURINHAS
    if (isGroup && groupData.antifig && groupData.antifig.enabled && type === "stickerMessage" && !isGroupAdmin && !info.key.fromMe) {
      if (!isUserWhitelisted(sender, 'antifig')) {
        try {
          await nazu.sendMessage(from, {
            delete: {
              remoteJid: from,
              fromMe: false,
              id: info.key.id,
              participant: sender
            }
          });
          groupData.warnings = groupData.warnings || {};
          groupData.warnings[sender] = groupData.warnings[sender] || {
            count: 0,
            lastWarned: null
          };
          groupData.warnings[sender].count += 1;
          groupData.warnings[sender].lastWarned = new Date().toISOString();
          const warnCount = groupData.warnings[sender].count;
          const warnLimit = groupData.antifig.warnLimit || 3;
          let warnMessage = `üö´ @${getUserName(sender)}, figurinhas n√£o s√£o permitidas neste grupo! Advert√™ncia ${warnCount}/${warnLimit}.`;
          if (warnCount >= warnLimit && isBotAdmin) {
            warnMessage += `\n‚ö†Ô∏è Voc√™ atingiu o limite de advert√™ncias e ser√° removido.`;
            await nazu.groupParticipantsUpdate(from, [sender], 'remove');
            delete groupData.warnings[sender];
          }
          await nazu.sendMessage(from, {
            text: warnMessage,
            mentions: [sender]
          });
    writeJsonFile(groupFile, groupData);
  // Otimiza√ß√£o: Invalida cache quando groupData √© salvo
  if (isGroup) {
    optimizer.invalidateGroup(from);
  }
        } catch (error) {
          console.error("Erro no sistema antifig:", error);
          await reply(`‚ö†Ô∏è Erro ao processar antifig para @${getUserName(sender)}. Administradores, verifiquem!`, {
            mentions: [sender]
          });
        }
      }
    }
    if (!isCmd) {
      // Se modo soadm ativo e n√£o √© admin, ignorar comandos sem prefixo silenciosamente
      if (isGroup && isOnlyAdmin && !isGroupAdmin && !isOwner) {
        // N√£o processar comandos sem prefixo para n√£o-admins quando soadm est√° ativo
      } else {
        // Otimiza√ß√£o: Cache de comandos sem prefixo
        const noPrefixCommands = await optimizer.memoize(
          `noprefix:${from}`,
          () => Promise.resolve(loadNoPrefixCommands()),
          10000 // 10 segundos
        );
        // Otimiza√ß√£o: Usar regex pr√©-compilada para split
        const splitRegex = optimizer.getRegex('commandSplit') || /\s+/;
        const firstWord = budy2.split(splitRegex)[0]?.trim();
        const matchedCommand = noPrefixCommands.find(item => firstWord === item.trigger);
        if (matchedCommand) {
          var command = matchedCommand.command;
          var isCmd = true;
          const bodyParts = body.trim().split(/ +/);
          const dynamicArgs = bodyParts.slice(1);
          const fixedParams = matchedCommand.fixedParams || '';
          const allParams = fixedParams ? (fixedParams + (dynamicArgs.length > 0 ? ' ' + dynamicArgs.join(' ') : '')) : dynamicArgs.join(' ');
          args.length = 0;
          if (allParams) {
            args.push(...allParams.split(/ +/));
          }
          q = allParams;
        }
      }
    }

    // Verificar comandos personalizados do dono
    if (isCmd && command) {
      // Otimiza√ß√£o: Normaliza√ß√£o otimizada
      const normalizedTrigger = optimizer.normalizeCommand(command) || normalizar(command);
      // Otimiza√ß√£o: Cache de comandos personalizados
      const customCmd = await optimizer.memoize(
        `customcmd:${from}:${normalizedTrigger}`,
        () => Promise.resolve(findCustomCommand(normalizedTrigger)),
        5000 // 5 segundos
      );
      if (customCmd) {
        try {
          const responseData = customCmd.response;
          const settings = customCmd.settings || {};

          // Verifica√ß√µes de permiss√£o/contexto
          if (settings.ownerOnly && !isOwner) {
            return reply('üö´ Este comando s√≥ pode ser usado pelo dono do bot.');
          }
          if (settings.adminOnly && !isGroup) {
            return reply('üö´ Este comando s√≥ pode ser usado por admins do grupo (em grupos apenas).');
          }
          if (settings.adminOnly && isGroup && !isGroupAdmin) {
            return reply('üö´ Este comando s√≥ pode ser usado por admins do grupo.');
          }
          if (settings.context === 'group' && !isGroup) {
            return reply('‚ö†Ô∏è Este comando est√° restrito a grupos.');
          }
          if (settings.context === 'private' && isGroup) {
            return reply('‚ö†Ô∏è Este comando est√° restrito ao privado.');
          }

          // Verificar par√¢metros obrigat√≥rios e tipos (baseado na ordem)
          const allArgsCheck = q || '';
          let argsListCheck = parseArgsFromString(allArgsCheck);
          if (Array.isArray(settings.params) && settings.params.length) {
            // Handle rest params: if last param has rest: true, capture remainder
            const restIndex = settings.params.findIndex(p => p.rest);
            if (restIndex !== -1 && restIndex < settings.params.length) {
              if (argsListCheck.length > restIndex) {
                const restVal = argsListCheck.slice(restIndex).join(' ');
                argsListCheck = argsListCheck.slice(0, restIndex);
                argsListCheck[restIndex] = restVal;
              }
            }
            const missing = [];
            for (let i = 0; i < settings.params.length; i++) {
              const p = settings.params[i];
              let val = typeof argsListCheck[i] !== 'undefined' ? argsListCheck[i] : '';
              if ((val === '' || typeof val === 'undefined') && typeof p.default !== 'undefined') {
                val = p.default;
                argsListCheck[i] = val;
              }
              if (p.required && (typeof val === 'undefined' || val === '')) missing.push(p.name);
              if (typeof val !== 'undefined' && val !== '') {
                const check = validateParamValue(val, p);
                if (!check.ok) {
                  return reply(`‚ùå Par√¢metro inv√°lido: ${check.message}`);
                }
              }
            }
            if (missing.length) {
              const usage = customCmd.usage || buildUsageFromParams(customCmd.trigger, settings.params);
              return reply(`‚ùå Par√¢metros obrigat√≥rios ausentes: ${missing.join(', ')}\nUso: ${usage}`);
            }
          }

          // Substituir par√¢metros (posicionais e por nome)
          let processedResponse = responseData;
          const allArgs = q || '';
          let argsList = typeof argsListCheck !== 'undefined' ? argsListCheck : parseArgsFromString(allArgs);
          // Support named args like key=value
          if (Array.isArray(argsList) && argsList.some(t => t.includes('='))) {
            const namedMap = {};
            const remainingPositional = [];
            for (const t of argsList) {
              const idxEq = t.indexOf('=');
              if (idxEq > 0) {
                const k = normalizar(t.slice(0, idxEq)).replace(/\s+/g, '_');
                const v = t.slice(idxEq + 1);
                namedMap[k] = v;
              } else {
                remainingPositional.push(t);
              }
            }
            const remArgs = [];
            if (Array.isArray(settings.params) && settings.params.length) {
              for (let i = 0; i < settings.params.length; i++) {
                const p = settings.params[i];
                const nm = p.name;
                if (Object.prototype.hasOwnProperty.call(namedMap, nm)) {
                  remArgs[i] = namedMap[nm];
                } else {
                  remArgs[i] = remainingPositional.length ? remainingPositional.shift() : '';
                }
              }
            } else {
              // no param meta, just keep positional
              remArgs.push(...remainingPositional);
            }
            // handle rest param capturing: if rest param found as last
            const restIndexLocal = (settings.params || []).findIndex(p => p.rest);
            if (restIndexLocal !== -1 && restIndexLocal < remArgs.length) {
              const restVal = remArgs.slice(restIndexLocal).join(' ');
              remArgs.splice(restIndexLocal, remArgs.length - restIndexLocal, restVal);
            }
            argsList = remArgs;
          }
          if (typeof processedResponse === 'string') {
            processedResponse = processedResponse
              .replace(/{prefixo}/gi, groupPrefix)
              .replace(/{prefix}/gi, groupPrefix)
              .replace(/{nomedono}/gi, nomedono)
              .replace(/{numerodono}/gi, numerodono)
              .replace(/{nomebot}/gi, nomebot)
              .replace(/{user}/gi, pushname || 'Usu√°rio')
              .replace(/{grupo}/gi, isGroup ? groupName : 'Privado');
            
            // Par√¢metros avan√ßados: args, posi√ß√£o, named params e men√ß√µes
            const allArgs = q || '';
            // re-use processed argsList from validation phase if available (argsListCheck), otherwise parse
            let argsList = typeof argsListCheck !== 'undefined' ? argsListCheck : parseArgsFromString(allArgs);
            // Map named params for replacement
            const paramsMap = {};
            if (Array.isArray(settings.params)) {
              for (let i = 0; i < settings.params.length; i++) {
                const p = settings.params[i];
                paramsMap[p.name] = argsList[i] || '';
              }
            }
            // {args} | {all}
            processedResponse = processedResponse.replace(/\{(?:args|all)\}/gi, allArgs);
            // {1}, {2}, ... (1-based index)
            processedResponse = processedResponse.replace(/\{(\d+)\}/g, (m, idx) => {
              const i = parseInt(idx, 10) - 1;
              return argsList[i] || '';
            });
            // Named parameters replacement: {name}
            for (const nm in paramsMap) {
              if (!Object.prototype.hasOwnProperty.call(paramsMap, nm)) continue;
              const val = paramsMap[nm];
              if (typeof val === 'undefined' || val === '') continue;
              try {
                const re = new RegExp('\\{' + escapeRegExp(nm) + '\\}', 'gi');
                processedResponse = processedResponse.replace(re, val);
              } catch (err) {
                console.warn('Warn: Invalid param name during regex replace:', nm, err.message);
              }
            }
            // mentions: {mention} -> first mentioned, {mentions} -> all mentioned
            const mentionedJids = info.message?.extendedTextMessage?.contextInfo?.mentionedJid || [];
            let mentionsToInclude = Array.isArray(mentionedJids) ? mentionedJids : [];
            // fallback to menc_os2 (participant/quoted participant) when no explicit mentions
            if (!mentionsToInclude.length && typeof menc_os2 !== 'undefined' && menc_os2) {
              mentionsToInclude = [menc_os2];
            }
            const mentionText = mentionsToInclude.length > 0 ? mentionsToInclude.map(m => '@' + getUserName(m)).join(' ') : '';
            processedResponse = processedResponse.replace(/\{mention\}/gi, mentionText);
            processedResponse = processedResponse.replace(/\{mentions\}/gi, mentionText);
            // quoted
            const quotedText = (quotedMessageContent && (quotedMessageContent.conversation || quotedMessageContent.extendedTextMessage?.text)) || '';
            processedResponse = processedResponse.replace(/\{quoted\}/gi, quotedText);
            // placeholders adicionais
            const groupDescValue = (groupMetadata && groupMetadata.desc) ? groupMetadata.desc : '';
            const latency = info?.messageTimestamp ? ((Date.now() - info.messageTimestamp * 1000) / 1000).toFixed(3) : null;
            if (groupDescValue) {
              processedResponse = processedResponse.replace(/\{(?:groupdesc|descricao|desc)\}/gi, groupDescValue);
            }
            if (latency !== null) {
              processedResponse = processedResponse.replace(/\{(?:velocidade|speed|latency)\}/gi, `${latency}s`);
            }
          } else if (processedResponse && typeof processedResponse === 'object') {
            if (processedResponse.caption) {
              processedResponse.caption = processedResponse.caption
                .replace(/{prefixo}/gi, groupPrefix)
                .replace(/{prefix}/gi, groupPrefix)
                .replace(/{nomedono}/gi, nomedono)
                .replace(/{numerodono}/gi, numerodono)
                .replace(/{nomebot}/gi, nomebot)
                .replace(/{user}/gi, pushname || 'Usu√°rio')
                .replace(/{grupo}/gi, isGroup ? groupName : 'Privado');
              // placeholders extras para legenda
              const argsListC = argsList;
              const paramsMapC = {};
              if (Array.isArray(settings.params)) {
                for (let i = 0; i < settings.params.length; i++) {
                  const p = settings.params[i];
                  paramsMapC[p.name] = argsListC[i] || '';
                }
              }
              processedResponse.caption = processedResponse.caption.replace(/\{(?:args|all)\}/gi, allArgsC);
              processedResponse.caption = processedResponse.caption.replace(/\{(\d+)\}/g, (m, idx) => {
                const i = parseInt(idx, 10) - 1;
                return argsListC[i] || '';
              });
              for (const nm in paramsMapC) {
                if (!Object.prototype.hasOwnProperty.call(paramsMapC, nm)) continue;
                const val = paramsMapC[nm];
                if (typeof val === 'undefined' || val === '') continue;
                try {
                  const re = new RegExp('\\{' + escapeRegExp(nm) + '\\}', 'gi');
                  processedResponse.caption = processedResponse.caption.replace(re, val);
                } catch (err) {
                  console.warn('Warn: Invalid param name during caption regex replace:', nm, err.message);
                }
              }
              const mentionedJidsC = info.message?.extendedTextMessage?.contextInfo?.mentionedJid || [];
              let mentionsToIncludeC = Array.isArray(mentionedJidsC) ? mentionedJidsC : [];
              if (!mentionsToIncludeC.length && typeof menc_os2 !== 'undefined' && menc_os2) {
                mentionsToIncludeC = [menc_os2];
              }
              const mentionTextC = mentionsToIncludeC.length > 0 ? mentionsToIncludeC.map(m => '@' + getUserName(m)).join(' ') : '';
              processedResponse.caption = processedResponse.caption.replace(/\{mention\}/gi, mentionTextC);
              processedResponse.caption = processedResponse.caption.replace(/\{mentions\}/gi, mentionTextC);
              const quotedTextC = (quotedMessageContent && (quotedMessageContent.conversation || quotedMessageContent.extendedTextMessage?.text)) || '';
              processedResponse.caption = processedResponse.caption.replace(/\{quoted\}/gi, quotedTextC);
              const groupDescValueC = (groupMetadata && groupMetadata.desc) ? groupMetadata.desc : '';
              const latencyC = info?.messageTimestamp ? ((Date.now() - info.messageTimestamp * 1000) / 1000).toFixed(3) : null;
              if (groupDescValueC) processedResponse.caption = processedResponse.caption.replace(/\{(?:groupdesc|descricao|desc)\}/gi, groupDescValueC);
              if (latencyC !== null) processedResponse.caption = processedResponse.caption.replace(/\{(?:velocidade|speed|latency)\}/gi, `${latencyC}s`);
            }
          }
          
          // Enviar resposta
          if (typeof processedResponse === 'string') {
            // Incluir mentions quando houver
            const mentionedJidsExec = info.message?.extendedTextMessage?.contextInfo?.mentionedJid || [];
            let mentionsToIncludeExec = Array.isArray(mentionedJidsExec) ? mentionedJidsExec : [];
            if (!mentionsToIncludeExec.length && typeof menc_os2 !== 'undefined' && menc_os2) {
              mentionsToIncludeExec = [menc_os2];
            }
            if (mentionsToIncludeExec.length > 0) {
              await reply(processedResponse, { mentions: mentionsToIncludeExec });
            } else {
              await reply(processedResponse);
            }
          } else if (processedResponse.type === 'text') {
            // substituir placeholders em conte√∫do de texto
            let content = processedResponse.content || 'Resposta personalizada';
            const argsListExec = argsList;
            const paramsMapExec = {};
            if (Array.isArray(settings.params)) {
              for (let i = 0; i < settings.params.length; i++) {
                const p = settings.params[i];
                paramsMapExec[p.name] = argsListExec[i] || '';
              }
            }
            content = content.replace(/\{(?:args|all)\}/gi, allArgsExec);
            content = content.replace(/\{(\d+)\}/g, (m, idx) => {
              const i = parseInt(idx, 10) - 1;
              return argsListExec[i] || '';
            });
            // Named parameter replacement for {name}
            for (const nm in paramsMapExec) {
              if (!Object.prototype.hasOwnProperty.call(paramsMapExec, nm)) continue;
              const val = paramsMapExec[nm];
              if (typeof val === 'undefined' || val === '') continue;
              const re = new RegExp('\\{' + escapeRegExp(nm) + '\\}', 'gi');
              content = content.replace(re, val);
            }
            // mentions
            const mentionedJidsExec = info.message?.extendedTextMessage?.contextInfo?.mentionedJid || [];
            let mentionsToIncludeExec = Array.isArray(mentionedJidsExec) ? mentionedJidsExec : [];
            if (!mentionsToIncludeExec.length && typeof menc_os2 !== 'undefined' && menc_os2) {
              mentionsToIncludeExec = [menc_os2];
            }
            const mentionTextExec = mentionsToIncludeExec.length > 0 ? mentionsToIncludeExec.map(m => '@' + getUserName(m)).join(' ') : '';
            content = content.replace(/\{mention\}/gi, mentionTextExec);
            content = content.replace(/\{mentions\}/gi, mentionTextExec);
            const quotedEx = (quotedMessageContent && (quotedMessageContent.conversation || quotedMessageContent.extendedTextMessage?.text)) || '';
            content = content.replace(/\{quoted\}/gi, quotedEx);
            const groupDescValueT = (groupMetadata && groupMetadata.desc) ? groupMetadata.desc : '';
            const latencyT = info?.messageTimestamp ? ((Date.now() - info.messageTimestamp * 1000) / 1000).toFixed(3) : null;
            if (groupDescValueT) content = content.replace(/\{(?:groupdesc|descricao|desc)\}/gi, groupDescValueT);
            if (latencyT !== null) content = content.replace(/\{(?:velocidade|speed|latency)\}/gi, `${latencyT}s`);

            if (mentionsToIncludeExec.length > 0) {
              await reply(content, { mentions: mentionsToIncludeExec });
            } else {
              await reply(content);
            }
          } else if (processedResponse.type === 'image') {
            const imageBuffer = processedResponse.buffer ? Buffer.from(processedResponse.buffer, 'base64') : null;
            if (imageBuffer) {
              const mentionedJidsExec = info.message?.extendedTextMessage?.contextInfo?.mentionedJid || [];
              let mentionsToIncludeExec = Array.isArray(mentionedJidsExec) ? mentionedJidsExec : [];
              if (!mentionsToIncludeExec.length && typeof menc_os2 !== 'undefined' && menc_os2) {
                mentionsToIncludeExec = [menc_os2];
              }
              await nazu.sendMessage(from, {
                image: imageBuffer,
                caption: processedResponse.caption || '',
                mentions: mentionsToIncludeExec
              }, { quoted: info });
            }
          } else if (processedResponse.type === 'video') {
            const videoBuffer = processedResponse.buffer ? Buffer.from(processedResponse.buffer, 'base64') : null;
            if (videoBuffer) {
              const mentionedJidsExec = info.message?.extendedTextMessage?.contextInfo?.mentionedJid || [];
              let mentionsToIncludeExec = Array.isArray(mentionedJidsExec) ? mentionedJidsExec : [];
              if (!mentionsToIncludeExec.length && typeof menc_os2 !== 'undefined' && menc_os2) {
                mentionsToIncludeExec = [menc_os2];
              }
              await nazu.sendMessage(from, {
                video: videoBuffer,
                caption: processedResponse.caption || '',
                mentions: mentionsToIncludeExec
              }, { quoted: info });
            }
          } else if (processedResponse.type === 'audio') {
            const audioBuffer = processedResponse.buffer ? Buffer.from(processedResponse.buffer, 'base64') : null;
            if (audioBuffer) {
              await nazu.sendMessage(from, {
                audio: audioBuffer,
                mimetype: 'audio/mp4',
                ptt: processedResponse.ptt || false
              }, { quoted: info });
            }
          } else if (processedResponse.type === 'sticker') {
            const stickerBuffer = processedResponse.buffer ? Buffer.from(processedResponse.buffer, 'base64') : null;
            if (stickerBuffer) {
              await nazu.sendMessage(from, {
                sticker: stickerBuffer
              }, { quoted: info });
            }
          }
          
          return; // Comando personalizado executado, n√£o continuar
        } catch (error) {
          console.error('Erro ao executar comando personalizado:', error);
          await reply('‚ùå Erro ao executar comando personalizado.');
        }
      }
    }

    if (isCmd && !['cmdlimitar', 'cmdlimit', 'limitarcmd', 'cmddeslimitar', 'cmdremovelimit', 'rmcmdlimit', 'cmdlimites', 'cmdlimits', 'listcmdlimites'].includes(command)) {
      const globalLimitCheck = checkCommandLimit(command, sender);
      if (globalLimitCheck.limited) {
        return reply(globalLimitCheck.message);
      }
    }

    // Verifica√ß√£o de comandos VIP
    if (isCmd && vipCommandsManager.isVipCommand(command)) {
      if (!isPremium) {
        await reply(`üîí *Comando VIP Exclusivo*

Este comando est√° dispon√≠vel apenas para usu√°rios VIP/Premium!

üíé *Benef√≠cios VIP:*
‚Ä¢ Acesso a comandos exclusivos
‚Ä¢ Sem limites de uso
‚Ä¢ Prioridade no atendimento
‚Ä¢ Recursos premium

üìû *Como ser VIP?*
Entre em contato com o dono do bot:
‚Ä¢ Use: ${prefix}dono

‚ú® Use ${prefix}menuvip para ver todos os comandos VIP dispon√≠veis!`);
        return;
      }
    }

    switch (command) {
      
      case 'roles':
      case 'role.lista':
      case 'listaroles': {
        try {
          if (!isGroup) {
            await reply('‚ö†Ô∏è Este comando s√≥ pode ser usado em grupos.');
            break;
          }

          const roleEntries = Object.entries(groupData.roles || {});
          if (!roleEntries.length) {
            await reply('ü™© Nenhum rol√™ ativo no momento.');
            break;
          }

          const wantsPv = normalizar(args[0] || '') === 'pv';
          const sendInPv = !isGroupAdmin || wantsPv;
          const sendTarget = sendInPv ? sender : from;
          const listLines = roleEntries.map(([roleCode, roleData], index) => formatRoleSummary(roleCode, roleData, roleEntries.length > 1 ? index : null));
          const listText = `ü™© *Rol√™s ativos*\n\n${listLines.join('\n\n')}\n\nüôã Reaja com ${ROLE_GOING_BASE} ou use ${groupPrefix}role.vou CODIGO\nü§∑ Reaja com ${ROLE_NOT_GOING_BASE} ou use ${groupPrefix}role.nvou CODIGO`;

          try {
            await nazu.sendMessage(sendTarget, { text: listText });
            if (sendInPv && sendTarget !== from) {
              await reply('üì¨ Enviei a lista de rol√™s no seu privado!', { mentions: [sender] });
            }
          } catch (listError) {
            console.error('Erro ao enviar lista de rol√™s:', listError);
            await reply('‚ùå N√£o consegui enviar a lista de rol√™s agora. Tente novamente mais tarde.');
          }
        } catch (e) {
          console.error('Erro em listaroles:', e);
          await reply('‚ùå Ocorreu um erro ao listar os rol√™s.');
        }
        break;
      }

      case 'role.criar': {
        try {
          if (!isGroup) {
            await reply('‚ö†Ô∏è Este comando s√≥ pode ser usado em grupos.');
            break;
          }
          if (!isGroupAdmin) {
            await reply('üö´ Apenas administradores podem criar rol√™s.');
            break;
          }

          const parts = parsePipeArgs(q);
          if (parts.length < 1) {
            await reply(`üìã Formato esperado:\n${groupPrefix}role.criar CODIGO | T√≠tulo/Descri√ß√£o\n\n*Opcional:* CODIGO | T√≠tulo | Data/Hor√°rio | Local | Observa√ß√µes`);
            break;
          }

          const code = sanitizeRoleCode(parts.shift());
          if (!code) {
            await reply('‚ùå Informe um c√≥digo alfanum√©rico para o rol√™.');
            break;
          }
          if (groupData.roles[code]) {
            await reply('‚ùå J√° existe um rol√™ cadastrado com esse c√≥digo.');
            break;
          }

          const title = parts[0] || '';
          const when = parts[1] || '';
          const where = parts[2] || '';
          const description = parts.slice(3).join(' | ') || '';

          const roleData = {
            code,
            title,
            when,
            where,
            description,
            createdAt: new Date().toISOString(),
            createdBy: sender,
            participants: {
              going: [],
              notGoing: []
            }
          };
          ensureRoleParticipants(roleData);

          const lines = [
            'ü™© *Novo rol√™ confirmado!*',
            `üé´ C√≥digo: *${code}*`
          ];
          if (title) lines.push(`üìõ T√≠tulo: ${title}`);
          if (when) lines.push(`üóìÔ∏è Quando: ${when}`);
          if (where) lines.push(`üìç Onde: ${where}`);
          if (description) lines.push(`üìù Descri√ß√£o: ${description}`);
          lines.push('');
          lines.push(`üôã Reaja com ${ROLE_GOING_BASE} ou use ${groupPrefix}role.vou ${code}`);
          lines.push(`ü§∑ Reaja com ${ROLE_NOT_GOING_BASE} ou use ${groupPrefix}role.nvou ${code}`);
          const announcementText = lines.join('\n');

          let sentMessage = null;
          let mediaData = null;
          try {
            const mediaInfo = getMediaInfo(info.message);
            if (mediaInfo && (mediaInfo.type === 'image' || mediaInfo.type === 'video')) {
              const buffer = await getFileBuffer(mediaInfo.media, mediaInfo.type);
              const payload = {
                caption: announcementText
              };
              
              // Salva informa√ß√µes da m√≠dia para uso posterior
              mediaData = {
                type: mediaInfo.type,
                buffer: buffer.toString('base64'),
                mimetype: mediaInfo.media.mimetype || (mediaInfo.type === 'image' ? 'image/jpeg' : 'video/mp4'),
                gifPlayback: mediaInfo.type === 'video' && mediaInfo.media.gifPlayback
              };
              
              if (mediaInfo.type === 'image') {
                payload.image = buffer;
                payload.mimetype = mediaData.mimetype;
              } else {
                payload.video = buffer;
                payload.mimetype = mediaData.mimetype;
                if (mediaData.gifPlayback) {
                  payload.gifPlayback = true;
                }
              }
              sentMessage = await nazu.sendMessage(from, payload);
            } else {
              sentMessage = await nazu.sendMessage(from, { text: announcementText });
            }
          } catch (sendError) {
            console.error('Erro ao divulgar rol√™:', sendError);
          }

          if (sentMessage?.key?.id) {
            roleData.announcementKey = {
              id: sentMessage.key.id,
              fromMe: sentMessage.key.fromMe ?? true,
              participant: sentMessage.key.participant || null
            };
            groupData.roleMessages[sentMessage.key.id] = code;
          } else {
            roleData.announcementKey = null;
          }
          
          // Salva a m√≠dia no roleData
          if (mediaData) {
            roleData.media = mediaData;
          }

          groupData.roles[code] = roleData;
          persistGroupData();

          await reply(sentMessage ? `‚úÖ Rol√™ *${code}* cadastrado e divulgado!` : `‚ö†Ô∏è Rol√™ *${code}* salvo, mas n√£o consegui enviar a divulga√ß√£o automaticamente. Use ${groupPrefix}roles para compartilhar.`);
        } catch (e) {
          console.error('Erro em role.criar:', e);
          await reply('‚ùå Ocorreu um erro ao criar o rol√™.');
        }
        break;
      }

      case 'role.alterar': {
        try {
          if (!isGroup) {
            await reply('‚ö†Ô∏è Este comando s√≥ pode ser usado em grupos.');
            break;
          }
          if (!isGroupAdmin) {
            await reply('üö´ Apenas administradores podem alterar rol√™s.');
            break;
          }

          const parts = parsePipeArgs(q);
          if (!parts.length) {
            await reply(`üìã Formato esperado:\n${groupPrefix}role.alterar CODIGO | Novo t√≠tulo | Novo hor√°rio | Novo local | Nova descri√ß√£o`);
            break;
          }

          const code = sanitizeRoleCode(parts.shift());
          if (!code) {
            await reply('‚ùå Informe um c√≥digo v√°lido para o rol√™.');
            break;
          }

          const roleData = groupData.roles[code];
          if (!roleData) {
            await reply('‚ùå N√£o encontrei nenhum rol√™ com esse c√≥digo.');
            break;
          }

          const mediaInfo = getMediaInfo(info.message);
          if (!parts.length && !mediaInfo) {
            await reply('‚ÑπÔ∏è Informe pelo menos um campo para atualiza√ß√£o ou envie uma nova m√≠dia.');
            break;
          }

          if (parts[0]) roleData.title = parts[0];
          if (parts[1]) roleData.when = parts[1];
          if (parts[2]) roleData.where = parts[2];
          if (parts.length > 3) {
            roleData.description = parts.slice(3).join(' | ');
          }

          roleData.updatedAt = new Date().toISOString();
          roleData.updatedBy = sender;
          ensureRoleParticipants(roleData);

          if (roleData.announcementKey?.id) {
            delete groupData.roleMessages[roleData.announcementKey.id];
            try {
              await nazu.sendMessage(from, {
                delete: {
                  remoteJid: from,
                  fromMe: roleData.announcementKey.fromMe !== undefined ? roleData.announcementKey.fromMe : true,
                  id: roleData.announcementKey.id,
                  participant: roleData.announcementKey.participant || undefined
                }
              });
            } catch (deleteErr) {
              console.warn('N√£o consegui remover a divulga√ß√£o antiga do rol√™:', deleteErr.message || deleteErr);
            }
          }

          const lines = [
            'üõ†Ô∏è *Rol√™ atualizado!*',
            `üé´ C√≥digo: *${code}*`
          ];
          if (roleData.title) lines.push(`üìõ T√≠tulo: ${roleData.title}`);
          if (roleData.when) lines.push(`üóìÔ∏è Quando: ${roleData.when}`);
          if (roleData.where) lines.push(`üìç Onde: ${roleData.where}`);
          if (roleData.description) lines.push(`üìù Descri√ß√£o: ${roleData.description}`);
          lines.push('');
          lines.push(`üôã Reaja com ${ROLE_GOING_BASE} ou use ${groupPrefix}role.vou ${code}`);
          lines.push(`ü§∑ Reaja com ${ROLE_NOT_GOING_BASE} ou use ${groupPrefix}role.nvou ${code}`);
          const announcementText = lines.join('\n');

          let sentMessage = null;
          try {
            if (mediaInfo && (mediaInfo.type === 'image' || mediaInfo.type === 'video')) {
              const buffer = await getFileBuffer(mediaInfo.media, mediaInfo.type);
              const payload = {
                caption: announcementText
              };
              if (mediaInfo.type === 'image') {
                payload.image = buffer;
                payload.mimetype = mediaInfo.media.mimetype || 'image/jpeg';
              } else {
                payload.video = buffer;
                payload.mimetype = mediaInfo.media.mimetype || 'video/mp4';
                if (mediaInfo.media.gifPlayback) {
                  payload.gifPlayback = true;
                }
              }
              sentMessage = await nazu.sendMessage(from, payload);
            } else {
              sentMessage = await nazu.sendMessage(from, { text: announcementText });
            }
          } catch (updateErr) {
            console.error('Erro ao reenviar divulga√ß√£o do rol√™:', updateErr);
          }

          if (sentMessage?.key?.id) {
            roleData.announcementKey = {
              id: sentMessage.key.id,
              fromMe: sentMessage.key.fromMe ?? true,
              participant: sentMessage.key.participant || null
            };
            groupData.roleMessages[sentMessage.key.id] = code;
          } else {
            roleData.announcementKey = null;
          }

          groupData.roles[code] = roleData;
          persistGroupData();
          await reply(`‚úÖ Rol√™ *${code}* atualizado.`);
        } catch (e) {
          console.error('Erro em role.alterar:', e);
          await reply('‚ùå Ocorreu um erro ao alterar o rol√™.');
        }
        break;
      }

      case 'role.excluir': {
        try {
          if (!isGroup) {
            await reply('‚ö†Ô∏è Este comando s√≥ pode ser usado em grupos.');
            break;
          }
          if (!isGroupAdmin) {
            await reply('üö´ Apenas administradores podem excluir rol√™s.');
            break;
          }

          const code = sanitizeRoleCode(q || args[0] || '');
          if (!code) {
            await reply(`üìã Informe o c√≥digo do rol√™. Exemplo: ${groupPrefix}role.excluir CODIGO`);
            break;
          }

          const roleData = groupData.roles[code];
          if (!roleData) {
            await reply('‚ùå N√£o encontrei nenhum rol√™ com esse c√≥digo.');
            break;
          }

          if (roleData.announcementKey?.id) {
            delete groupData.roleMessages[roleData.announcementKey.id];
            try {
              await nazu.sendMessage(from, {
                delete: {
                  remoteJid: from,
                  fromMe: roleData.announcementKey.fromMe !== undefined ? roleData.announcementKey.fromMe : true,
                  id: roleData.announcementKey.id,
                  participant: roleData.announcementKey.participant || undefined
                }
              });
            } catch (deleteErr) {
              console.warn('N√£o consegui remover a divulga√ß√£o do rol√™:', deleteErr.message || deleteErr);
            }
          }

          delete groupData.roles[code];
          persistGroupData();
          await reply(`üóëÔ∏è Rol√™ *${code}* removido.`);
        } catch (e) {
          console.error('Erro em role.excluir:', e);
          await reply('‚ùå Ocorreu um erro ao excluir o rol√™.');
        }
        break;
      }

      case 'role.vou': {
        try {
          if (!isGroup) {
            await reply('‚ö†Ô∏è Este comando s√≥ pode ser usado em grupos.');
            break;
          }

          const code = sanitizeRoleCode(args[0] || '');
          if (!code) {
            await reply(`üìã Informe o c√≥digo do rol√™. Exemplo: ${groupPrefix}role.vou CODIGO`);
            break;
          }

          const roleData = groupData.roles[code];
          if (!roleData) {
            await reply('‚ùå N√£o encontrei nenhum rol√™ com esse c√≥digo.');
            break;
          }

          const participants = ensureRoleParticipants(roleData);
          if (participants.going.includes(sender)) {
            await reply(`üôã Voc√™ j√° confirmou presen√ßa no rol√™ *${roleData.title || code}*.`);
            break;
          }

          participants.going.push(sender);
          participants.notGoing = participants.notGoing.filter(id => id !== sender);
          participants.updatedAt = new Date().toISOString();

          groupData.roles[code] = roleData;
          persistGroupData();

          await reply(`‚úÖ Presen√ßa confirmada no rol√™ *${roleData.title || code}*.`);
          // Atualiza an√∫ncio principal
          await refreshRoleAnnouncement(code, roleData);
        } catch (e) {
          console.error('Erro em role.vou:', e);
          await reply('‚ùå Ocorreu um erro ao confirmar sua presen√ßa.');
        }
        break;
      }

      case 'role.nvou': {
        try {
          if (!isGroup) {
            await reply('‚ö†Ô∏è Este comando s√≥ pode ser usado em grupos.');
            break;
          }

          const code = sanitizeRoleCode(args[0] || '');
          if (!code) {
            await reply(`üìã Informe o c√≥digo do rol√™. Exemplo: ${groupPrefix}role.nvou CODIGO`);
            break;
          }

          const roleData = groupData.roles[code];
          if (!roleData) {
            await reply('‚ùå N√£o encontrei nenhum rol√™ com esse c√≥digo.');
            break;
          }

          const participants = ensureRoleParticipants(roleData);
          const wasGoing = participants.going.includes(sender);

          participants.going = participants.going.filter(id => id !== sender);
          if (!participants.notGoing.includes(sender)) {
            participants.notGoing.push(sender);
          }
          participants.updatedAt = new Date().toISOString();

          groupData.roles[code] = roleData;
          persistGroupData();

          await reply(wasGoing ? `ü§∑ Presen√ßa removida do rol√™ *${roleData.title || code}*.` : `ü§∑ Voc√™ j√° estava marcado como ausente para o rol√™ *${roleData.title || code}*.`);
          // Atualiza an√∫ncio principal
          await refreshRoleAnnouncement(code, roleData);
        } catch (e) {
          console.error('Erro em role.nvou:', e);
          await reply('‚ùå Ocorreu um erro ao atualizar sua presen√ßa.');
        }
        break;
      }

      case 'role':
      case 'role.confirmados':
      case 'role.participantes':
      case 'role.info': {
        try {
          if (!isGroup) {
            await reply('‚ö†Ô∏è Este comando s√≥ pode ser usado em grupos.');
            break;
          }
          const code = sanitizeRoleCode(args[0] || '');
          if (!code) {
            await reply(`üìã Informe o c√≥digo do rol√™. Exemplo: ${groupPrefix}role CODIGO`);
            break;
          }
          const roleData = groupData.roles[code];
          if (!roleData) {
            await reply('‚ùå N√£o encontrei nenhum rol√™ com esse c√≥digo.');
            break;
          }
          const parts = ensureRoleParticipants(roleData);
          const going = parts.going || [];
          const notGoing = parts.notGoing || [];
          const lines = [];
          lines.push(`ü™© *${roleData.title || code}*`);
          lines.push(`üé´ C√≥digo: ${code}`);
          if (roleData.when) lines.push(`üóìÔ∏è Quando: ${roleData.when}`);
          if (roleData.where) lines.push(`üìç Onde: ${roleData.where}`);
          if (roleData.description) lines.push(`üìù Descri√ß√£o: ${roleData.description}`);
          lines.push('');
          lines.push(`üôã Confirmados (${going.length}):`);
          lines.push(going.length ? going.map(id => `‚Ä¢ @${getUserName(id)}`).join('\n') : '‚Ä¢ ‚Äî');
          lines.push('');
          lines.push(`ü§∑ Desistiram (${notGoing.length}):`);
          lines.push(notGoing.length ? notGoing.map(id => `‚Ä¢ @${getUserName(id)}`).join('\n') : '‚Ä¢ ‚Äî');
          
          // Envia com a m√≠dia salva se dispon√≠vel
          if (roleData.media) {
            try {
              const buffer = Buffer.from(roleData.media.buffer, 'base64');
              const payload = {
                caption: lines.join('\n'),
                mentions: [...going, ...notGoing]
              };
              
              if (roleData.media.type === 'image') {
                payload.image = buffer;
                payload.mimetype = roleData.media.mimetype;
              } else if (roleData.media.type === 'video') {
                payload.video = buffer;
                payload.mimetype = roleData.media.mimetype;
                if (roleData.media.gifPlayback) {
                  payload.gifPlayback = true;
                }
              }
              
              await nazu.sendMessage(from, payload, { quoted: info });
            } catch (mediaError) {
              console.log('Erro ao enviar m√≠dia do rol√™:', mediaError.message);
              // Se falhar, envia apenas texto
              await nazu.sendMessage(from, { text: lines.join('\n'), mentions: [...going, ...notGoing] }, { quoted: info });
            }
          } else {
            // Se n√£o tiver m√≠dia, envia apenas texto
            await nazu.sendMessage(from, { text: lines.join('\n'), mentions: [...going, ...notGoing] }, { quoted: info });
          }
        } catch (e) {
          console.error('Erro em role.info:', e);
          await reply('‚ùå Ocorreu um erro ao buscar informa√ß√µes do rol√™.');
        }
        break;
      }

      case 'menurpg':
      case 'rpg': {
        await sendMenuWithMedia('menurpg', menuRPG);
        break;
      }

      case 'lembrete':
      case 'lembrar': {
        try {
          if (!q) return reply(`üìÖ *Como usar o comando lembrete:*\n\nüí° *Exemplos:*\n‚Ä¢ ${prefix}lembrete em 30m beber √°gua\n‚Ä¢ ${prefix}lembrete 15/09 18:30 reuni√£o\n‚Ä¢ ${prefix}lembrete amanh√£ 08:00 acordar`);
          const parsed = parseReminderInput(q);
          if (!parsed) return reply('‚ùå N√£o consegui entender a data/hora. Exemplos:\n- em 10m tomar rem√©dio\n- 25/12 09:00 ligar para a fam√≠lia\n- hoje 21:15 estudar');
          const { at, message } = parsed;
          const minDelay = 10 * 1000;
          if (at - Date.now() < minDelay) return reply('‚è≥ Escolha um hor√°rio pelo menos 10 segundos √† frente.');
          const newReminder = {
            id: (() => {
              try {
                return crypto.randomBytes(6).toString('hex');
              } catch (error) {
                return Math.random().toString(16).substring(2, 14);
              }
            })(),
            userId: sender,
            chatId: from,
            createdByName: pushname || '',
            createdAt: new Date().toISOString(),
            at,
            message: message,
            status: 'pending'
          };
          // Otimiza√ß√£o: Cache de reminders
          const list = await optimizer.memoize(
            'reminders:all',
            () => Promise.resolve(loadReminders()),
            5000 // 5 segundos
          );
          list.push(newReminder);
          saveReminders(list);
          // Invalida cache ap√≥s salvar
          optimizer.clearStatic('reminders:all');
          // Invalida cache ap√≥s salvar
          optimizer.clearStatic('reminders:all');
          await reply(`‚úÖ Lembrete agendado para ${tzFormat(at)}.\nüìù Mensagem: ${message}`);
        } catch (e) {
          console.error('Erro ao agendar lembrete:', e);
          await reply('‚ùå Ocorreu um erro ao agendar seu lembrete.');
        }
        break;
      }
      case 'meuslembretes':
      case 'listalembretes': {
        try {
          // Otimiza√ß√£o: Cache de reminders
          const allReminders = await optimizer.memoize(
            'reminders:all',
            () => Promise.resolve(loadReminders()),
            5000 // 5 segundos
          );
          const list = allReminders.filter(r => r.userId === sender && r.status !== 'sent');
          if (!list.length) return reply('üì≠ Voc√™ n√£o tem lembretes pendentes.');
          const lines = list
            .sort((a,b)=>a.at-b.at)
            .map((r,i)=>`${i+1}. [${r.id.slice(0,6)}] ${tzFormat(r.at)} ‚Äî ${r.message}`);
          await reply(`üóìÔ∏è Seus lembretes pendentes:\n\n${lines.join('\n')}`);
        } catch (e) {
          console.error('Erro ao listar lembretes:', e);
          await reply('‚ùå Ocorreu um erro ao listar seus lembretes.');
        }
        break;
      }
      case 'apagalembrete':
      case 'removerlembrete': {
        try {
          const idArg = (q||'').trim();
          if (!idArg) return reply(`üóëÔ∏è *Uso do comando apagalembrete:*\n\nüìù *Formato:* ${prefix}apagalembrete <id|tudo>\n\nüí° *Exemplos:*\n‚Ä¢ ${prefix}apagalembrete 123456\n‚Ä¢ ${prefix}apagalembrete tudo`);
          // Otimiza√ß√£o: Cache de reminders
          let list = await optimizer.memoize(
            'reminders:all',
            () => Promise.resolve(loadReminders()),
            5000 // 5 segundos
          );
          if (['tudo','todos','all'].includes(idArg.toLowerCase())) {
            const before = list.length;
            list = list.filter(r => !(r.userId === sender && r.status !== 'sent'));
            const removed = before - list.length;
            saveReminders(list);
          // Invalida cache ap√≥s salvar
          optimizer.clearStatic('reminders:all');
            return reply(`üóëÔ∏è Removidos ${removed} lembrete(s) pendente(s).`);
          }
          const idx = list.findIndex(r => r.id.startsWith(idArg) && r.userId === sender && r.status !== 'sent');
          if (idx === -1) return reply('‚ùå Lembrete n√£o encontrado ou j√° enviado. Dica: use o ID mostrado em "meuslembretes".');
          const removed = list.splice(idx,1)[0];
          saveReminders(list);
          // Invalida cache ap√≥s salvar
          optimizer.clearStatic('reminders:all');
          await reply(`üóëÔ∏è Lembrete removido: ${removed.message}`);
        } catch (e) {
          console.error('Erro ao apagar lembrete:', e);
          await reply('‚ùå Ocorreu um erro ao remover seu lembrete.');
        }
        break;
      }

      case 'modorpg':
      case 'rpgmode': {
        if (!isGroup) return reply('Este comando s√≥ funciona em grupos.');
        if (!isGroupAdmin) return reply('Apenas administradores podem usar este comando.');
        groupData.modorpg = !groupData.modorpg;
  writeJsonFile(groupFile, groupData);
  // Otimiza√ß√£o: Invalida cache quando groupData √© salvo
  if (isGroup) {
    optimizer.invalidateGroup(from);
  }
        await reply(`‚öîÔ∏è Modo RPG ${groupData.modorpg ? 'ATIVADO' : 'DESATIVADO'} neste grupo.\n\n${groupData.modorpg ? 'üéÆ Agora os membros podem usar todos os comandos RPG!' : 'üîí Comandos RPG desativados.'}`);
        break;
      }

      case 'perfilrpg':
      case 'carteira':
      case 'banco':
      case 'depositar':
      case 'dep':
      case 'sacar':
      case 'saque':
      case 'transferir':
      case 'pix':
      case 'loja':
      case 'lojarps':
      case 'comprar':
      case 'buy':
  case 'inventario':
  case 'inv':
  case 'apostar':
  case 'bet':
  case 'slots':
      case 'minerar':
      case 'mine':
      case 'trabalhar':
      case 'work':
  case 'emprego':
  case 'vagas':
  case 'demitir':
  case 'pescar':
  case 'fish':
  case 'explorar':
  case 'explore':
  case 'cacar':
  case 'ca√ßar':
  case 'hunt':
  case 'mercado':
  case 'listar':
  case 'comprarmercado':
  case 'cmerc':
  case 'meusanuncios':
  case 'meusan':
  case 'cancelar':
  case 'propriedades':
  case 'comprarpropriedade':
  case 'cprop':
  case 'coletarpropriedades':
  case 'cprops':
  case 'habilidades':
  case 'desafiosemanal':
  case 'desafiomensal':
  case 'materiais':
  case 'precos':
  case 'pre√ßos':
  case 'vender':
  case 'reparar':
  case 'desafio':
  case 'forjar':
  case 'forge':
  case 'crime':
      case 'assaltar':
      case 'roubar':
      case 'cozinhar':
      case 'cook':
      case 'receitas':
      case 'plantar':
      case 'cultivar':
      case 'plant':
      case 'farm':
      case 'colher':
      case 'coletar':
      case 'harvest':
      case 'plantacao':
      case 'planta√ß√£o':
      case 'horta':
      case 'comer':
      case 'eat':
      case 'vendercomida':
      case 'ingredientes':
      case 'sementes':
      case 'toprpg':
      case 'ranklevel':
      case 'ranklvl':
      case 'rankinglevel':
      case 'levels':
      case 'toplevels':
      case 'diario':
      case 'daily':
      case 'resetrpg':
      {
        if (!isGroup) return reply('‚öîÔ∏è Os comandos RPG funcionam apenas em grupos.');
  if (!groupData.modorpg) return reply(`‚öîÔ∏è *Modo RPG desativado!*\n\nüîí Este recurso est√° dispon√≠vel apenas quando o Modo RPG est√° ativado.\nüîê *Administradores* podem ativar com: ${prefix}modorpg\n\nüí° Use ${prefix}menurpg para ver todos os comandos!`);
    const econ = loadEconomy();
    const changedEconomy = ensureEconomyDefaults(econ);
  const me = getEcoUser(econ, sender);
  ensureUserChallenge(me);
  const { mineBonus, workBonus, bankCapacity, fishBonus, exploreBonus, huntBonus, forgeBonus } = applyShopBonuses(me, econ);
  if (changedEconomy) saveEconomy(econ);

        const sub = command;
        const args = q ? q.trim().toLowerCase().split(/\s+/) : [];
        // Tratamento especial para ranklevel/ranklvl/levels etc.
        if (['ranklevel','ranklvl','rankinglevel','levels','toplevels'].includes(sub)) {
          // Se estiver em grupo, usamos o ranking do grupo (RPG)
          if (isGroup) {
            if (!groupData.modorpg) return reply(`‚öîÔ∏è Modo RPG desativado! Use ${prefix}modorpg para ativar.`);
            const levelingData = loadLevelingSafe();
            const userEntries = Object.entries(levelingData.users || {});
            const groupUsers = userEntries.filter(([id, data]) => AllgroupMembers.includes(id));
            if (groupUsers.length === 0) return reply('üìä Nenhum usu√°rio do grupo encontrado no sistema de levels.');

            const sortedUsers = groupUsers
              .map(([id, userData]) => ({ id, level: userData?.level || 1, xp: userData?.xp || 0, messages: userData?.messages || 0, commands: userData?.commands || 0, patent: userData?.patent || 'Iniciante' }))
              .sort((a, b) => (b.level !== a.level ? b.level - a.level : b.xp - a.xp))
              .slice(0, 15);

            let text = 'üèÜ *RANKING DE LEVELS DO GRUPO* üèÜ\n\n';
            const mentions = [];
            sortedUsers.forEach((user, i) => {
              const medal = i === 0 ? 'ü•á' : i === 1 ? 'ü•à' : i === 2 ? 'ü•â' : `${i+1}.`;
              const userName = user.id.split('@')[0];
              const xpNeeded = (user.level * 100) - (user.level - 1) * 100;
              const progress = user.xp > 0 ? ` (${user.xp}/${xpNeeded} XP)` : '';
              text += `${medal} @${userName} ‚Äî *Level ${user.level}*${progress}\n`;
              text += `   üèÖ ${user.patent} | üí¨ ${user.messages} msgs | ‚ö° ${user.commands} cmds\n`;
              mentions.push(user.id);
            });
            text += '\n‚ú® Continue jogando e interagindo para subir no ranking!';
            return reply(text, { mentions });
          }

          // Se n√£o for grupo, serve como ranking global
          const levelingDataRank = loadLevelingSafe();
          const sortedUsers = Object.entries(levelingDataRank.users || {}).sort((a,b)=> (b[1]?.level || 1) - (a[1]?.level || 1) || (b[1]?.xp || 0) - (a[1]?.xp || 0) ).slice(0, 15);
          let rankMessage = 'üèÜ *Ranking Global de N√≠veis*\n\n';
          const mentionsG = [];
          sortedUsers.forEach(([userId,data],index)=>{ rankMessage += `${index+1}. @${getUserName(userId)} - N√≠vel ${data?.level || 1} (XP: ${data?.xp || 0})\n`; mentionsG.push(userId); });
          return reply(rankMessage, { mentions: mentionsG });
        }
        const mentioned = (menc_jid2 && menc_jid2[0]) || (q.includes('@') ? q.split(' ')[0].replace('@','') : null);

        if (sub === 'resetrpg') {
          if (!(isOwner && !isSubOwner && (sender === nmrdn || isBotSender))) return reply('Apenas o Dono principal pode resetar usu√°rios.');
          const target = (menc_jid2 && menc_jid2[0]) || null;
          const scope = (q||'').toLowerCase();
          if (scope.includes('all') || scope.includes('todos')) {
            let count = 0;
            for (const p of (AllgroupMembers||[])) {
              if (econ.users[p]) { delete econ.users[p]; count++; }
            }
            saveEconomy(econ);
            return reply(`‚úÖ Resetado os dados RPG de ${count} membros do grupo.`);
          }
          if (!target) return reply('Marque um usu√°rio para resetar ou use "all".');
          delete econ.users[target];
          saveEconomy(econ);
          return reply(`‚úÖ Dados RPG resetados para @${getUserName(target)}.`, { mentions:[target] });
        }

        if (sub === 'perfilrpg') {
          // Perfil completo do RPG
          const total = (me.wallet||0) + (me.bank||0);
          const level = me.level || 1;
          const exp = me.exp || 0;
          const nextLevelXp = 100 * Math.pow(1.5, level - 1);
          const expProgress = `${exp}/${Math.floor(nextLevelXp)}`;
          const expPercent = Math.min(100, Math.floor((exp / nextLevelXp) * 100));
          
          // Skills
          ensureUserSkills(me);
          const topSkills = SKILL_LIST.map(sk => ({ name: sk, level: me.skills[sk]?.level || 1 }))
            .sort((a,b) => b.level - a.level).slice(0, 3);
          
          // Estat√≠sticas gerais
          const battlesWon = me.battlesWon || 0;
          const battlesLost = me.battlesLost || 0;
          const totalBattles = battlesWon + battlesLost;
          const winRate = totalBattles > 0 ? Math.floor((battlesWon / totalBattles) * 100) : 0;
          
          const achievements = Object.keys(me.achievements || {}).length;
          const pets = (me.pets || []).length;
          const premiumItems = Object.keys(me.premiumItems || {}).length;
          
          // Progresso de prestige
          const prestigeLevel = me.prestige?.level || 0;
          const prestigeMultiplier = me.prestige?.bonusMultiplier || 1;
          
          // Reputa√ß√£o
          const reputation = me.reputation?.points || 0;
          const karma = me.reputation?.karma || 0;
          
          // Streak di√°rio
          const streak = me.streak?.count || 0;
          
          // Classe
          const classes = {
            'guerreiro': { emoji: '‚öîÔ∏è', name: 'Guerreiro' },
            'mago': { emoji: 'üßô', name: 'Mago' },
            'arqueiro': { emoji: 'üèπ', name: 'Arqueiro' },
            'curandeiro': { emoji: 'üíö', name: 'Curandeiro' },
            'ladino': { emoji: 'üó°Ô∏è', name: 'Ladino' },
            'paladino': { emoji: 'üõ°Ô∏è', name: 'Paladino' }
          };
          const classeInfo = me.classe ? `${classes[me.classe]?.emoji} ${classes[me.classe]?.name}` : 'Nenhuma';
          
          // Cl√£
          let clanInfo = 'Nenhum';
          if (me.clan && econ.clans[me.clan]) {
            const myClan = econ.clans[me.clan];
            clanInfo = myClan.name || 'Sem nome';
          }
          
          // Casa
          const casas = {
            'barraca': { emoji: '‚õ∫', name: 'Barraca' },
            'cabana': { emoji: 'üèöÔ∏è', name: 'Cabana' },
            'casa': { emoji: 'üè†', name: 'Casa' },
            'mansao': { emoji: 'üè∞', name: 'Mans√£o' },
            'castelo': { emoji: 'üèØ', name: 'Castelo' }
          };
          const houseInfo = me.house?.type ? `${casas[me.house.type]?.emoji || ''} ${casas[me.house.type]?.name || me.house.type}` : 'Nenhuma';
          
          // Fam√≠lia e Relacionamento
          if (!me.family) me.family = { spouse: null, children: [], parents: [], siblings: [] };
          const familyChildren = (me.family.children || []).length;
          
          // Buscar relacionamento ativo do sistema de relacionamentos
          let familySpouse = 'Solteiro(a)';
          let relationshipType = '';
          let relationshipEmoji = '';
          const mentions = [];
          
          const activePair = relationshipManager.getActivePairForUser(sender);
          if (activePair && activePair.partnerId) {
            familySpouse = `@${activePair.partnerId.split('@')[0]}`;
            mentions.push(activePair.partnerId);
            
            // Determinar tipo de relacionamento
            if (activePair.pair?.status === 'casamento') {
              relationshipType = 'Casado(a)';
              relationshipEmoji = 'üíç';
            } else if (activePair.pair?.status === 'namoro') {
              relationshipType = 'Namorando';
              relationshipEmoji = 'üíû';
            } else if (activePair.pair?.status === 'brincadeira') {
              relationshipType = 'Brincadeira';
              relationshipEmoji = 'üéà';
            }
          }
          
          let text = `‚ï≠‚îÅ‚îÅ‚îÅ‚ä± ‚öîÔ∏è *PERFIL RPG* ‚öîÔ∏è ‚ä±‚îÅ‚îÅ‚îÅ‚ïÆ\n`;
          text += `‚îÇ ${pushname}\n`;
          text += `‚ï∞‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚ïØ\n\n`;
          
          text += `üìä *N√çVEL & EXPERI√äNCIA*\n`;
          text += `‚îú Level: ${level}\n`;
          text += `‚îú XP: ${expProgress} (${expPercent}%)\n`;
          text += `‚îú Prestige: ${prestigeLevel}x (${prestigeMultiplier.toFixed(2)}x)\n`;
          text += `‚îî Streak: ${streak} dia${streak !== 1 ? 's' : ''}\n\n`;
          
          text += `üí∞ *FINAN√áAS*\n`;
          text += `‚îú Carteira: ${fmt(me.wallet)}\n`;
          text += `‚îú Banco: ${fmt(me.bank)}\n`;
          text += `‚îú Total: ${fmt(total)}\n`;
          text += `‚îî Emprego: ${me.job ? econ.jobCatalog[me.job]?.name || me.job : 'Desempregado(a)'}\n\n`;
          
          text += `üé≠ *PERSONALIZA√á√ÉO*\n`;
          text += `‚îú Classe: ${classeInfo}\n`;
          text += `‚îú Cl√£: ${clanInfo}\n`;
          text += `‚îî Casa: ${houseInfo}\n\n`;
          
          text += `‚öîÔ∏è *COMBATE*\n`;
          text += `‚îú Vit√≥rias: ${battlesWon}\n`;
          text += `‚îú Derrotas: ${battlesLost}\n`;
          text += `‚îú Win Rate: ${winRate}%\n`;
          text += `‚îî Poder: ${me.power || 100}\n\n`;
          
          text += `üõ†Ô∏è *HABILIDADES (TOP 3)*\n`;
          topSkills.forEach((sk, i) => {
            const prefixChar = i === topSkills.length - 1 ? '‚îî' : '‚îú';
            const skillName = sk.name.charAt(0).toUpperCase() + sk.name.slice(1);
            text += `${prefixChar} ${skillName}: Lv.${sk.level}\n`;
          });
          text += `\n`;
          
          text += `üë®‚Äçüë©‚Äçüëß‚Äçüë¶ *FAM√çLIA & RELACIONAMENTO*\n`;
          if (relationshipEmoji) {
            text += `‚îú ${relationshipEmoji} Status: ${relationshipType}\n`;
            text += `‚îú Parceiro(a): ${familySpouse}\n`;
          } else {
            text += `‚îú üíî Status: Solteiro(a)\n`;
          }
          text += `‚îî Filhos: ${familyChildren}\n\n`;
          
          text += `üèÜ *COLECION√ÅVEIS*\n`;
          text += `‚îú Conquistas: ${achievements}\n`;
          text += `‚îú Pets: ${pets}\n`;
          text += `‚îî Itens Premium: ${premiumItems}\n\n`;
          
          text += `‚≠ê *REPUTA√á√ÉO*\n`;
          text += `‚îú Pontos: ${reputation}\n`;
          text += `‚îî Karma: ${karma}\n\n`;
          
          text += `üíé Use ${prefix}meustats para ver estat√≠sticas detalhadas`;
          
          return reply(text, mentions.length > 0 ? { mentions } : undefined);
        }
        
        if (sub === 'carteira') {
          const total = (me.wallet||0) + (me.bank||0);
          return reply(`‚ï≠‚îÅ‚îÅ‚îÅ‚ä± üë§ *PERFIL FINANCEIRO* üë§ ‚ä±‚îÅ‚îÅ‚îÅ‚ïÆ
‚îÇ
‚îÇ ÔøΩ *Carteira:* ${fmt(me.wallet)}
‚îÇ üè¶ *Banco:* ${fmt(me.bank)}
‚îÇ ÔøΩ *Total:* ${fmt(total)}
‚îÇ
‚îÇ üíº *Emprego:* ${me.job ? econ.jobCatalog[me.job]?.name || me.job : 'Desempregado(a)'}
‚îÇ
‚ï∞‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚ïØ`);
        }
        if (sub === 'banco') {
          const cap = isFinite(bankCapacity) ? bankCapacity : '‚àû';
          return reply(`‚ï≠‚îÅ‚îÅ‚îÅ‚ä± üè¶ *BANCO* üè¶ ‚ä±‚îÅ‚îÅ‚îÅ‚ïÆ
‚îÇ
‚îÇ üí∞ *Saldo:* ${fmt(me.bank)}
‚îÇ üì¶ *Capacidade:* ${cap === '‚àû' ? 'Ilimitada' : fmt(cap)}
‚îÇ
‚ï∞‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚ïØ`);
        }

        if (sub === 'depositar' || sub === 'dep') {
          const amount = parseAmount(q.split(' ')[0], me.wallet);
          if (!isFinite(amount) || amount <= 0) return reply('‚ùå Informe um valor v√°lido (ou "all").');
          if (amount > me.wallet) return reply('‚ùå Voc√™ n√£o tem tudo isso na carteira.');
          const cap = isFinite(bankCapacity) ? bankCapacity : Infinity;
          const space = cap - me.bank;
          if (space <= 0) return reply('‚ö†Ô∏è Seu banco est√° cheio. Compre um Cofre na loja para aumentar a capacidade.');
          const toDep = Math.min(amount, space);
          me.wallet -= toDep; me.bank += toDep;
          saveEconomy(econ);
          return reply(`‚ï≠‚îÅ‚îÅ‚îÅ‚ä± üí∞ *DEP√ìSITO* üí∞ ‚ä±‚îÅ‚îÅ‚îÅ‚ïÆ
‚îÇ
‚îÇ ‚úÖ Depositado: ${fmt(toDep)}
‚îÇ
‚îÇ üè¶ Banco: ${fmt(me.bank)}
‚îÇ üíº Carteira: ${fmt(me.wallet)}
‚îÇ
‚ï∞‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚ïØ`);
        }
        if (sub === 'sacar' || sub === 'saque') {
          const amount = parseAmount(q.split(' ')[0], me.bank);
          if (!isFinite(amount) || amount <= 0) return reply('‚ùå Informe um valor v√°lido (ou "all").');
          if (amount > me.bank) return reply('‚ùå Saldo insuficiente no banco.');
          // TAXA DE SAQUE: 5%
          const taxa = Math.floor(amount * 0.05);
          const received = amount - taxa;
          me.bank -= amount; 
          me.wallet += received;
          saveEconomy(econ);
          return reply(`‚ï≠‚îÅ‚îÅ‚îÅ‚ä± üí≥ *SAQUE* üí≥ ‚ä±‚îÅ‚îÅ‚îÅ‚ïÆ
‚îÇ
‚îÇ üí∞ Valor sacado: ${fmt(amount)}
‚îÇ üí∏ Taxa (5%): ${fmt(taxa)}
‚îÇ ‚úÖ Recebido: ${fmt(received)}
‚îÇ
‚îÇ üè¶ Banco: ${fmt(me.bank)}
‚îÇ üíº Carteira: ${fmt(me.wallet)}
‚îÇ
‚ï∞‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚ïØ`);
        }

        if (sub === 'transferir' || sub === 'pix') {
          if (!mentioned) return reply(`‚ï≠‚îÅ‚îÅ‚îÅ‚ä± üí∏ *TRANSFER√äNCIA* üí∏ ‚ä±‚îÅ‚îÅ‚îÅ‚ïÆ
‚îÇ
‚îÇ üë• Marque um usu√°rio e informe
‚îÇ    o valor a transferir
‚îÇ
‚îÇ ‚ö†Ô∏è *Taxa de transfer√™ncia: 15%*
‚îÇ
‚îÇ üìù *Exemplo:*
‚îÇ ${prefix}${sub} @user 100
‚îÇ
‚ï∞‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚ïØ`);
          const amount = parseAmount(args.slice(-1)[0], me.wallet);
          if (!isFinite(amount) || amount <= 0) return reply('‚ùå Informe um valor v√°lido.');
          // TAXA DE TRANSFER√äNCIA: 15%
          const taxa = Math.floor(amount * 0.15);
          const totalNeeded = amount + taxa;
          if (totalNeeded > me.wallet) return reply(`‚ùå Voc√™ n√£o tem saldo suficiente.\nüí∞ Valor: ${fmt(amount)}\nüí∏ Taxa (15%): ${fmt(taxa)}\nüìä Total necess√°rio: ${fmt(totalNeeded)}\nüíº Seu saldo: ${fmt(me.wallet)}`);
          const other = getEcoUser(econ, mentioned);
          if (mentioned === sender) return reply('‚ùå Voc√™ n√£o pode transferir para si mesmo.');
          me.wallet -= totalNeeded; // Desconta valor + taxa
          other.wallet += amount; // Destinat√°rio recebe valor sem taxa
          saveEconomy(econ);
          return reply(`‚ï≠‚îÅ‚îÅ‚îÅ‚ä± ‚úÖ *TRANSFER√äNCIA* ‚úÖ ‚ä±‚îÅ‚îÅ‚îÅ‚ïÆ
‚îÇ
‚îÇ üí∏ Transferido: ${fmt(amount)}
‚îÇ üí∞ Taxa (15%): ${fmt(taxa)}
‚îÇ üìä Total debitado: ${fmt(totalNeeded)}
‚îÇ üë§ Para: @${getUserName(mentioned)}
‚îÇ
‚ï∞‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚ïØ`, { mentions:[mentioned] });
        }

        if (sub === 'loja' || sub === 'lojarps') {
          const items = Object.entries(econ.shop||{});
          if (items.length === 0) return reply('‚ùå A loja est√° vazia no momento.');
          let text = '‚ï≠‚îÅ‚îÅ‚îÅ‚ä± üõçÔ∏è *LOJA DE ITENS* üõçÔ∏è ‚ä±‚îÅ‚îÅ‚îÅ‚ïÆ\n‚îÇ\n';
          for (const [k, it] of items) {
            text += `‚îÇ üîπ *${k}*\n‚îÇ   ${it.name} ‚Äî ${fmt(it.price)}\n‚îÇ\n`;
          }
          text += `‚ï∞‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚ïØ\n\nüí° Compre com: ${prefix}comprar <item>`;
          return reply(text);
        }
        if (sub === 'comprar' || sub === 'buy') {
          const rawKey = (args[0]||'');
          if (!rawKey) return reply(`‚ï≠‚îÅ‚îÅ‚îÅ‚ä± üõí *COMPRAR* üõí ‚ä±‚îÅ‚îÅ‚îÅ‚ïÆ
‚îÇ
‚îÇ ‚ùå Informe o item desejado
‚îÇ
‚îÇ üìù *Exemplo:*
‚îÇ ${prefix}comprar pickaxe_bronze
‚îÇ
‚îÇ üõçÔ∏è Ver loja: ${prefix}loja
‚îÇ
‚ï∞‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚ïØ`);
          // Normaliza a busca do item ignorando acentos e underscores
          const key = findKeyIgnoringAccents(econ.shop || {}, rawKey) || normalizeParam(rawKey).replace(/\s+/g, '_');
          const it = (econ.shop||{})[key];
          if (!it) return reply(`‚ùå Item n√£o encontrado.\n\nüõçÔ∏è Veja a loja com ${prefix}loja`);
          if (me.wallet < it.price) return reply('‚ùå Saldo insuficiente na carteira.');
          me.wallet -= it.price;
          // Se for ferramenta (picareta), equipa automaticamente
          if (it.type === 'tool' && it.toolType === 'pickaxe') {
            me.tools = me.tools || {};
            me.tools.pickaxe = { tier: it.tier, dur: it.durability, max: it.durability, key };
            saveEconomy(econ);
            return reply(`‚ï≠‚îÅ‚îÅ‚îÅ‚ä± ‚úÖ *COMPRA* ‚úÖ ‚ä±‚îÅ‚îÅ‚îÅ‚ïÆ
‚îÇ
‚îÇ üõ†Ô∏è Voc√™ comprou e equipou:
‚îÇ ${it.name}
‚îÇ
‚îÇ ‚öôÔ∏è Durabilidade: ${it.durability}
‚îÇ
‚ï∞‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚ïØ`);
          }
          // Caso contr√°rio, vai para o invent√°rio
          me.inventory[key] = (me.inventory[key]||0)+1;
          saveEconomy(econ);
          return reply(`‚ï≠‚îÅ‚îÅ‚îÅ‚ä± ‚úÖ *COMPRA* ‚úÖ ‚ä±‚îÅ‚îÅ‚îÅ‚ïÆ
‚îÇ
‚îÇ üéí Voc√™ comprou:
‚îÇ ${it.name}
‚îÇ
‚îÇ üí∞ Pre√ßo: ${fmt(it.price)}
‚îÇ
‚ï∞‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚ïØ`);
        }

        if (sub === 'inventario' || sub === 'inv') {
          const entries = Object.entries(me.inventory||{}).filter(([,q])=>q>0);
          let text = '‚ï≠‚îÅ‚îÅ‚îÅ‚ä± üéí *INVENT√ÅRIO* üéí ‚ä±‚îÅ‚îÅ‚îÅ‚ïÆ\n‚îÇ\n';
          if (entries.length>0) {
            for (const [k,q] of entries) {
              const it = (econ.shop||{})[k];
              text += `‚îÇ üì¶ ${it?.name || k} x${q}\n`;
            }
          } else {
            text += '‚îÇ üì≠ (vazio)\n';
          }
          text += '‚îÇ\n';
          // Ferramentas
          const pk = me.tools?.pickaxe;
          text += '‚ï†‚îÅ‚îÅ‚îÅ‚ä± üõ†Ô∏è *FERRAMENTAS* üõ†Ô∏è ‚ä±‚îÅ‚îÅ‚îÅ‚ï£\n‚îÇ\n';
          if (pk) {
            const tierName = pk.tier || 'desconhecida';
            const dur = pk.dur ?? 0; const max = pk.max ?? (pk.tier==='bronze'?20:pk.tier==='ferro'?60:pk.tier==='diamante'?150:0);
            text += `‚îÇ ‚õèÔ∏è Picareta ${tierName}\n‚îÇ    Durabilidade: ${dur}/${max}\n`;
          } else {
            text += '‚îÇ ‚õèÔ∏è Picareta ‚Äî nenhuma\n';
          }
          text += '‚îÇ\n‚ï∞‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚ïØ';
          return reply(text);
        }

        // Materiais e pre√ßos
        if (sub === 'materiais') {
          const mats = me.materials || {};
          const keys = Object.keys(mats).filter(k=>mats[k]>0);
          if (keys.length===0) return reply('‚ï≠‚îÅ‚îÅ‚îÅ‚ä± ‚õèÔ∏è *MATERIAIS* ‚õèÔ∏è ‚ä±‚îÅ‚îÅ‚îÅ‚ïÆ\n‚îÇ\n‚îÇ üì≠ Voc√™ n√£o possui materiais\n‚îÇ\n‚îÇ ‚õèÔ∏è Mine para coletar!\n‚îÇ Use: '+prefix+'minerar\n‚îÇ\n‚ï∞‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚ïØ');
          let text = '‚ï≠‚îÅ‚îÅ‚îÅ‚ä± ‚õèÔ∏è *MATERIAIS* ‚õèÔ∏è ‚ä±‚îÅ‚îÅ‚îÅ‚ïÆ\n‚îÇ\n';
          for (const k of keys) text += `‚îÇ üíé ${k}: ${mats[k]}\n`;
          text += '‚îÇ\n‚ï∞‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚ïØ';
          return reply(text);
        }
        if (sub === 'precos' || sub === 'pre√ßos') {
          const mp = econ.materialsPrices || {};
          let text = '‚ï≠‚îÅ‚îÅ‚îÅ‚ä± üí± *PRE√áOS* üí± ‚ä±‚îÅ‚îÅ‚îÅ‚ïÆ\n‚îÇ\n‚îÇ üíé *MATERIAIS (unidade)*\n‚îÇ\n';
          for (const [k,v] of Object.entries(mp)) text += `‚îÇ üî∏ ${k}: ${fmt(v)}\n`;
          // Receitas b√°sicas
          const r = econ.recipes || {};
          if (Object.keys(r).length>0) {
            text += '‚îÇ\n‚îÇ üìú *RECEITAS*\n‚îÇ\n';
            for (const [key,rec] of Object.entries(r)) {
              const shopItem = econ.shop?.[key];
              const name = shopItem?.name || key;
              const req = Object.entries(rec.requires||{}).map(([mk,mq])=>`${mk} x${mq}`).join(', ');
              text += `‚îÇ üî® ${name}\n‚îÇ    ${req} + ${fmt(rec.gold||0)}\n`;
            }
          }
          text += '‚îÇ\n‚ï∞‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚ïØ';
          return reply(text);
        }
        if (sub === 'vender') {
          const matKey = (args[0]||'').toLowerCase();
          if (!matKey) return reply(`‚ï≠‚îÅ‚îÅ‚îÅ‚ä± üí∞ *VENDER MATERIAIS* üí∞ ‚ä±‚îÅ‚îÅ‚îÅ‚ïÆ
‚îÇ
‚îÇ üìù *Uso:*
‚îÇ ${prefix}vender <material> <qtd|all>
‚îÇ
‚îÇ üí° *Exemplo:*
‚îÇ ${prefix}vender ferro 10
‚îÇ ${prefix}vender ouro all
‚îÇ
‚îÇ üí± Ver pre√ßos: ${prefix}precos
‚îÇ
‚ï∞‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚ïØ`);
          const price = (econ.materialsPrices||{})[matKey];
          if (!price) return reply(`‚ùå Material inv√°lido.\n\nüí± Veja pre√ßos com ${prefix}precos`);
          const have = me.materials?.[matKey] || 0;
          if (have<=0) return reply('‚ùå Voc√™ n√£o possui esse material.');
          const qtyArg = args[1]||'all';
          const qty = ['all','tudo','max'].includes((qtyArg||'').toLowerCase()) ? have : parseAmount(qtyArg, have);
          if (!isFinite(qty) || qty<=0) return reply('‚ùå Quantidade inv√°lida.');
          const gain = qty * price;
          me.materials[matKey] = have - qty;
          me.wallet += gain;
          saveEconomy(econ);
          return reply(`‚ï≠‚îÅ‚îÅ‚îÅ‚ä± ‚úÖ *VENDA* ‚úÖ ‚ä±‚îÅ‚îÅ‚îÅ‚ïÆ
‚îÇ
‚îÇ ÔøΩ Vendeu: ${qty}x ${matKey}
‚îÇ üí∞ Ganhou: ${fmt(gain)}
‚îÇ
‚ï∞‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚ïØ`);
        }
        if (sub === 'reparar') {
          const pk = getActivePickaxe(me) || me.tools?.pickaxe;
          if (!pk) return reply(`‚ï≠‚îÅ‚îÅ‚îÅ‚ä± üõ†Ô∏è *REPARAR* üõ†Ô∏è ‚ä±‚îÅ‚îÅ‚îÅ‚ïÆ
‚îÇ
‚îÇ ‚ùå Voc√™ n√£o tem picareta equipada
‚îÇ
‚îÇ üõçÔ∏è Compre uma: ${prefix}loja
‚îÇ
‚ï∞‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚ïØ`);
          const kits = me.inventory?.repairkit || 0;
          if (kits<=0) return reply(`‚ï≠‚îÅ‚îÅ‚îÅ‚ä± üîß *KIT DE REPAROS* üîß ‚ä±‚îÅ‚îÅ‚îÅ‚ïÆ
‚îÇ
‚îÇ ‚ùå Voc√™ n√£o tem Kit de Reparos
‚îÇ
‚îÇ üõí Compre com:
‚îÇ ${prefix}comprar repairkit
‚îÇ
‚ï∞‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚ïØ`);
          const repair = econ.shop?.repairkit?.effect?.repair || 40;
          const max = pk.max ?? (pk.tier==='bronze'?20:pk.tier==='ferro'?60:pk.tier==='diamante'?150:pk.dur);
          const before = pk.dur;
          pk.dur = Math.min(max, pk.dur + repair);
          me.inventory.repairkit = kits - 1;
          me.tools.pickaxe = { ...pk, max };
          saveEconomy(econ);
          return reply(`‚ï≠‚îÅ‚îÅ‚îÅ‚ä± üõ†Ô∏è *REPARADO!* üõ†Ô∏è ‚ä±‚îÅ‚îÅ‚îÅ‚ïÆ
‚îÇ
‚îÇ ‚õèÔ∏è Picareta reparada
‚îÇ üìä ${before} ‚ûú ${pk.dur}/${max}
‚îÇ
‚îÇ üîß Kits restantes: ${kits - 1}
‚îÇ
‚ï∞‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚ïØ`);
        }
        if (sub === 'desafio') {
          ensureUserChallenge(me);
          const ch = me.challenge;
          if ((args[0]||'').toLowerCase()==='coletar') {
            if (ch.claimed) return reply('‚ùå Voc√™ j√° coletou a recompensa de hoje.');
            if (!isChallengeCompleted(me)) return reply('‚ùå Complete todas as tarefas di√°rias para coletar.');
            me.wallet += ch.reward;
            ch.claimed = true;
            saveEconomy(econ);
            return reply(`‚ï≠‚îÅ‚îÅ‚îÅ‚ä± üéâ *RECOMPENSA!* üéâ ‚ä±‚îÅ‚îÅ‚îÅ‚ïÆ
‚îÇ
‚îÇ ‚úÖ Desafio di√°rio conclu√≠do!
‚îÇ üí∞ Recompensa: ${fmt(ch.reward)}
‚îÇ
‚ï∞‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚ïØ`);
          }
          const labels = {
            mine: 'Minera√ß√µes', work:'Trabalhos', fish:'Pescarias', explore:'Explora√ß√µes', hunt:'Ca√ßadas', crimeSuccess:'Crimes bem-sucedidos'
          };
          let text = '‚ï≠‚îÅ‚îÅ‚îÅ‚ä± üèÖ *DESAFIO DI√ÅRIO* üèÖ ‚ä±‚îÅ‚îÅ‚îÅ‚ïÆ\n‚îÇ\n';
          for (const t of ch.tasks||[]) {
            text += `‚îÇ üìã ${labels[t.type]||t.type}\n‚îÇ    ${t.progress||0}/${t.target}\n`;
          }
          text += `‚îÇ\n‚îÇ üéÅ Pr√™mio: ${fmt(ch.reward)}\n`;
          if (ch.claimed) text += `‚îÇ ‚úÖ (coletado)\n`;
          text += '‚îÇ\n‚ï∞‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚ïØ';
          if (isChallengeCompleted(me) && !ch.claimed) text += `\n\nüí° Use: ${prefix}desafio coletar`;
          return reply(text);
        }

        if (sub === 'apostar' || sub === 'bet') {
          const cdBet = me.cooldowns?.bet || 0;
          if (Date.now() < cdBet) return reply(`‚è≥ Aguarde ${timeLeft(cdBet)} para apostar novamente.`);
          const amount = parseAmount(args[0], me.wallet);
          if (!isFinite(amount) || amount <= 0) return reply('Valor inv√°lido.');
          if (amount > me.wallet) return reply('Saldo insuficiente.');
          // CASSINO NERFADO: 3% de chance de ganhar (era 47%)
          const win = Math.random() < 0.03;
          if (win) { 
            me.wallet += Math.floor(amount * 0.8); // ganha apenas 80% do apostado
            me.cooldowns.bet = Date.now() + 10*60*1000; // 10 minutos (era 3)
            saveEconomy(econ); 
            return reply(`‚ï≠‚îÄ‚îÄ‚îÄ‚äÉ‚ä± üçÄ *VIT√ìRIA RARA!* üçÄ ‚äÉ‚ä±‚îÄ‚îÄ‚îÄ‚ïÆ\n‚îÇ\n‚îÇ üí∞ Ganhou: *+${fmt(Math.floor(amount * 0.8))}*\n‚îÇ üé∞ Sorte incr√≠vel!\n‚îÇ\n‚ï∞‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚ïØ`); 
          }
          me.wallet -= amount; 
          me.cooldowns.bet = Date.now() + 10*60*1000; // 10 minutos (era 3)
          saveEconomy(econ); 
          return reply(`‚ï≠‚îÄ‚îÄ‚îÄ‚äÉ‚ä± üí• *PERDEU!* üí• ‚äÉ‚ä±‚îÄ‚îÄ‚îÄ‚ïÆ\n‚îÇ\n‚îÇ üí∏ Perdeu: *-${fmt(amount)}*\n‚îÇ üé∞ A casa sempre ganha...\n‚îÇ\n‚ï∞‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚ïØ`);
        }
        if (sub === 'slots') {
          const cdSlots = me.cooldowns?.slots || 0;
          if (Date.now() < cdSlots) return reply(`‚è≥ Aguarde ${timeLeft(cdSlots)} para jogar slots novamente.`);
          const amount = parseAmount(args[0]||'100', me.wallet);
          if (!isFinite(amount) || amount <= 0) return reply('Valor inv√°lido.');
          if (amount > me.wallet) return reply('Saldo insuficiente.');
          // SLOTS NERFADO: s√≠mbolos com pesos para quase nunca combinar
          const symbols = ['üçí','üçã','üçâ','‚≠ê','üîî','üçá','üçä','üçì']; // mais s√≠mbolos = menos chance
          // Cada slot √© independente e viciado para n√£o combinar
          const getSlot = (idx) => {
            // Cada posi√ß√£o tem prefer√™ncia por s√≠mbolos diferentes
            const weights = [30, 20, 15, 12, 10, 6, 4, 3];
            const shifted = [...weights.slice(idx * 2), ...weights.slice(0, idx * 2)];
            const total = shifted.reduce((a,b) => a+b, 0);
            let rand = Math.random() * total;
            for (let i = 0; i < symbols.length; i++) {
              rand -= shifted[i];
              if (rand <= 0) return symbols[i];
            }
            return symbols[0];
          };
          const r = [getSlot(0), getSlot(1), getSlot(2)];
          let mult = 0;
          // Jackpot quase imposs√≠vel (~0.5% real)
          if (r[0]===r[1] && r[1]===r[2]) mult = 2; // multiplicador reduzido (era 3)
          else if (r[0]===r[1] || r[1]===r[2] || r[0]===r[2]) mult = 1.2; // par paga menos (era 1.5)
          const delta = Math.floor(amount * (mult-1));
          me.wallet += delta; // delta pode ser negativo
          saveEconomy(econ);
          me.cooldowns.slots = Date.now() + 8*60*1000; // 8 minutos (era 2)
          
          let slotText = `‚ï≠‚îÅ‚îÅ‚îÅ‚ä± üé∞ *SLOTS* üé∞ ‚ä±‚îÅ‚îÅ‚îÅ‚ïÆ\n`;
          slotText += `‚îÇ\n`;
          slotText += `‚îÇ ${r.join(' | ')}\n`;
          slotText += `‚îÇ\n`;
          slotText += `‚ï∞‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚ïØ\n\n`;
          
          if (mult > 1) {
            slotText += `‚ï≠‚îÅ‚îÅ‚îÅ‚ä± üéâ *GANHOU!* üéâ ‚ä±‚îÅ‚îÅ‚îÅ‚ïÆ\n`;
            slotText += `‚îÇ\n`;
            slotText += `‚îÇ üí∞ Ganhou: *+${fmt(Math.floor(amount*(mult-1)))}*\n`;
            slotText += `‚îÇ\n`;
            slotText += `‚ï∞‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚ïØ`;
          } else {
            slotText += `‚ï≠‚îÅ‚îÅ‚îÅ‚ä± üí∏ *PERDEU!* üí∏ ‚ä±‚îÅ‚îÅ‚îÅ‚ïÆ\n`;
            slotText += `‚îÇ\n`;
            slotText += `‚îÇ üíî Perdeu: *-${fmt(amount)}*\n`;
            slotText += `‚îÇ\n`;
            slotText += `‚ï∞‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚ïØ`;
          }
          
          return reply(slotText);
        }

        if (sub === 'vagas') {
          let jobs = econ.jobCatalog || {};
          // Se n√£o houver vagas no arquivo de economia, usar cat√°logo padr√£o embutido
          if (!jobs || Object.keys(jobs).length === 0) {
            jobs = {
              "estagiario": { name: "Estagi√°rio", min: 80, max: 140 },
              "designer": { name: "Designer", min: 150, max: 250 },
              "programador": { name: "Programador", min: 200, max: 350 },
              "gerente": { name: "Gerente", min: 260, max: 420 }
            };
          }

          let txt = '‚ï≠‚îÅ‚îÅ‚îÅ‚ä± üíº *VAGAS DE EMPREGO* üíº ‚ä±‚îÅ‚îÅ‚îÅ‚ïÆ\n‚îÇ\n';
          Object.entries(jobs).forEach(([k, j]) => {
            txt += `‚îÇ üîπ *${k}*\n‚îÇ   ${j.name}\n‚îÇ   üí∞ ${fmt(j.min)}-${fmt(j.max)}\n‚îÇ\n`;
          });
          txt += `‚ï∞‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚ïØ\n\nüí° Use: ${prefix}emprego <vaga>`;
          return reply(txt);
        }
        if (sub === 'emprego') {
          const rawKey = (args[0]||'');
          if (!rawKey) return reply(`‚ï≠‚îÅ‚îÅ‚îÅ‚ä± üíº *EMPREGO* üíº ‚ä±‚îÅ‚îÅ‚îÅ‚ïÆ
‚îÇ
‚îÇ ‚ùå Informe a vaga desejada
‚îÇ
‚îÇ üìã Ver vagas: ${prefix}vagas
‚îÇ
‚îÇ üí° Exemplo:
‚îÇ ${prefix}emprego vendedor
‚îÇ
‚ï∞‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚ïØ`);

          const defaultJobs = {
            "estagiario": { name: "Estagi√°rio", min: 80, max: 140 },
            "designer": { name: "Designer", min: 150, max: 250 },
            "programador": { name: "Programador", min: 200, max: 350 },
            "gerente": { name: "Gerente", min: 260, max: 420 }
          };

          const jobCatalog = (econ.jobCatalog && Object.keys(econ.jobCatalog).length) ? econ.jobCatalog : defaultJobs;
          // Normaliza a busca da vaga ignorando acentos
          const key = findKeyIgnoringAccents(jobCatalog, rawKey) || normalizeParam(rawKey);
          const job = jobCatalog[key];
          if (!job) return reply('‚ùå Vaga inexistente. Use ' + prefix + 'vagas para ver dispon√≠veis.');

          // If economy file had no jobCatalog, persist defaults so future queries find them
          if (!econ.jobCatalog || Object.keys(econ.jobCatalog).length === 0) {
            econ.jobCatalog = jobCatalog;
          }

          me.job = key;
          saveEconomy(econ);
          return reply(`‚ï≠‚îÅ‚îÅ‚îÅ‚ä± ‚úÖ *CONTRATADO!* ‚úÖ ‚ä±‚îÅ‚îÅ‚îÅ‚ïÆ
‚îÇ
‚îÇ üíº Emprego: ${job.name}
‚îÇ üí∞ Ganhos: ${fmt(job.min)}-${fmt(job.max)}
‚îÇ
‚îÇ üè¢ Use ${prefix}trabalhar
‚îÇ    para receber seu sal√°rio!
‚îÇ
‚ï∞‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚ïØ`);
        }
        if (sub === 'demitir') { 
          me.job = null; 
          saveEconomy(econ); 
          return reply(`‚ï≠‚îÅ‚îÅ‚îÅ‚ä± üëã *DEMISS√ÉO* üëã ‚ä±‚îÅ‚îÅ‚îÅ‚ïÆ
‚îÇ
‚îÇ ‚úÖ Voc√™ pediu demiss√£o
‚îÇ
‚îÇ üíº Veja novas vagas: ${prefix}vagas
‚îÇ
‚ï∞‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚ïØ`); 
        }

        if (sub === 'pescar' || sub === 'fish') {
          const cd = me.cooldowns?.fish || 0; if (Date.now()<cd) return reply(`‚è≥ Aguarde ${timeLeft(cd)} para pescar novamente.`);
          const base = 80 + Math.floor(Math.random()*121); // 80-200 (BALANCEADO)
          const skillB = getSkillBonus(me,'fishing');
          const bonus = Math.floor(base * ((fishBonus||0) + skillB)); const total = base + bonus;
          me.wallet += total; me.cooldowns.fish = Date.now() + 12*60*1000; // 12 min
          addSkillXP(me,'fishing',1); updateChallenge(me,'fish',1,true); updatePeriodChallenge(me,'fish',1,true);
          
          // Adiciona peixe como ingrediente
          me.ingredients = me.ingredients || {};
          const fishQty = 2 + Math.floor(Math.random()*3); // 2-4 peixes
          me.ingredients.peixe = (me.ingredients.peixe || 0) + fishQty;
          
          // Rastrear stats
          if (!me.stats) me.stats = {};
          me.stats.totalFish = (me.stats.totalFish || 0) + 1;
          me.stats.fishCount = (me.stats.fishCount || 0) + 1;
          
          saveEconomy(econ);
          
          let fishText = `‚ï≠‚îÅ‚îÅ‚îÅ‚ä± üé£ *PESCOU!* üé£ ‚ä±‚îÅ‚îÅ‚îÅ‚ïÆ\n`;
          fishText += `‚îÇ\n`;
          fishText += `‚îÇ üí∞ Ganhou: *${fmt(total)}*\n`;
          if (bonus > 0) {
            fishText += `‚îÇ ‚ú® B√¥nus: *+${fmt(bonus)}*\n`;
          }
          fishText += `‚îÇ üêü Peixe: *+${fishQty}*\n`;
          fishText += `‚îÇ\n`;
          fishText += `‚ï∞‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚ïØ`;
          
          return reply(fishText);
        }

        if (sub === 'explorar' || sub === 'explore') {
          const cd = me.cooldowns?.explore || 0; 
          if (Date.now()<cd) return reply(`‚è≥ Aguarde ${timeLeft(cd)} para explorar novamente.`);
          const base = 100 + Math.floor(Math.random()*151); // 100-250 (BALANCEADO)
          const skillB = getSkillBonus(me,'exploring');
          const bonus = Math.floor(base * ((exploreBonus||0) + skillB));
          const total = base + bonus;
          me.wallet += total; 
          me.cooldowns.explore = Date.now() + 15*60*1000; // 15 min
          addSkillXP(me,'exploring',1); 
          updateChallenge(me,'explore',1,true); 
          updatePeriodChallenge(me,'explore',1,true);
          // Rastrear stats
          if (!me.stats) me.stats = {};
          me.stats.totalExplore = (me.stats.totalExplore || 0) + 1;
          me.stats.exploreCount = (me.stats.exploreCount || 0) + 1;
          
          // Adiciona materiais da explora√ß√£o
          const matsGain = {};
          if (Math.random() < 0.6) matsGain.madeira = 1 + Math.floor(Math.random() * 3); // 60% chance, 1-3 madeira
          if (Math.random() < 0.3) matsGain.corda = 1; // 30% chance, 1 corda
          if (Math.random() < 0.4) matsGain.linha = 1 + Math.floor(Math.random() * 2); // 40% chance, 1-2 linha
          if (Math.random() < 0.2) matsGain.cristal = 1; // 20% chance, 1 cristal (raro)
          
          for (const [mk,mq] of Object.entries(matsGain)) giveMaterial(me, mk, mq);
          
          saveEconomy(econ);
          
          let exploreText = `‚ï≠‚îÅ‚îÅ‚îÅ‚ä± üß≠ *EXPLOROU!* üß≠ ‚ä±‚îÅ‚îÅ‚îÅ‚ïÆ\n`;
          exploreText += `‚îÇ\n`;
          exploreText += `‚îÇ üí∞ Ganhou: *${fmt(total)}*\n`;
          if (bonus > 0) {
            exploreText += `‚îÇ ‚ú® B√¥nus: *+${fmt(bonus)}*\n`;
          }
          if (Object.keys(matsGain).length > 0) {
            exploreText += `‚îÇ üì¶ Materiais: ` + Object.entries(matsGain).map(([k,q])=>`${k} x${q}`).join(', ') + `\n`;
          }
          exploreText += `‚îÇ\n`;
          exploreText += `‚ï∞‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚ïØ`;
          
          return reply(exploreText);
        }

        if (sub === 'cacar' || sub === 'ca√ßar' || sub === 'hunt') {
          const cd = me.cooldowns?.hunt || 0; if (Date.now()<cd) return reply(`‚è≥ Aguarde ${timeLeft(cd)} para ca√ßar novamente.`);
          const base = 22 + Math.floor(Math.random()*34); // 22-55 (era 45-120)
          const skillB = getSkillBonus(me,'hunting');
          const bonus = Math.floor(base * ((huntBonus||0) + skillB) * 0.4); const total = base + bonus; // b√¥nus reduzido 60%
          me.wallet += total; me.cooldowns.hunt = Date.now() + 22*60*1000; // 22 min (era 6 min)
          addSkillXP(me,'hunting',1); updateChallenge(me,'hunt',1,true); updatePeriodChallenge(me,'hunt',1,true);
          
          // Adiciona carne como ingrediente
          me.ingredients = me.ingredients || {};
          const meatQty = 1 + (Math.random() < 0.25 ? 1 : 0); // 1-2 carnes (25% chance de pegar 2)
          me.ingredients.carne = (me.ingredients.carne || 0) + meatQty;
          
          // Adiciona materiais da ca√ßa
          const huntMats = {};
          if (Math.random() < 0.5) huntMats.couro = 1 + Math.floor(Math.random() * 2); // 50% chance, 1-2 couro
          
          for (const [mk,mq] of Object.entries(huntMats)) giveMaterial(me, mk, mq);
          
          saveEconomy(econ);
          
          let huntText = `‚ï≠‚îÅ‚îÅ‚îÅ‚ä± üèπ *CA√áOU!* üèπ ‚ä±‚îÅ‚îÅ‚îÅ‚ïÆ\n`;
          huntText += `‚îÇ\n`;
          huntText += `‚îÇ üí∞ Ganhou: *${fmt(total)}*\n`;
          if (bonus > 0) {
            huntText += `‚îÇ ‚ú® B√¥nus: *+${fmt(bonus)}*\n`;
          }
          huntText += `‚îÇ ü•© Carne: *+${meatQty}*\n`;
          if (Object.keys(huntMats).length > 0) {
            huntText += `‚îÇ üì¶ Materiais: ` + Object.entries(huntMats).map(([k,q])=>`${k} x${q}`).join(', ') + `\n`;
          }
          huntText += `‚îÇ\n`;
          huntText += `‚ï∞‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚ïØ`;
          
          return reply(huntText);
        }

        if (sub === 'forjar' || sub === 'forge') {
          if (!me.materials) me.materials = {};
          if (!me.inventory) me.inventory = {};
          // Mostra receitas dispon√≠veis se n√£o especificar item
          const rawCraftKey = (args[0]||'');
          if (!rawCraftKey) {
            let text = `‚ï≠‚îÅ‚îÅ‚îÅ‚ä± ‚öíÔ∏è *RECEITAS DE FORJA* ‚ä±‚îÅ‚îÅ‚îÅ‚ïÆ\n`;
            text += `‚îÇ üí∞ Seu gold: ${fmt(me.wallet)}\n`;
            text += `‚ï∞‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚ïØ\n\n`;
            
            const recipes = econ.recipes || {};
            if (Object.keys(recipes).length === 0) {
              text += `‚ùå Nenhuma receita dispon√≠vel no momento.`;
            } else {
              text += `üìú *RECEITAS DISPON√çVEIS*\n\n`;
              for (const [key, recipe] of Object.entries(recipes)) {
                const item = econ.shop[key];
                if (!item) continue;
                
                text += `üî∏ *${item.name || key}*\n`;
                text += `   üí∞ Custo: ${fmt(recipe.gold || 0)}\n`;
                
                if (recipe.requires && Object.keys(recipe.requires).length > 0) {
                  const materials = Object.entries(recipe.requires).map(([mat, qty]) => `${mat} x${qty}`).join(', ');
                  text += `   üì¶ Materiais: ${materials}\n`;
                }
                text += `   üí° Forjar: ${prefix}forjar ${key}\n\n`;
              }
            }
            
            text += `üí° *Dica:* Use ${prefix}materiais para ver seus materiais dispon√≠veis`;
            return reply(text);
          }
          
          // Modo 1: craft a partir de receitas
          // Normaliza o nome da receita ignorando acentos
          const craftKey = findKeyIgnoringAccents(econ.recipes || {}, rawCraftKey) || normalizeParam(rawCraftKey);
          if (craftKey && (econ.recipes||{})[craftKey]) {
            const rec = econ.recipes[craftKey];
            const reqs = rec.requires || {};
            // Verifica materiais
            for (const [mk,mq] of Object.entries(reqs)) {
              if ((me.materials?.[mk]||0) < mq) return reply(`Faltam materiais: ${mk} x${mq}. Veja ${prefix}materiais.`);
            }
            // Verifica gold
            const goldCost = rec.gold || 0;
            if (me.wallet < goldCost) return reply(`Voc√™ precisa de ${fmt(goldCost)} para forjar.`);
            // Consome
            for (const [mk,mq] of Object.entries(reqs)) { me.materials[mk] -= mq; }
            me.wallet -= goldCost;
            const item = (econ.shop||{})[craftKey];
            if (item?.type==='tool' && item.toolType==='pickaxe') {
              me.tools.pickaxe = { tier: item.tier, dur: item.durability, max: item.durability, key: craftKey };
              saveEconomy(econ);
              return reply(`‚öíÔ∏è Voc√™ forjou e equipou ${item.name}! Durabilidade ${item.durability}.`);
            }
            // Sen√£o, adiciona ao invent√°rio
            me.inventory[craftKey] = (me.inventory[craftKey]||0)+1;
            saveEconomy(econ);
            return reply(`‚öíÔ∏è Voc√™ forjou ${item?.name||craftKey}!`);
          }
          // Modo 2: minigame de forja (antigo) - NERFADO
          const cd = me.cooldowns?.forge || 0; if (Date.now()<cd) return reply(`‚è≥ Aguarde ${timeLeft(cd)} para forjar novamente.`);
          const cost = 150; if (me.wallet < cost) return reply(`Voc√™ precisa de ${fmt(cost)} para materiais.`); // custo aumentado (era 100)
          me.wallet -= cost;
          const success = Math.random()<0.35; // 35% chance (era 60%)
          if (success) {
            const gain = 80 + Math.floor(Math.random()*101); // 80-180 (era 180-400)
            const bonus = Math.floor(gain * (forgeBonus||0) * 0.5); const total = gain + bonus; // b√¥nus reduzido
            me.wallet += total; me.cooldowns.forge = Date.now()+25*60*1000; saveEconomy(econ); // 25 min (era 6 min)
            return reply(`‚öíÔ∏è Forja bem-sucedida! Lucro ${fmt(total)} ${bonus>0?`(b√¥nus ${fmt(bonus)})`:''}.`);
          } else {
            me.cooldowns.forge = Date.now()+25*60*1000; saveEconomy(econ); // 25 min (era 6 min)
            return reply(`üî• A forja falhou e os materiais foram perdidos.`);
          }
        }

    if (sub === 'crime') {
          const cd = me.cooldowns?.crime || 0; 
          if (Date.now()<cd) return reply(`‚è≥ Aguarde ${timeLeft(cd)} para tentar de novo.`);
          const success = Math.random() < 0.18; // 18% sucesso (era 35%)
          if (success) {
            const base = 40 + Math.floor(Math.random()*61); // 40-100 (era 90-230)
            const skillB = getSkillBonus(me,'crime');
            const gain = Math.floor(base * (1 + skillB * 0.3)); // skill b√¥nus reduzido
            me.wallet += gain; 
            me.cooldowns.crime = Date.now()+30*60*1000; // 30 min
            addSkillXP(me,'crime',1); 
            updateChallenge(me,'crimeSuccess',1,true); 
            updatePeriodChallenge(me,'crimeSuccess',1,true);
            // Rastrear stats
            if (!me.stats) me.stats = {};
            me.stats.totalCrimes = (me.stats.totalCrimes || 0) + 1;
            saveEconomy(econ);
            return reply(`‚ï≠‚îÅ‚îÅ‚îÅ‚ä± üïµÔ∏è *CRIME* üïµÔ∏è ‚ä±‚îÅ‚îÅ‚îÅ‚ïÆ
‚îÇ
‚îÇ ‚úÖ Crime bem-sucedido!
‚îÇ üí∞ Lucrou: ${fmt(gain)}
‚îÇ
‚îÇ ‚ö†Ô∏è Cuidado para n√£o ser pego!
‚îÇ
‚ï∞‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚ïØ`);
          } else {
            const fine = 200 + Math.floor(Math.random()*401); // multa maior: 200-600 (era 120-320)
            const pay = Math.min(me.wallet, fine); 
            me.wallet -= pay; 
            me.cooldowns.crime = Date.now()+30*60*1000; // 30 min (era 10 min)
            saveEconomy(econ);
            return reply(`‚ï≠‚îÅ‚îÅ‚îÅ‚ä± üöî *PEGO!* üöî ‚ä±‚îÅ‚îÅ‚îÅ‚ïÆ
‚îÇ
‚îÇ ‚ùå Voc√™ foi pego pela pol√≠cia!
‚îÇ üí∏ Multa: ${fmt(pay)}
‚îÇ
‚ï∞‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚ïØ`);
          }
        }

        // ===== SISTEMA DE COZINHAR =====
        if (sub === 'receitas') {
          // Inicializa receitas culin√°rias se n√£o existir
          if (!econ.cookingRecipes) {
            econ.cookingRecipes = {
              pao: { name: 'üçû P√£o', requires: { trigo: 3 }, gold: 10, sellPrice: 50, energy: 10 },
              sopa: { name: 'üç≤ Sopa', requires: { cenoura: 2, batata: 2 }, gold: 15, sellPrice: 80, energy: 20 },
              salada: { name: 'ü•ó Salada', requires: { alface: 2, tomate: 2 }, gold: 12, sellPrice: 60, energy: 15 },
              bolo: { name: 'üç∞ Bolo', requires: { trigo: 5, ovo: 3 }, gold: 25, sellPrice: 120, energy: 30 },
              pizza: { name: 'üçï Pizza', requires: { trigo: 4, tomate: 3, queijo: 2 }, gold: 35, sellPrice: 150, energy: 40 },
              hamburguer: { name: 'üçî Hamb√∫rguer', requires: { carne: 2, trigo: 3, alface: 1 }, gold: 40, sellPrice: 180, energy: 50 },
              sushi: { name: 'üç£ Sushi', requires: { peixe: 4, arroz: 3 }, gold: 50, sellPrice: 200, energy: 45 },
              macarrao: { name: 'üçù Macarr√£o', requires: { trigo: 3, tomate: 2 }, gold: 20, sellPrice: 90, energy: 25 }
            };
            saveEconomy(econ);
          }

          let text = 'üìñ *RECEITAS CULIN√ÅRIAS*\n\n';
          for (const [key, rec] of Object.entries(econ.cookingRecipes)) {
            const ingredients = Object.entries(rec.requires).map(([ing, qty]) => `${ing} x${qty}`).join(', ');
            text += `${rec.name}\n`;
            text += `  üì¶ Ingredientes: ${ingredients}\n`;
            text += `  üí∞ Custo: ${fmt(rec.gold)}\n`;
            text += `  üíµ Venda: ${fmt(rec.sellPrice)}\n`;
            text += `  ‚ö° Energia: +${rec.energy}\n`;
            text += `  üç≥ Cozinhar: ${prefix}cozinhar ${key}\n\n`;
          }
          text += `üí° *Dica:* Plante ingredientes com ${prefix}plantar`;
          return reply(text);
        }

        if (sub === 'cozinhar' || sub === 'cook') {
          const recipeKey = (args[0] || '').toLowerCase();
          
          // Inicializa receitas se n√£o existir
          if (!econ.cookingRecipes) {
            econ.cookingRecipes = {
              pao: { name: 'üçû P√£o', requires: { trigo: 3 }, gold: 10, sellPrice: 50, energy: 10 },
              sopa: { name: 'üç≤ Sopa', requires: { cenoura: 2, batata: 2 }, gold: 15, sellPrice: 80, energy: 20 },
              salada: { name: 'ü•ó Salada', requires: { alface: 2, tomate: 2 }, gold: 12, sellPrice: 60, energy: 15 },
              bolo: { name: 'üç∞ Bolo', requires: { trigo: 5, ovo: 3 }, gold: 25, sellPrice: 120, energy: 30 },
              pizza: { name: 'üçï Pizza', requires: { trigo: 4, tomate: 3, queijo: 2 }, gold: 35, sellPrice: 150, energy: 40 },
              hamburguer: { name: 'üçî Hamb√∫rguer', requires: { carne: 2, trigo: 3, alface: 1 }, gold: 40, sellPrice: 180, energy: 50 },
              sushi: { name: 'üç£ Sushi', requires: { peixe: 4, arroz: 3 }, gold: 50, sellPrice: 200, energy: 45 },
              macarrao: { name: 'üçù Macarr√£o', requires: { trigo: 3, tomate: 2 }, gold: 20, sellPrice: 90, energy: 25 }
            };
          }

          if (!recipeKey) {
            return reply(`üë®‚Äçüç≥ *SISTEMA DE COZINHA*\n\nüìñ Veja as receitas dispon√≠veis: ${prefix}receitas\nüç≥ Cozinhar: ${prefix}cozinhar <receita>\n\nüí° Exemplo: ${prefix}cozinhar pao`);
          }

          const recipe = econ.cookingRecipes[recipeKey];
          if (!recipe) {
            return reply(`‚ùå Receita n√£o encontrada! Use ${prefix}receitas para ver todas as receitas dispon√≠veis.`);
          }

          // Verifica cooldown
          const cd = me.cooldowns?.cook || 0;
          if (Date.now() < cd) {
            return reply(`‚è≥ Voc√™ ainda est√° cozinhando! Aguarde ${timeLeft(cd)}.`);
          }

          // Verifica gold
          if (me.wallet < recipe.gold) {
            return reply(`üí∞ Voc√™ precisa de ${fmt(recipe.gold)} para cozinhar ${recipe.name}. Saldo atual: ${fmt(me.wallet)}`);
          }

          // Verifica ingredientes
          me.ingredients = me.ingredients || {};
          for (const [ing, qty] of Object.entries(recipe.requires)) {
            if ((me.ingredients[ing] || 0) < qty) {
              return reply(`üì¶ Ingredientes insuficientes! Voc√™ precisa de ${ing} x${qty}, mas tem apenas x${me.ingredients[ing] || 0}.\n\nüå± Plante ingredientes com ${prefix}plantar`);
            }
          }

          // Consome recursos
          me.wallet -= recipe.gold;
          for (const [ing, qty] of Object.entries(recipe.requires)) {
            me.ingredients[ing] -= qty;
          }

          // Adiciona comida ao invent√°rio
          me.cookedFood = me.cookedFood || {};
          me.cookedFood[recipeKey] = (me.cookedFood[recipeKey] || 0) + 1;

          // Skill e desafios
          addSkillXP(me, 'cooking', 2);
          updateChallenge(me, 'cook', 1, true);
          updatePeriodChallenge(me, 'cook', 1, true);
          
          // Atualiza progresso de miss√µes di√°rias
          updateQuestProgress(me, 'cook', 1);

          // Cooldown de 3 minutos
          me.cooldowns.cook = Date.now() + 3 * 60 * 1000;
          
          saveEconomy(econ);

          return reply(`üë®‚Äçüç≥ *COZINHA CONCLU√çDA!*\n\n${recipe.name} preparado com sucesso!\n‚ö° Energia: +${recipe.energy}\nüíµ Valor de venda: ${fmt(recipe.sellPrice)}\n\nüç¥ Use ${prefix}comer ${recipeKey} para consumir\nüí∞ Use ${prefix}vendercomida ${recipeKey} para vender`);
        }

        // ===== SISTEMA DE PLANTA√á√ÉO =====
        if (sub === 'plantacao' || sub === 'planta√ß√£o' || sub === 'horta') {
          me.farm = me.farm || { plots: [], maxPlots: 4, lastExpansion: 0 };
          
          const now = Date.now();
          let text = 'üåæ *MINHA PLANTA√á√ÉO*\n\n';
          text += `üìä Terrenos: ${me.farm.plots.length}/${me.farm.maxPlots}\n\n`;

          if (me.farm.plots.length === 0) {
            text += 'üå± Sua planta√ß√£o est√° vazia!\n\n';
          } else {
            me.farm.plots.forEach((plot, idx) => {
              const timeLeft = plot.readyAt - now;
              const isReady = timeLeft <= 0;
              const seed = econ.seeds?.[plot.seed] || { name: plot.seed, growTime: 600000, yield: { [plot.seed]: 1 } };
              
              text += `üå± *Terreno ${idx + 1}*\n`;
              text += `  Semente: ${seed.name}\n`;
              if (isReady) {
                text += `  ‚úÖ Pronto para colher!\n`;
              } else {
                const mins = Math.ceil(timeLeft / 60000);
                text += `  ‚è≥ Pronto em: ${mins} min\n`;
              }
              text += `\n`;
            });
          }

          text += `\nüí° *Comandos:*\n`;
          text += `üå± Plantar: ${prefix}plantar <semente>\n`;
          text += `üåæ Colher: ${prefix}colher\n`;
          text += `üì¶ Sementes: ${prefix}sementes\n`;

          return reply(text);
        }

        if (sub === 'plantar' || sub === 'plant' || sub === 'farm') {
          const seedKey = (args[0] || '').toLowerCase();
          
          // Inicializa sistema de sementes
          if (!econ.seeds) {
            econ.seeds = {
              trigo: { name: 'üåæ Trigo', cost: 20, growTime: 5 * 60 * 1000, yield: { trigo: 3 } },
              cenoura: { name: 'ü•ï Cenoura', cost: 15, growTime: 4 * 60 * 1000, yield: { cenoura: 2 } },
              batata: { name: 'ü•î Batata', cost: 15, growTime: 4 * 60 * 1000, yield: { batata: 2 } },
              tomate: { name: 'üçÖ Tomate', cost: 18, growTime: 6 * 60 * 1000, yield: { tomate: 3 } },
              alface: { name: 'ü•¨ Alface', cost: 12, growTime: 3 * 60 * 1000, yield: { alface: 2 } },
              milho: { name: 'üåΩ Milho', cost: 25, growTime: 7 * 60 * 1000, yield: { milho: 4 } },
              arroz: { name: 'üåæ Arroz', cost: 22, growTime: 8 * 60 * 1000, yield: { arroz: 4 } },
              cana: { name: 'üåø Cana-de-a√ß√∫car', cost: 30, growTime: 10 * 60 * 1000, yield: { acucar: 5 } },
              galinha: { name: 'üêî Galinha', cost: 35, growTime: 15 * 60 * 1000, yield: { ovo: 2 } },
              vaca: { name: 'üêÑ Vaca', cost: 50, growTime: 20 * 60 * 1000, yield: { queijo: 3 } }
            };
            saveEconomy(econ);
          }

          if (!seedKey) {
            let text = 'üå± *SISTEMA DE PLANTA√á√ÉO*\n\n';
            text += 'üì¶ *Sementes Dispon√≠veis:*\n\n';
            for (const [key, seed] of Object.entries(econ.seeds)) {
              const mins = Math.floor(seed.growTime / 60000);
              const yieldText = Object.entries(seed.yield).map(([k, v]) => `${k} x${v}`).join(', ');
              text += `${seed.name}\n`;
              text += `  üí∞ Custo: ${fmt(seed.cost)}\n`;
              text += `  ‚è±Ô∏è Tempo: ${mins} min\n`;
              text += `  üåæ Colheita: ${yieldText}\n\n`;
            }
            text += `üå± Plantar: ${prefix}plantar <semente>\n`;
            text += `üí° Exemplo: ${prefix}plantar trigo`;
            return reply(text);
          }

          const seed = econ.seeds[seedKey];
          if (!seed) {
            return reply(`‚ùå Semente n√£o encontrada! Use ${prefix}plantar para ver as sementes dispon√≠veis.`);
          }

          // Inicializa fazenda do usu√°rio
          me.farm = me.farm || { plots: [], maxPlots: 4, lastExpansion: 0 };

          // Verifica se tem espa√ßo
          if (me.farm.plots.length >= me.farm.maxPlots) {
            return reply(`üåæ Todos os seus terrenos est√£o ocupados! Aguarde a colheita ou expanda sua fazenda.\n\nüåæ Use ${prefix}colher para colher plantas prontas`);
          }

          // Verifica gold
          if (me.wallet < seed.cost) {
            return reply(`üí∞ Voc√™ precisa de ${fmt(seed.cost)} para plantar ${seed.name}. Saldo: ${fmt(me.wallet)}`);
          }

          // Planta
          me.wallet -= seed.cost;
          const now = Date.now();
          me.farm.plots.push({
            seed: seedKey,
            plantedAt: now,
            readyAt: now + seed.growTime
          });

          // Skill
          addSkillXP(me, 'farming', 1);
          updateChallenge(me, 'plant', 1, true);
          updatePeriodChallenge(me, 'plant', 1, true);

          saveEconomy(econ);

          const mins = Math.floor(seed.growTime / 60000);
          return reply(`üå± ${seed.name} plantado com sucesso!\n\n‚è±Ô∏è Estar√° pronto para colher em ${mins} minutos.\nüåæ Terrenos ocupados: ${me.farm.plots.length}/${me.farm.maxPlots}\n\nüí° Use ${prefix}horta para ver suas planta√ß√µes`);
        }

        if (sub === 'colher' || sub === 'harvest') {
          me.farm = me.farm || { plots: [], maxPlots: 4, lastExpansion: 0 };

          if (me.farm.plots.length === 0) {
            return reply(`üåæ Voc√™ n√£o tem nada plantado!\n\nüå± Use ${prefix}plantar <semente> para come√ßar a cultivar.`);
          }

          const now = Date.now();
          const readyPlots = me.farm.plots.filter(plot => plot.readyAt <= now);

          if (readyPlots.length === 0) {
            const nextReady = Math.min(...me.farm.plots.map(p => p.readyAt));
            const timeLeft = Math.ceil((nextReady - now) / 60000);
            return reply(`‚è≥ Nenhuma planta est√° pronta para colher ainda.\n\nüïê Pr√≥xima colheita em: ${timeLeft} minuto(s)\n\nüí° Use ${prefix}horta para ver o status de todas as planta√ß√µes`);
          }

          // Colhe todas as plantas prontas
          me.ingredients = me.ingredients || {};
          let harvestedText = '';
          let totalValue = 0;

          readyPlots.forEach(plot => {
            const seed = econ.seeds?.[plot.seed];
            if (seed && seed.yield) {
              for (const [ingredient, qty] of Object.entries(seed.yield)) {
                me.ingredients[ingredient] = (me.ingredients[ingredient] || 0) + qty;
                harvestedText += `${ingredient} x${qty}, `;
                totalValue += qty * 10; // Valor estimado
              }
            }
          });

          // Remove plantas colhidas
          me.farm.plots = me.farm.plots.filter(plot => plot.readyAt > now);

          // Skill e desafios
          addSkillXP(me, 'farming', readyPlots.length * 2);
          updateChallenge(me, 'harvest', readyPlots.length, true);
          updatePeriodChallenge(me, 'harvest', readyPlots.length, true);
          
          // Atualiza progresso de miss√µes di√°rias (coletar recursos)
          updateQuestProgress(me, 'gather', readyPlots.length);

          saveEconomy(econ);

          harvestedText = harvestedText.slice(0, -2); // Remove √∫ltima v√≠rgula

          return reply(`üåæ *COLHEITA CONCLU√çDA!*\n\n‚úÖ Plantas colhidas: ${readyPlots.length}\nüì¶ Ingredientes obtidos:\n${harvestedText}\n\nüíµ Valor estimado: ${fmt(totalValue)}\nüå± Terrenos livres: ${me.farm.maxPlots - me.farm.plots.length}/${me.farm.maxPlots}\n\nüë®‚Äçüç≥ Use ${prefix}receitas para ver o que pode cozinhar!`);
        }

        // ===== COMANDOS COMPLEMENTARES DE COZINHA =====
        if (sub === 'ingredientes') {
          me.ingredients = me.ingredients || {};
          const entries = Object.entries(me.ingredients).filter(([, qty]) => qty > 0);
          
          if (entries.length === 0) {
            return reply(`üì¶ *INGREDIENTES*\n\nVoc√™ n√£o possui ingredientes.\n\nüå± Plante com ${prefix}plantar para conseguir ingredientes!`);
          }

          let text = 'üì¶ *MEUS INGREDIENTES*\n\n';
          for (const [ing, qty] of entries) {
            text += `‚Ä¢ ${ing}: x${qty}\n`;
          }
          text += `\nüë®‚Äçüç≥ Use ${prefix}receitas para ver o que pode cozinhar`;
          return reply(text);
        }

        if (sub === 'comer' || sub === 'eat') {
          const foodKey = (args[0] || '').toLowerCase();
          
          me.cookedFood = me.cookedFood || {};
          
          if (!foodKey) {
            const entries = Object.entries(me.cookedFood).filter(([, qty]) => qty > 0);
            if (entries.length === 0) {
              return reply(`üçΩÔ∏è Voc√™ n√£o tem comida preparada.\n\nüë®‚Äçüç≥ Cozinhe algo com ${prefix}cozinhar`);
            }
            
            let text = 'üçΩÔ∏è *COMIDAS PREPARADAS*\n\n';
            for (const [key, qty] of entries) {
              const recipe = econ.cookingRecipes?.[key];
              if (recipe) {
                text += `${recipe.name} x${qty}\n`;
                text += `  ‚ö° Energia: +${recipe.energy}\n`;
                text += `  üíµ Valor: ${fmt(recipe.sellPrice)}\n\n`;
              }
            }
            text += `üç¥ Comer: ${prefix}comer <comida>\n`;
            text += `üí∞ Vender: ${prefix}vendercomida <comida>`;
            return reply(text);
          }

          if (!me.cookedFood[foodKey] || me.cookedFood[foodKey] <= 0) {
            return reply(`‚ùå Voc√™ n√£o tem ${foodKey} preparado.\n\nüë®‚Äçüç≥ Cozinhe com ${prefix}cozinhar ${foodKey}`);
          }

          const recipe = econ.cookingRecipes?.[foodKey];
          if (!recipe) {
            return reply('‚ùå Receita n√£o encontrada.');
          }

          // Consome a comida
          me.cookedFood[foodKey] -= 1;
          
          // Adiciona energia (pode ser usado para reduzir cooldowns ou dar b√¥nus)
          me.energy = (me.energy || 0) + recipe.energy;
          
          // Skill
          addSkillXP(me, 'cooking', 1);
          
          saveEconomy(econ);

          return reply(`üòã *DELICIOSO!*\n\nVoc√™ comeu ${recipe.name}!\n‚ö° Energia: +${recipe.energy}\nüí™ Energia total: ${me.energy}\n\nüí° Quanto mais energia, mais b√¥nus voc√™ recebe!`);
        }

        if (sub === 'vendercomida') {
          const foodKey = (args[0] || '').toLowerCase();
          
          me.cookedFood = me.cookedFood || {};
          
          if (!foodKey) {
            return reply(`üí∞ *VENDER COMIDA*\n\nUse: ${prefix}vendercomida <comida>\n\nüí° Veja suas comidas com ${prefix}comer`);
          }

          const qty = parseInt(args[1]) || 1;
          
          if (!me.cookedFood[foodKey] || me.cookedFood[foodKey] < qty) {
            return reply(`‚ùå Voc√™ n√£o tem ${qty}x ${foodKey}.\n\nüçΩÔ∏è Voc√™ tem: ${me.cookedFood[foodKey] || 0}`);
          }

          const recipe = econ.cookingRecipes?.[foodKey];
          if (!recipe) {
            return reply('‚ùå Receita n√£o encontrada.');
          }

          const totalValue = recipe.sellPrice * qty;
          me.cookedFood[foodKey] -= qty;
          me.wallet += totalValue;
          
          saveEconomy(econ);

          return reply(`üí∞ *VENDA CONCLU√çDA!*\n\nVoc√™ vendeu ${qty}x ${recipe.name}\nüíµ Ganhou: ${fmt(totalValue)}\nüíº Carteira: ${fmt(me.wallet)}`);
        }

        if (sub === 'sementes') {
          // Inicializa sementes se n√£o existir
          if (!econ.seeds) {
            econ.seeds = {
              trigo: { name: 'üåæ Trigo', cost: 20, growTime: 5 * 60 * 1000, yield: { trigo: 3 } },
              cenoura: { name: 'ü•ï Cenoura', cost: 15, growTime: 4 * 60 * 1000, yield: { cenoura: 2 } },
              batata: { name: 'ü•î Batata', cost: 15, growTime: 4 * 60 * 1000, yield: { batata: 2 } },
              tomate: { name: 'üçÖ Tomate', cost: 18, growTime: 6 * 60 * 1000, yield: { tomate: 3 } },
              alface: { name: 'ü•¨ Alface', cost: 12, growTime: 3 * 60 * 1000, yield: { alface: 2 } },
              milho: { name: 'üåΩ Milho', cost: 25, growTime: 7 * 60 * 1000, yield: { milho: 4 } },
              arroz: { name: 'üåæ Arroz', cost: 22, growTime: 8 * 60 * 1000, yield: { arroz: 4 } },
              cana: { name: 'üåø Cana-de-a√ß√∫car', cost: 30, growTime: 10 * 60 * 1000, yield: { acucar: 5 } }
            };
            saveEconomy(econ);
          }

          let text = 'üå± *CAT√ÅLOGO DE SEMENTES*\n\n';
          for (const [key, seed] of Object.entries(econ.seeds)) {
            const mins = Math.floor(seed.growTime / 60000);
            const yieldText = Object.entries(seed.yield).map(([k, v]) => `${k} x${v}`).join(', ');
            text += `${seed.name}\n`;
            text += `  üí∞ Custo: ${fmt(seed.cost)}\n`;
            text += `  ‚è±Ô∏è Crescimento: ${mins} min\n`;
            text += `  üåæ Colheita: ${yieldText}\n`;
            text += `  üå± Plantar: ${prefix}plantar ${key}\n\n`;
          }
          text += `üí° *Dica:* Use ${prefix}horta para ver suas planta√ß√µes`;
          return reply(text);
        }

        if (sub === 'minerar' || sub === 'mine') {
          const cd = me.cooldowns?.mine || 0;
          if (Date.now() < cd) return reply(`‚è≥ Aguarde ${timeLeft(cd)} para minerar novamente.`);
          const pk = getActivePickaxe(me);
          if (!pk) return reply(`‚õèÔ∏è Voc√™ precisa de uma picareta para minerar. Compre na ${prefix}loja (ex: ${prefix}comprar pickaxe_bronze) ou repare com ${prefix}reparar.`);
          // C√°lculo de ouro com base na picareta e b√¥nus (BALANCEADO)
          const tierMult = PICKAXE_TIER_MULT[pk.tier] || 1.0;
          const base = 100 + Math.floor(Math.random()*101); // 100-200 (AUMENTADO)
          const skillB = getSkillBonus(me,'mining');
          const raw = Math.floor(base * tierMult);
          const bonus = Math.floor(raw * ((mineBonus||0) + skillB));
          const total = raw + bonus;
          me.wallet += total;
          // Quedas de materiais (chances balanceadas)
          let drops = { pedra: 2 + Math.floor(Math.random()*3) }; // 2-4
          if (pk.tier==='ferro' || pk.tier==='diamante') {
            drops.ferro = (drops.ferro||0) + 1 + Math.floor(Math.random()*2); // 1-2
            drops.carvao = (drops.carvao||0) + (Math.random() < 0.4 ? 1 : 0); // 40% chance
          }
          if (pk.tier==='diamante') {
            drops.ferro = (drops.ferro||0) + (Math.random() < 0.7 ? 1 : 0); // 70% chance de +1
            drops.ouro = (drops.ouro||0) + (Math.random() < 0.3 ? 1 : 0); // 30% chance
            drops.carvao = (drops.carvao||0) + (Math.random() < 0.6 ? 1 : 0); // 60% chance
            if (Math.random()<0.1) drops.diamante = (drops.diamante||0) + 1; // 10% chance
          }
          for (const [mk,mq] of Object.entries(drops)) if (mq>0) giveMaterial(me, mk, mq);
          // Durabilidade
          const before = pk.dur; pk.dur = Math.max(0, pk.dur - 1);
          me.tools.pickaxe = { ...pk, max: pk.max ?? (pk.tier==='bronze'?20:pk.tier==='ferro'?60:pk.tier==='diamante'?150:pk.dur) };
          me.cooldowns.mine = Date.now() + 10*60*1000; // 10 min
          addSkillXP(me,'mining',1); updateChallenge(me,'mine',1,true); updatePeriodChallenge(me,'mine',1,true);
          // Rastrear stats
          if (!me.stats) me.stats = {};
          me.stats.totalMine = (me.stats.totalMine || 0) + 1;
          me.stats.mineCount = (me.stats.mineCount || 0) + 1;
          saveEconomy(econ);
          let dropTxt = Object.entries(drops).filter(([,q])=>q>0).map(([k,q])=>`${k} x${q}`).join(', ');
          const broke = pk.dur===0 && before>0;
          return reply(`‚õèÔ∏è Voc√™ minerou e ganhou ${fmt(total)} ${bonus>0?`(b√¥nus ${fmt(bonus)})`:''}!\nüì¶ Drops: ${dropTxt||'‚Äî'}\nüõ†Ô∏è Picareta: ${pk.dur}/${me.tools.pickaxe.max}${broke?' ‚Äî quebrou!':''}`);
        }

        if (sub === 'trabalhar' || sub === 'work') {
          const cd = me.cooldowns?.work || 0;
          if (Date.now() < cd) return reply(`‚è≥ Aguarde ${timeLeft(cd)} para trabalhar novamente.`);
          const base = 150 + Math.floor(Math.random()*151); // 150-300 (AUMENTADO para economia balanceada)
          const skillB = getSkillBonus(me,'working');
          const bonus = Math.floor(base * (workBonus + skillB));
          const total = base + bonus;
          me.wallet += total;
          me.cooldowns.work = Date.now() + 15*60*1000; // 15 min
          addSkillXP(me,'working',1); updateChallenge(me,'work',1,true); updatePeriodChallenge(me,'work',1,true);
          // Rastrear stats
          if (!me.stats) me.stats = {};
          me.stats.totalWork = (me.stats.totalWork || 0) + 1;
          me.stats.workCount = (me.stats.workCount || 0) + 1;
          saveEconomy(econ);
          return reply(`üíº Voc√™ trabalhou e recebeu ${fmt(total)} ${bonus>0?`(b√¥nus ${fmt(bonus)})`:''}!`);
        }

        // ===== Mercado entre usu√°rios =====
        if (sub === 'mercado') {
          const items = econ.market || [];
          if (items.length===0) return reply('üõí O mercado est√° vazio. Use listar para anunciar algo.');
          let text = 'üõí Mercado (ofertas abertas)\n\n';
          for (const ofr of items) {
            text += `#${ofr.id} ‚Ä¢ ${ofr.type==='item'?`${ofr.key} x${ofr.qty}`:`${ofr.mat} x${ofr.qty}`} ‚Äî ${fmt(ofr.price)} | Vendedor: @${ofr.seller.split('@')[0]}\n`;
          }
          return reply(text, { mentions: (items.map(i=>i.seller)) });
        }
        if (sub === 'listar') {
          // listar item <key> <qtd> <preco> | listar mat <material> <qtd> <preco>
          const kind = (args[0]||'').toLowerCase();
          if (!['item','mat','material'].includes(kind)) return reply(`Use: ${prefix}listar item <key> <qtd> <preco> | ${prefix}listar mat <material> <qtd> <preco>`);
          const qty = parseInt(args[2]); const price = parseInt(args[3]);
          if (!isFinite(qty)||qty<=0||!isFinite(price)||price<=0) return reply('Quantidade e pre√ßo inv√°lidos.');
          if (kind==='item') {
            const key = (args[1]||'').toLowerCase();
            if ((me.inventory?.[key]||0) < qty) return reply('Voc√™ n√£o possui itens suficientes.');
            me.inventory[key] -= qty;
            const id = econ.marketCounter++;
            econ.market.push({ id, type:'item', key, qty, price, seller: sender });
            saveEconomy(econ);
            return reply(`üì¢ An√∫ncio #${id} criado: ${key} x${qty} por ${fmt(price)}.`);
          } else {
            const mat = (args[1]||'').toLowerCase();
            if ((me.materials?.[mat]||0) < qty) return reply('Voc√™ n√£o possui materiais suficientes.');
            me.materials[mat] -= qty;
            const id = econ.marketCounter++;
            econ.market.push({ id, type:'mat', mat, qty, price, seller: sender });
            saveEconomy(econ);
            return reply(`üì¢ An√∫ncio #${id} criado: ${mat} x${qty} por ${fmt(price)}.`);
          }
        }
        if (sub === 'meusanuncios' || sub === 'meusan') {
          const mine = (econ.market||[]).filter(o=>o.seller===sender);
          if (mine.length===0) return reply('Voc√™ n√£o tem an√∫ncios.');
          let text='üìã Seus an√∫ncios\n\n';
          for (const ofr of mine) text += `#${ofr.id} ‚Ä¢ ${ofr.type==='item'?`${ofr.key} x${ofr.qty}`:`${ofr.mat} x${ofr.qty}`} ‚Äî ${fmt(ofr.price)}\n`;
          return reply(text);
        }
        if (sub === 'cancelar') {
          const id = parseInt(args[0]); if (!isFinite(id)) return reply('Informe o ID do an√∫ncio.');
          const idx = (econ.market||[]).findIndex(o=>o.id===id);
          if (idx<0) return reply('An√∫ncio n√£o encontrado.');
          const ofr = econ.market[idx];
          if (ofr.seller!==sender) return reply('Apenas o vendedor pode cancelar.');
          // devolve ao vendedor
          if (ofr.type==='item') me.inventory[ofr.key] = (me.inventory[ofr.key]||0) + ofr.qty; else me.materials[ofr.mat]=(me.materials[ofr.mat]||0)+ofr.qty;
          econ.market.splice(idx,1); saveEconomy(econ);
          return reply(`‚ùå An√∫ncio #${id} cancelado e itens devolvidos.`);
        }
        if (sub === 'comprarmercado' || sub === 'cmerc') {
          const id = parseInt(args[0]); if (!isFinite(id)) return reply('Informe o ID do an√∫ncio.');
          const ofr = (econ.market||[]).find(o=>o.id===id);
          if (!ofr) return reply('An√∫ncio n√£o encontrado.');
          if (ofr.seller===sender) return reply('Voc√™ n√£o pode comprar seu pr√≥prio an√∫ncio.');
          const tax = Math.floor(ofr.price * 0.05);
          if (me.wallet < ofr.price) return reply('Saldo insuficiente.');
          const seller = getEcoUser(econ, ofr.seller);
          me.wallet -= ofr.price;
          seller.wallet += (ofr.price - tax); // taxa de 5%
          if (ofr.type==='item') me.inventory[ofr.key] = (me.inventory[ofr.key]||0) + ofr.qty; else me.materials[ofr.mat]=(me.materials[ofr.mat]||0)+ofr.qty;
          econ.market = (econ.market||[]).filter(o=>o.id!==id);
          saveEconomy(econ);
          return reply(`üõí Compra realizada! Taxa de ${fmt(tax)} aplicada. Vendedor recebeu ${fmt(ofr.price - tax)}.`);
        }

        // ===== Propriedades =====
        if (sub === 'propriedades') {
          const keys = Object.keys(econ.propertiesCatalog||{});
          let text = 'üè† Propriedades dispon√≠veis\n\n';
          for (const k of keys) {
            const p = econ.propertiesCatalog[k];
            const upkeep = p.upkeepPerDay || 0; const incGold = p.incomeGoldPerDay||0; const incMat = p.incomeMaterialsPerDay||{};
            const mats = Object.entries(incMat).map(([mk,mq])=>`${mk} x${mq}/dia`).join(', ');
            text += `‚Ä¢ ${k} ‚Äî ${p.name} ‚Äî Pre√ßo: ${fmt(p.price)} ‚Äî Manuten√ß√£o: ${fmt(upkeep)}/dia ‚Äî Renda: ${incGold>0?`${fmt(incGold)} gold/dia`:''}${mats?`${incGold>0?' e ':''}${mats}`:''}\n`;
          }
          // minhas propriedades
          const mine = me.properties||{}; const owned = Object.keys(mine).filter(k=>mine[k]?.owned);
          if (owned.length>0){
            text += '\nüì¶ Suas propriedades:\n';
            for (const k of owned) {
              const o = mine[k];
              const last = o.lastCollect ? new Date(o.lastCollect).toLocaleDateString('pt-BR') : '‚Äî';
              text += `‚Ä¢ ${econ.propertiesCatalog[k]?.name||k} ‚Äî desde ${last}\n`;
            }
          }
          return reply(text);
        }
        if (sub === 'comprarpropriedade' || sub === 'cprop') {
          const key = (args[0]||'').toLowerCase(); if (!key) return reply(`Use: ${prefix}comprarpropriedade <tipo>`);
          const prop = (econ.propertiesCatalog||{})[key]; if (!prop) return reply('Propriedade inexistente.');
          if (me.properties?.[key]?.owned) return reply('Voc√™ j√° possui essa propriedade.');
          if (me.wallet < prop.price) return reply('Saldo insuficiente.');
          me.wallet -= prop.price;
          me.properties[key] = { owned: true, lastCollect: Date.now() };
          saveEconomy(econ);
          return reply(`üè† Voc√™ comprou ${prop.name}!`);
        }
        if (sub === 'coletarpropriedades' || sub === 'cprops') {
          const props = me.properties || {}; const keys = Object.keys(props).filter(k=>props[k].owned);
          if (keys.length===0) return reply('Voc√™ n√£o possui propriedades.');
          let totalGold = 0; const matsGain = {};
          for (const k of keys) {
            const meta = (econ.propertiesCatalog||{})[k]; if (!meta) continue;
            const days = Math.max(1, Math.ceil((Date.now() - (props[k].lastCollect||Date.now())) / (24*60*60*1000)));
            const upkeep = (meta.upkeepPerDay||0) * days; if (me.wallet < upkeep) return reply(`Saldo insuficiente para pagar manuten√ß√£o de ${meta.name} (${fmt(upkeep)}).`);
            me.wallet -= upkeep;
            if (meta.incomeGoldPerDay) totalGold += meta.incomeGoldPerDay * days;
            if (meta.incomeMaterialsPerDay){
              for (const [mk,mq] of Object.entries(meta.incomeMaterialsPerDay)) matsGain[mk]=(matsGain[mk]||0)+(mq*days);
            }
            props[k].lastCollect = Date.now();
          }
          me.wallet += totalGold;
          for (const [mk,mq] of Object.entries(matsGain)) giveMaterial(me, mk, mq);
          saveEconomy(econ);
          let msg = `üè° Coleta conclu√≠da! +${fmt(totalGold)} gold`;
          if (Object.keys(matsGain).length>0) msg += ` | Materiais: `+Object.entries(matsGain).map(([k,q])=>`${k} x${q}`).join(', ');
          return reply(msg);
        }

        // ===== Habilidades & Desafios Peri√≥dicos (visualiza√ß√£o) =====
        if (sub === 'habilidades') {
          ensureUserSkills(me);
          let text = 'üìö Habilidades\n\n';
          for (const s of SKILL_LIST){
            const sk = me.skills[s];
            text += `‚Ä¢ ${s}: N√≠vel ${sk.level} (${sk.xp}/${skillXpForNext(sk.level)})\n`;
          }
          return reply(text);
        }
        if (sub === 'desafiosemanal' || sub === 'desafiomensal') {
          ensureUserPeriodChallenges(me);
          const show = sub==='desafiosemanal' ? me.weeklyChallenge : me.monthlyChallenge;
          const labels = { mine:'Minera√ß√µes', work:'Trabalhos', fish:'Pescarias', explore:'Explora√ß√µes', hunt:'Ca√ßadas', crimeSuccess:'Crimes OK' };
          let text = `üèÖ Desafio ${sub==='desafiosemanal'?'Semanal':'Mensal'}\n\n`;
          for (const t of (show.tasks||[])) text += `‚Ä¢ ${labels[t.type]||t.type}: ${t.progress||0}/${t.target}\n`;
          text += `\nPr√™mio: ${fmt(show.reward)} ${show.claimed?'(coletado)':''}`;
          if (isPeriodCompleted(show) && !show.claimed) text += `\nUse: ${prefix}${sub} coletar`;
          if ((args[0]||'').toLowerCase()==='coletar'){
            if (show.claimed) return reply('Voc√™ j√° coletou este pr√™mio.');
            if (!isPeriodCompleted(show)) return reply('Complete todas as tarefas para coletar.');
            me.wallet += show.reward; show.claimed = true; saveEconomy(econ);
            return reply(`üéâ Voc√™ coletou ${fmt(show.reward)} do ${sub==='desafiosemanal'?'desafio semanal':'desafio mensal'}!`);
          }
          return reply(text);
        }

        if (sub === 'assaltar' || sub === 'roubar') {
          if (!mentioned) return reply('Marque algu√©m para assaltar.');
          if (mentioned === sender) return reply('Voc√™ n√£o pode assaltar a si mesmo.');
          const cd = me.cooldowns?.rob || 0;
          if (Date.now() < cd) return reply(`‚è≥ Aguarde ${timeLeft(cd)} para tentar novamente.`);
          const target = getEcoUser(econ, mentioned);
          const chance = Math.random();
          const maxSteal = Math.min(target.wallet, 300);
          if (maxSteal <= 0) {
            me.cooldowns.rob = Date.now() + 10*60*1000; // 10 min
            saveEconomy(econ);
            return reply('A v√≠tima est√° sem dinheiro na carteira. Roubo falhou.');
          }
          if (chance < 0.5) {
            const amt = 50 + Math.floor(Math.random() * Math.max(1, maxSteal-49));
            target.wallet -= amt; me.wallet += amt;
            me.cooldowns.rob = Date.now() + 10*60*1000;
            saveEconomy(econ);
            return reply(`ü¶π Sucesso! Voc√™ roubou ${fmt(amt)} de @${getUserName(mentioned)}.`, { mentions:[mentioned] });
          } else {
            const multa = 80 + Math.floor(Math.random()*121); // 80-200
            const pay = Math.min(me.wallet, multa);
            me.wallet -= pay; target.wallet += pay;
            me.cooldowns.rob = Date.now() + 10*60*1000;
            saveEconomy(econ);
            return reply(`üö® Voc√™ foi pego! Pagou ${fmt(pay)} de multa para @${getUserName(mentioned)}.`, { mentions:[mentioned] });
          }
        }

        if (sub === 'diario' || sub === 'daily') {
          const cd = me.cooldowns?.daily || 0;
          const now = Date.now();
          
          if (now < cd) {
            return reply(`‚è≥ Voc√™ j√° coletou hoje!\n\nüïê Volte em: ${timeLeft(cd)}`);
          }
          
          // Sistema de Streak (sequ√™ncia di√°ria)
          if (!me.streak) {
            me.streak = { count: 0, lastClaim: 0, record: 0 };
          }
          
          const oneDayMs = 24 * 60 * 60 * 1000;
          const twoDaysMs = 48 * 60 * 60 * 1000;
          const timeSinceLastClaim = now - me.streak.lastClaim;
          
          // Verifica se manteve a sequ√™ncia (coletou no dia seguinte)
          if (timeSinceLastClaim <= twoDaysMs && timeSinceLastClaim >= oneDayMs) {
            me.streak.count += 1;
          } else if (timeSinceLastClaim > twoDaysMs) {
            // Quebrou a sequ√™ncia
            me.streak.count = 1;
          } else {
            me.streak.count = 1;
          }
          
          // Atualiza recorde
          if (me.streak.count > me.streak.record) {
            me.streak.record = me.streak.count;
          }
          
          // Calcula recompensa baseada no streak
          const baseReward = 150;
          const streakBonus = Math.min(me.streak.count * 10, 300); // M√°x +300
          const totalReward = baseReward + streakBonus;
          
          // B√¥nus especial a cada 7 dias
          let extraBonus = 0;
          let bonusMessage = '';
          if (me.streak.count % 7 === 0) {
            extraBonus = 500;
            bonusMessage = '\nüéâ *B√îNUS DE 7 DIAS:* +500!';
          }
          
          // B√¥nus especial a cada 30 dias
          if (me.streak.count % 30 === 0) {
            extraBonus += 2000;
            bonusMessage += '\nüèÜ *B√îNUS DE 30 DIAS:* +2000!';
          }
          
          const finalReward = totalReward + extraBonus;
          
          me.wallet += finalReward;
          me.streak.lastClaim = now;
          me.cooldowns.daily = now + oneDayMs;
          
          // Adiciona XP
          const xpGain = 50 + (me.streak.count * 5);
          me.exp = (me.exp || 0) + xpGain;
          
          // Verifica level up
          const level = me.level || 1;
          const nextLevelXp = 100 * Math.pow(1.5, level - 1);
          let leveledUp = false;
          while (me.exp >= nextLevelXp) {
            me.exp -= nextLevelXp;
            me.level += 1;
            leveledUp = true;
          }
          
          saveEconomy(econ);
          
          let text = `‚ï≠‚îÅ‚îÅ‚îÅ‚ä± üéÅ *RECOMPENSA DI√ÅRIA* ‚ä±‚îÅ‚îÅ‚îÅ‚ïÆ\n`;
          text += `‚îÇ\n`;
          text += `‚îÇ üí∞ Base: +${fmt(baseReward)}\n`;
          text += `‚îÇ üî• Streak (${me.streak.count}x): +${fmt(streakBonus)}\n`;
          if (extraBonus > 0) {
            text += `‚îÇ ‚ú® B√¥nus: +${fmt(extraBonus)}\n`;
          }
          text += `‚îÇ ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ\n`;
          text += `‚îÇ üíµ Total: *${fmt(finalReward)}*\n`;
          text += `‚îÇ ‚ö° XP: +${xpGain}\n`;
          text += `‚îÇ\n`;
          text += `‚îÇ üî• Sequ√™ncia: *${me.streak.count} dia${me.streak.count !== 1 ? 's' : ''}*\n`;
          text += `‚îÇ üèÜ Recorde: ${me.streak.record} dia${me.streak.record !== 1 ? 's' : ''}\n`;
          text += `‚îÇ\n`;
          text += `‚ï∞‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚ïØ`;
          
          if (bonusMessage) {
            text += bonusMessage;
          }
          
          if (leveledUp) {
            text += `\n\n‚ö° *LEVEL UP!* Agora voc√™ √© level ${me.level}!`;
          }
          
          text += `\n\nüí° Volte amanh√£ para manter a sequ√™ncia!`;
          
          return reply(text);
        }

        if (sub === 'toprpg') {
          const arr = Object.entries(econ.users).map(([id,u])=>[id,(u.wallet||0)+(u.bank||0)]).sort((a,b)=>b[1]-a[1]).slice(0,10);
          if (arr.length===0) return reply('Sem dados suficientes para ranking.');
          let text = '‚öîÔ∏è üèÜ *RANKING RPG* üèÜ ‚öîÔ∏è\n\n';
          const mentions = [];
          arr.forEach(([id,total],i)=>{
            const medal = i === 0 ? 'ü•á' : i === 1 ? 'ü•à' : i === 2 ? 'ü•â' : `${i+1}.`;
            text += `${medal} @${id.split('@')[0]} ‚Äî üí∞ ${fmt(total)}\n`;
            mentions.push(id);
          });
          text += `\n‚ú® Continue jogando para subir no rank!`;
          return reply(text, { mentions });
        }

        

        return reply('Comando RPG inv√°lido. Use '+prefix+'menurpg para ver todos os comandos.');
      }

      // ==================== NOVOS COMANDOS RPG ====================
      
      // Sistema de Equipamentos
      case 'equipamentos':
      case 'gear':
      case 'equip': {
        if (!isGroup) return reply('‚öîÔ∏è Este comando funciona apenas em grupos com Modo RPG ativo.');
        if (!groupData.modorpg) return reply(`‚öîÔ∏è Modo RPG desativado! Use ${prefix}modorpg para ativar.`);
        
        const econ = loadEconomy();
        const me = getEcoUser(econ, sender);
        
        if (!me.equipment) me.equipment = { weapon: null, armor: null, helmet: null, boots: null, shield: null, accessory: null };
        
        const eq = me.equipment;
        // Recalcula os b√¥nus a partir dos itens equipados
        recalcEquipmentBonuses(me, econ.shop);

        let text = `‚ï≠‚îÅ‚îÅ‚îÅ‚ä± ‚öîÔ∏è *EQUIPAMENTOS* ‚ä±‚îÅ‚îÅ‚îÅ‚ïÆ\n`;
        text += `‚îÇ üë§ Aventureiro: *${pushname}*\n`;
        text += `‚ï∞‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚ïØ\n\n`;
        text += `üó°Ô∏è *Arma:* ${eq.weapon || '‚ùå Nenhuma'}\n`;
        text += `üõ°Ô∏è *Armadura:* ${eq.armor || '‚ùå Nenhuma'}\n`;
        text += `‚õëÔ∏è *Capacete:* ${eq.helmet || '‚ùå Nenhum'}\n`;
        text += `üë¢ *Botas:* ${eq.boots || '‚ùå Nenhuma'}\n`;
        text += `üõ°Ô∏è *Escudo:* ${eq.shield || '‚ùå Nenhum'}\n`;
        text += `üíç *Acess√≥rio:* ${eq.accessory || '‚ùå Nenhum'}\n\n`;
        text += `‚ï≠‚îÅ‚îÅ‚îÅ‚ä± üìä *ESTAT√çSTICAS* ‚ä±‚îÅ‚îÅ‚îÅ‚ïÆ\n`;
        text += `‚îÇ ‚öîÔ∏è Poder de Ataque: +${me.attackBonus || 0}\n`;
        text += `‚îÇ üõ°Ô∏è Poder de Defesa: +${me.defenseBonus || 0}\n`;
        text += `‚îÇ ‚ú® Poder Total: ${me.power || 100}\n`;
        text += `‚ï∞‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚ïØ\n\n`;
        text += `üí° *Dicas:*\n`;
        text += `‚Ä¢ Use ${prefix}forjar para criar equipamentos\n`;
        text += `‚Ä¢ Use ${prefix}encantar para melhorar\n`;
        text += `‚Ä¢ Use ${prefix}inventario para ver itens`;
        
        return reply(text);
      }

      // Sistema de Conquistas
      case 'conquistas':
      case 'achievements':
      case 'medalhas': {
        if (!isGroup) return reply('‚öîÔ∏è Este comando funciona apenas em grupos com Modo RPG ativo.');
        if (!groupData.modorpg) return reply(`‚öîÔ∏è Modo RPG desativado! Use ${prefix}modorpg para ativar.`);
        
        const econ = loadEconomy();
        const me = getEcoUser(econ, sender);
        
        me.achievements = me.achievements || {};
        me.stats = me.stats || { totalMine: 0, totalWork: 0, totalFish: 0, totalHunt: 0, totalExplore: 0, totalBattles: 0, totalWins: 0, totalCrimes: 0 };
        
        const achievements = [
          { id: 'minerador', name: '‚õèÔ∏è Minerador', desc: 'Minere 100 vezes', req: me.stats.totalMine >= 100, progress: `${me.stats.totalMine || 0}/100` },
          { id: 'trabalhador', name: 'üíº Trabalhador', desc: 'Trabalhe 50 vezes', req: me.stats.totalWork >= 50, progress: `${me.stats.totalWork || 0}/50` },
          { id: 'pescador', name: 'üé£ Pescador', desc: 'Pesque 75 vezes', req: me.stats.totalFish >= 75, progress: `${me.stats.totalFish || 0}/75` },
          { id: 'cacador', name: 'üèπ Ca√ßador', desc: 'Cace 50 vezes', req: me.stats.totalHunt >= 50, progress: `${me.stats.totalHunt || 0}/50` },
          { id: 'explorador', name: 'üó∫Ô∏è Explorador', desc: 'Explore 100 vezes', req: me.stats.totalExplore >= 100, progress: `${me.stats.totalExplore || 0}/100` },
          { id: 'gladiador', name: '‚öîÔ∏è Gladiador', desc: 'Ven√ßa 25 batalhas', req: me.stats.totalWins >= 25, progress: `${me.stats.totalWins || 0}/25` },
          { id: 'milionario', name: 'üí∞ Milion√°rio', desc: 'Tenha 500K no banco', req: (me.bank || 0) >= 500000, progress: `${(me.bank || 0).toLocaleString()}/500.000` },
          { id: 'veterano', name: 'üèÜ Veterano', desc: 'Alcance n√≠vel 50', req: (me.level || 1) >= 50, progress: `${me.level || 1}/50` },
          { id: 'colecionador', name: 'üêæ Colecionador', desc: 'Tenha 5 pets', req: (me.pets?.length || 0) >= 5, progress: `${me.pets?.length || 0}/5` },
          { id: 'criminoso', name: 'ü¶π Criminoso', desc: 'Cometa 30 crimes', req: me.stats.totalCrimes >= 30, progress: `${me.stats.totalCrimes || 0}/30` }
        ];
        
        let unlockedCount = 0;
        let text = `‚ï≠‚îÅ‚îÅ‚îÅ‚ä± üèÖ *CONQUISTAS* ‚ä±‚îÅ‚îÅ‚îÅ‚ïÆ\n`;
        text += `‚îÇ Aventureiro: *${pushname}*\n`;
        text += `‚ï∞‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚ïØ\n\n`;
        
        for (const ach of achievements) {
          const unlocked = ach.req;
          if (unlocked && !me.achievements[ach.id]) {
            me.achievements[ach.id] = Date.now();
          }
          if (unlocked) unlockedCount++;
          
          const status = unlocked ? '‚úÖ' : 'üîí';
          text += `${status} ${ach.name}\n`;
          text += `   ${ach.desc}\n`;
          text += `   üìä Progresso: ${ach.progress}\n\n`;
        }
        
        text += `‚ï≠‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚ïÆ\n`;
        text += `‚îÇ üèÜ Total: ${unlockedCount}/${achievements.length} conquistas\n`;
        text += `‚ï∞‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚ïØ`;
        
        saveEconomy(econ);
        return reply(text);
      }

      // Sistema de Pets
      case 'pets':
      case 'meuspets': {
        if (!isGroup) return reply('‚öîÔ∏è Este comando funciona apenas em grupos com Modo RPG ativo.');
        if (!groupData.modorpg) return reply(`‚öîÔ∏è Modo RPG desativado! Use ${prefix}modorpg para ativar.`);
        
        const econ = loadEconomy();
        const me = getEcoUser(econ, sender);
        
        if (!me.pets) me.pets = [];
        
        // Aplica degrada√ß√£o autom√°tica
        const degradation = applyPetDegradation(me.pets);
        if (degradation.changed) {
          saveEconomy(econ);
        }
        
        if (me.pets.length === 0) {
          let text = `‚ï≠‚îÅ‚îÅ‚îÅ‚ä± üêæ *SISTEMA DE PETS* ‚ä±‚îÅ‚îÅ‚îÅ‚ïÆ\n`;
          text += `‚îÇ Voc√™ ainda n√£o tem companheiros!\n`;
          text += `‚ï∞‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚ïØ\n\n`;
          text += `ü¶ä *PETS DISPON√çVEIS:*\n\n`;
          text += `ÔøΩ *Lobo* - Veloz e leal\n`;
          text += `üêâ *Drag√£o* - Poderoso e raro\n`;
          text += `üî• *F√™nix* - Imortal e m√≠stico\n`;
          text += `üêØ *Tigre* - Feroz e forte\n`;
          text += `ü¶Ö *√Åguia* - √Ågil e preciso\n\n`;
          text += `üí° Use ${prefix}adotar <nome> para come√ßar!`;
          return reply(text);
        }
        
        let text = `‚ï≠‚îÅ‚îÅ‚îÅ‚ä± üêæ *MEUS PETS* ‚ä±‚îÅ‚îÅ‚îÅ‚ïÆ\n`;
        text += `‚îÇ Treinador: *${pushname}*\n`;
        text += `‚îÇ Total de Pets: ${me.pets.length}/5\n`;
        text += `‚ï∞‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚ïØ\n\n`;
        
        let hasWarnings = false;
        me.pets.forEach((pet, i) => {
          const hungerBar = '‚ñà'.repeat(Math.floor(pet.hunger / 10)) + '‚ñë'.repeat(10 - Math.floor(pet.hunger / 10));
          const moodBar = '‚ñà'.repeat(Math.floor(pet.mood / 10)) + '‚ñë'.repeat(10 - Math.floor(pet.mood / 10));
          
          // Status de alerta
          let statusEmoji = '';
          if (pet.hunger < 20) {
            statusEmoji = ' ‚ö†Ô∏è FOME CR√çTICA';
            hasWarnings = true;
          } else if (pet.hunger < 40) {
            statusEmoji = ' üçñ Com fome';
          }
          
          if (pet.mood < 20) {
            statusEmoji += ' üò¢ TRISTE';
            hasWarnings = true;
          }
          
          // Mostra evolu√ß√£o atual
          let evolutionText = '';
          if (pet.evolutions && pet.evolutions > 0) {
            evolutionText = ` ${'‚≠ê'.repeat(pet.evolutions)}`;
          }
          
          text += `${i + 1}. ${pet.emoji} *${pet.name}*${evolutionText}${statusEmoji}\n`;
          text += `‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ\n`;
          text += `‚îÇ üìä Level ${pet.level} | üí´ ${pet.exp}/${pet.level * 100} EXP\n`;
          text += `‚îÇ ‚ù§Ô∏è HP: ${pet.hp}/${pet.maxHp}\n`;
          text += `‚îÇ ‚öîÔ∏è ATK: ${pet.attack} | üõ°Ô∏è DEF: ${pet.defense}\n`;
          if (pet.speed) text += `‚îÇ ‚ö° SPD: ${pet.speed}\n`;
          text += `‚îÇ üèÜ ${pet.wins || 0}V | üíÄ ${pet.losses || 0}D\n`;
          
          // Mostra equipamentos
          if (pet.equipment && Object.keys(pet.equipment).length > 0) {
            text += `‚îÇ üì¶ Equipado:\n`;
            Object.entries(pet.equipment).forEach(([slot, itemId]) => {
              const item = SHOP_ITEMS[itemId];
              if (item) {
                const slotIcon = slot === 'weapon' ? '‚öîÔ∏è' : slot === 'armor' ? 'üõ°Ô∏è' : slot === 'shield' ? 'üõ°Ô∏è' : slot === 'accessory' ? 'üíç' : 'üß™';
                text += `‚îÇ   ${slotIcon} ${item.name}\n`;
              }
            });
          }
          
          text += `‚îÇ üçñ Fome: ${hungerBar} ${pet.hunger}%\n`;
          text += `‚îÇ üòä Humor: ${moodBar} ${pet.mood}%\n`;
          text += `‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ\n\n`;
        });
        
        if (hasWarnings) {
          text += `‚ö†Ô∏è *ATEN√á√ÉO:* Alguns pets precisam de cuidados!\n\n`;
        }
        
        text += `üéÆ *COMANDOS DISPON√çVEIS:*\n`;
        text += `‚Ä¢ ${prefix}alimentar <n√∫mero>\n`;
        text += `‚Ä¢ ${prefix}treinar <n√∫mero>\n`;
        text += `‚Ä¢ ${prefix}evoluir <n√∫mero>\n`;
        text += `‚Ä¢ ${prefix}renomear <n√∫mero> <nome>\n`;
        text += `‚Ä¢ ${prefix}batalha <n√∫mero> @user\n\n`;
        text += `üí° Seus pets perdem fome e humor com o tempo!`;
        
        return reply(text);
        break;
      }

      case 'adotar':
      case 'adopt': {
        if (!isGroup) return reply('‚öîÔ∏è Este comando funciona apenas em grupos com Modo RPG ativo.');
        if (!groupData.modorpg) return reply(`‚öîÔ∏è Modo RPG desativado! Use ${prefix}modorpg para ativar.`);
        
        const econ = loadEconomy();
        const me = getEcoUser(econ, sender);
        
        if (!me.pets) me.pets = [];
        if (me.pets.length >= 5) return reply('üêæ Voc√™ j√° tem o m√°ximo de 5 pets!');
        
        const petTypes = {
          lobo: { emoji: 'üê∫', name: 'Lobo', type: 'lobo', hp: 100, attack: 15, defense: 10, speed: 18, cost: 5000, desc: 'Veloz e leal', element: 'normal' },
          dragao: { emoji: 'üêâ', name: 'Drag√£o', type: 'dragao', hp: 150, attack: 25, defense: 15, speed: 12, cost: 15000, desc: 'Poderoso e raro', element: 'fire' },
          fenix: { emoji: 'üî•', name: 'F√™nix', type: 'fenix', hp: 120, attack: 20, defense: 12, speed: 20, cost: 10000, desc: 'Imortal e m√≠stico', element: 'fire' },
          tigre: { emoji: 'üêØ', name: 'Tigre', type: 'tigre', hp: 110, attack: 18, defense: 11, speed: 16, cost: 7000, desc: 'Feroz e forte', element: 'normal' },
          aguia: { emoji: 'ü¶Ö', name: '√Åguia', type: 'aguia', hp: 90, attack: 22, defense: 8, speed: 25, cost: 6000, desc: '√Ågil e preciso', element: 'wind' }
        };
        
        // Normaliza o par√¢metro ignorando acentos
        const inputType = (q || '').trim();
        const type = matchParam(inputType, petTypes) || findKeyIgnoringAccents(petTypes, inputType);
        
        if (!type || !petTypes[type]) {
          let text = `‚ï≠‚îÅ‚îÅ‚îÅ‚ä± üêæ *LOJA DE PETS* ‚ä±‚îÅ‚îÅ‚îÅ‚ïÆ\n`;
          text += `‚îÇ Escolha seu companheiro!\n`;
          text += `‚ï∞‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚ïØ\n\n`;
          
          Object.entries(petTypes).forEach(([key, pet]) => {
            text += `${pet.emoji} *${pet.name}*\n`;
            text += `‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ\n`;
            text += `‚îÇ üìù ${pet.desc}\n`;
            text += `‚îÇ ÔøΩ Pre√ßo: ${pet.cost.toLocaleString()}\n`;
            text += `‚îÇ ‚ù§Ô∏è HP: ${pet.hp}\n`;
            text += `‚îÇ ‚öîÔ∏è ATK: ${pet.attack}\n`;
            text += `‚îÇ üõ°Ô∏è DEF: ${pet.defense}\n`;
            text += `‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ\n\n`;
          });
          
          text += `ÔøΩüí° Use ${prefix}adotar <nome> para adotar`;
          return reply(text);
        }
        
        const pet = petTypes[type];
        if (me.wallet < pet.cost) {
          return reply(`üí∞ Voc√™ precisa de *${pet.cost.toLocaleString()}* moedas!\n\nüí∏ Voc√™ tem: ${me.wallet.toLocaleString()}\n‚ùå Faltam: ${(pet.cost - me.wallet).toLocaleString()}`);
        }
        
        me.wallet -= pet.cost;
        me.pets.push({
          ...pet,
          level: 1,
          maxHp: pet.hp,
          exp: 0,
          hunger: 100,
          mood: 100,
          wins: 0,
          losses: 0,
          equipment: {},
          evolutions: 0,
          lastUpdate: Date.now()
        });
        
        saveEconomy(econ);
        
        let text = `‚ï≠‚îÅ‚îÅ‚îÅ‚ä± üéâ *ADO√á√ÉO REALIZADA!* ‚ä±‚îÅ‚îÅ‚îÅ‚ïÆ\n`;
        text += `‚îÇ\n`;
        text += `‚îÇ Voc√™ adotou ${pet.emoji} *${pet.name}*!\n`;
        text += `‚îÇ\n`;
        text += `‚îÇ ${pet.desc}\n`;
        text += `‚îÇ\n`;
        text += `‚ï∞‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚ïØ\n\n`;
        text += `üí° Use ${prefix}pets para ver seus companheiros\n`;
        text += `‚ö†Ô∏è Lembre-se: seus pets precisam de cuidados regulares!`;
        
        return reply(text);
        break;
      }

      case 'alimentar':
      case 'feed': {
        if (!isGroup) return reply('‚öîÔ∏è Este comando funciona apenas em grupos com Modo RPG ativo.');
        if (!groupData.modorpg) return reply(`‚öîÔ∏è Modo RPG desativado! Use ${prefix}modorpg para ativar.`);
        
        const econ = loadEconomy();
        const me = getEcoUser(econ, sender);
        
        if (!me.pets || me.pets.length === 0) return reply('üêæ Voc√™ n√£o tem pets para alimentar!');
        
        // Aplica degrada√ß√£o antes de alimentar
        applyPetDegradation(me.pets);
        
        const index = parseInt(q) - 1;
        if (isNaN(index) || index < 0 || index >= me.pets.length) {
          return reply(`‚ùå Pet inv√°lido! Use ${prefix}pets para ver seus pets e escolha um n√∫mero.`);
        }
        
        const pet = me.pets[index];
        const foodCost = 100;
        
        if (me.wallet < foodCost) return reply(`üí∞ Voc√™ precisa de ${foodCost} moedas para comprar comida!`);
        if (pet.hunger >= 100) return reply(`üçñ ${pet.emoji} *${pet.name}* j√° est√° satisfeito!`);
        
        me.wallet -= foodCost;
        const hungerGain = 30 + Math.floor(Math.random() * 20);
        pet.hunger = Math.min(100, pet.hunger + hungerGain);
        pet.mood = Math.min(100, pet.mood + 10);
        pet.lastUpdate = Date.now(); // Atualiza timestamp
        
        // Recupera HP se estava perdendo
        if (pet.hp < pet.maxHp) {
          const hpRecover = Math.floor(pet.maxHp * 0.1);
          pet.hp = Math.min(pet.maxHp, pet.hp + hpRecover);
        }
        
        saveEconomy(econ);
        
        let text = `‚ï≠‚îÅ‚îÅ‚îÅ‚ä± üçñ *ALIMENTA√á√ÉO* ‚ä±‚îÅ‚îÅ‚îÅ‚ïÆ\n`;
        text += `‚îÇ ${pet.emoji} *${pet.name}* comeu!\n`;
        text += `‚ï∞‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚ïØ\n\n`;
        text += `üòä Humor: ${pet.mood}/100 (+10)\n`;
        text += `üçñ Fome: ${pet.hunger}/100 (+${hungerGain})\n`;
        if (pet.hp < pet.maxHp) {
          text += `‚ù§Ô∏è HP: ${pet.hp}/${pet.maxHp} (recuperando)\n`;
        }
        text += `\nüí∏ Custo: -${foodCost} moedas`;
        
        return reply(text);
        break;
      }

      case 'treinar':
      case 'train': {
        if (!isGroup) return reply('‚öîÔ∏è Este comando funciona apenas em grupos com Modo RPG ativo.');
        if (!groupData.modorpg) return reply(`‚öîÔ∏è Modo RPG desativado! Use ${prefix}modorpg para ativar.`);
        
        const econ = loadEconomy();
        const me = getEcoUser(econ, sender);
        
        if (!me.pets || me.pets.length === 0) return reply('üêæ Voc√™ n√£o tem pets para treinar!');
        
        // Aplica degrada√ß√£o antes de treinar
        applyPetDegradation(me.pets);
        
        const index = parseInt(q) - 1;
        if (isNaN(index) || index < 0 || index >= me.pets.length) {
          return reply(`‚ùå Pet inv√°lido! Use ${prefix}pets para ver seus pets.`);
        }
        
        const pet = me.pets[index];
        if (pet.hunger < 30) return reply(`üçñ ${pet.emoji} *${pet.name}* est√° com muita fome! Alimente-o primeiro.`);
        
        const now = Date.now();
        if (pet.lastTrain && (now - pet.lastTrain) < 3600000) {
          const remaining = Math.ceil((3600000 - (now - pet.lastTrain)) / 60000);
          return reply(`‚è∞ ${pet.emoji} *${pet.name}* est√° cansado!\n\nüïê Aguarde *${remaining} minutos*`);
        }
        
        const expGain = 50 + Math.floor(Math.random() * 30);
        pet.exp = (pet.exp || 0) + expGain;
        pet.hunger = Math.max(0, pet.hunger - 20);
        pet.lastTrain = now;
        
        // Atualiza miss√£o de treinar pet
        updateQuestProgress(me, 'train_pet', 1);
        
        let text = `‚ï≠‚îÅ‚îÅ‚îÅ‚ä± üí™ *TREINAMENTO* ‚ä±‚îÅ‚îÅ‚îÅ‚ïÆ\n`;
        text += `‚îÇ ${pet.emoji} *${pet.name}* treinou!\n`;
        text += `‚ï∞‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚ïØ\n\n`;
        
        if (pet.exp >= pet.level * 100) {
          pet.level++;
          const atkGain = 2 + Math.floor(Math.random() * 3);
          const defGain = 1 + Math.floor(Math.random() * 2);
          const hpGain = 10 + Math.floor(Math.random() * 10);
          
          pet.attack += atkGain;
          pet.defense += defGain;
          pet.maxHp += hpGain;
          pet.hp = pet.maxHp;
          pet.exp = 0;
          
          text += `‚ï≠‚îÅ‚îÅ‚îÅ‚ä± ÔøΩ *PET EVOLUIU!* ÔøΩ ‚ä±‚îÅ‚îÅ‚îÅ‚ïÆ\n`;
          text += `‚îÇ\n`;
          text += `‚îÇ üêæ *${pet.name}* ${pet.emoji}\n`;
          text += `‚îÇ\n`;
          text += `‚îÇ üìä *N√≠vel:* ${pet.level - 1} ‚ûú *${pet.level}*\n`;
          text += `‚îÇ\n`;
          text += `‚îÇ ‚öîÔ∏è *ATK:* ${pet.attack - atkGain} ‚ûú *${pet.attack}* *(+${atkGain})*\n`;
          text += `‚îÇ üõ°Ô∏è *DEF:* ${pet.defense - defGain} ‚ûú *${pet.defense}* *(+${defGain})*\n`;
          text += `‚îÇ ‚ù§Ô∏è *HP:* ${pet.maxHp - hpGain} ‚ûú *${pet.maxHp}* *(+${hpGain})*\n`;
          text += `‚îÇ\n`;
          text += `‚ï∞‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚ïØ\n`;
          text += `\n‚ú® *Seu pet ficou mais forte!* ‚ú®`;
          
          saveEconomy(econ);
          return reply(text);
        }
        
        text += `‚ú® EXP: +${expGain}\n`;
        text += `üìä Progresso: ${pet.exp}/${pet.level * 100}\n`;
        text += `üçñ Fome: ${pet.hunger}/100\n\n`;
        text += `üí° ${pet.exp} de ${pet.level * 100} para o pr√≥ximo n√≠vel`;
        
        saveEconomy(econ);
        return reply(text);
        break;
      }

      case 'evoluirpet':
      case 'evolve': {
        if (!isGroup) return reply('‚öîÔ∏è Este comando funciona apenas em grupos com Modo RPG ativo.');
        if (!groupData.modorpg) return reply(`‚öîÔ∏è Modo RPG desativado! Use ${prefix}modorpg para ativar.`);
        
        const econ = loadEconomy();
        const me = getEcoUser(econ, sender);
        
        if (!me.pets || me.pets.length === 0) return reply('üêæ Voc√™ n√£o tem pets para evoluir!');
        if (!me.items) me.items = {};
        
        const index = parseInt(q) - 1;
        if (isNaN(index) || index < 0 || index >= me.pets.length) {
          return reply(`‚ùå Pet inv√°lido! Use ${prefix}pets para ver seus pets.`);
        }
        
        const pet = me.pets[index];
        if (!pet.evolutions) pet.evolutions = 0;
        
        // Sistema de evolu√ß√µes: cada pet pode evoluir 3 vezes
        const evolutionData = {
          lobo: [
            { name: 'Lobo Alpha', emoji: 'üê∫‚≠ê', reqLevel: 10, atkBonus: 15, defBonus: 8, hpBonus: 50, spdBonus: 10 },
            { name: 'Lobo Lunar', emoji: 'üåôüê∫', reqLevel: 25, atkBonus: 30, defBonus: 18, hpBonus: 120, spdBonus: 25 },
            { name: 'Fenrir Despertado', emoji: 'üê∫üí´', reqLevel: 50, atkBonus: 60, defBonus: 40, hpBonus: 250, spdBonus: 50 }
          ],
          dragao: [
            { name: 'Drag√£o de Fogo', emoji: 'üê≤üî•', reqLevel: 15, atkBonus: 25, defBonus: 15, hpBonus: 80, spdBonus: 5 },
            { name: 'Drag√£o Anci√£o', emoji: 'üêâ‚ö°', reqLevel: 30, atkBonus: 50, defBonus: 35, hpBonus: 180, spdBonus: 15 },
            { name: 'Drag√£o Despertado', emoji: 'üêâüí•', reqLevel: 60, atkBonus: 100, defBonus: 70, hpBonus: 400, spdBonus: 30 }
          ],
          fenix: [
            { name: 'F√™nix Flamejante', emoji: 'üî•‚≠ê', reqLevel: 12, atkBonus: 20, defBonus: 10, hpBonus: 60, spdBonus: 15 },
            { name: 'F√™nix Imortal', emoji: 'üî•üí´', reqLevel: 28, atkBonus: 40, defBonus: 25, hpBonus: 150, spdBonus: 35 },
            { name: 'F√™nix Celestial', emoji: 'üî•üëë', reqLevel: 55, atkBonus: 80, defBonus: 50, hpBonus: 320, spdBonus: 70 }
          ],
          tigre: [
            { name: 'Tigre Real', emoji: 'üêØüëë', reqLevel: 10, atkBonus: 18, defBonus: 10, hpBonus: 55, spdBonus: 12 },
            { name: 'Tigre de Jade', emoji: 'üêØüíö', reqLevel: 25, atkBonus: 35, defBonus: 22, hpBonus: 130, spdBonus: 28 },
            { name: 'Tigre Divino', emoji: 'üêØ‚ö°', reqLevel: 50, atkBonus: 70, defBonus: 45, hpBonus: 280, spdBonus: 55 }
          ],
          aguia: [
            { name: '√Åguia Majestosa', emoji: 'ü¶Ö‚≠ê', reqLevel: 10, atkBonus: 22, defBonus: 7, hpBonus: 45, spdBonus: 20 },
            { name: '√Åguia Dourada', emoji: 'ü¶Öüëë', reqLevel: 25, atkBonus: 45, defBonus: 15, hpBonus: 110, spdBonus: 45 },
            { name: 'Grifo Lend√°rio', emoji: 'ü¶Öüí´', reqLevel: 50, atkBonus: 90, defBonus: 35, hpBonus: 240, spdBonus: 90 }
          ]
        };
        
        const petEvolutions = evolutionData[pet.type];
        if (!petEvolutions || pet.evolutions >= petEvolutions.length) {
          return reply(`‚ùå ${pet.emoji} *${pet.name}* j√° atingiu sua forma m√°xima!`);
        }
        
        const nextEvolution = petEvolutions[pet.evolutions];
        
        // Verifica requisitos
        if (pet.level < nextEvolution.reqLevel) {
          return reply(`‚ùå ${pet.emoji} *${pet.name}* precisa estar no n√≠vel ${nextEvolution.reqLevel}!\n\nüìä N√≠vel atual: ${pet.level}`);
        }
        
        // Verifica pedra da evolu√ß√£o (verifica em inventory e items)
        const hasStoneInInventory = me.inventory?.evolution_stone && me.inventory.evolution_stone >= 1;
        const hasStoneInItems = me.items?.evolution_stone && me.items.evolution_stone >= 1;
        
        if (!hasStoneInInventory && !hasStoneInItems) {
          return reply(`‚ùå Voc√™ precisa de uma *Pedra da Evolu√ß√£o* para evoluir seu pet!\n\nüõí Compre na ${prefix}loja ou ganhe em batalhas de pets.`);
        }
        
        // Consome a pedra (verifica onde est√°)
        if (hasStoneInInventory) {
          me.inventory.evolution_stone--;
        } else {
          me.items.evolution_stone--;
        }
        
        const oldName = pet.name;
        const oldEmoji = pet.emoji;
        const oldStats = {
          attack: pet.attack,
          defense: pet.defense,
          maxHp: pet.maxHp,
          speed: pet.speed || 0
        };
        
        pet.name = nextEvolution.name;
        pet.emoji = nextEvolution.emoji;
        pet.attack += nextEvolution.atkBonus;
        pet.defense += nextEvolution.defBonus;
        pet.maxHp += nextEvolution.hpBonus;
        pet.speed = (pet.speed || 0) + nextEvolution.spdBonus;
        pet.hp = pet.maxHp;
        pet.evolutions++;
        
        saveEconomy(econ);
        
        let text = `‚ï≠‚îÅ‚îÅ‚îÅ‚ä± ‚ú® *EVOLU√á√ÉO CONCLU√çDA!* ‚ú® ‚ä±‚îÅ‚îÅ‚îÅ‚ïÆ\n`;
        text += `‚îÇ\n`;
        text += `‚îÇ ${oldEmoji} ‚ûú ${pet.emoji}\n`;
        text += `‚îÇ\n`;
        text += `‚îÇ üéâ *${oldName}* evoluiu para\n`;
        text += `‚îÇ üåü *${pet.name}*!\n`;
        text += `‚îÇ\n`;
        text += `‚ï∞‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚ïØ\n\n`;
        text += `üìä *NOVOS ATRIBUTOS:*\n\n`;
        text += `‚öîÔ∏è *ATK:* ${oldStats.attack} ‚ûú ${pet.attack} *(+${nextEvolution.atkBonus})*\n`;
        text += `üõ°Ô∏è *DEF:* ${oldStats.defense} ‚ûú ${pet.defense} *(+${nextEvolution.defBonus})*\n`;
        text += `‚ù§Ô∏è *HP:* ${oldStats.maxHp} ‚ûú ${pet.maxHp} *(+${nextEvolution.hpBonus})*\n`;
        text += `‚ö° *SPD:* ${oldStats.speed} ‚ûú ${pet.speed} *(+${nextEvolution.spdBonus})*\n\n`;
        
        if (pet.evolutions < petEvolutions.length) {
          const next = petEvolutions[pet.evolutions];
          text += `üîÆ *Pr√≥xima Evolu√ß√£o:* ${next.name} ${next.emoji}\n`;
          text += `üìä *Requisito:* N√≠vel ${next.reqLevel}\n`;
        } else {
          text += `üëë *${pet.name}* atingiu sua FORMA FINAL!`;
        }
        
        return reply(text);
        break;
      }

      case 'renomearpet':
      case 'renamepet': {
        if (!isGroup) return reply('‚öîÔ∏è Este comando funciona apenas em grupos com Modo RPG ativo.');
        if (!groupData.modorpg) return reply(`‚öîÔ∏è Modo RPG desativado! Use ${prefix}modorpg para ativar.`);
        
        const econ = loadEconomy();
        const me = getEcoUser(econ, sender);
        
        if (!me.pets || me.pets.length === 0) return reply('üêæ Voc√™ n√£o tem pets!');
        
        const args = q.split(' ');
        const index = parseInt(args[0]) - 1;
        const newName = args.slice(1).join(' ');
        
        if (isNaN(index) || index < 0 || index >= me.pets.length) {
          return reply(`‚ùå Pet inv√°lido!`);
        }
        
        if (!newName || newName.length < 2) {
          return reply(`‚ùå Nome muito curto! M√≠nimo 2 caracteres.`);
        }
        
        if (newName.length > 20) {
          return reply(`‚ùå Nome muito longo! M√°ximo 20 caracteres.`);
        }
        
        const pet = me.pets[index];
        const oldName = pet.name;
        const cost = 500;
        
        if (me.wallet < cost) {
          return reply(`üí∞ Renomear custa ${cost} moedas!`);
        }
        
        me.wallet -= cost;
        pet.name = newName.substring(0, 20);
        
        saveEconomy(econ);
        return reply(`‚úèÔ∏è ${pet.emoji} *${oldName}* agora se chama *${pet.name}*!\n\nüí∏ Custo: -${cost} moedas`);
        break;
      }

      case 'batalhapet':
      case 'petbattle': {
        if (!isGroup) return reply('‚öîÔ∏è Este comando funciona apenas em grupos com Modo RPG ativo.');
        if (!groupData.modorpg) return reply(`‚öîÔ∏è Modo RPG desativado! Use ${prefix}modorpg para ativar.`);
        
        const econ = loadEconomy();
        const me = getEcoUser(econ, sender);
        const target = (menc_jid2 && menc_jid2[0]) || null;
        const now = Date.now();
        
        const PET_BATTLE_COOLDOWN = 10 * 60 * 1000;
        if (me.lastPetBattle && (now - me.lastPetBattle) < PET_BATTLE_COOLDOWN) {
          const remaining = Math.ceil((PET_BATTLE_COOLDOWN - (now - me.lastPetBattle)) / 60000);
          return reply(`‚è∞ Voc√™ acabou de batalhar. Aguarde *${remaining} minutos*.`);
        }
        
        if (!target) return reply(`‚ùå Marque algu√©m para batalhar!\n\nüí° Uso: ${prefix}batalha <n√∫mero> @user`);
        if (target === sender) return reply('‚ùå Voc√™ n√£o pode batalhar contra si mesmo!');
        
        const opponent = getEcoUser(econ, target);
        
        if (!me.pets || me.pets.length === 0) return reply('üêæ Voc√™ n√£o tem pets!');
        if (!opponent.pets || opponent.pets.length === 0) {
          return reply('‚ùå Seu oponente n√£o tem pets!');
        }
        
        const args = q.split(' ');
        const myIndex = parseInt(args[0]) - 1;
        
        if (isNaN(myIndex) || myIndex < 0 || myIndex >= me.pets.length) {
          return reply(`‚ùå Pet inv√°lido! Use ${prefix}pets para ver.`);
        }
        
        const myPet = me.pets[myIndex];
        const oppPet = opponent.pets[Math.floor(Math.random() * opponent.pets.length)];
        
        if (!me.items) me.items = {};
        if (!opponent.items) opponent.items = {};
        if (!myPet.equipment) myPet.equipment = {};
        if (!oppPet.equipment) oppPet.equipment = {};
        
        // Calcula stats com equipamentos
        const calcStats = (pet) => {
          let totalAtk = pet.attack;
          let totalDef = pet.defense;
          let totalSpd = pet.speed || 0;
          let critBonus = 0;
          let advantage = null;
          
          Object.entries(pet.equipment || {}).forEach(([slot, itemId]) => {
            const item = SHOP_ITEMS[itemId];
            if (item) {
              totalAtk += item.stats?.attack || 0;
              totalDef += item.stats?.defense || 0;
              totalSpd += item.stats?.speed || 0;
              critBonus += item.stats?.critBonus || 0;
              if (item.advantage) advantage = item.advantage;
            }
          });
          
          return { totalAtk, totalDef, totalSpd, critBonus, advantage };
        };
        
        const myStats = calcStats(myPet);
        const oppStats = calcStats(oppPet);
        
        // Sistema de vantagem de tipo
        const hasAdvantage = myStats.advantage === oppPet.type;
        const oppHasAdvantage = oppStats.advantage === myPet.type;
        
        // Determina quem ataca primeiro (velocidade)
        const myFirst = myStats.totalSpd >= oppStats.totalSpd;
        
        // Batalha detalhada
        let myHp = myPet.hp;
        let oppHp = oppPet.hp;
        let turn = 0;
        const maxTurns = 15;
        
        let battleLog = `‚ï≠‚îÅ‚îÅ‚îÅ‚ä± ‚öîÔ∏è *BATALHA DE PETS!* ‚öîÔ∏è ‚ä±‚îÅ‚îÅ‚îÅ‚ïÆ\n\n`;
        battleLog += `${myPet.emoji} *${myPet.name}* (Lv.${myPet.level})\n`;
        battleLog += `‚ù§Ô∏è ${myHp}/${myPet.maxHp} | ‚öîÔ∏è ${myStats.totalAtk} | üõ°Ô∏è ${myStats.totalDef} | ‚ö° ${myStats.totalSpd}\n`;
        if (hasAdvantage) battleLog += `‚ú® *VANTAGEM DE TIPO!*\n`;
        battleLog += `\nüÜö\n\n`;
        battleLog += `${oppPet.emoji} *${oppPet.name}* (Lv.${oppPet.level})\n`;
        battleLog += `‚ù§Ô∏è ${oppHp}/${oppPet.maxHp} | ‚öîÔ∏è ${oppStats.totalAtk} | üõ°Ô∏è ${oppStats.totalDef} | ‚ö° ${oppStats.totalSpd}\n`;
        if (oppHasAdvantage) battleLog += `‚ú® *VANTAGEM DE TIPO!*\n`;
        battleLog += `\n‚ï∞‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚ïØ\n\n`;
        battleLog += `‚ö° *IN√çCIO DA BATALHA!*\n\n`;
        
        while (myHp > 0 && oppHp > 0 && turn < maxTurns) {
          turn++;
          battleLog += `‚îÅ‚îÅ‚îÅ *Turno ${turn}* ‚îÅ‚îÅ‚îÅ\n`;
          
          const attackers = myFirst ? 
            [{ pet: myPet, stats: myStats, hp: myHp, isMe: true }, { pet: oppPet, stats: oppStats, hp: oppHp, isMe: false }] :
            [{ pet: oppPet, stats: oppStats, hp: oppHp, isMe: false }, { pet: myPet, stats: myStats, hp: myHp, isMe: true }];
          
          for (const attacker of attackers) {
            if (myHp <= 0 || oppHp <= 0) break;
            
            const defender = attacker.isMe ? 
              { pet: oppPet, stats: oppStats, hp: oppHp, isMe: false } :
              { pet: myPet, stats: myStats, hp: myHp, isMe: true };
            
            const advantage = attacker.isMe ? hasAdvantage : oppHasAdvantage;
            
            // Calcula dano
            let baseDmg = Math.max(1, attacker.stats.totalAtk - Math.floor(defender.stats.totalDef / 2));
            const variance = Math.floor(Math.random() * 11) - 5; // -5 a +5
            baseDmg += variance;
            
            // B√¥nus de vantagem: 50% de dano extra
            if (advantage) {
              baseDmg = Math.floor(baseDmg * 1.5);
            }
            
            // Chance de cr√≠tico (10% base + b√¥nus de equipamento)
            const critChance = 10 + (attacker.stats.critBonus || 0);
            const isCrit = Math.random() * 100 < critChance;
            if (isCrit) {
              baseDmg = Math.floor(baseDmg * 1.8);
            }
            
            // Aplica dano
            if (attacker.isMe) {
              oppHp -= baseDmg;
              battleLog += `‚öîÔ∏è ${attacker.pet.emoji} ${attacker.pet.name} atacou!\n`;
              if (advantage) battleLog += `   ‚ú® *SUPER EFETIVO!*\n`;
              if (isCrit) battleLog += `   üí• *CR√çTICO!*\n`;
              battleLog += `   üíî Dano: ${baseDmg}\n`;
              battleLog += `   ‚ù§Ô∏è HP Oponente: ${Math.max(0, oppHp)}/${oppPet.maxHp}\n`;
            } else {
              myHp -= baseDmg;
              battleLog += `üõ°Ô∏è ${attacker.pet.emoji} ${attacker.pet.name} contra-atacou!\n`;
              if (advantage) battleLog += `   ‚ú® *SUPER EFETIVO!*\n`;
              if (isCrit) battleLog += `   üí• *CR√çTICO!*\n`;
              battleLog += `   üíî Dano: ${baseDmg}\n`;
              battleLog += `   ‚ù§Ô∏è Seu HP: ${Math.max(0, myHp)}/${myPet.maxHp}\n`;
            }
          }
          
          battleLog += `\n`;
        }
        
        const won = myHp > oppHp;
        let reward = 0;
        let expGain = 0;
        let itemDropped = null;
        
        if (won) {
          // Recompensas
          reward = 1000 + (oppPet.level * 150);
          expGain = 75 + (oppPet.level * 5);
          
          me.wallet += reward;
          myPet.wins = (myPet.wins || 0) + 1;
          myPet.exp = (myPet.exp || 0) + expGain;
          oppPet.losses = (oppPet.losses || 0) + 1;
          
          // Sistema de drop de item (30% de chance)
          if (Math.random() < 0.3) {
            const oppEquipment = Object.entries(oppPet.equipment || {});
            if (oppEquipment.length > 0) {
              const [slot, itemId] = oppEquipment[Math.floor(Math.random() * oppEquipment.length)];
              const item = SHOP_ITEMS[itemId];
              
              if (item) {
                itemDropped = item.name;
                me.inventory[itemId] = (me.inventory[itemId] || 0) + 1;
              }
            }
          }
          
          battleLog += `‚ï≠‚îÅ‚îÅ‚îÅ‚ä± üèÜ *VIT√ìRIA!* üèÜ ‚ä±‚îÅ‚îÅ‚îÅ‚ïÆ\n`;
          battleLog += `‚îÇ ${myPet.emoji} *${myPet.name}* venceu!\n`;
          battleLog += `‚ï∞‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚ïØ\n\n`;
          battleLog += `üìä *RECOMPENSAS:*\n`;
          battleLog += `üí∞ Moedas: +${reward.toLocaleString()}\n`;
          battleLog += `‚ú® EXP: +${expGain}\n`;
          if (itemDropped) {
            battleLog += `üéÅ Item dropado: *${itemDropped}*\n`;
          }
          
          // Verifica level up
          if (myPet.exp >= myPet.level * 100) {
            myPet.level++;
            const atkGain = 2 + Math.floor(Math.random() * 3);
            const defGain = 1 + Math.floor(Math.random() * 2);
            const hpGain = 10 + Math.floor(Math.random() * 10);
            
            myPet.attack += atkGain;
            myPet.defense += defGain;
            myPet.maxHp += hpGain;
            myPet.hp = myPet.maxHp;
            myPet.exp = 0;
            
            battleLog += `\n‚ï≠‚îÅ‚îÅ‚îÅ‚ä± ‚≠ê *LEVEL UP!* ‚≠ê ‚ä±‚îÅ‚îÅ‚îÅ‚ïÆ\n`;
            battleLog += `‚îÇ ${myPet.emoji} ${myPet.name} ‚Üí Lv.${myPet.level}\n`;
            battleLog += `‚îÇ ‚öîÔ∏è ATK +${atkGain} | üõ°Ô∏è DEF +${defGain} | ‚ù§Ô∏è HP +${hpGain}\n`;
            battleLog += `‚ï∞‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚ïØ`;
          }
        } else {
          oppPet.wins = (oppPet.wins || 0) + 1;
          myPet.losses = (myPet.losses || 0) + 1;
          
          battleLog += `‚ï≠‚îÅ‚îÅ‚îÅ‚ä± üíÄ *DERROTA!* üíÄ ‚ä±‚îÅ‚îÅ‚îÅ‚ïÆ\n`;
          battleLog += `‚îÇ ${oppPet.emoji} *${oppPet.name}* venceu!\n`;
          battleLog += `‚ï∞‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚ïØ\n\n`;
          battleLog += `üí™ Continue treinando para melhorar!`;
        }
        
        me.lastPetBattle = Date.now();
        saveEconomy(econ);
        return reply(battleLog, { mentions: [target] });
        break;
      }

      // Apostar com Pets
      case 'apostarpet':
      case 'petbet': {
        if (!isGroup) return reply('‚öîÔ∏è Este comando funciona apenas em grupos com Modo RPG ativo.');
        if (!groupData.modorpg) return reply(`‚öîÔ∏è Modo RPG desativado! Use ${prefix}modorpg para ativar.`);
        
        const econ = loadEconomy();
        const me = getEcoUser(econ, sender);
        const target = (menc_jid2 && menc_jid2[0]) || null;
        
        if (!target) return reply(`‚ùå Marque algu√©m para apostar!\n\nüí° Uso: ${prefix}apostarpet <valor> <n¬∫ pet> @user`);
        if (target === sender) return reply('‚ùå Voc√™ n√£o pode apostar contra si mesmo!');
        
        const argsArr = q.split(' ');
        const betAmount = parseInt(argsArr[0]) || 0;
        const petIndex = parseInt(argsArr[1]) - 1;
        
        if (betAmount <= 0) return reply('‚ùå Informe um valor v√°lido para apostar!');
        if (betAmount > me.wallet) return reply('‚ùå Voc√™ n√£o tem dinheiro suficiente na carteira!');
        
        const opponent = getEcoUser(econ, target);
        if (betAmount > opponent.wallet) return reply('‚ùå Seu oponente n√£o tem dinheiro suficiente!');
        
        if (!me.pets || me.pets.length === 0) return reply('üêæ Voc√™ n√£o tem pets!');
        if (!opponent.pets || opponent.pets.length === 0) return reply('‚ùå Seu oponente n√£o tem pets!');
        
        if (isNaN(petIndex) || petIndex < 0 || petIndex >= me.pets.length) {
          return reply(`‚ùå Pet inv√°lido! Use ${prefix}pets para ver seus pets.`);
        }
        
        const myPet = me.pets[petIndex];
        const oppPet = opponent.pets[Math.floor(Math.random() * opponent.pets.length)];
        
        // Batalha
        let myHp = myPet.hp;
        let oppHp = oppPet.hp;
        
        while (myHp > 0 && oppHp > 0) {
          const myDmg = Math.max(1, myPet.attack - Math.floor(oppPet.defense / 2) + Math.floor(Math.random() * 10));
          oppHp -= myDmg;
          if (oppHp <= 0) break;
          
          const oppDmg = Math.max(1, oppPet.attack - Math.floor(myPet.defense / 2) + Math.floor(Math.random() * 10));
          myHp -= oppDmg;
        }
        
        const won = myHp > oppHp;
        
        let resultMsg = `‚ï≠‚îÅ‚îÅ‚îÅ‚ä± üé∞ *APOSTA DE PETS* ‚ä±‚îÅ‚îÅ‚îÅ‚ïÆ\n\n`;
        resultMsg += `${myPet.emoji} *${myPet.name}* (Lv.${myPet.level}) VS ${oppPet.emoji} *${oppPet.name}* (Lv.${oppPet.level})\n\n`;
        resultMsg += `üí∞ Aposta: ${betAmount.toLocaleString()}\n\n`;
        
        if (won) {
          me.wallet += betAmount;
          opponent.wallet -= betAmount;
          resultMsg += `üèÜ *VOC√ä VENCEU!*\nüí∞ Ganhou: +${betAmount.toLocaleString()}`;
        } else {
          me.wallet -= betAmount;
          opponent.wallet += betAmount;
          resultMsg += `üíÄ *VOC√ä PERDEU!*\nüí∏ Perdeu: -${betAmount.toLocaleString()}`;
        }
        
        resultMsg += `\n‚ï∞‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚ïØ`;
        
        saveEconomy(econ);
        return reply(resultMsg, { mentions: [target] });
      }

      // Equipar item no Pet
      case 'equippet':
      case 'equiparpet': {
        if (!isGroup) return reply('‚öîÔ∏è Este comando funciona apenas em grupos com Modo RPG ativo.');
        if (!groupData.modorpg) return reply(`‚öîÔ∏è Modo RPG desativado! Use ${prefix}modorpg para ativar.`);
        
        const econ = loadEconomy();
        const me = getEcoUser(econ, sender);
        
        if (!me.inventory) me.inventory = {};
        
        const argsArr = q.split(' ');
        const petIndex = parseInt(argsArr[0]) - 1;
        const itemId = argsArr.slice(1).join('_').toLowerCase();
        
        if (!me.pets || me.pets.length === 0) return reply('üêæ Voc√™ n√£o tem pets!');
        if (isNaN(petIndex) || petIndex < 0 || petIndex >= me.pets.length) {
          return reply(`‚ùå Pet inv√°lido!\n\nüí° Uso: ${prefix}equippet <n¬∫ pet> <item>`);
        }
        if (!itemId) return reply(`‚ùå Informe o item!\n\nüí° Uso: ${prefix}equippet <n¬∫ pet> <item>`);
        
        const pet = me.pets[petIndex];
        
        // Busca o item no invent√°rio
        const foundItemId = Object.keys(me.inventory).find(key => {
          return key.toLowerCase().includes(itemId) && me.inventory[key] > 0;
        });
        
        if (!foundItemId) return reply('‚ùå Voc√™ n√£o tem esse item no invent√°rio!');
        
        const item = SHOP_ITEMS[foundItemId];
        if (!item) return reply('‚ùå Item inv√°lido!');
        
        // Determina o slot do equipamento
        let slot = 'weapon';
        if (item.name.includes('Armadura') || item.name.includes('Armor')) slot = 'armor';
        else if (item.name.includes('Escudo') || item.name.includes('Shield')) slot = 'shield';
        else if (item.name.includes('Anel') || item.name.includes('Ring') || item.name.includes('Colar') || item.name.includes('Collar')) slot = 'accessory';
        else if (item.name.includes('Po√ß√£o') || item.name.includes('Potion')) slot = 'potion';
        else if (foundItemId.includes('slayer') || foundItemId.includes('bane') || foundItemId.includes('feather') || foundItemId.includes('talisman') || foundItemId.includes('eye')) slot = 'weapon';
        
        if (!pet.equipment) pet.equipment = {};
        
        // Se j√° tem item no slot, devolve ao invent√°rio
        if (pet.equipment[slot]) {
          me.inventory[pet.equipment[slot]] = (me.inventory[pet.equipment[slot]] || 0) + 1;
        }
        
        // Equipa o novo item
        pet.equipment[slot] = foundItemId;
        me.inventory[foundItemId]--;
        
        saveEconomy(econ);
        
        let text = `‚úÖ ${pet.emoji} *${pet.name}* equipou *${item.name}*!\n\n`;
        text += `üì¶ *Slot:* ${slot === 'weapon' ? '‚öîÔ∏è Arma' : slot === 'armor' ? 'üõ°Ô∏è Armadura' : slot === 'shield' ? 'üõ°Ô∏è Escudo' : slot === 'accessory' ? 'üíç Acess√≥rio' : 'üß™ Po√ß√£o'}\n\n`;
        
        if (item.stats) {
          text += `üìä *B√¥nus:*\n`;
          if (item.stats.attack) text += `‚öîÔ∏è ATK +${item.stats.attack}\n`;
          if (item.stats.defense) text += `üõ°Ô∏è DEF +${item.stats.defense}\n`;
          if (item.stats.speed) text += `‚ö° SPD +${item.stats.speed}\n`;
          if (item.stats.critBonus) text += `üí• CRIT +${item.stats.critBonus}%\n`;
        }
        
        if (item.advantage) {
          text += `\n‚ú® *Vantagem contra:* ${item.advantage}`;
        }
        
        return reply(text);
      }

      // Desequipar item do Pet
      case 'unequippet':
      case 'desequiparpet': {
        if (!isGroup) return reply('‚öîÔ∏è Este comando funciona apenas em grupos com Modo RPG ativo.');
        if (!groupData.modorpg) return reply(`‚öîÔ∏è Modo RPG desativado! Use ${prefix}modorpg para ativar.`);
        
        const econ = loadEconomy();
        const me = getEcoUser(econ, sender);
        
        const petIndex = parseInt(q) - 1;
        
        if (!me.pets || me.pets.length === 0) return reply('üêæ Voc√™ n√£o tem pets!');
        if (isNaN(petIndex) || petIndex < 0 || petIndex >= me.pets.length) {
          return reply(`‚ùå Pet inv√°lido!\n\nüí° Uso: ${prefix}unequippet <n¬∫ pet>`);
        }
        
        const pet = me.pets[petIndex];
        if (!pet.equipment || !pet.equipment.accessory) {
          return reply(`‚ùå ${pet.emoji} *${pet.name}* n√£o tem equipamentos!`);
        }
        
        const item = pet.equipment.accessory;
        me.inventory = me.inventory || {};
        me.inventory[item] = (me.inventory[item] || 0) + 1;
        delete pet.equipment.accessory;
        
        saveEconomy(econ);
        return reply(`‚úÖ *${item}* foi removido de ${pet.emoji} *${pet.name}* e devolvido ao invent√°rio!`);
      }

      // Equipar item para o Jogador
      case 'equipar':
      case 'equip': {
        if (!isGroup) return reply('‚öîÔ∏è Este comando funciona apenas em grupos com Modo RPG ativo.');
        if (!groupData.modorpg) return reply(`‚öîÔ∏è Modo RPG desativado! Use ${prefix}modorpg para ativar.`);
        
        const econ = loadEconomy();
        const me = getEcoUser(econ, sender);
        
        if (!me.equipment) me.equipment = { weapon: null, armor: null, helmet: null, boots: null, shield: null, accessory: null };
        if (!me.inventory) me.inventory = {};
        
        const itemId = q?.toLowerCase().trim();
        if (!itemId) {
          return reply(`‚ùå Informe o item para equipar!\n\nüí° Uso: ${prefix}equipar <item>\nüì¶ Veja seus itens: ${prefix}inventario`);
        }
        
        // Procura o item no invent√°rio
        let foundItemId = null;
        for (const [key, qty] of Object.entries(me.inventory)) {
          if (qty > 0 && (key.toLowerCase().includes(itemId) || key === itemId)) {
            foundItemId = key;
            break;
          }
        }
        
        if (!foundItemId) {
          return reply(`‚ùå Item n√£o encontrado no invent√°rio!\n\nüí° Use ${prefix}inventario para ver seus itens`);
        }
        
        const item = econ.shop[foundItemId];
        if (!item || item.type !== 'equipment') {
          return reply('‚ùå Este item n√£o pode ser equipado!');
        }
        
        const slot = item.slot;
        if (!slot) {
          return reply('‚ùå Item sem slot definido!');
        }
        
        // Se j√° tem item no slot, devolve ao invent√°rio
        if (me.equipment[slot]) {
          me.inventory[me.equipment[slot]] = (me.inventory[me.equipment[slot]] || 0) + 1;
        }
        
        // Equipa o novo item
        me.equipment[slot] = foundItemId;
        me.inventory[foundItemId]--;
        
        // Recalcula b√¥nus dos equipamentos e salva
        recalcEquipmentBonuses(me, econ.shop);
        saveEconomy(econ);
        
        let text = `‚úÖ Voc√™ equipou *${item.name}*!\n\n`;
        text += `üì¶ *Slot:* ${slot === 'weapon' ? '‚öîÔ∏è Arma' : slot === 'armor' ? 'üõ°Ô∏è Armadura' : slot === 'helmet' ? 'üé© Elmo' : slot === 'boots' ? 'üë¢ Botas' : slot === 'shield' ? 'üõ°Ô∏è Escudo' : 'üíç Acess√≥rio'}\n\n`;
        
        if (item.attackBonus) text += `‚öîÔ∏è Ataque: +${item.attackBonus}\n`;
        if (item.defenseBonus) text += `üõ°Ô∏è Defesa: +${item.defenseBonus}\n`;
        if (item.hpBonus) text += `‚ù§Ô∏è Vida: +${item.hpBonus}\n`;
        
        return reply(text);
      }

      // Desequipar item do Jogador
      case 'desequipar':
      case 'unequip': {
        if (!isGroup) return reply('‚öîÔ∏è Este comando funciona apenas em grupos com Modo RPG ativo.');
        if (!groupData.modorpg) return reply(`‚öîÔ∏è Modo RPG desativado! Use ${prefix}modorpg para ativar.`);
        
        const econ = loadEconomy();
        const me = getEcoUser(econ, sender);
        
        if (!me.equipment) me.equipment = { weapon: null, armor: null, helmet: null, boots: null, shield: null, accessory: null };
        if (!me.inventory) me.inventory = {};
        
        const slotName = q?.toLowerCase().trim();
        if (!slotName) {
          let text = `‚ùå Informe o slot para desequipar!\n\nüí° Uso: ${prefix}desequipar <slot>\n`;
          text += `üì¶ Slots dispon√≠veis: arma, armadura, elmo, botas, escudo, acess√≥rio`;
          return reply(text);
        }
        
        // Mapeia nomes de slot
        let slot = null;
        if (slotName.includes('arma') || slotName.includes('weapon')) slot = 'weapon';
        else if (slotName.includes('armadura') || slotName.includes('armor')) slot = 'armor';
        else if (slotName.includes('elmo') || slotName.includes('helmet')) slot = 'helmet';
        else if (slotName.includes('botas') || slotName.includes('boots')) slot = 'boots';
        else if (slotName.includes('escudo') || slotName.includes('shield')) slot = 'shield';
        else if (slotName.includes('acess√≥rio') || slotName.includes('accessory') || slotName.includes('anel')) slot = 'accessory';
        
        if (!slot) {
          return reply(`‚ùå Slot inv√°lido!\n\nüí° Use: arma, armadura, elmo, botas, escudo ou acess√≥rio`);
        }
        
        if (!me.equipment[slot]) {
          return reply(`‚ùå Voc√™ n√£o tem nada equipado no slot ${slotName}!`);
        }
        
        const itemId = me.equipment[slot];
        const item = econ.shop[itemId];
        if (!item) {
          return reply('‚ùå Item inv√°lido!');
        }
        
        // Devolve ao invent√°rio
        me.inventory[itemId] = (me.inventory[itemId] || 0) + 1;
        me.equipment[slot] = null;
        
        saveEconomy(econ);
        return reply(`‚úÖ *${item.name}* foi removido e devolvido ao invent√°rio!`);
      }

      // Sistema de Dungeons/Masmorras Solo
      case 'masmorrasolo':
      case 'dungeonsolo':
      case 'dg': {
        if (!isGroup) return reply('‚öîÔ∏è Este comando funciona apenas em grupos com Modo RPG ativo.');
        if (!groupData.modorpg) return reply(`‚öîÔ∏è Modo RPG desativado! Use ${prefix}modorpg para ativar.`);
        
        const econ = loadEconomy();
        const me = getEcoUser(econ, sender);
        
        const now = Date.now();
        if (me.lastDungeon && (now - me.lastDungeon) < 7200000) {
          const remaining = Math.ceil((7200000 - (now - me.lastDungeon)) / 60000);
          return reply(`‚è∞ Voc√™ est√° cansado da √∫ltima aventura!\n\nüïê Aguarde *${remaining} minutos*`);
        }
        
        const dungeons = [
          { name: 'üï∑Ô∏è Caverna das Aranhas', diff: 1, reward: [1000, 2000], exp: 100, emoji: 'üï∑Ô∏è' },
          { name: 'üßü Cripta dos Mortos', diff: 2, reward: [2000, 4000], exp: 200, emoji: 'üßü' },
          { name: 'üêâ Covil do Drag√£o', diff: 3, reward: [5000, 10000], exp: 500, emoji: 'üêâ' },
          { name: 'üëπ Fortaleza Demon√≠aca', diff: 4, reward: [10000, 20000], exp: 1000, emoji: 'üëπ' }
        ];
        
        const userLevel = me.level || 1;
        const availableDungeons = dungeons.filter(d => d.diff <= Math.ceil(userLevel / 5) + 1);
        
        if (!q) {
          let text = `‚ï≠‚îÅ‚îÅ‚îÅ‚ä± üó∫Ô∏è *MASMORRAS* ‚ä±‚îÅ‚îÅ‚îÅ‚ïÆ\n`;
          text += `‚îÇ Aventureiro: *${pushname}*\n`;
          text += `‚îÇ N√≠vel: ${userLevel}\n`;
          text += `‚ï∞‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚ïØ\n\n`;
          
          availableDungeons.forEach((d, i) => {
            text += `${i + 1}. ${d.emoji} *${d.name}*\n`;
            text += `‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ\n`;
            text += `‚îÇ üéØ Dificuldade: ${'‚≠ê'.repeat(d.diff)}\n`;
            text += `‚îÇ üí∞ Recompensa: ${d.reward[0].toLocaleString()}-${d.reward[1].toLocaleString()}\n`;
            text += `‚îÇ ‚ú® EXP: ${d.exp}\n`;
            text += `‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ\n\n`;
          });
          
          text += `üí° Use ${prefix}masmorra <n√∫mero>`;
          return reply(text);
        }
        
        const index = parseInt(q) - 1;
        if (isNaN(index) || index < 0 || index >= availableDungeons.length) {
          return reply('‚ùå Masmorra inv√°lida!');
        }
        
        const dungeon = availableDungeons[index];
        const userPower = (me.power || 100) + (me.attackBonus || 0);
        const success = Math.random() < (0.7 - (dungeon.diff * 0.1) + (userPower / 1000));
        
        me.lastDungeon = now;
        
        if (success) {
          const reward = Math.floor(Math.random() * (dungeon.reward[1] - dungeon.reward[0])) + dungeon.reward[0];
          me.wallet += reward;
          me.exp = (me.exp || 0) + dungeon.exp;
          
          // Verifica level up
          if (!me.level) me.level = 1;
          const nextLevelXp = 100 * Math.pow(1.5, me.level - 1);
          let leveledUp = false;
          let levelsGained = 0;
          
          while (me.exp >= nextLevelXp) {
            me.exp -= nextLevelXp;
            me.level++;
            levelsGained++;
            leveledUp = true;
            if (me.level > 100) break; // Safety cap
          }
          
          // Atualiza miss√£o de dungeon
          updateQuestProgress(me, 'dungeon', 1);
          
          let text = `‚ï≠‚îÅ‚îÅ‚îÅ‚ä± ‚öîÔ∏è *VIT√ìRIA!* ‚öîÔ∏è ‚ä±‚îÅ‚îÅ‚îÅ‚ïÆ\n`;
          text += `‚îÇ\n`;
          text += `‚îÇ ${dungeon.emoji} *${dungeon.name}*\n`;
          text += `‚îÇ\n`;
          text += `‚ï∞‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚ïØ\n\n`;
          text += `üéâ *Voc√™ derrotou todos os monstros!*\n\n`;
          text += `‚îå‚îÄ‚ä± üí∞ *RECOMPENSAS* ‚ä∞‚îÄ‚îê\n`;
          text += `‚îÇ\n`;
          text += `‚îÇ üíµ Moedas: *+${reward.toLocaleString()}*\n`;
          text += `‚îÇ ‚ú® EXP: *+${dungeon.exp}*\n`;
          
          if (leveledUp) {
            text += `‚îÇ\n`;
            text += `‚ï∞‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚ïØ\n\n`;
            text += `‚ï≠‚îÅ‚îÅ‚îÅ‚ä± ÔøΩ *LEVEL UP!* ÔøΩ ‚ä±‚îÅ‚îÅ‚îÅ‚ïÆ\n`;
            text += `‚îÇ\n`;
            text += `‚îÇ üìä Voc√™ subiu *${levelsGained}*`;
            text += levelsGained > 1 ? ` *n√≠veis!*\n` : ` *n√≠vel!*\n`;
            text += `‚îÇ ÔøΩ N√≠vel atual: *${me.level}*\n`;
            text += `‚îÇ\n`;
            text += `‚ï∞‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚ïØ`;
          } else {
            text += `‚îÇ\n`;
            text += `‚îî‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îò`;
          }
          
          text += `\n\nüèÜ *Continue assim, aventureiro!*`;
          
          saveEconomy(econ);
          return reply(text);
        } else {
          const loss = Math.floor(me.wallet * 0.1);
          me.wallet = Math.max(0, me.wallet - loss);
          
          let text = `‚ï≠‚îÅ‚îÅ‚îÅ‚ä± üíÄ *DERROTA!* üíÄ ‚ä±‚îÅ‚îÅ‚îÅ‚ïÆ\n`;
          text += `‚îÇ\n`;
          text += `‚îÇ ${dungeon.emoji} *${dungeon.name}*\n`;
          text += `‚îÇ\n`;
          text += `‚ï∞‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚ïØ\n\n`;
          text += `üòµ *Voc√™ foi derrotado pelos monstros...*\n\n`;
          text += `‚îå‚îÄ‚ä± üí∏ *PERDAS* ‚ä∞‚îÄ‚îê\n`;
          text += `‚îÇ\n`;
          text += `‚îÇ üíµ Moedas: *-${loss.toLocaleString()}*\n`;
          text += `‚îÇ\n`;
          text += `‚îî‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îò\n\n`;
          text += `üí™ *Fortale√ßa-se e tente novamente!*`;
          
          saveEconomy(econ);
          return reply(text);
        }
        break;
      }

      // Sistema de Chefe/Boss RPG
      case 'cheferpg':
      case 'bossrpg':
      case 'bossfight': {
        if (!isGroup) return reply('‚öîÔ∏è Este comando funciona apenas em grupos com Modo RPG ativo.');
        if (!groupData.modorpg) return reply(`‚öîÔ∏è Modo RPG desativado! Use ${prefix}modorpg para ativar.`);
        
        const econ = loadEconomy();
        const me = getEcoUser(econ, sender);
        
        const now = Date.now();
        const BOSS_COOLDOWN = 4 * 60 * 60 * 1000; // 4 horas
        
        if (me.lastBoss && (now - me.lastBoss) < BOSS_COOLDOWN) {
          const remaining = Math.ceil((BOSS_COOLDOWN - (now - me.lastBoss)) / 60000);
          const hours = Math.floor(remaining / 60);
          const mins = remaining % 60;
          return reply(`‚è∞ Voc√™ est√° exausto da √∫ltima batalha!\n\nüïê Aguarde *${hours}h ${mins}min*`);
        }
        
        const bosses = [
          { name: 'Drag√£o Anci√£o', emoji: 'üêâ', hp: 1000, attack: 80, defense: 50, reward: 15000, xp: 500 },
          { name: 'Golem de Pedra', emoji: 'üóø', hp: 1500, attack: 60, defense: 80, reward: 12000, xp: 400 },
          { name: 'Hidra Venenosa', emoji: 'üêç', hp: 800, attack: 100, defense: 30, reward: 18000, xp: 600 },
          { name: 'F√™nix Sombria', emoji: 'üî•', hp: 700, attack: 90, defense: 40, reward: 20000, xp: 700 },
          { name: 'Kraken Abissal', emoji: 'ü¶ë', hp: 1200, attack: 70, defense: 60, reward: 16000, xp: 550 }
        ];
        
        const boss = bosses[Math.floor(Math.random() * bosses.length)];
        const playerPower = (me.power || 100) + (me.level || 1) * 10;
        
        let bossHp = boss.hp;
        let playerHp = 100 + (me.level || 1) * 5;
        let turns = 0;
        const maxTurns = 15;
        
        let battleLog = `‚ï≠‚îÅ‚îÅ‚îÅ‚ä± üëπ *BOSS FIGHT!* ‚ä±‚îÅ‚îÅ‚îÅ‚ïÆ\n\n`;
        battleLog += `${boss.emoji} *${boss.name}*\n`;
        battleLog += `‚ù§Ô∏è HP: ${boss.hp} | ‚öîÔ∏è ATK: ${boss.attack} | üõ°Ô∏è DEF: ${boss.defense}\n\n`;
        battleLog += `VS\n\n`;
        battleLog += `‚öîÔ∏è *${pushname}* (Poder: ${playerPower})\n\n`;
        battleLog += `‚ï∞‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚ïØ\n\n`;
        
        while (bossHp > 0 && playerHp > 0 && turns < maxTurns) {
          // Player ataca
          const playerDmg = Math.max(10, Math.floor(playerPower * 0.3 + Math.random() * 30 - boss.defense * 0.2));
          bossHp -= playerDmg;
          
          if (bossHp <= 0) {
            battleLog += `‚öîÔ∏è Voc√™ desferiu o golpe final! (-${playerDmg} HP)\n`;
            break;
          }
          
          // Boss ataca
          const bossDmg = Math.max(5, boss.attack - Math.floor(playerPower * 0.1) + Math.floor(Math.random() * 20));
          playerHp -= bossDmg;
          
          turns++;
        }
        
        me.lastBoss = Date.now();
        me.stats = me.stats || {};
        
        if (bossHp <= 0) {
          me.wallet += boss.reward;
          me.stats.bossesDefeated = (me.stats.bossesDefeated || 0) + 1;
          
          battleLog += `\n‚ï≠‚îÅ‚îÅ‚îÅ‚ä± üèÜ *VIT√ìRIA!* ‚ä±‚îÅ‚îÅ‚îÅ‚ïÆ\n`;
          battleLog += `‚îÇ Voc√™ derrotou ${boss.emoji} *${boss.name}*!\n`;
          battleLog += `‚îÇ\n`;
          battleLog += `‚îÇ üí∞ Recompensa: +${boss.reward.toLocaleString()}\n`;
          battleLog += `‚îÇ ‚ú® XP: +${boss.xp}\n`;
          battleLog += `‚îÇ üèÖ Bosses derrotados: ${me.stats.bossesDefeated}\n`;
          battleLog += `‚ï∞‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚ïØ`;
        } else {
          battleLog += `\n‚ï≠‚îÅ‚îÅ‚îÅ‚ä± üíÄ *DERROTA!* ‚ä±‚îÅ‚îÅ‚îÅ‚ïÆ\n`;
          battleLog += `‚îÇ ${boss.emoji} *${boss.name}* foi mais forte!\n`;
          battleLog += `‚îÇ\n`;
          battleLog += `‚îÇ üí° Fique mais forte e tente novamente!\n`;
          battleLog += `‚îÇ üìà Use ${prefix}evoluir para melhorar\n`;
          battleLog += `‚ï∞‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚ïØ`;
        }
        
        saveEconomy(econ);
        return reply(battleLog);
      }

      // Sistema de Eventos
      case 'eventos':
      case 'events':
      case 'eventosrpg': {
        if (!isGroup) return reply('‚öîÔ∏è Este comando funciona apenas em grupos com Modo RPG ativo.');
        if (!groupData.modorpg) return reply(`‚öîÔ∏è Modo RPG desativado! Use ${prefix}modorpg para ativar.`);
        
        const now = new Date();
        const dayOfWeek = now.getDay();
        const hour = now.getHours();
        
        const weeklyEvents = [
          { day: 0, name: 'üéÅ Domingo de B√¥nus', desc: 'Recompensas dobradas em todas atividades!', active: dayOfWeek === 0 },
          { day: 1, name: '‚õèÔ∏è Segunda da Minera√ß√£o', desc: 'B√¥nus +50% em minera√ß√£o!', active: dayOfWeek === 1 },
          { day: 2, name: 'üé£ Ter√ßa da Pescaria', desc: 'Chances de peixes raros aumentadas!', active: dayOfWeek === 2 },
          { day: 3, name: 'üèπ Quarta da Ca√ßa', desc: 'Encontre presas lend√°rias!', active: dayOfWeek === 3 },
          { day: 4, name: 'üí∞ Quinta do Trabalho', desc: 'Sal√°rios aumentados em +75%!', active: dayOfWeek === 4 },
          { day: 5, name: '‚öîÔ∏è Sexta de Batalha', desc: 'XP dobrado em duelos e arenas!', active: dayOfWeek === 5 },
          { day: 6, name: 'üé∞ S√°bado do Cassino', desc: 'Chances de ganhar melhoradas!', active: dayOfWeek === 6 }
        ];
        
        const hourlyEvents = [
          { start: 12, end: 14, name: 'üåû Hora do Almo√ßo', desc: 'Cooldowns reduzidos pela metade!' },
          { start: 18, end: 20, name: 'üåô Happy Hour', desc: 'Ganhos +30% em todas atividades!' },
          { start: 0, end: 3, name: 'üåå Evento Noturno', desc: 'Encontre itens raros e misteriosos!' }
        ];
        
        let text = `‚ï≠‚îÅ‚îÅ‚îÅ‚ä± üéâ *EVENTOS RPG* ‚ä±‚îÅ‚îÅ‚îÅ‚ïÆ\n`;
        text += `‚îÇ üìÖ ${now.toLocaleDateString('pt-BR')}\n`;
        text += `‚îÇ üïê ${now.toLocaleTimeString('pt-BR', { hour: '2-digit', minute: '2-digit' })}\n`;
        text += `‚ï∞‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚ïØ\n\n`;
        
        text += `üóìÔ∏è *EVENTO DO DIA:*\n`;
        const todayEvent = weeklyEvents.find(e => e.active);
        if (todayEvent) {
          text += `‚ú® ${todayEvent.name}\n`;
          text += `   ${todayEvent.desc}\n\n`;
        }
        
        text += `‚è∞ *EVENTOS POR HOR√ÅRIO:*\n`;
        for (const ev of hourlyEvents) {
          const isActive = hour >= ev.start && hour < ev.end;
          const status = isActive ? 'üü¢ ATIVO' : '‚ö™ Inativo';
          text += `${status} ${ev.name} (${ev.start}h-${ev.end}h)\n`;
          text += `   ${ev.desc}\n\n`;
        }
        
        text += `‚ï≠‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚ïÆ\n`;
        text += `‚îÇ üìÖ *CALEND√ÅRIO SEMANAL:*\n`;
        for (const ev of weeklyEvents) {
          const days = ['Dom', 'Seg', 'Ter', 'Qua', 'Qui', 'Sex', 'S√°b'];
          const isToday = ev.active ? ' ‚Üê HOJE' : '';
          text += `‚îÇ ${days[ev.day]}: ${ev.name}${isToday}\n`;
        }
        text += `‚ï∞‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚ïØ`;
        
        return reply(text);
      }

      // Sistema de Duelos/PvP RPG
      case 'duelarrpg':
      case 'duelorpg':
      case 'duelrpg': {
        if (!isGroup) return reply('‚öîÔ∏è Este comando funciona apenas em grupos com Modo RPG ativo.');
        if (!groupData.modorpg) return reply(`‚öîÔ∏è Modo RPG desativado! Use ${prefix}modorpg para ativar.`);
        
        const econ = loadEconomy();
        const me = getEcoUser(econ, sender);
        
        const target = (menc_jid2 && menc_jid2[0]) || null;
        if (!target) return reply(`‚ùå Marque algu√©m para duelar!\n\nüí° Exemplo: ${prefix}duelarrpg @user`);
        if (target === sender) return reply('‚ùå Voc√™ n√£o pode duelar consigo mesmo!');
        
        const opponent = getEcoUser(econ, target);
        
        const now = Date.now();
        if (me.lastDuel && (now - me.lastDuel) < 600000) {
          const remaining = Math.ceil((600000 - (now - me.lastDuel)) / 60000);
          return reply(`‚è∞ Voc√™ est√° cansado! Aguarde ${remaining} minutos para outro duelo.`);
        }
        
        // Calcular stats
        const myPower = (me.power || 100) + (me.attackBonus || 0);
        const myDefense = (me.defenseBonus || 0) + 50;
        const oppPower = (opponent.power || 100) + (opponent.attackBonus || 0);
        const oppDefense = (opponent.defenseBonus || 0) + 50;
        
        let myHp = 200 + ((me.level || 1) * 10);
        let oppHp = 200 + ((opponent.level || 1) * 10);
        
        let text = `‚ï≠‚îÅ‚îÅ‚îÅ‚ä± ‚öîÔ∏è *DUELO* ‚ä±‚îÅ‚îÅ‚îÅ‚ïÆ\n`;
        text += `‚îÇ ${pushname} VS @${target.split('@')[0]}\n`;
        text += `‚ï∞‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚ïØ\n\n`;
        
        let turn = 0;
        let battle = '';
        
        while (myHp > 0 && oppHp > 0 && turn < 10) {
          turn++;
          
          // Meu ataque
          const myDmg = Math.max(5, myPower - Math.floor(Math.random() * oppDefense));
          oppHp -= myDmg;
          battle += `‚öîÔ∏è ${pushname}: -${myDmg} HP\n`;
          
          if (oppHp <= 0) break;
          
          // Ataque oponente
          const oppDmg = Math.max(5, oppPower - Math.floor(Math.random() * myDefense));
          myHp -= oppDmg;
          battle += `üõ°Ô∏è Oponente: -${oppDmg} HP\n\n`;
        }
        
        me.lastDuel = now;
        
        if (myHp > oppHp) {
          const reward = Math.floor((opponent.wallet || 0) * 0.05);
          me.wallet += reward;
          opponent.wallet = Math.max(0, opponent.wallet - reward);
          me.exp = (me.exp || 0) + 150;
          
          // Incrementar estat√≠sticas de batalha
          if (!me.battlesWon) me.battlesWon = 0;
          if (!opponent.battlesLost) opponent.battlesLost = 0;
          me.battlesWon++;
          opponent.battlesLost++;
          
          // Verifica level up
          if (!me.level) me.level = 1;
          const nextLevelXp = 100 * Math.pow(1.5, me.level - 1);
          let leveledUp = false;
          
          if (me.exp >= nextLevelXp) {
            me.exp -= nextLevelXp;
            me.level++;
            leveledUp = true;
          }
          
          // Atualiza miss√£o de duelo
          updateQuestProgress(me, 'duel', 1);
          
          text += battle;
          text += `\n‚ï≠‚îÅ‚îÅ‚îÅ‚ä± üèÜ *VIT√ìRIA!* üèÜ ‚ä±‚îÅ‚îÅ‚îÅ‚ïÆ\n`;
          text += `‚îÇ\n`;
          text += `‚îÇ üí∞ Recompensa: *+${reward.toLocaleString()}*\n`;
          text += `‚îÇ ‚ú® EXP: *+150*\n`;
          
          if (leveledUp) {
            text += `‚îÇ\n`;
            text += `‚ï∞‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚ïØ\n\n`;
            text += `‚ï≠‚îÅ‚îÅ‚îÅ‚ä± ÔøΩ *LEVEL UP!* üåü ‚ä±‚îÅ‚îÅ‚îÅ‚ïÆ\n`;
            text += `‚îÇ\n`;
            text += `‚îÇ üìä N√≠vel atual: *${me.level}*\n`;
            text += `‚îÇ ‚ù§Ô∏è HP restante: *${Math.max(0, myHp)}*\n`;
            text += `‚îÇ\n`;
            text += `‚ï∞‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚ïØ`;
          } else {
            text += `‚îÇ ‚ù§Ô∏è HP restante: *${Math.max(0, myHp)}*\n`;
            text += `‚îÇ\n`;
            text += `‚ï∞‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚ïØ`;
          }
          
          saveEconomy(econ);
          return reply(text, { mentions: [target] });
        } else {
          const loss = Math.floor(me.wallet * 0.05);
          me.wallet = Math.max(0, me.wallet - loss);
          opponent.wallet += loss;
          opponent.exp = (opponent.exp || 0) + 150;
          
          // Incrementar estat√≠sticas de batalha
          if (!me.battlesLost) me.battlesLost = 0;
          if (!opponent.battlesWon) opponent.battlesWon = 0;
          me.battlesLost++;
          opponent.battlesWon++;
          
          // Atualiza miss√£o de duelo mesmo em derrota
          updateQuestProgress(me, 'duel', 1);
          
          text += battle;
          text += `\n‚ï≠‚îÅ‚îÅ‚îÅ‚ä± üíÄ *DERROTA!* üíÄ ‚ä±‚îÅ‚îÅ‚îÅ‚ïÆ\n`;
          text += `‚îÇ\n`;
          text += `‚îÇ üí∏ Perdeu: *-${loss.toLocaleString()}*\n`;
          text += `‚îÇ\n`;
          text += `‚ï∞‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚ïØ\n\n`;
          text += `üí™ *Treine mais e desafie novamente!*`;
          
          saveEconomy(econ);
          return reply(text, { mentions: [target] });
        }
        break;
      }

      // Sistema de Arena
      case 'arena': {
        if (!isGroup) return reply('‚öîÔ∏è Este comando funciona apenas em grupos com Modo RPG ativo.');
        if (!groupData.modorpg) return reply(`‚öîÔ∏è Modo RPG desativado! Use ${prefix}modorpg para ativar.`);
        
        const econ = loadEconomy();
        const me = getEcoUser(econ, sender);
        
        const now = Date.now();
        if (me.lastArena && (now - me.lastArena) < 1800000) {
          const remaining = Math.ceil((1800000 - (now - me.lastArena)) / 60000);
          return reply(`‚è∞ A arena est√° fechada para voc√™! Aguarde ${remaining} minutos.`);
        }
        
        const levels = [
          { name: 'Bronze', minLevel: 1, reward: [1000, 3000], enemies: 3 },
          { name: 'Prata', minLevel: 5, reward: [3000, 7000], enemies: 5 },
          { name: 'Ouro', minLevel: 10, reward: [7000, 15000], enemies: 7 },
          { name: 'Platina', minLevel: 20, reward: [15000, 30000], enemies: 10 }
        ];
        
        const userLevel = me.level || 1;
        const available = levels.filter(l => l.minLevel <= userLevel);
        
        if (!q) {
          let text = `‚ï≠‚îÅ‚îÅ‚îÅ‚ä± üèõÔ∏è *ARENA* ‚ä±‚îÅ‚îÅ‚îÅ‚ïÆ\n`;
          text += `‚îÇ Gladiador: *${pushname}*\n`;
          text += `‚îÇ N√≠vel: ${userLevel}\n`;
          text += `‚ï∞‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚ïØ\n\n`;
          
          available.forEach((l, i) => {
            text += `${i + 1}. üèÜ *${l.name}*\n`;
            text += `‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ\n`;
            text += `‚îÇ üéØ N√≠vel M√≠nimo: ${l.minLevel}\n`;
            text += `‚îÇ üí∞ Pr√™mio: ${l.reward[0].toLocaleString()}-${l.reward[1].toLocaleString()}\n`;
            text += `‚îÇ ‚öîÔ∏è Inimigos: ${l.enemies}\n`;
            text += `‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ\n\n`;
          });
          
          text += `üí° Use ${prefix}arena <n√∫mero>`;
          return reply(text);
        }
        
        const index = parseInt(q) - 1;
        if (isNaN(index) || index < 0 || index >= available.length) {
          return reply('‚ùå Arena inv√°lida!');
        }
        
        const arena = available[index];
        const userPower = (me.power || 100) + (me.attackBonus || 0);
        const wins = Math.floor(Math.random() * (arena.enemies + 1));
        
        me.lastArena = now;
        
        if (wins >= arena.enemies * 0.7) {
          const reward = Math.floor(Math.random() * (arena.reward[1] - arena.reward[0])) + arena.reward[0];
          me.wallet += reward;
          me.exp = (me.exp || 0) + (arena.enemies * 50);
          
          // Incrementar estat√≠sticas de batalha (vit√≥ria na arena conta como batalhas ganhas)
          if (!me.battlesWon) me.battlesWon = 0;
          me.battlesWon += Math.floor(arena.enemies * 0.7); // Conta o n√∫mero de inimigos derrotados
          
          let text = `‚ï≠‚îÅ‚îÅ‚îÅ‚ä± üèÜ *VIT√ìRIA NA ARENA!* üèÜ ‚ä±‚îÅ‚îÅ‚îÅ‚ïÆ\n`;
          text += `‚îÇ\n`;
          text += `‚îÇ üèüÔ∏è Arena: *${arena.name}*\n`;
          text += `‚îÇ\n`;
          text += `‚ï∞‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚ïØ\n\n`;
          text += `‚öîÔ∏è *Derrotou:* ${wins}/${arena.enemies} inimigos\n\n`;
          text += `‚îå‚îÄ‚ä± üéÅ *RECOMPENSAS* ‚ä∞‚îÄ‚îê\n`;
          text += `‚îÇ\n`;
          text += `‚îÇ üí∞ Pr√™mio: *+${reward.toLocaleString()}*\n`;
          text += `‚îÇ ‚ú® EXP: *+${arena.enemies * 50}*\n`;
          text += `‚îÇ\n`;
          text += `‚îî‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îò\n\n`;
          text += `üéâ *A multid√£o te aclama!*`;
          
          saveEconomy(econ);
          return reply(text);
        } else {
          const loss = Math.floor(me.wallet * 0.08);
          me.wallet = Math.max(0, me.wallet - loss);
          
          // Incrementar estat√≠sticas de batalha (derrota na arena conta como batalha perdida)
          if (!me.battlesLost) me.battlesLost = 0;
          me.battlesLost++;
          
          let text = `‚ï≠‚îÅ‚îÅ‚îÅ‚ä± üíÄ *DERROTA NA ARENA* üíÄ ‚ä±‚îÅ‚îÅ‚îÅ‚ïÆ\n`;
          text += `‚îÇ\n`;
          text += `‚îÇ üèüÔ∏è Arena: *${arena.name}*\n`;
          text += `‚îÇ\n`;
          text += `‚ï∞‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚ïØ\n\n`;
          text += `‚öîÔ∏è *Derrotou:* ${wins}/${arena.enemies} inimigos\n\n`;
          text += `‚îå‚îÄ‚ä± üí∏ *PERDAS* ‚ä∞‚îÄ‚îê\n`;
          text += `‚îÇ\n`;
          text += `‚îÇ üíµ Moedas: *-${loss.toLocaleString()}*\n`;
          text += `‚îÇ\n`;
          text += `‚îî‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îò\n\n`;
          text += `üí™ *Continue treinando!*`;
          
          saveEconomy(econ);
          return reply(text);
        }
        break;
      }

      // Sistema de Encantamento
      case 'encantar':
      case 'enchant': {
        if (!isGroup) return reply('‚öîÔ∏è Este comando funciona apenas em grupos com Modo RPG ativo.');
        if (!groupData.modorpg) return reply(`‚öîÔ∏è Modo RPG desativado! Use ${prefix}modorpg para ativar.`);
        
        const econ = loadEconomy();
        const me = getEcoUser(econ, sender);
        
        if (!me.equipment || !me.equipment.weapon) {
          return reply(`‚ùå Voc√™ n√£o tem uma arma equipada!\n\nüí° Use ${prefix}equipar para equipar uma arma`);
        }
        
        const weapon = me.equipment.weapon;
        const enchantLevel = weapon.enchant || 0;
        
        if (enchantLevel >= 10) return reply('‚ú® Sua arma j√° est√° no encantamento m√°ximo (+10)!');
        
        const cost = (enchantLevel + 1) * 5000;
        const crystals = (enchantLevel + 1) * 3;
        
        if (!q) {
          let text = `‚ï≠‚îÅ‚îÅ‚îÅ‚ä± ‚ú® *ENCANTAR* ‚ä±‚îÅ‚îÅ‚îÅ‚ïÆ\n`;
          text += `‚îÇ Arma: ${weapon.emoji} *${weapon.name}*\n`;
          text += `‚îÇ Encantamento: +${enchantLevel}\n`;
          text += `‚ï∞‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚ïØ\n\n`;
          text += `üíé Pr√≥ximo n√≠vel: +${enchantLevel + 1}\n`;
          text += `‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ\n`;
          text += `‚îÇ üí∞ Custo: ${cost.toLocaleString()}\n`;
          text += `‚îÇ üíé Cristais: ${crystals}x\n`;
          text += `‚îÇ ‚öîÔ∏è ATK: +${(enchantLevel + 1) * 5}\n`;
          text += `‚îÇ üé≤ Chance: ${Math.max(30, 90 - (enchantLevel * 6))}%\n`;
          text += `‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ\n\n`;
          text += `‚ö†Ô∏è Falha pode destruir a arma!\n\n`;
          text += `üí° Use ${prefix}encantar confirmar`;
          return reply(text);
        }
        
        if (q.toLowerCase() !== 'confirmar') return reply('‚ùå Use "confirmar" para prosseguir');
        
        if (me.wallet < cost) return reply(`üí∞ Voc√™ precisa de ${cost.toLocaleString()} moedas!`);
        if (!me.materials || (me.materials.cristal || 0) < crystals) {
          return reply(`üíé Voc√™ precisa de ${crystals}x cristais!`);
        }
        
        me.wallet -= cost;
        me.materials.cristal -= crystals;
        
        const chance = Math.max(30, 90 - (enchantLevel * 6));
        const success = Math.random() * 100 < chance;
        
        if (success) {
          weapon.enchant = (weapon.enchant || 0) + 1;
          weapon.attack = (weapon.attack || 0) + 5;
          
          let text = `‚ï≠‚îÅ‚îÅ‚îÅ‚ä± ‚ú® *SUCESSO!* ‚ä±‚îÅ‚îÅ‚îÅ‚ïÆ\n`;
          text += `‚îÇ ${weapon.emoji} ${weapon.name} +${weapon.enchant}\n`;
          text += `‚ï∞‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚ïØ\n\n`;
          text += `üéâ Encantamento realizado!\n\n`;
          text += `‚öîÔ∏è ATK: ${weapon.attack}\n`;
          text += `‚ú® B√¥nus: +${weapon.enchant * 5}\n\n`;
          text += `üåü Sua arma est√° mais poderosa!`;
          
          saveEconomy(econ);
          return reply(text);
        } else {
          if (enchantLevel >= 5 && Math.random() < 0.3) {
            delete me.equipment.weapon;
            saveEconomy(econ);
            return reply(`üí• *FALHA CR√çTICA!*\n\nüò± Sua arma foi destru√≠da no processo...\n\n‚ö†Ô∏è Voc√™ perdeu: ${weapon.emoji} ${weapon.name} +${enchantLevel}`);
          } else {
            saveEconomy(econ);
            return reply(`‚ùå *FALHA!*\n\nüòî O encantamento falhou, mas sua arma permaneceu intacta.\n\nüí∞ Perdeu: ${cost.toLocaleString()}\nüíé Perdeu: ${crystals}x cristais`);
          }
        }
        break;
      }

      // Sistema de Desmontar
      case 'desmontar':
      case 'dismantle': {
        if (!isGroup) return reply('‚öîÔ∏è Este comando funciona apenas em grupos com Modo RPG ativo.');
        if (!groupData.modorpg) return reply(`‚öîÔ∏è Modo RPG desativado! Use ${prefix}modorpg para ativar.`);
        
        const econ = loadEconomy();
        const me = getEcoUser(econ, sender);
        
        if (!me.inventory || Object.keys(me.inventory).length === 0) {
          return reply(`‚ùå Seu invent√°rio est√° vazio!\n\nüí° Consiga equipamentos em masmorras`);
        }
        
        if (!q) {
          let text = `‚ï≠‚îÅ‚îÅ‚îÅ‚ä± üî® *DESMONTAR* ‚ä±‚îÅ‚îÅ‚îÅ‚ïÆ\n`;
          text += `‚îÇ Desmonte itens por materiais\n`;
          text += `‚ï∞‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚ïØ\n\n`;
          text += `üì¶ *SEU INVENT√ÅRIO:*\n\n`;
          
          let index = 1;
          for (const [item, qty] of Object.entries(me.inventory)) {
            if (qty > 0) {
              text += `${index}. ${item} (${qty}x)\n`;
              index++;
            }
          }
          
          text += `\nüí° Use ${prefix}desmontar <nome do item>`;
          return reply(text);
        }
        
        const itemName = q.toLowerCase();
        if (!me.inventory[itemName] || me.inventory[itemName] <= 0) {
          return reply('‚ùå Voc√™ n√£o tem este item!');
        }
        
        me.inventory[itemName]--;
        
        if (!me.materials) me.materials = {};
        
        const materials = ['ferro', 'madeira', 'couro', 'cristal'];
        const gained = {};
        
        materials.forEach(mat => {
          const amount = Math.floor(Math.random() * 5) + 1;
          me.materials[mat] = (me.materials[mat] || 0) + amount;
          gained[mat] = amount;
        });
        
        let text = `‚ï≠‚îÅ‚îÅ‚îÅ‚ä± üî® *DESMONTADO* ‚ä±‚îÅ‚îÅ‚îÅ‚ïÆ\n`;
        text += `‚îÇ Item: ${itemName}\n`;
        text += `‚ï∞‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚ïØ\n\n`;
        text += `üì¶ *MATERIAIS OBTIDOS:*\n\n`;
        
        for (const [mat, amt] of Object.entries(gained)) {
          text += `‚Ä¢ ${mat}: +${amt}\n`;
        }
        
        text += `\nüí° Use materiais para craftar e encantar!`;
        
        saveEconomy(econ);
        return reply(text);
        break;
      }

      // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
      // ‚öîÔ∏è SISTEMA DE CLASSES/PROFISS√ïES
      // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
      case 'classe':
      case 'class':
      case 'profissao': {
        if (!isGroup) return reply('‚öîÔ∏è Este comando funciona apenas em grupos com Modo RPG ativo.');
        if (!groupData.modorpg) return reply(`‚öîÔ∏è Modo RPG desativado! Use ${prefix}modorpg para ativar.`);

        const econ = loadEconomy();
        const me = getEcoUser(econ, sender);

        const classes = {
          'guerreiro': { emoji: '‚öîÔ∏è', name: 'Guerreiro', bonus: { attack: 20, defense: 10 }, skill: 'F√∫ria', skillDesc: '+30% dano em duelos' },
          'mago': { emoji: 'üßô', name: 'Mago', bonus: { attack: 15, mana: 30 }, skill: 'Arcano', skillDesc: '+25% ganho em minera√ß√£o m√°gica' },
          'arqueiro': { emoji: 'üèπ', name: 'Arqueiro', bonus: { attack: 18, speed: 15 }, skill: 'Precis√£o', skillDesc: '+20% chance de cr√≠tico' },
          'curandeiro': { emoji: 'üíö', name: 'Curandeiro', bonus: { defense: 15, healing: 25 }, skill: 'Cura', skillDesc: 'Cura 20% HP ap√≥s batalhas' },
          'ladino': { emoji: 'üó°Ô∏è', name: 'Ladino', bonus: { attack: 12, luck: 20 }, skill: 'Roubo', skillDesc: '+15% ganho em crimes' },
          'paladino': { emoji: 'üõ°Ô∏è', name: 'Paladino', bonus: { defense: 25, attack: 10 }, skill: 'Prote√ß√£o', skillDesc: '-20% dano recebido' }
        };

        if (!q) {
          let text = `‚ï≠‚îÅ‚îÅ‚îÅ‚ä± ‚öîÔ∏è *CLASSES* ‚ä±‚îÅ‚îÅ‚îÅ‚ïÆ\n`;
          text += `‚îÇ Sua classe: ${me.classe ? `${classes[me.classe]?.emoji} ${classes[me.classe]?.name}` : '‚ùå Nenhuma'}\n`;
          text += `‚ï∞‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚ïØ\n\n`;
          text += `üìú *CLASSES DISPON√çVEIS:*\n\n`;
          
          for (const [id, data] of Object.entries(classes)) {
            text += `${data.emoji} *${data.name}*\n`;
            text += `   ‚öîÔ∏è ATK +${data.bonus.attack || 0} | üõ°Ô∏è DEF +${data.bonus.defense || 0}\n`;
            text += `   ‚ú® ${data.skill}: ${data.skillDesc}\n\n`;
          }
          
          text += `üí° Use: ${prefix}classe <nome>\n`;
          text += `‚ö†Ô∏è Custo: 50.000 (trocar classe)`;
          
          return reply(text);
        }

        const classeEscolhida = q.toLowerCase().trim();
        
        if (!classes[classeEscolhida]) {
          return reply(`‚ùå Classe "${q}" n√£o existe!\n\nüìú Classes: guerreiro, mago, arqueiro, curandeiro, ladino, paladino`);
        }

        // Custo para trocar classe (gr√°tis se n√£o tiver nenhuma)
        const custo = me.classe ? 50000 : 0;
        if (me.wallet < custo) {
          return reply(`üí∞ Voc√™ precisa de ${custo.toLocaleString()} para trocar de classe!`);
        }

        me.wallet -= custo;
        me.classe = classeEscolhida;
        me.classeBonuses = classes[classeEscolhida].bonus;
        
        const classData = classes[classeEscolhida];
        
        saveEconomy(econ);
        return reply(`‚ï≠‚îÅ‚îÅ‚îÅ‚ä± ‚ú® *CLASSE ESCOLHIDA* ‚ä±‚îÅ‚îÅ‚îÅ‚ïÆ\n\n${classData.emoji} Voc√™ agora √© um *${classData.name}*!\n\nüìä *B√¥nus:*\n‚öîÔ∏è ATK +${classData.bonus.attack || 0}\nüõ°Ô∏è DEF +${classData.bonus.defense || 0}\n\n‚ú® *Habilidade:* ${classData.skill}\n${classData.skillDesc}\n\n‚ï∞‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚ïØ`);
      }

      // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
      // üè† SISTEMA DE HOUSING (CASAS)
      // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
      case 'casa':
      case 'house':
      case 'lar': {
        if (!isGroup) return reply('‚öîÔ∏è Este comando funciona apenas em grupos com Modo RPG ativo.');
        if (!groupData.modorpg) return reply(`‚öîÔ∏è Modo RPG desativado! Use ${prefix}modorpg para ativar.`);

        const econ = loadEconomy();
        const me = getEcoUser(econ, sender);

        const casas = {
          'barraca': { emoji: '‚õ∫', name: 'Barraca', price: 5000, bonus: { storage: 10, regen: 1 }, renda: 100 },
          'cabana': { emoji: 'üèöÔ∏è', name: 'Cabana de Madeira', price: 25000, bonus: { storage: 25, regen: 2 }, renda: 500 },
          'casa': { emoji: 'üè†', name: 'Casa Simples', price: 100000, bonus: { storage: 50, regen: 3 }, renda: 2000 },
          'mansao': { emoji: 'üè∞', name: 'Mans√£o', price: 500000, bonus: { storage: 100, regen: 5 }, renda: 10000 },
          'castelo': { emoji: 'üèØ', name: 'Castelo', price: 2000000, bonus: { storage: 200, regen: 10 }, renda: 50000 }
        };

        const decoracoes = {
          'altar': { emoji: '‚õ©Ô∏è', name: 'Altar M√≠stico', price: 10000, bonus: 'xp', value: 10 },
          'bau': { emoji: 'üì¶', name: 'Ba√∫ Refor√ßado', price: 15000, bonus: 'storage', value: 20 },
          'jardim': { emoji: 'üå∏', name: 'Jardim Encantado', price: 20000, bonus: 'regen', value: 2 },
          'forja': { emoji: 'üî•', name: 'Forja Caseira', price: 30000, bonus: 'craft', value: 15 },
          'biblioteca': { emoji: 'üìö', name: 'Biblioteca', price: 25000, bonus: 'xp', value: 15 }
        };

        if (!me.house) {
          me.house = { type: null, decorations: [], lastCollect: 0 };
        }

        const sub = args[0]?.toLowerCase();

        // Ver informa√ß√µes da casa
        if (!sub || sub === 'ver') {
          let text = `‚ï≠‚îÅ‚îÅ‚îÅ‚ä± üè† *SUA CASA* ‚ä±‚îÅ‚îÅ‚îÅ‚ïÆ\n\n`;
          
          if (me.house.type) {
            const casa = casas[me.house.type];
            text += `${casa.emoji} *${casa.name}*\n\n`;
            text += `üì¶ Armazenamento: +${casa.bonus.storage}\n`;
            text += `üíö Regenera√ß√£o: +${casa.bonus.regen}/h\n`;
            text += `üí∞ Renda passiva: ${casa.renda}/dia\n\n`;
            
            if (me.house.decorations.length > 0) {
              text += `üé® *Decora√ß√µes:*\n`;
              me.house.decorations.forEach(d => {
                const dec = decoracoes[d];
                if (dec) text += `‚Ä¢ ${dec.emoji} ${dec.name}\n`;
              });
            }
            
            text += `\nüí° *Comandos:*\n`;
            text += `‚Ä¢ ${prefix}casa coletar - Coletar renda\n`;
            text += `‚Ä¢ ${prefix}casa decorar <item>\n`;
            text += `‚Ä¢ ${prefix}casa upgrade`;
          } else {
            text += `‚ùå Voc√™ n√£o tem uma casa!\n\n`;
            text += `üèòÔ∏è *CASAS DISPON√çVEIS:*\n\n`;
            for (const [id, data] of Object.entries(casas)) {
              text += `${data.emoji} *${data.name}*\n`;
              text += `   üí∞ ${data.price.toLocaleString()} | üì¶ +${data.bonus.storage}\n\n`;
            }
            text += `üí° Use: ${prefix}casa comprar <tipo>`;
          }
          
          return reply(text);
        }

        // Comprar casa
        if (sub === 'comprar') {
          const tipo = args[1]?.toLowerCase();
          if (!tipo || !casas[tipo]) {
            return reply(`‚ùå Tipo inv√°lido!\n\nüèòÔ∏è Tipos: barraca, cabana, casa, mansao, castelo`);
          }
          
          const casa = casas[tipo];
          if (me.wallet < casa.price) {
            return reply(`üí∞ Voc√™ precisa de ${casa.price.toLocaleString()} para comprar ${casa.name}!`);
          }
          
          me.wallet -= casa.price;
          me.house.type = tipo;
          me.house.lastCollect = Date.now();
          
          saveEconomy(econ);
          return reply(`‚ï≠‚îÅ‚îÅ‚îÅ‚ä± üéâ *CASA COMPRADA* ‚ä±‚îÅ‚îÅ‚îÅ‚ïÆ\n\n${casa.emoji} Voc√™ comprou uma *${casa.name}*!\n\nüì¶ Armazenamento: +${casa.bonus.storage}\nüí∞ Renda: ${casa.renda}/dia\n\n‚ï∞‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚ïØ`);
        }

        // Coletar renda
        if (sub === 'coletar') {
          if (!me.house.type) return reply('‚ùå Voc√™ n√£o tem uma casa!');
          
          const casa = casas[me.house.type];
          const agora = Date.now();
          const tempoPassado = agora - me.house.lastCollect;
          const diasPassados = Math.floor(tempoPassado / 86400000);
          
          if (diasPassados < 1) {
            const tempoRestante = 86400000 - tempoPassado;
            const horas = Math.floor(tempoRestante / 3600000);
            const minutos = Math.floor((tempoRestante % 3600000) / 60000);
            return reply(`‚è∞ Pr√≥xima coleta em: ${horas}h ${minutos}min`);
          }
          
          const rendaTotal = Math.min(diasPassados, 7) * casa.renda; // M√°ximo 7 dias acumulados
          me.wallet += rendaTotal;
          me.house.lastCollect = agora;
          
          saveEconomy(econ);
          return reply(`üí∞ *RENDA COLETADA*\n\n${casa.emoji} ${casa.name}\nüíµ +${rendaTotal.toLocaleString()} (${Math.min(diasPassados, 7)} dias)`);
        }

        // Decorar
        if (sub === 'decorar') {
          if (!me.house.type) return reply('‚ùå Voc√™ n√£o tem uma casa!');
          
          const decId = args[1]?.toLowerCase();
          if (!decId) {
            let text = `üé® *DECORA√á√ïES DISPON√çVEIS*\n\n`;
            for (const [id, data] of Object.entries(decoracoes)) {
              const owned = me.house.decorations.includes(id) ? '‚úÖ' : '';
              text += `${data.emoji} *${data.name}* ${owned}\n`;
              text += `   üí∞ ${data.price.toLocaleString()} | +${data.value} ${data.bonus}\n\n`;
            }
            text += `üí° Use: ${prefix}casa decorar <nome>`;
            return reply(text);
          }
          
          if (!decoracoes[decId]) return reply('‚ùå Decora√ß√£o n√£o encontrada!');
          if (me.house.decorations.includes(decId)) return reply('‚ùå Voc√™ j√° tem essa decora√ß√£o!');
          
          const dec = decoracoes[decId];
          if (me.wallet < dec.price) return reply(`üí∞ Voc√™ precisa de ${dec.price.toLocaleString()}!`);
          
          me.wallet -= dec.price;
          me.house.decorations.push(decId);
          
          saveEconomy(econ);
          return reply(`üé® *DECORA√á√ÉO ADICIONADA*\n\n${dec.emoji} ${dec.name}\n‚ú® +${dec.value} ${dec.bonus}`);
        }

        return reply(`üí° Use: ${prefix}casa para ver op√ß√µes`);
      }

      // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
      // üè∞ SISTEMA DE DUNGEONS EM GRUPO
      // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
      case 'dungeon':
      case 'masmorra':
      case 'raid': {
        if (!isGroup) return reply('‚öîÔ∏è Este comando funciona apenas em grupos com Modo RPG ativo.');
        if (!groupData.modorpg) return reply(`‚öîÔ∏è Modo RPG desativado! Use ${prefix}modorpg para ativar.`);

        const econ = loadEconomy();
        const me = getEcoUser(econ, sender);
        const args = q ? q.trim().toLowerCase().split(/\s+/) : [];

        // Sistema de dungeons em grupo
        if (!econ.dungeonParties) econ.dungeonParties = {};
        
        const dungeons = {
          'floresta': { emoji: 'üå≤', name: 'Floresta Sombria', level: 1, players: 2, reward: 5000, xp: 200, boss: 'üê∫ Lobo Alfa' },
          'caverna': { emoji: 'üï≥Ô∏è', name: 'Caverna Cristalina', level: 5, players: 3, reward: 15000, xp: 500, boss: 'ü¶á Morcego Gigante' },
          'ruinas': { emoji: 'üèöÔ∏è', name: 'Ru√≠nas Antigas', level: 10, players: 3, reward: 35000, xp: 1000, boss: 'üíÄ Esqueleto Rei' },
          'vulcao': { emoji: 'üåã', name: 'Vulc√£o Ardente', level: 20, players: 4, reward: 80000, xp: 2500, boss: 'üî• Drag√£o de Fogo' },
          'abismo': { emoji: 'üï≥Ô∏è', name: 'Abismo Profundo', level: 35, players: 4, reward: 200000, xp: 6000, boss: 'üëπ Dem√¥nio Anci√£o' }
        };

        const sub = args[0]?.toLowerCase();

        // Listar dungeons
        if (!sub || sub === 'lista') {
          let text = `‚ï≠‚îÅ‚îÅ‚îÅ‚ä± üè∞ *DUNGEONS* ‚ä±‚îÅ‚îÅ‚îÅ‚ïÆ\n`;
          text += `‚îÇ Seu N√≠vel: ${me.level || 1}\n`;
          text += `‚ï∞‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚ïØ\n\n`;
          
          for (const [id, data] of Object.entries(dungeons)) {
            const available = (me.level || 1) >= data.level ? '‚úÖ' : 'üîí';
            text += `${data.emoji} *${data.name}* ${available}\n`;
            text += `   üìä Nv.${data.level}+ | üë• ${data.players} jogadores\n`;
            text += `   üí∞ ${data.reward.toLocaleString()} | ‚ú® ${data.xp} XP\n`;
            text += `   üëπ Boss: ${data.boss}\n\n`;
          }
          
          text += `üí° *Comandos:*\n`;
          text += `‚Ä¢ ${prefix}dungeon criar <tipo>\n`;
          text += `‚Ä¢ ${prefix}dungeon entrar <id>\n`;
          text += `‚Ä¢ ${prefix}dungeon iniciar`;
          
          return reply(text);
        }

        // Criar party
        if (sub === 'criar') {
          const tipo = args[1]?.toLowerCase();
          if (!tipo || !dungeons[tipo]) {
            return reply(`‚ùå Dungeon inv√°lida!\n\nüè∞ Tipos: floresta, caverna, ruinas, vulcao, abismo`);
          }
          
          const dg = dungeons[tipo];
          if ((me.level || 1) < dg.level) {
            return reply(`üîí Voc√™ precisa ser n√≠vel ${dg.level}+ para esta dungeon!`);
          }
          
          // Verificar se j√° est√° em uma party
          for (const [id, party] of Object.entries(econ.dungeonParties)) {
            if (party.members.includes(sender)) {
              return reply(`‚ùå Voc√™ j√° est√° em uma party!\n\nüí° Use ${prefix}dungeon sair para sair`);
            }
          }
          
          const partyId = `party_${Date.now()}`;
          econ.dungeonParties[partyId] = {
            id: partyId,
            type: tipo,
            leader: sender,
            members: [sender],
            maxMembers: dg.players,
            created: Date.now(),
            status: 'waiting'
          };
          
          saveEconomy(econ);
          return reply(`‚ï≠‚îÅ‚îÅ‚îÅ‚ä± üéâ *PARTY CRIADA* ‚ä±‚îÅ‚îÅ‚îÅ‚ïÆ\n\n${dg.emoji} *${dg.name}*\n\nüÜî ID: \`${partyId.slice(-8)}\`\nüë• Membros: 1/${dg.players}\nüëπ Boss: ${dg.boss}\n\nüí° Outros jogadores podem usar:\n${prefix}dungeon entrar ${partyId.slice(-8)}\n\n‚ï∞‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚ïØ`);
        }

        // Entrar em party
        if (sub === 'entrar') {
          const partyInput = args[1];
          if (!partyInput) return reply(`üí° Use: ${prefix}dungeon entrar <id da party>`);
          
          // Encontrar party
          let partyId = null;
          for (const id of Object.keys(econ.dungeonParties)) {
            if (id.endsWith(partyInput)) {
              partyId = id;
              break;
            }
          }
          
          if (!partyId || !econ.dungeonParties[partyId]) {
            return reply('‚ùå Party n√£o encontrada!');
          }
          
          const party = econ.dungeonParties[partyId];
          const dg = dungeons[party.type];
          
          if (party.members.includes(sender)) {
            return reply('‚ùå Voc√™ j√° est√° nesta party!');
          }
          
          if (party.members.length >= party.maxMembers) {
            return reply('‚ùå Party est√° cheia!');
          }
          
          if ((me.level || 1) < dg.level) {
            return reply(`üîí Voc√™ precisa ser n√≠vel ${dg.level}+!`);
          }
          
          party.members.push(sender);
          
          saveEconomy(econ);
          return reply(`‚úÖ Voc√™ entrou na party!\n\n${dg.emoji} *${dg.name}*\nüë• Membros: ${party.members.length}/${party.maxMembers}\n\n${party.members.length >= party.maxMembers ? `üéÆ Party completa! L√≠der pode usar ${prefix}dungeon iniciar` : '‚è≥ Aguardando mais membros...'}`);
        }

        // Iniciar dungeon
        if (sub === 'iniciar') {
          let myParty = null;
          for (const [id, party] of Object.entries(econ.dungeonParties)) {
            if (party.leader === sender) {
              myParty = party;
              break;
            }
          }
          
          if (!myParty) return reply('‚ùå Voc√™ n√£o √© l√≠der de nenhuma party!');
          
          const dg = dungeons[myParty.type];
          
          if (myParty.members.length < 2) {
            return reply(`‚ùå Voc√™ precisa de pelo menos 2 membros para iniciar!`);
          }
          
          // Calcular poder total do grupo
          let poderTotal = 0;
          myParty.members.forEach(member => {
            const user = getEcoUser(econ, member);
            poderTotal += (user.power || 100) + ((user.level || 1) * 10);
          });
          
          // Poder do boss
          const poderBoss = dg.level * 100 + dg.players * 50;
          
          // Calcular chance de vit√≥ria
          const chance = Math.min(95, Math.max(20, (poderTotal / poderBoss) * 50 + 25));
          const vitoria = Math.random() * 100 < chance;
          
          let text = `‚ï≠‚îÅ‚îÅ‚îÅ‚ä± ${dg.emoji} *${dg.name}* ‚ä±‚îÅ‚îÅ‚îÅ‚ïÆ\n\n`;
          text += `üë• *PARTY:*\n`;
          myParty.members.forEach(m => {
            const u = getEcoUser(econ, m);
            text += `‚Ä¢ @${m.split('@')[0]} (Nv.${u.level || 1})\n`;
          });
          text += `\n‚öîÔ∏è Poder Total: ${poderTotal}\n`;
          text += `üëπ Boss: ${dg.boss}\n\n`;
          
          if (vitoria) {
            text += `üéâ *VIT√ìRIA!*\n\n`;
            text += `üí∞ Recompensas (cada):\n`;
            text += `‚Ä¢ ${Math.floor(dg.reward / myParty.members.length).toLocaleString()} moedas\n`;
            text += `‚Ä¢ ${Math.floor(dg.xp / myParty.members.length)} XP\n`;
            
            // Distribuir recompensas
            myParty.members.forEach(m => {
              const u = getEcoUser(econ, m);
              u.wallet += Math.floor(dg.reward / myParty.members.length);
              u.xp = (u.xp || 0) + Math.floor(dg.xp / myParty.members.length);
            });
          } else {
            text += `üíÄ *DERROTA!*\n\n`;
            text += `üòî O boss ${dg.boss} foi muito forte...\n`;
            text += `üí° Tente novamente com mais poder!`;
          }
          
          text += `\n\n‚ï∞‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚ïØ`;
          
          // Deletar party
          delete econ.dungeonParties[myParty.id];
          
          saveEconomy(econ);
          return reply(text, { mentions: myParty.members });
        }

        // Sair da party
        if (sub === 'sair') {
          for (const [id, party] of Object.entries(econ.dungeonParties)) {
            if (party.members.includes(sender)) {
              if (party.leader === sender) {
                delete econ.dungeonParties[id];
                saveEconomy(econ);
                return reply('‚úÖ Party encerrada!');
              } else {
                party.members = party.members.filter(m => m !== sender);
                saveEconomy(econ);
                return reply('‚úÖ Voc√™ saiu da party!');
              }
            }
          }
          return reply('‚ùå Voc√™ n√£o est√° em nenhuma party!');
        }

        return reply(`üí° Use ${prefix}dungeon para ver comandos`);
      }

      // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
      // üõí MERCADO DE JOGADORES (AUCTION HOUSE)
      // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
      case 'mercadoplayer':
      case 'auction':
      case 'leilaoplayer': {
        if (!isGroup) return reply('‚öîÔ∏è Este comando funciona apenas em grupos com Modo RPG ativo.');
        if (!groupData.modorpg) return reply(`‚öîÔ∏è Modo RPG desativado! Use ${prefix}modorpg para ativar.`);

        const econ = loadEconomy();
        const me = getEcoUser(econ, sender);

        if (!econ.playerMarket) econ.playerMarket = { listings: [], fee: 0.05 }; // 5% taxa

        const sub = args[0]?.toLowerCase();

        // Listar itens √† venda
        if (!sub || sub === 'ver') {
          const listings = econ.playerMarket.listings.filter(l => l.seller !== sender);
          
          let text = `‚ï≠‚îÅ‚îÅ‚îÅ‚ä± üõí *MERCADO DE JOGADORES* ‚ä±‚îÅ‚îÅ‚îÅ‚ïÆ\n`;
          text += `‚îÇ Taxa: ${econ.playerMarket.fee * 100}% por venda\n`;
          text += `‚ï∞‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚ïØ\n\n`;
          
          if (listings.length === 0) {
            text += `üì¶ Nenhum item √† venda no momento!\n\n`;
          } else {
            text += `üì¶ *ITENS √Ä VENDA:*\n\n`;
            listings.slice(0, 15).forEach((item, i) => {
              text += `${i + 1}. *${item.name}* ${item.enchant ? `+${item.enchant}` : ''}\n`;
              text += `   üí∞ ${item.price.toLocaleString()} | üë§ @${item.seller.split('@')[0]}\n`;
            });
          }
          
          text += `\nüí° *Comandos:*\n`;
          text += `‚Ä¢ ${prefix}mercadoplayer vender <item> <pre√ßo>\n`;
          text += `‚Ä¢ ${prefix}mercadoplayer comprar <n¬∫>\n`;
          text += `‚Ä¢ ${prefix}mercadoplayer meus`;
          
          return reply(text);
        }

        // Vender item
        if (sub === 'vender') {
          const itemName = args[1];
          const preco = parseInt(args[2]);
          
          if (!itemName || !preco || preco < 100) {
            return reply(`üí° Use: ${prefix}mercadoplayer vender <item> <pre√ßo>\n\n‚ö†Ô∏è Pre√ßo m√≠nimo: 100`);
          }
          
          if (!me.inventory || !me.inventory[itemName] || me.inventory[itemName] <= 0) {
            return reply('‚ùå Voc√™ n√£o tem este item!');
          }
          
          // Verificar limite de an√∫ncios
          const meusAnuncios = econ.playerMarket.listings.filter(l => l.seller === sender);
          if (meusAnuncios.length >= 5) {
            return reply('‚ùå Voc√™ j√° tem 5 itens √† venda! Cancele algum primeiro.');
          }
          
          me.inventory[itemName]--;
          
          econ.playerMarket.listings.push({
            id: `listing_${Date.now()}`,
            name: itemName,
            price: preco,
            seller: sender,
            sellerName: pushname,
            created: Date.now()
          });
          
          saveEconomy(econ);
          return reply(`‚úÖ *ITEM LISTADO*\n\nüì¶ ${itemName}\nüí∞ ${preco.toLocaleString()}\n\n‚ö†Ô∏è Taxa de ${econ.playerMarket.fee * 100}% ser√° cobrada na venda`);
        }

        // Comprar item
        if (sub === 'comprar') {
          const index = parseInt(args[1]) - 1;
          const listings = econ.playerMarket.listings.filter(l => l.seller !== sender);
          
          if (isNaN(index) || index < 0 || index >= listings.length) {
            return reply('‚ùå N√∫mero inv√°lido! Use o n√∫mero da lista.');
          }
          
          const listing = listings[index];
          
          if (me.wallet < listing.price) {
            return reply(`üí∞ Voc√™ precisa de ${listing.price.toLocaleString()}!`);
          }
          
          // Processar compra
          me.wallet -= listing.price;
          if (!me.inventory) me.inventory = {};
          me.inventory[listing.name] = (me.inventory[listing.name] || 0) + 1;
          
          // Pagar vendedor (menos taxa)
          const vendedor = getEcoUser(econ, listing.seller);
          const valorLiquido = Math.floor(listing.price * (1 - econ.playerMarket.fee));
          vendedor.wallet += valorLiquido;
          
          // Remover do mercado
          econ.playerMarket.listings = econ.playerMarket.listings.filter(l => l.id !== listing.id);
          
          saveEconomy(econ);
          return reply(`‚úÖ *COMPRA REALIZADA*\n\nüì¶ ${listing.name}\nüí∞ -${listing.price.toLocaleString()}\n\nüì¨ Vendedor @${listing.seller.split('@')[0]} recebeu ${valorLiquido.toLocaleString()}`);
        }

        // Meus an√∫ncios
        if (sub === 'meus') {
          const meusAnuncios = econ.playerMarket.listings.filter(l => l.seller === sender);
          
          if (meusAnuncios.length === 0) {
            return reply('üì¶ Voc√™ n√£o tem nenhum item √† venda!');
          }
          
          let text = `üõí *SEUS AN√öNCIOS*\n\n`;
          meusAnuncios.forEach((item, i) => {
            text += `${i + 1}. *${item.name}*\n`;
            text += `   üí∞ ${item.price.toLocaleString()}\n\n`;
          });
          
          text += `üí° Use ${prefix}mercadoplayer cancelar <n¬∫> para cancelar`;
          
          return reply(text);
        }

        // Cancelar an√∫ncio
        if (sub === 'cancelar') {
          const meusAnuncios = econ.playerMarket.listings.filter(l => l.seller === sender);
          const index = parseInt(args[1]) - 1;
          
          if (isNaN(index) || index < 0 || index >= meusAnuncios.length) {
            return reply('‚ùå N√∫mero inv√°lido!');
          }
          
          const listing = meusAnuncios[index];
          
          // Devolver item
          if (!me.inventory) me.inventory = {};
          me.inventory[listing.name] = (me.inventory[listing.name] || 0) + 1;
          
          // Remover do mercado
          econ.playerMarket.listings = econ.playerMarket.listings.filter(l => l.id !== listing.id);
          
          saveEconomy(econ);
          return reply(`‚úÖ An√∫ncio cancelado! ${listing.name} devolvido ao invent√°rio.`);
        }

        return reply(`üí° Use ${prefix}mercadoplayer para ver comandos`);
      }

      // Sistema de Miss√µes
      case 'missoes':
      case 'quests':
      case 'missao': {
        if (!isGroup) return reply('‚öîÔ∏è Este comando funciona apenas em grupos com Modo RPG ativo.');
        if (!groupData.modorpg) return reply(`‚öîÔ∏è Modo RPG desativado! Use ${prefix}modorpg para ativar.`);
        
        const econ = loadEconomy();
        const me = getEcoUser(econ, sender);
        
        if (!me.quests) {
          me.quests = {
            daily: [],
            lastReset: Date.now()
          };
        }
        
        // Reset di√°rio
        const now = Date.now();
        if (now - me.quests.lastReset > 86400000) {
          me.quests.daily = [];
          me.quests.lastReset = now;
        }
        
        // Gerar miss√µes di√°rias
        if (me.quests.daily.length === 0) {
          const allQuests = [
            { id: 'duel_3', name: '‚öîÔ∏è Duelar 3 vezes', reward: 5000, exp: 200, progress: 0, goal: 3, claimed: false },
            { id: 'dungeon_2', name: 'üó∫Ô∏è Completar 2 dungeons', reward: 8000, exp: 300, progress: 0, goal: 2, claimed: false },
            { id: 'gather_10', name: 'üåæ Coletar 10 recursos', reward: 3000, exp: 150, progress: 0, goal: 10, claimed: false },
            { id: 'cook_5', name: 'üë®‚Äçüç≥ Cozinhar 5 receitas', reward: 4000, exp: 180, progress: 0, goal: 5, claimed: false },
            { id: 'train_pet', name: 'üêæ Treinar pet 5 vezes', reward: 6000, exp: 250, progress: 0, goal: 5, claimed: false }
          ];
          
          // Escolher 3 miss√µes aleat√≥rias
          const shuffled = allQuests.sort(() => Math.random() - 0.5);
          me.quests.daily = shuffled.slice(0, 3);
        }
        
        // Garante que todas as miss√µes existentes tenham a propriedade claimed
        me.quests.daily.forEach(quest => {
          if (quest.claimed === undefined) {
            quest.claimed = false;
          }
        });
        
        let text = `‚ï≠‚îÅ‚îÅ‚îÅ‚ä± üìú *MISS√ïES DI√ÅRIAS* ‚ä±‚îÅ‚îÅ‚îÅ‚ïÆ\n`;
        text += `‚îÇ Aventureiro: *${pushname}*\n`;
        text += `‚ï∞‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚ïØ\n\n`;
        
        me.quests.daily.forEach((quest, i) => {
          const completed = quest.progress >= quest.goal;
          const claimed = quest.claimed === true;
          text += `${i + 1}. ${quest.name}\n`;
          text += `‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ\n`;
          text += `‚îÇ üìä Progresso: ${quest.progress}/${quest.goal}\n`;
          text += `‚îÇ üí∞ Recompensa: ${quest.reward.toLocaleString()}\n`;
          text += `‚îÇ ‚ú® EXP: ${quest.exp}\n`;
          if (claimed) {
            text += `‚îÇ ‚úÖ Reivindicado!\n`;
          } else if (completed) {
            text += `‚îÇ ‚úÖ Completo! Use ${prefix}reivindicar\n`;
          } else {
            text += `‚îÇ ‚è≥ Em andamento\n`;
          }
          text += `‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ\n\n`;
        });
        
        const timeUntilReset = 86400000 - (now - me.quests.lastReset);
        const hoursLeft = Math.floor(timeUntilReset / 3600000);
        text += `‚è∞ Reseta em: ${hoursLeft}h`;
        
        saveEconomy(econ);
        return reply(text);
        break;
      }

      // Guerra de Cl√£s
      case 'guerra':
      case 'war':
      case 'guerracla': {
        if (!isGroup) return reply('‚öîÔ∏è Este comando funciona apenas em grupos com Modo RPG ativo.');
        if (!groupData.modorpg) return reply(`‚öîÔ∏è Modo RPG desativado! Use ${prefix}modorpg para ativar.`);
        
        const econ = loadEconomy();
        const me = getEcoUser(econ, sender);
        
        if (!me.clan) return reply('üè∞ Voc√™ precisa estar em um cl√£ para declarar guerra!');
        
        const myClan = econ.clans[me.clan];
        if (myClan.leader !== sender) return reply('üëë Apenas o l√≠der pode declarar guerra!');
        
        if (!q) {
          let text = `‚ï≠‚îÅ‚îÅ‚îÅ‚ä± ‚öîÔ∏è *GUERRA DE CL√ÉS* ‚ä±‚îÅ‚îÅ‚îÅ‚ïÆ\n`;
          text += `‚îÇ Seu Cl√£: *${myClan.name}*\n`;
          text += `‚ï∞‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚ïØ\n\n`;
          text += `üí° Em breve: Sistema de guerras entre cl√£s!\n\n`;
          text += `üèÜ Recursos:\n`;
          text += `‚Ä¢ Batalhas estrat√©gicas\n`;
          text += `‚Ä¢ Territ√≥rio conquist√°vel\n`;
          text += `‚Ä¢ Recompensas √©picas\n`;
          text += `‚Ä¢ Rankings de cl√£s\n\n`;
          text += `‚è∞ Sistema em desenvolvimento...`;
          return reply(text);
        }
        
        return reply('‚ö†Ô∏è Sistema de guerras ser√° implementado em breve!');
        break;
      }

      // Criar cl√£
      case 'criarcla':
      case 'criarcl√£': {
        if (!isGroup) return reply('‚öîÔ∏è Este comando funciona apenas em grupos com Modo RPG ativo.');
        if (!groupData.modorpg) return reply(`‚öîÔ∏è Modo RPG desativado! Use ${prefix}modorpg para ativar.`);

        const econ = loadEconomy();
        const me = getEcoUser(econ, sender);

        if (!q) return reply(`‚ùó Use: ${prefix}criarcla <nome do cl√£>`);
        if (me.clan) return reply('‚ùå Voc√™ j√° pertence a um cl√£!');

        const clanName = q.trim();
        if (clanName.length < 3 || clanName.length > 24) return reply('‚ùå Nome do cl√£ precisa ter entre 3 e 24 caracteres.');

        // Verificar duplicado
  const baseNormalized = normalizeClanName(clanName);
  const nameTaken = Object.values(econ.clans || {}).some(c => c.name && normalizeClanName(c.name) === baseNormalized);
        if (nameTaken) return reply('‚ùå J√° existe um cl√£ com esse nome!');

        // Custo para criar cl√£
        const clanCost = 20000;
        if ((me.wallet || 0) < clanCost) return reply(`üí∞ Voc√™ precisa de ${clanCost.toLocaleString()} moedas para criar um cl√£.`);

        me.wallet -= clanCost;

        const id = `clan_${econ.clanCounter++}`;
        econ.clans = econ.clans || {};
  econ.clans[id] = { id, name: clanName, leader: sender, members: [sender], pendingInvites: [], createdAt: Date.now() };

        me.clan = id;

        saveEconomy(econ);
        return reply(`‚úÖ Cl√£ criado com sucesso!\nNome: *${clanName}*\nL√≠der: @${sender.split('@')[0]}`, { mentions: [sender] });
        break;
      }

      // Info de Cl√£
      case 'cla':
      case 'claninfo': {
        if (!isGroup) return reply('‚öîÔ∏è Este comando funciona apenas em grupos com Modo RPG ativo.');
        if (!groupData.modorpg) return reply(`‚öîÔ∏è Modo RPG desativado! Use ${prefix}modorpg para ativar.`);

        const econ = loadEconomy();
        const me = getEcoUser(econ, sender);

        let clanObj = null;
        if (!q && me.clan) clanObj = econ.clans[me.clan];
        if (q) {
          // procurar por ID ou por nome
          const qTrim = q.trim();
          const qNormalized = normalizeClanName(qTrim);
          clanObj = econ.clans[qTrim] || Object.values(econ.clans || {}).find(c => c.name && normalizeClanName(c.name) === qNormalized);
        }

        if (!clanObj) return reply('‚ùå Cl√£ n√£o encontrado. Voc√™ pode usar: ' + prefix + 'criarcla <nome>');

        let text = `‚ï≠‚îÅ‚îÅ‚îÅ‚ä± üè∞ *INFORMA√á√ïES DO CL√É* ‚ä±‚îÅ‚îÅ‚îÅ‚ïÆ\n`;
        text += `‚îÇ Nome: *${clanObj.name}*\n`;
        text += `‚îÇ ID: ${clanObj.id}\n`;
        text += `‚îÇ L√≠der: @${clanObj.leader.split('@')[0]}\n`;
        text += `‚ï∞‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚ïØ\n\n`;
        text += `üë• Membros (${clanObj.members.length}):\n`;

        const mentions = [];
        clanObj.members.forEach(m => {
          mentions.push(m);
          text += `‚Ä¢ @${m.split('@')[0]}\n`;
        });
        // Mostrar convites pendentes
        if (Array.isArray(clanObj.pendingInvites) && clanObj.pendingInvites.length > 0) {
          text += `\nüì® Convites pendentes (${clanObj.pendingInvites.length}):\n`;
          clanObj.pendingInvites.forEach(m => { text += `‚Ä¢ @${m.split('@')[0]}\n`; mentions.push(m); });
        }

        return reply(text, { mentions });
        break;
      }

      // Convidar membro para o cl√£
      case 'convidar':
      case 'invite':
      case 'convite': {
        if (!isGroup) return reply('‚öîÔ∏è Este comando funciona apenas em grupos com Modo RPG ativo.');
        if (!groupData.modorpg) return reply(`‚öîÔ∏è Modo RPG desativado! Use ${prefix}modorpg para ativar.`);

        const econ = loadEconomy();
        const me = getEcoUser(econ, sender);

        if (!me.clan) return reply('‚ùå Voc√™ precisa estar em um cl√£ para convidar membros!');

        const clan = econ.clans[me.clan];
        if (!clan) { me.clan = null; saveEconomy(econ); return reply('‚ùå Seu cl√£ n√£o foi encontrado.'); }

        // Apenas l√≠der pode convidar por enquanto
        if (clan.leader !== sender) return reply('üëë Apenas o l√≠der do cl√£ pode convidar novos membros!');
    const target = (menc_jid2 && menc_jid2[0]) || null;
    if (!target) return reply(`‚ùó Marque um membro para convidar. Ex: ${prefix}convidar @user`);
    if (target === sender) return reply('‚ùå Voc√™ n√£o pode convidar voc√™ mesmo!');

    const targetUser = getEcoUser(econ, target);
    if (targetUser.clan) return reply('‚ùå Esta pessoa j√° pertence a outro cl√£!');

    // Usar convites pendentes em vez de adicionar imediatamente.
    clan.pendingInvites = clan.pendingInvites || [];
    if (clan.pendingInvites.includes(target)) return reply('‚ùó Este usu√°rio j√° tem um convite pendente para o cl√£.');
    clan.pendingInvites.push(target);
    saveEconomy(econ);

    // Notificar no grupo com men√ß√£o se poss√≠vel
    await reply(`üì® Convite enviado para @${target.split('@')[0]}!
  Use ${prefix}aceitarconvite ${clan.id} para aceitar.`, { mentions: [target] });
    break;
      }
      
      // Remover convite pendente (apenas l√≠der)
      case 'rmconvite':
      case 'removerconvite': {
        if (!isGroup) return reply('‚öîÔ∏è Este comando funciona apenas em grupos com Modo RPG ativo.');
        if (!groupData.modorpg) return reply(`‚öîÔ∏è Modo RPG desativado! Use ${prefix}modorpg para ativar.`);
        const econ2 = loadEconomy();
        const me2 = getEcoUser(econ2, sender);
        if (!me2.clan) return reply('‚ùå Voc√™ n√£o faz parte de nenhum cl√£.');
        const clan2 = econ2.clans[me2.clan];
        if (!clan2) { me2.clan = null; saveEconomy(econ2); return reply('‚ùå Seu cl√£ n√£o foi encontrado.'); }
        if (clan2.leader !== sender) return reply('üëë Apenas o l√≠der pode remover convites.');
        const target2 = (menc_jid2 && menc_jid2[0]) || null;
        if (!target2) return reply(`‚ùó Marque um usu√°rio para remover o convite. Ex: ${prefix}rmconvite @user`);
        if (!Array.isArray(clan2.pendingInvites) || !clan2.pendingInvites.includes(target2)) return reply('‚ùå Este usu√°rio n√£o tem um convite pendente para o seu cl√£.');
        clan2.pendingInvites = clan2.pendingInvites.filter(id => id !== target2);
        saveEconomy(econ2);
        return reply(`üóëÔ∏è Convite removido para @${target2.split('@')[0]}.`, { mentions: [target2] });
      }
        break;
      

      // Sair do cl√£
      case 'sair': {
        if (!isGroup) return reply('‚öîÔ∏è Este comando funciona apenas em grupos com Modo RPG ativo.');
        if (!groupData.modorpg) return reply(`‚öîÔ∏è Modo RPG desativado! Use ${prefix}modorpg para ativar.`);

        const econ = loadEconomy();
        const me = getEcoUser(econ, sender);

        if (!me.clan) return reply('‚ùå Voc√™ n√£o faz parte de nenhum cl√£.');

        const clan = econ.clans[me.clan];
        if (!clan) {
          me.clan = null;
          saveEconomy(econ);
          return reply('‚ùå Seu cl√£ n√£o foi encontrado, seu status foi resetado.');
        }

        // Se for l√≠der
        if (clan.leader === sender) {
          // Se houver outros membros, transferir lideran√ßa para o primeiro membro
          const remaining = clan.members.filter(m => m !== sender);
          if (remaining.length === 0) {
            // Remover refer√™ncia do cl√£ em todos os membros
            (clan.members || []).forEach(m => {
              const u = getEcoUser(econ, m);
              if (u.clan === clan.id) u.clan = null;
            });
            delete econ.clans[clan.id];
            me.clan = null;
            saveEconomy(econ);
            return reply('üóëÔ∏è Voc√™ saiu e o cl√£ foi dissolvido pois n√£o h√° mais membros.');
          } else {
            const newLeader = remaining[0];
            clan.leader = newLeader;
            clan.members = remaining;
            me.clan = null;
            saveEconomy(econ);
            return reply(`üîÅ Voc√™ deixou o cl√£ e a lideran√ßa foi transferida para @${newLeader.split('@')[0]}.`, { mentions: [newLeader] });
          }
        }

        // Membro comum
        clan.members = clan.members.filter(m => m !== sender);
        me.clan = null;
        // remover convites pendentes que o membro tinha em outros cl√£s (limpeza)
        for (const [k, c] of Object.entries(econ.clans || {})) {
          if (Array.isArray(c.pendingInvites) && c.pendingInvites.includes(sender)) {
            c.pendingInvites = c.pendingInvites.filter(x => x !== sender);
          }
        }
        saveEconomy(econ);
        return reply('‚úÖ Voc√™ saiu do cl√£.');
        break;
      }
      // Aceitar convite de cl√£
      case 'aceitarconvite':
      case 'aceitarrpg': {
        if (!isGroup) return reply('‚öîÔ∏è Comandos de cl√£ s√≥ funcionam em grupos com Modo RPG.');
        if (!groupData.modorpg) return reply(`‚öîÔ∏è Modo RPG desativado! Use ${prefix}modorpg para ativar.`);

        const econ = loadEconomy();
        const me = getEcoUser(econ, sender);

        // Procurar convites pendentes
        const clansWithInvite = Object.values(econ.clans || {}).filter(c => Array.isArray(c.pendingInvites) && c.pendingInvites.includes(sender));
        if (!q && clansWithInvite.length === 0) return reply('‚ùå Voc√™ n√£o possui convites pendentes para cl√£s.');
        let clanObj = null;
        if (!q) {
          if (clansWithInvite.length === 1) clanObj = clansWithInvite[0];
          else return reply('üîé Voc√™ possui m√∫ltiplos convites. Use: ' + prefix + 'aceitarconvite <clanId>');
        } else {
          const qLower = q.trim().toLowerCase();
          clanObj = econ.clans[q] || Object.values(econ.clans || {}).find(c => (c.name||'').toLowerCase() === qLower);
        }
        if (!clanObj) return reply('‚ùå Cl√£ n√£o encontrado ou sem convite pendente.');
        // Join
        clanObj.members = clanObj.members || [];
        if (!clanObj.members.includes(sender)) clanObj.members.push(sender);
        // Remove pending invite
        clanObj.pendingInvites = (clanObj.pendingInvites || []).filter(id => id !== sender);
        me.clan = clanObj.id;
        saveEconomy(econ);
        return reply(`‚úÖ Voc√™ entrou para o cl√£ *${clanObj.name}*!`);
      }

      // Recusar convite
      case 'recusarconvite':
      case 'recusar': {
        if (!isGroup) return reply('‚öîÔ∏è Comandos de cl√£ s√≥ funcionam em grupos com Modo RPG.');
        if (!groupData.modorpg) return reply(`‚öîÔ∏è Modo RPG desativado! Use ${prefix}modorpg para ativar.`);
        const econ = loadEconomy();
        const me = getEcoUser(econ, sender);
        const clansWithInvite = Object.values(econ.clans || {}).filter(c => Array.isArray(c.pendingInvites) && c.pendingInvites.includes(sender));
        if (!q && clansWithInvite.length === 0) return reply('‚ùå Voc√™ n√£o possui convites pendentes para cl√£s.');
        let clanObj = null;
        if (!q) {
          if (clansWithInvite.length === 1) clanObj = clansWithInvite[0];
          else return reply('üîé Voc√™ possui m√∫ltiplos convites. Use: ' + prefix + 'recusarconvite <clanId>');
        } else {
          const qLower = q.trim().toLowerCase();
          clanObj = econ.clans[q] || Object.values(econ.clans || {}).find(c => (c.name||'').toLowerCase() === qLower);
        }
        if (!clanObj) return reply('‚ùå Cl√£ n√£o encontrado ou sem convite pendente.');
        clanObj.pendingInvites = (clanObj.pendingInvites || []).filter(id => id !== sender);
        saveEconomy(econ);
        return reply(`‚ùó Voc√™ recusou o convite do cl√£ *${clanObj.name}*.`);
      }

      // Expulsar membro do cl√£ (apenas l√≠der)
      case 'expulsar':
      case 'kickcla': {
        if (!isGroup) return reply('‚öîÔ∏è Este comando funciona apenas em grupos com Modo RPG ativo.');
        if (!groupData.modorpg) return reply(`‚öîÔ∏è Modo RPG desativado! Use ${prefix}modorpg para ativar.`);
        const econ = loadEconomy();
        const me = getEcoUser(econ, sender);
        if (!me.clan) return reply('‚ùå Voc√™ n√£o faz parte de nenhum cl√£.');
        const clan = econ.clans[me.clan];
        if (!clan) { me.clan = null; saveEconomy(econ); return reply('‚ùå Seu cl√£ n√£o foi encontrado.'); }
        if (clan.leader !== sender) return reply('üëë Apenas o l√≠der pode expulsar membros.');
        const target = (menc_jid2 && menc_jid2[0]) || null;
        if (!target) return reply(`‚ùó Marque um membro para expulsar. Ex: ${prefix}expulsar @user`);
        if (target === sender) return reply('‚ùå Voc√™ n√£o pode se expulsar como l√≠der. Use sair para demitir-se e transferir lideran√ßa.');
        if (!clan.members || !clan.members.includes(target)) return reply('‚ùå Este usu√°rio n√£o √© membro do seu cl√£.');
        clan.members = clan.members.filter(m => m !== target);
        const targetUser = getEcoUser(econ, target);
        if (targetUser.clan === clan.id) targetUser.clan = null;
        // cleanup pending invites anywhere
        for (const [k,c] of Object.entries(econ.clans||{})) {
          if (Array.isArray(c.pendingInvites) && c.pendingInvites.includes(target)) c.pendingInvites = c.pendingInvites.filter(x => x !== target);
        }
        saveEconomy(econ);
        return reply(`üóëÔ∏è @${target.split('@')[0]} foi expulso do cl√£ *${clan.name}*.`, { mentions: [target] });
      }

      // Sistema de Fam√≠lia
      case 'familia':
      case 'family': {
        if (!isGroup) return reply('‚öîÔ∏è Este comando funciona apenas em grupos com Modo RPG ativo.');
        if (!groupData.modorpg) return reply(`‚öîÔ∏è Modo RPG desativado! Use ${prefix}modorpg para ativar.`);
        
        const econ = loadEconomy();
        const me = getEcoUser(econ, sender);
        
        if (!me.family) me.family = { spouse: null, children: [], parents: [], siblings: [] };
        
        let text = `‚ï≠‚îÅ‚îÅ‚îÅ‚ä± üë®‚Äçüë©‚Äçüëß‚Äçüë¶ *MINHA FAM√çLIA* ‚ä±‚îÅ‚îÅ‚îÅ‚ïÆ\n`;
        text += `‚îÇ ${pushname}\n`;
        text += `‚ï∞‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚ïØ\n\n`;
        
        // Buscar relacionamento ativo do sistema de relacionamentos
        const activePair = relationshipManager.getActivePairForUser(sender);
        if (activePair && activePair.partnerId) {
          let relationshipEmoji = 'üíç';
          let relationshipType = 'C√¥njuge';
          
          if (activePair.pair?.status === 'casamento') {
            relationshipEmoji = 'üíç';
            relationshipType = 'C√¥njuge';
          } else if (activePair.pair?.status === 'namoro') {
            relationshipEmoji = 'üíû';
            relationshipType = 'Namorado(a)';
          } else if (activePair.pair?.status === 'brincadeira') {
            relationshipEmoji = 'üéà';
            relationshipType = 'Parceiro(a)';
          }
          
          const relationshipSince = activePair.pair?.stages?.[activePair.pair.status]?.since;
          const sinceDate = relationshipSince ? new Date(relationshipSince).toLocaleDateString() : 'Data desconhecida';
          
          text += `${relationshipEmoji} *${relationshipType}:*\n`;
          text += `‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ\n`;
          text += `‚îÇ @${activePair.partnerId.split('@')[0]}\n`;
          text += `‚îÇ ‚ù§Ô∏è Desde: ${sinceDate}\n`;
          text += `‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ\n\n`;
        } else {
          text += `üíî *Relacionamento:* Solteiro(a)\n\n`;
        }
        
        // Pais
        if (me.family.parents && me.family.parents.length > 0) {
          text += `üë´ *Pais:*\n`;
          me.family.parents.forEach(parent => {
            text += `‚Ä¢ @${parent.split('@')[0]}\n`;
          });
          text += `\n`;
        }
        
        // Filhos
        if (me.family.children && me.family.children.length > 0) {
          text += `üë∂ *Filhos (${me.family.children.length}):*\n`;
          me.family.children.forEach((child, i) => {
            text += `${i + 1}. @${child.split('@')[0]}\n`;
          });
          text += `\n`;
        } else {
          text += `üë∂ *Filhos:* Nenhum\n\n`;
        }
        
        // Irm√£os
        if (me.family.siblings && me.family.siblings.length > 0) {
          text += `üë´ *Irm√£os (${me.family.siblings.length}):*\n`;
          me.family.siblings.forEach(sibling => {
            text += `‚Ä¢ @${sibling.split('@')[0]}\n`;
          });
          text += `\n`;
        }
        
        text += `üí° Use ${prefix}adotaruser @user para adotar\n`;
        text += `üí° Use ${prefix}arvore para ver √°rvore geneal√≥gica`;
        
        const mentions = [
          ...(me.family.parents || []),
          ...(me.family.children || []),
          ...(me.family.siblings || [])
        ].filter(Boolean);
        
        // Adiciona o parceiro do sistema de relacionamentos nas men√ß√µes
        const activePairForMentions = relationshipManager.getActivePairForUser(sender);
        if (activePairForMentions && activePairForMentions.partnerId) {
          mentions.push(activePairForMentions.partnerId);
        }
        
        saveEconomy(econ);
        return reply(text, { mentions });
        break;
      }

      case 'adotaruser':
      case 'adotarfilho': {
        if (!isGroup) return reply('‚öîÔ∏è Este comando funciona apenas em grupos com Modo RPG ativo.');
        if (!groupData.modorpg) return reply(`‚öîÔ∏è Modo RPG desativado! Use ${prefix}modorpg para ativar.`);
        
        const econ = loadEconomy();
        const me = getEcoUser(econ, sender);
        
        const target = (menc_jid2 && menc_jid2[0]) || null;
        if (!target) return reply(`‚ùå Marque algu√©m para adotar!\n\nüí° Exemplo: ${prefix}adotaruser @user`);
        if (target === sender) return reply('‚ùå Voc√™ n√£o pode se adotar!');
        
        const targetUser = getEcoUser(econ, target);
        
        if (!me.family) me.family = { spouse: null, children: [], parents: [], siblings: [] };
        if (!targetUser.family) targetUser.family = { spouse: null, children: [], parents: [], siblings: [] };
        
        // Verificar se j√° √© filho
        if (me.family.children && me.family.children.includes(target)) {
          return reply('‚ùå Esta pessoa j√° √© seu filho(a)!');
        }
        
        // Verificar se j√° tem pais
        if (targetUser.family.parents && targetUser.family.parents.length >= 2) {
          return reply('‚ùå Esta pessoa j√° tem 2 pais/m√£es!');
        }
        
        // Custo da ado√ß√£o
        const adoptCost = 10000;
        if (me.wallet < adoptCost) {
          return reply(`üí∞ Voc√™ precisa de ${adoptCost.toLocaleString()} moedas para adotar!`);
        }
        
        me.wallet -= adoptCost;
        
        // Adicionar aos filhos
        if (!me.family.children) me.family.children = [];
        me.family.children.push(target);
        
        // Adicionar aos pais
        if (!targetUser.family.parents) targetUser.family.parents = [];
        targetUser.family.parents.push(sender);
        
        // Se tiver parceiro(a) no sistema de relacionamentos, adicionar como pai/m√£e tamb√©m
        const activePair = relationshipManager.getActivePairForUser(sender);
        if (activePair && activePair.partnerId) {
          const spouseData = getEcoUser(econ, activePair.partnerId);
          if (!spouseData.family) spouseData.family = { spouse: null, children: [], parents: [], siblings: [] };
          if (!spouseData.family.children) spouseData.family.children = [];
          spouseData.family.children.push(target);
          targetUser.family.parents.push(activePair.partnerId);
        }
        
        let text = `‚ï≠‚îÅ‚îÅ‚îÅ‚ä± üë∂ *ADO√á√ÉO* ‚ä±‚îÅ‚îÅ‚îÅ‚ïÆ\n`;
        text += `‚ï∞‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚ïØ\n\n`;
        text += `üéâ Parab√©ns!\n\n`;
        text += `${pushname} adotou @${target.split('@')[0]}!\n\n`;
        text += `üí∞ Custo: ${adoptCost.toLocaleString()}\n`;
        text += `üë®‚Äçüë©‚Äçüëß‚Äçüë¶ Agora voc√™ tem ${me.family.children.length} filho(s)!`;
        
        saveEconomy(econ);
        return reply(text, { mentions: [target] });
        break;
      }

      case 'deserdar':
      case 'desherdar':
      case 'removerfilho': {
        if (!isGroup) return reply('‚öîÔ∏è Este comando funciona apenas em grupos com Modo RPG ativo.');
        if (!groupData.modorpg) return reply(`‚öîÔ∏è Modo RPG desativado! Use ${prefix}modorpg para ativar.`);
        
        const econ = loadEconomy();
        const me = getEcoUser(econ, sender);
        
        const target = (menc_jid2 && menc_jid2[0]) || null;
        if (!target) return reply(`‚ùå Marque algu√©m para deserdar!\n\nüí° Exemplo: ${prefix}deserdar @user`);
        if (target === sender) return reply('‚ùå Voc√™ n√£o pode se deserdar!');
        
        const targetUser = getEcoUser(econ, target);
        
        if (!me.family) me.family = { spouse: null, children: [], parents: [], siblings: [] };
        if (!targetUser.family) targetUser.family = { spouse: null, children: [], parents: [], siblings: [] };
        
        // Verificar se √© filho
        if (!me.family.children || !me.family.children.includes(target)) {
          return reply('‚ùå Esta pessoa n√£o √© seu filho(a)!');
        }
        
        // Remover dos filhos
        me.family.children = me.family.children.filter(child => child !== target);
        
        // Remover dos pais
        if (targetUser.family.parents) {
          targetUser.family.parents = targetUser.family.parents.filter(parent => parent !== sender);
        }
        
        // Se tiver parceiro(a) no sistema de relacionamentos, remover como pai/m√£e tamb√©m
        const activePair = relationshipManager.getActivePairForUser(sender);
        if (activePair && activePair.partnerId) {
          const spouseData = getEcoUser(econ, activePair.partnerId);
          if (spouseData.family && spouseData.family.children) {
            spouseData.family.children = spouseData.family.children.filter(child => child !== target);
          }
          if (targetUser.family.parents) {
            targetUser.family.parents = targetUser.family.parents.filter(parent => parent !== activePair.partnerId);
          }
        }
        
        let text = `‚ï≠‚îÅ‚îÅ‚îÅ‚ä± üíî *DESERDADO* ‚ä±‚îÅ‚îÅ‚îÅ‚ïÆ\n`;
        text += `‚ï∞‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚ïØ\n\n`;
        text += `üò¢ ${pushname} deserdou @${target.split('@')[0]}!\n\n`;
        text += `üë®‚Äçüë©‚Äçüëß‚Äçüë¶ Agora voc√™ tem ${me.family.children.length} filho(s)!\n\n`;
        text += `üí° Use ${prefix}familia para ver sua fam√≠lia atualizada.`;
        
        saveEconomy(econ);
        return reply(text, { mentions: [target] });
        break;
      }

      case 'arvore':
      case 'familytree': {
        if (!isGroup) return reply('‚öîÔ∏è Este comando funciona apenas em grupos com Modo RPG ativo.');
        if (!groupData.modorpg) return reply(`‚öîÔ∏è Modo RPG desativado! Use ${prefix}modorpg para ativar.`);
        
        const econ = loadEconomy();
        const me = getEcoUser(econ, sender);
        
        if (!me.family) me.family = { spouse: null, children: [], parents: [], siblings: [] };
        
        let text = `‚ï≠‚îÅ‚îÅ‚îÅ‚ä± üå≥ *√ÅRVORE GENEAL√ìGICA* ‚ä±‚îÅ‚îÅ‚îÅ‚ïÆ\n`;
        text += `‚ï∞‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚ïØ\n\n`;
        
        // Av√≥s
        const grandparents = [];
        if (me.family.parents) {
          for (const parent of me.family.parents) {
            const parentData = getEcoUser(econ, parent);
            if (parentData.family && parentData.family.parents) {
              grandparents.push(...parentData.family.parents);
            }
          }
        }
        
        if (grandparents.length > 0) {
          text += `üë¥üëµ *Av√≥s:*\n`;
          [...new Set(grandparents)].forEach(gp => {
            text += `‚Ä¢ @${gp.split('@')[0]}\n`;
          });
          text += `\n`;
        }
        
        // Pais
        if (me.family.parents && me.family.parents.length > 0) {
          text += `üë´ *Pais:*\n`;
          me.family.parents.forEach(parent => {
            text += `‚Ä¢ @${parent.split('@')[0]}\n`;
          });
          text += `\n`;
        }
        
        // Voc√™
        text += `üë§ *Voc√™:* ${pushname}\n`;
        
        // Buscar relacionamento ativo do sistema de relacionamentos
        const activePair = relationshipManager.getActivePairForUser(sender);
        if (activePair && activePair.partnerId) {
          const relationshipEmoji = activePair.pair?.status === 'casamento' ? 'üíç' : 
                                   activePair.pair?.status === 'namoro' ? 'üíû' : 'üéà';
          const relationshipType = activePair.pair?.status === 'casamento' ? 'C√¥njuge' :
                                  activePair.pair?.status === 'namoro' ? 'Namorado(a)' : 'Parceiro(a)';
          text += `${relationshipEmoji} *${relationshipType}:* @${activePair.partnerId.split('@')[0]}\n`;
        }
        text += `\n`;
        
        // Filhos
        if (me.family.children && me.family.children.length > 0) {
          text += `üë∂ *Filhos:*\n`;
          me.family.children.forEach(child => {
            text += `‚Ä¢ @${child.split('@')[0]}\n`;
          });
          text += `\n`;
        }
        
        // Netos
        const grandchildren = [];
        if (me.family.children) {
          for (const child of me.family.children) {
            const childData = getEcoUser(econ, child);
            if (childData.family && childData.family.children) {
              grandchildren.push(...childData.family.children);
            }
          }
        }
        
        if (grandchildren.length > 0) {
          text += `üë∂üë∂ *Netos:*\n`;
          grandchildren.forEach(gc => {
            text += `‚Ä¢ @${gc.split('@')[0]}\n`;
          });
          text += `\n`;
        }
        
        text += `üå≥ ${grandparents.length + (me.family.parents?.length || 0) + 1 + (me.family.children?.length || 0) + grandchildren.length} membros na fam√≠lia`;
        
        const allMembers = [
          ...grandparents,
          ...(me.family.parents || []),
          ...(me.family.children || []),
          ...grandchildren
        ].filter(Boolean);
        
        // Adiciona o parceiro do sistema de relacionamentos nas men√ß√µes
        const activePairForMentions = relationshipManager.getActivePairForUser(sender);
        if (activePairForMentions && activePairForMentions.partnerId) {
          allMembers.push(activePairForMentions.partnerId);
        }
        
        return reply(text, { mentions: [...new Set(allMembers)] });
        break;
      }

      // Sistema de Torneio
      case 'torneio':
      case 'tournament': {
        if (!isGroup) return reply('‚öîÔ∏è Este comando funciona apenas em grupos com Modo RPG ativo.');
        if (!groupData.modorpg) return reply(`‚öîÔ∏è Modo RPG desativado! Use ${prefix}modorpg para ativar.`);
        
        const econ = loadEconomy();
        const me = getEcoUser(econ, sender);
        
        if (!econ.tournament) {
          econ.tournament = {
            active: false,
            participants: [],
            startTime: null,
            prize: 0
          };
        }
        
        const tournament = econ.tournament;
        
        if (!tournament.active) {
          // Criar torneio
          if (q === 'criar' && isGroupAdmins) {
            tournament.active = true;
            tournament.participants = [];
            tournament.startTime = Date.now();
            tournament.prize = 50000;
            
            saveEconomy(econ);
            return reply(`‚ï≠‚îÅ‚îÅ‚îÅ‚ä± üèÜ *TORNEIO ABERTO!* ‚ä±‚îÅ‚îÅ‚îÅ‚ïÆ\n‚ï∞‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚ïØ\n\n‚öîÔ∏è Um torneio foi iniciado!\n\nüí∞ Pr√™mio: ${tournament.prize.toLocaleString()}\n‚è∞ Inscri√ß√µes abertas!\n\nüí° Use ${prefix}torneio entrar`);
          }
          
          return reply(`‚ùå N√£o h√° torneio ativo!\n\nüí° Admins: Use ${prefix}torneio criar`);
        }
        
        // Entrar no torneio
        if (q === 'entrar') {
          if (tournament.participants.includes(sender)) {
            return reply('‚ùå Voc√™ j√° est√° inscrito no torneio!');
          }
          
          const entryCost = 5000;
          if (me.wallet < entryCost) {
            return reply(`üí∞ Voc√™ precisa de ${entryCost.toLocaleString()} moedas para participar!`);
          }
          
          me.wallet -= entryCost;
          tournament.participants.push(sender);
          tournament.prize += entryCost;
          
          saveEconomy(econ);
          return reply(`‚úÖ Voc√™ entrou no torneio!\n\nüë• Participantes: ${tournament.participants.length}\nüí∞ Pr√™mio acumulado: ${tournament.prize.toLocaleString()}`);
        }
        
        // Iniciar torneio
        if (q === 'iniciar' && isGroupAdmins) {
          if (tournament.participants.length < 2) {
            return reply('‚ùå Precisa de pelo menos 2 participantes!');
          }
          
          // Simular batalhas
          let fighters = [...tournament.participants];
          let round = 1;
          let results = `‚ï≠‚îÅ‚îÅ‚îÅ‚ä± üèÜ *TORNEIO* ‚ä±‚îÅ‚îÅ‚îÅ‚ïÆ\n‚ï∞‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚ïØ\n\n`;
          
          while (fighters.length > 1) {
            results += `‚öîÔ∏è *RODADA ${round}*\n\n`;
            const nextRound = [];
            
            for (let i = 0; i < fighters.length; i += 2) {
              if (i + 1 < fighters.length) {
                const fighter1 = fighters[i];
                const fighter2 = fighters[i + 1];
                const winner = Math.random() > 0.5 ? fighter1 : fighter2;
                
                results += `${fighter1 === winner ? '‚úÖ' : '‚ùå'} @${fighter1.split('@')[0]} vs @${fighter2.split('@')[0]} ${fighter2 === winner ? '‚úÖ' : '‚ùå'}\n`;
                nextRound.push(winner);
              } else {
                nextRound.push(fighters[i]);
              }
            }
            
            results += `\n`;
            fighters = nextRound;
            round++;
          }
          
          const winner = fighters[0];
          const winnerData = getEcoUser(econ, winner);
          winnerData.wallet += tournament.prize;
          
          results += `\nüèÜ *CAMPE√ÉO:* @${winner.split('@')[0]}\n`;
          results += `üí∞ Pr√™mio: ${tournament.prize.toLocaleString()}`;
          
          tournament.active = false;
          tournament.participants = [];
          
          saveEconomy(econ);
          return reply(results, { mentions: tournament.participants });
        }
        
        // Ver info do torneio
        let text = `‚ï≠‚îÅ‚îÅ‚îÅ‚ä± üèÜ *TORNEIO ATIVO* ‚ä±‚îÅ‚îÅ‚îÅ‚ïÆ\n`;
        text += `‚ï∞‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚ïØ\n\n`;
        text += `üë• Participantes: ${tournament.participants.length}\n`;
        text += `üí∞ Pr√™mio: ${tournament.prize.toLocaleString()}\n\n`;
        text += `üìã *INSCRITOS:*\n`;
        tournament.participants.slice(0, 10).forEach((p, i) => {
          text += `${i + 1}. @${p.split('@')[0]}\n`;
        });
        if (tournament.participants.length > 10) {
          text += `... e mais ${tournament.participants.length - 10}\n`;
        }
        text += `\nüí° Use ${prefix}torneio entrar`;
        
        return reply(text, { mentions: tournament.participants.slice(0, 10) });
        break;
      }

      // Intera√ß√µes Sociais RPG
      case 'abracarrpg':
      case 'hugrpg': {
        if (!isGroup) return reply('‚öîÔ∏è Este comando funciona apenas em grupos com Modo RPG ativo.');
        if (!groupData.modorpg) return reply(`‚öîÔ∏è Modo RPG desativado! Use ${prefix}modorpg para ativar.`);
        
        const target = (menc_jid2 && menc_jid2[0]) || null;
        if (!target) return reply(`‚ùå Marque algu√©m para abra√ßar!\n\nüí° Exemplo: ${prefix}abracar @user`);
        if (target === sender) return reply('‚ùå Voc√™ n√£o pode se abra√ßar!');
        
        const actions = [
          `${pushname} deu um abra√ßo caloroso em @${target.split('@')[0]}! ü§ó`,
          `${pushname} abra√ßou @${target.split('@')[0]} com muito carinho! üíï`,
          `Um abra√ßo apertado de ${pushname} para @${target.split('@')[0]}! ü´Ç`,
          `${pushname} envolveu @${target.split('@')[0]} em seus bra√ßos! ü§óüíñ`
        ];
        
        return reply(actions[Math.floor(Math.random() * actions.length)], { mentions: [target] });
        break;
      }

      case 'beijarrpg':
      case 'kissrpg': {
        if (!isGroup) return reply('‚öîÔ∏è Este comando funciona apenas em grupos com Modo RPG ativo.');
        if (!groupData.modorpg) return reply(`‚öîÔ∏è Modo RPG desativado! Use ${prefix}modorpg para ativar.`);
        
        const target = (menc_jid2 && menc_jid2[0]) || null;
        if (!target) return reply(`‚ùå Marque algu√©m para beijar!\n\nüí° Exemplo: ${prefix}beijarrpg @user`);
        if (target === sender) return reply('‚ùå Voc√™ n√£o pode se beijar!');
        
        const actions = [
          `${pushname} deu um beijo em @${target.split('@')[0]}! üòò`,
          `${pushname} beijou @${target.split('@')[0]} apaixonadamente! üíã`,
          `Um beijo rom√¢ntico de ${pushname} para @${target.split('@')[0]}! üòç`,
          `${pushname} roubou um beijinho de @${target.split('@')[0]}! üòö`
        ];
        
        return reply(actions[Math.floor(Math.random() * actions.length)], { mentions: [target] });
        break;
      }

      case 'baterrpg':
      case 'taparpg':
      case 'slaprpg': {
        if (!isGroup) return reply('‚öîÔ∏è Este comando funciona apenas em grupos com Modo RPG ativo.');
        if (!groupData.modorpg) return reply(`‚öîÔ∏è Modo RPG desativado! Use ${prefix}modorpg para ativar.`);
        
        const target = (menc_jid2 && menc_jid2[0]) || null;
        if (!target) return reply(`‚ùå Marque algu√©m para dar um tapa!\n\nüí° Exemplo: ${prefix}baterrpg @user`);
        if (target === sender) return reply('‚ùå Voc√™ n√£o pode bater em si mesmo!');
        
        const actions = [
          `${pushname} deu um tapa em @${target.split('@')[0]}! üëãüí•`,
          `PAH! ${pushname} acertou @${target.split('@')[0]} em cheio! üò§`,
          `${pushname} n√£o teve piedade e bateu em @${target.split('@')[0]}! üí¢`,
          `SMACK! ${pushname} deu um tap√£o em @${target.split('@')[0]}! üò†`
        ];
        
        return reply(actions[Math.floor(Math.random() * actions.length)], { mentions: [target] });
        break;
      }

      case 'proteger':
      case 'protect': {
        if (!isGroup) return reply('‚öîÔ∏è Este comando funciona apenas em grupos com Modo RPG ativo.');
        if (!groupData.modorpg) return reply(`‚öîÔ∏è Modo RPG desativado! Use ${prefix}modorpg para ativar.`);
        
        const econ = loadEconomy();
        const me = getEcoUser(econ, sender);
        
        const target = (menc_jid2 && menc_jid2[0]) || null;
        if (!target) return reply(`‚ùå Marque algu√©m para proteger!\n\nüí° Exemplo: ${prefix}proteger @user`);
        if (target === sender) return reply('‚ùå Voc√™ n√£o pode se proteger assim!');
        
        const protectCost = 2000;
        if (me.wallet < protectCost) {
          return reply(`üí∞ Voc√™ precisa de ${protectCost.toLocaleString()} moedas para proteger algu√©m!`);
        }
        
        me.wallet -= protectCost;
        
        const targetData = getEcoUser(econ, target);
        if (!targetData.protection) targetData.protection = {};
        targetData.protection.protectedBy = sender;
        targetData.protection.until = Date.now() + 3600000; // 1 hora
        
        saveEconomy(econ);
        
        let text = `‚ï≠‚îÅ‚îÅ‚îÅ‚ä± üõ°Ô∏è *PROTE√á√ÉO ATIVA* ‚ä±‚îÅ‚îÅ‚îÅ‚ïÆ\n`;
        text += `‚ï∞‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚ïØ\n\n`;
        text += `${pushname} est√° protegendo @${target.split('@')[0]}!\n\n`;
        text += `‚è∞ Dura√ß√£o: 1 hora\n`;
        text += `üö´ Ataques e roubos bloqueados!\n`;
        text += `üí∞ Custo: ${protectCost.toLocaleString()}`;
        
        return reply(text, { mentions: [target] });
        break;
      }

      // Sistema de Reputa√ß√£o
      case 'reputacao':
      case 'rep':
      case 'reputation': {
        if (!isGroup) return reply('‚öîÔ∏è Este comando funciona apenas em grupos com Modo RPG ativo.');
        if (!groupData.modorpg) return reply(`‚öîÔ∏è Modo RPG desativado! Use ${prefix}modorpg para ativar.`);
        
        const econ = loadEconomy();
        const me = getEcoUser(econ, sender);
        
        if (!me.reputation) {
          me.reputation = {
            points: 0,
            upvotes: 0,
            downvotes: 0,
            karma: 0,
            fame: 0
          };
        }
        
        let text = `‚ï≠‚îÅ‚îÅ‚îÅ‚ä± ‚≠ê *REPUTA√á√ÉO* ‚ä±‚îÅ‚îÅ‚îÅ‚ïÆ\n`;
        text += `‚îÇ ${pushname}\n`;
        text += `‚ï∞‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚ïØ\n\n`;
        text += `‚≠ê Pontos: ${me.reputation.points}\n`;
        text += `üëç Votos Positivos: ${me.reputation.upvotes}\n`;
        text += `üëé Votos Negativos: ${me.reputation.downvotes}\n`;
        text += `‚òØÔ∏è Karma: ${me.reputation.karma}\n`;
        text += `üåü Fama: ${me.reputation.fame}\n\n`;
        
        const repLevel = Math.floor(me.reputation.points / 100);
        const ranks = ['Novato', 'Conhecido', 'Respeitado', 'Famoso', 'Lend√°rio'];
        const rank = ranks[Math.min(repLevel, ranks.length - 1)];
        
        text += `üèÖ Classifica√ß√£o: *${rank}*\n\n`;
        text += `üí° Use ${prefix}votar @user para dar reputa√ß√£o`;
        
        saveEconomy(econ);
        return reply(text);
        break;
      }

      case 'votar':
      case 'vote': {
        if (!isGroup) return reply('‚öîÔ∏è Este comando funciona apenas em grupos com Modo RPG ativo.');
        if (!groupData.modorpg) return reply(`‚öîÔ∏è Modo RPG desativado! Use ${prefix}modorpg para ativar.`);
        
        const econ = loadEconomy();
        const me = getEcoUser(econ, sender);
        
        const target = (menc_jid2 && menc_jid2[0]) || null;
        if (!target) return reply(`‚ùå Marque algu√©m para votar!\n\nüí° Exemplo: ${prefix}votar @user`);
        if (target === sender) return reply('‚ùå Voc√™ n√£o pode votar em si mesmo!');
        
        if (!me.lastVote) me.lastVote = {};
        
        const now = Date.now();
        if (me.lastVote[target] && (now - me.lastVote[target]) < 86400000) {
          const remaining = Math.ceil((86400000 - (now - me.lastVote[target])) / 3600000);
          return reply(`‚è∞ Voc√™ j√° votou nesta pessoa hoje!\n\nAguarde ${remaining}h para votar novamente.`);
        }
        
        const targetData = getEcoUser(econ, target);
        if (!targetData.reputation) {
          targetData.reputation = {
            points: 0,
            upvotes: 0,
            downvotes: 0,
            karma: 0,
            fame: 0
          };
        }
        
        targetData.reputation.points += 10;
        targetData.reputation.upvotes++;
        targetData.reputation.karma += 5;
        targetData.reputation.fame++;
        
        me.lastVote[target] = now;
        
        let text = `‚ï≠‚îÅ‚îÅ‚îÅ‚ä± üëç *VOTO POSITIVO* ‚ä±‚îÅ‚îÅ‚îÅ‚ïÆ\n`;
        text += `‚ï∞‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚ïØ\n\n`;
        text += `${pushname} deu reputa√ß√£o para @${target.split('@')[0]}!\n\n`;
        text += `‚≠ê +10 pontos de reputa√ß√£o\n`;
        text += `‚òØÔ∏è +5 karma\n`;
        text += `üåü +1 fama`;
        
        saveEconomy(econ);
        return reply(text, { mentions: [target] });
      }

      // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
      // COMANDOS ADMINISTRATIVOS DO RPG (DONO)
      // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
      
      // Ranking Global
      case 'rankglobal':
      case 'globalrank':
      case 'toprpgglobal':
      case 'topglobal': {
        const econ = loadEconomy();
        const allUsers = Object.entries(econ.users || {});
        
        if (allUsers.length === 0) return reply('üìä Nenhum jogador registrado no sistema RPG ainda.');
        
        // Calcular poder total de cada jogador
        const rankedUsers = allUsers.map(([id, data]) => {
          const totalWealth = (data.wallet || 0) + (data.bank || 0);
          const level = data.level || 1;
          const power = data.power || 100;
          const reputation = data.reputation?.points || 0;
          const achievements = Object.keys(data.achievements || {}).length;
          const pets = (data.pets || []).length;
          
          // Score composto
          const score = totalWealth + (level * 1000) + (power * 10) + (reputation * 50) + (achievements * 500) + (pets * 200);
          
          return { id, totalWealth, level, power, reputation, achievements, pets, score };
        }).sort((a, b) => b.score - a.score).slice(0, 20);
        
        let text = `‚ï≠‚îÅ‚îÅ‚îÅ‚ä± üåç *RANKING GLOBAL RPG* ‚ä±‚îÅ‚îÅ‚îÅ‚ïÆ\n`;
        text += `‚îÇ Top 20 jogadores do bot\n`;
        text += `‚ï∞‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚ïØ\n\n`;
        
        const mentions = [];
        rankedUsers.forEach((user, i) => {
          const medal = i === 0 ? 'ü•á' : i === 1 ? 'ü•à' : i === 2 ? 'ü•â' : `${i + 1}.`;
          const userName = user.id.split('@')[0];
          text += `${medal} @${userName}\n`;
          text += `   üí∞ ${user.totalWealth.toLocaleString()} | Lv.${user.level} | ‚öîÔ∏è ${user.power}\n`;
          text += `   üìä Score: ${user.score.toLocaleString()}\n\n`;
          mentions.push(user.id);
        });
        
        text += `‚ï≠‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚ïÆ\n`;
        text += `‚îÇ üí° O score √© calculado por:\n`;
        text += `‚îÇ dinheiro + level + poder +\n`;
        text += `‚îÇ reputa√ß√£o + conquistas + pets\n`;
        text += `‚ï∞‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚ïØ`;
        
        return reply(text, { mentions });
      }
      
      // Adicionar dinheiro a jogador
      case 'rpgadd':
      case 'rpgaddmoney':
      case 'adicionardinheiro': {
        if (!isOwnerOrSub) return reply('üö´ Apenas donos e subdonos podem usar este comando!');
        
        const target = (menc_jid2 && menc_jid2[0]) || null;
        if (!target) return reply(`‚ùå Marque um usu√°rio!\n\nüí° Uso: ${prefix}rpgadd @user <valor>`);
        
        const amount = parseInt(args[args.length - 1]) || 0;
        if (amount <= 0) return reply('‚ùå Informe um valor v√°lido maior que 0!');
        
        const econ = loadEconomy();
        const targetData = getEcoUser(econ, target);
        
        targetData.wallet = (targetData.wallet || 0) + amount;
        saveEconomy(econ);
        
        return reply(`‚ï≠‚îÅ‚îÅ‚îÅ‚ä± ‚úÖ *DINHEIRO ADICIONADO* ‚ä±‚îÅ‚îÅ‚îÅ‚ïÆ\n‚îÇ\n‚îÇ üë§ @${target.split('@')[0]}\n‚îÇ üí∞ +${amount.toLocaleString()} moedas\n‚îÇ üíº Carteira atual: ${targetData.wallet.toLocaleString()}\n‚îÇ\n‚ï∞‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚ïØ`, { mentions: [target] });
      }
      
      // Remover dinheiro de jogador
      case 'rpgremove':
      case 'rpgremovemoney':
      case 'removerdinheiro': {
        if (!isOwnerOrSub) return reply('üö´ Apenas donos e subdonos podem usar este comando!');
        
        const target = (menc_jid2 && menc_jid2[0]) || null;
        if (!target) return reply(`‚ùå Marque um usu√°rio!\n\nüí° Uso: ${prefix}rpgremove @user <valor>`);
        
        const amount = parseInt(args[args.length - 1]) || 0;
        if (amount <= 0) return reply('‚ùå Informe um valor v√°lido maior que 0!');
        
        const econ = loadEconomy();
        const targetData = getEcoUser(econ, target);
        
        targetData.wallet = Math.max(0, (targetData.wallet || 0) - amount);
        targetData.bank = Math.max(0, (targetData.bank || 0));
        saveEconomy(econ);
        
        return reply(`‚ï≠‚îÅ‚îÅ‚îÅ‚ä± ‚úÖ *DINHEIRO REMOVIDO* ‚ä±‚îÅ‚îÅ‚îÅ‚ïÆ\n‚îÇ\n‚îÇ üë§ @${target.split('@')[0]}\n‚îÇ üí∏ -${amount.toLocaleString()} moedas\n‚îÇ üíº Carteira atual: ${targetData.wallet.toLocaleString()}\n‚îÇ\n‚ï∞‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚ïØ`, { mentions: [target] });
      }
      
      // Definir level de jogador
      case 'rpgsetlevel':
      case 'setlevel':
      case 'definirnivelrpg': {
        if (!isOwnerOrSub) return reply('üö´ Apenas donos e subdonos podem usar este comando!');
        
        const target = (menc_jid2 && menc_jid2[0]) || null;
        if (!target) return reply(`‚ùå Marque um usu√°rio!\n\nüí° Uso: ${prefix}rpgsetlevel @user <nivel>`);
        
        const newLevel = parseInt(args[args.length - 1]) || 0;
        if (newLevel < 1 || newLevel > 1000) return reply('‚ùå N√≠vel deve ser entre 1 e 1000!');
        
        const econ = loadEconomy();
        const targetData = getEcoUser(econ, target);
        
        targetData.level = newLevel;
        targetData.power = 100 + (newLevel * 15);
        saveEconomy(econ);
        
        return reply(`‚ï≠‚îÅ‚îÅ‚îÅ‚ä± ‚úÖ *N√çVEL DEFINIDO* ‚ä±‚îÅ‚îÅ‚îÅ‚ïÆ\n‚îÇ\n‚îÇ üë§ @${target.split('@')[0]}\n‚îÇ üìä N√≠vel: ${newLevel}\n‚îÇ ‚öîÔ∏è Poder: ${targetData.power}\n‚îÇ\n‚ï∞‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚ïØ`, { mentions: [target] });
      }
      
      // Adicionar item ao jogador
      case 'rpgadditem':
      case 'adicionaritem': {
        if (!isOwnerOrSub) return reply('üö´ Apenas donos e subdonos podem usar este comando!');
        
        const target = (menc_jid2 && menc_jid2[0]) || null;
        if (!target) return reply(`‚ùå Marque um usu√°rio!\n\nüí° Uso: ${prefix}rpgadditem @user <item> <quantidade>`);
        
        const itemArgs = args.filter(a => !a.startsWith('@')).slice(0, -1).join('_').toLowerCase();
        const qty = parseInt(args[args.length - 1]) || 1;
        
        if (!itemArgs) return reply('‚ùå Informe o nome do item!');
        
        const econ = loadEconomy();
        const targetData = getEcoUser(econ, target);
        
        targetData.inventory = targetData.inventory || {};
        targetData.inventory[itemArgs] = (targetData.inventory[itemArgs] || 0) + qty;
        saveEconomy(econ);
        
        return reply(`‚ï≠‚îÅ‚îÅ‚îÅ‚ä± ‚úÖ *ITEM ADICIONADO* ‚ä±‚îÅ‚îÅ‚îÅ‚ïÆ\n‚îÇ\n‚îÇ üë§ @${target.split('@')[0]}\n‚îÇ üì¶ Item: ${itemArgs}\n‚îÇ üî¢ Quantidade: +${qty}\n‚îÇ\n‚ï∞‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚ïØ`, { mentions: [target] });
      }
      
      // Remover item do jogador
      case 'rpgremoveitem':
      case 'removeritem': {
        if (!isOwnerOrSub) return reply('üö´ Apenas donos e subdonos podem usar este comando!');
        
        const target = (menc_jid2 && menc_jid2[0]) || null;
        if (!target) return reply(`‚ùå Marque um usu√°rio!\n\nüí° Uso: ${prefix}rpgremoveitem @user <item> <quantidade>`);
        
        const itemArgs = args.slice(0, -1).join('_').toLowerCase();
        const qty = parseInt(args[args.length - 1]) || 1;
        
        if (!itemArgs) return reply('‚ùå Informe o nome do item!');
        
        const econ = loadEconomy();
        const targetData = getEcoUser(econ, target);
        
        targetData.inventory = targetData.inventory || {};
        targetData.inventory[itemArgs] = Math.max(0, (targetData.inventory[itemArgs] || 0) - qty);
        saveEconomy(econ);
        
        return reply(`‚ï≠‚îÅ‚îÅ‚îÅ‚ä± ‚úÖ *ITEM REMOVIDO* ‚ä±‚îÅ‚îÅ‚îÅ‚ïÆ\n‚îÇ\n‚îÇ üë§ @${target.split('@')[0]}\n‚îÇ üì¶ Item: ${itemArgs}\n‚îÇ üî¢ Quantidade: -${qty}\n‚îÇ\n‚ï∞‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚ïØ`, { mentions: [target] });
      }
      
      // Reset total do jogador
      case 'rpgresetplayer':
      case 'resetarjogador': {
        if (!isOwnerOrSub) return reply('üö´ Apenas donos e subdonos podem usar este comando!');
        
        const target = (menc_jid2 && menc_jid2[0]) || null;
        if (!target) return reply(`‚ùå Marque um usu√°rio!\n\nüí° Uso: ${prefix}rpgresetplayer @user`);
        
        const econ = loadEconomy();
        
        if (econ.users[target]) {
          delete econ.users[target];
          saveEconomy(econ);
          return reply(`‚ï≠‚îÅ‚îÅ‚îÅ‚ä± ‚úÖ *JOGADOR RESETADO* ‚ä±‚îÅ‚îÅ‚îÅ‚ïÆ\n‚îÇ\n‚îÇ üë§ @${target.split('@')[0]}\n‚îÇ üóëÔ∏è Todos os dados RPG removidos\n‚îÇ\n‚ï∞‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚ïØ`, { mentions: [target] });
        } else {
          return reply('‚ùå Jogador n√£o encontrado no sistema RPG!');
        }
      }
      
      // Reset global de todo o RPG
      case 'rpgresetglobal':
      case 'resetrpgglobal': {
        if (!(isOwner && !isSubOwner)) return reply('üö´ Apenas o dono principal pode usar este comando!');
        
        const confirmArg = (args[0] || '').toLowerCase();
        if (confirmArg !== 'confirmar') {
          return reply(`‚ö†Ô∏è *ATEN√á√ÉO: RESET GLOBAL DO RPG*\n\nüóëÔ∏è Este comando ir√° APAGAR TODOS os dados do sistema RPG!\n\n‚ùå Esta a√ß√£o √© IRREVERS√çVEL!\n\n‚úÖ Para confirmar, use:\n${prefix}rpgresetglobal confirmar`);
        }
        
        const econ = loadEconomy();
        econ.users = {};
        saveEconomy(econ);
        
        return reply(`‚ï≠‚îÅ‚îÅ‚îÅ‚ä± ‚ö†Ô∏è *RESET GLOBAL* ‚ä±‚îÅ‚îÅ‚îÅ‚ïÆ\n‚îÇ\n‚îÇ üóëÔ∏è Sistema RPG resetado!\n‚îÇ üë• Todos os jogadores zerados\n‚îÇ\n‚ï∞‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚ïØ`);
      }
      
      // Estat√≠sticas do sistema RPG
      case 'rpgstats':
      case 'rpgstatistics':
      case 'estatisticasrpg': {
        if (!isOwnerOrSub) return reply('üö´ Apenas donos e subdonos podem usar este comando!');
        
        const econ = loadEconomy();
        const allUsers = Object.entries(econ.users || {});
        
        let totalMoney = 0;
        let totalBank = 0;
        let totalPets = 0;
        let maxLevel = 0;
        let richestUser = { id: null, wealth: 0 };
        
        allUsers.forEach(([id, data]) => {
          const wallet = data.wallet || 0;
          const bank = data.bank || 0;
          totalMoney += wallet;
          totalBank += bank;
          totalPets += (data.pets || []).length;
          maxLevel = Math.max(maxLevel, data.level || 1);
          
          if ((wallet + bank) > richestUser.wealth) {
            richestUser = { id, wealth: wallet + bank };
          }
        });
        
        let text = `‚ï≠‚îÅ‚îÅ‚îÅ‚ä± üìä *ESTAT√çSTICAS DO RPG* ‚ä±‚îÅ‚îÅ‚îÅ‚ïÆ\n‚îÇ\n`;
        text += `‚îÇ üë• Total de jogadores: ${allUsers.length}\n`;
        text += `‚îÇ üí∞ Dinheiro em circula√ß√£o: ${totalMoney.toLocaleString()}\n`;
        text += `‚îÇ üè¶ Dinheiro em bancos: ${totalBank.toLocaleString()}\n`;
        text += `‚îÇ üíµ Total geral: ${(totalMoney + totalBank).toLocaleString()}\n`;
        text += `‚îÇ üêæ Total de pets: ${totalPets}\n`;
        text += `‚îÇ üìà Maior n√≠vel: ${maxLevel}\n`;
        text += `‚îÇ\n`;
        if (richestUser.id) {
          text += `‚îÇ üèÜ Mais rico: @${richestUser.id.split('@')[0]}\n`;
          text += `‚îÇ    üíé ${richestUser.wealth.toLocaleString()}\n`;
        }
        text += `‚îÇ\n‚ï∞‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚ïØ`;
        
        const mentions = richestUser.id ? [richestUser.id] : [];
        return reply(text, { mentions });
      }
      
      // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
      // SISTEMA DE LOJA PREMIUM / GASTAR DINHEIRO
      // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
      
      // Loja Premium com itens caros
      case 'lojapremium':
      case 'premiumshop':
      case 'lojadeluxo': {
        if (!isGroup) return reply('‚öîÔ∏è Este comando funciona apenas em grupos com Modo RPG ativo.');
        if (!groupData.modorpg) return reply(`‚öîÔ∏è Modo RPG desativado! Use ${prefix}modorpg para ativar.`);
        
        const premiumItems = [
          { id: 'titulo_lendario', name: 'üèÖ T√≠tulo Lend√°rio', price: 500000, desc: 'T√≠tulo exclusivo no perfil' },
          { id: 'mascote_raro', name: 'ü¶Ñ Mascote Raro', price: 750000, desc: 'Mascote especial que d√° b√¥nus' },
          { id: 'mansao', name: 'üè∞ Mans√£o', price: 2000000, desc: 'Propriedade de luxo (+5000 renda/dia)' },
          { id: 'yate', name: 'üõ•Ô∏è Iate', price: 1500000, desc: 'Barco de luxo (+b√¥nus pesca)' },
          { id: 'jet_privado', name: '‚úàÔ∏è Jato Privado', price: 5000000, desc: 'Viaje instantaneamente' },
          { id: 'diamante_eterno', name: 'üíé Diamante Eterno', price: 10000000, desc: 'Item colecion√°vel raro' },
          { id: 'coroa_rei', name: 'üëë Coroa Real', price: 25000000, desc: 'S√≠mbolo m√°ximo de poder' },
          { id: 'boost_permanente', name: '‚ö° Boost Permanente', price: 3000000, desc: '+50% em todas atividades' },
          { id: 'protecao_vip', name: 'üõ°Ô∏è Prote√ß√£o VIP', price: 1000000, desc: 'Prote√ß√£o eterna contra roubos' },
          { id: 'multiplicador_xp', name: '‚ú® Multiplicador XP', price: 2500000, desc: '2x XP permanente' }
        ];
        
        let text = `‚ï≠‚îÅ‚îÅ‚îÅ‚ä± üíé *LOJA PREMIUM* ‚ä±‚îÅ‚îÅ‚îÅ‚ïÆ\n`;
        text += `‚îÇ Itens exclusivos de luxo!\n`;
        text += `‚ï∞‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚ïØ\n\n`;
        
        premiumItems.forEach(item => {
          text += `${item.name}\n`;
          text += `   üí∞ ${item.price.toLocaleString()} moedas\n`;
          text += `   üìù ${item.desc}\n`;
          text += `   üõí ${prefix}comprarpremium ${item.id}\n\n`;
        });
        
        return reply(text);
      }
      
      // Comprar item premium
      case 'comprarpremium':
      case 'buypremium': {
        if (!isGroup) return reply('‚öîÔ∏è Este comando funciona apenas em grupos com Modo RPG ativo.');
        if (!groupData.modorpg) return reply(`‚öîÔ∏è Modo RPG desativado! Use ${prefix}modorpg para ativar.`);
        
        const rawItemId = (args[0] || '');
        if (!rawItemId) return reply(`‚ùå Informe o item!\n\nüí° Uso: ${prefix}comprarpremium <item>\nüõí Veja a loja: ${prefix}lojapremium`);
        
        const premiumItems = {
          'titulo_lendario': { name: 'üèÖ T√≠tulo Lend√°rio', price: 500000 },
          'mascote_raro': { name: 'ü¶Ñ Mascote Raro', price: 750000 },
          'mansao': { name: 'üè∞ Mans√£o', price: 2000000, income: 5000 },
          'yate': { name: 'üõ•Ô∏è Iate', price: 1500000 },
          'jet_privado': { name: '‚úàÔ∏è Jato Privado', price: 5000000 },
          'diamante_eterno': { name: 'üíé Diamante Eterno', price: 10000000 },
          'coroa_rei': { name: 'üëë Coroa Real', price: 25000000 },
          'boost_permanente': { name: '‚ö° Boost Permanente', price: 3000000 },
          'protecao_vip': { name: 'üõ°Ô∏è Prote√ß√£o VIP', price: 1000000 },
          'multiplicador_xp': { name: '‚ú® Multiplicador XP', price: 2500000 }
        };
        
        // Normaliza a busca do item ignorando acentos
        const itemId = findKeyIgnoringAccents(premiumItems, rawItemId) || normalizeParam(rawItemId).replace(/\s+/g, '_');
        const item = premiumItems[itemId];
        if (!item) return reply(`‚ùå Item n√£o encontrado!\n\nüõí Veja a loja: ${prefix}lojapremium`);
        
        const econ = loadEconomy();
        const me = getEcoUser(econ, sender);
        
        if (me.wallet < item.price) {
          return reply(`‚ùå Saldo insuficiente!\n\nüí∞ Necess√°rio: ${item.price.toLocaleString()}\nüíº Sua carteira: ${me.wallet.toLocaleString()}`);
        }
        
        me.wallet -= item.price;
        me.premiumItems = me.premiumItems || {};
        me.premiumItems[itemId] = (me.premiumItems[itemId] || 0) + 1;
        
        // Aplicar efeitos especiais
        if (itemId === 'boost_permanente') me.permanentBoost = true;
        if (itemId === 'protecao_vip') me.vipProtection = true;
        if (itemId === 'multiplicador_xp') me.xpMultiplier = 2;
        if (item.income) me.dailyIncome = (me.dailyIncome || 0) + item.income;
        
        saveEconomy(econ);
        
        return reply(`‚ï≠‚îÅ‚îÅ‚îÅ‚ä± ‚úÖ *COMPRA PREMIUM* ‚ä±‚îÅ‚îÅ‚îÅ‚ïÆ\n‚îÇ\n‚îÇ üõí ${item.name}\n‚îÇ üí∞ -${item.price.toLocaleString()}\n‚îÇ\n‚îÇ ‚ú® Item adicionado com sucesso!\n‚îÇ\n‚ï∞‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚ïØ`);
      }
      
      // Cassino Roleta - NERFADO
      case 'roleta':
      case 'roulette': {
        if (!isGroup) return reply('‚öîÔ∏è Este comando funciona apenas em grupos com Modo RPG ativo.');
        if (!groupData.modorpg) return reply(`‚öîÔ∏è Modo RPG desativado! Use ${prefix}modorpg para ativar.`);
        
        const econ = loadEconomy();
        const me = getEcoUser(econ, sender);
        
        // Cooldown de 10 minutos
        const cdRoleta = me.cooldowns?.roleta || 0;
        if (Date.now() < cdRoleta) return reply(`‚è≥ Aguarde ${timeLeft(cdRoleta)} para jogar roleta novamente.`);
        
        const bet = parseInt(args[0]) || 0;
        const rawChoice = (args[1] || '');
        
        if (bet <= 0) return reply(`üé∞ *ROLETA*\n\nüí° Uso: ${prefix}roleta <valor> <cor>\n\nCores: vermelho, preto, verde\n\nüî¥ Vermelho: 1.5x\n‚ö´ Preto: 1.5x\nüü¢ Verde (0): 5x`);
        
        // Normaliza a cor escolhida
        const colorMap = {
          'vermelho': 'vermelho', 'red': 'vermelho', 'rubro': 'vermelho', 'encarnado': 'vermelho',
          'preto': 'preto', 'black': 'preto', 'negro': 'preto',
          'verde': 'verde', 'green': 'verde'
        };
        const normalizedRaw = normalizeParam(rawChoice);
        const choice = colorMap[normalizedRaw] || findKeyIgnoringAccents(colorMap, rawChoice);
        
        if (!choice) {
          return reply('‚ùå Escolha: vermelho, preto ou verde\n\nüìù Aceita: red, black, green tamb√©m');
        }
        
        if (bet > me.wallet) return reply('‚ùå Saldo insuficiente na carteira!');
        
        // ROLETA NERFADA: A cor que o jogador N√ÉO escolheu tem 85% de chance de sair
        const result = Math.random();
        let winColor;
        const otherColors = ['vermelho', 'preto', 'verde'].filter(c => c !== choice);
        
        if (result < 0.85) {
          // 85% de chance de cair na cor que o jogador N√ÉO escolheu
          winColor = otherColors[Math.floor(Math.random() * otherColors.length)];
        } else if (result < 0.97) {
          // 12% de chance de cair na cor escolhida (se n√£o for verde)
          winColor = choice === 'verde' ? otherColors[0] : choice;
        } else {
          // 3% de chance de verde (se escolheu verde, ainda assim s√≥ 3%)
          winColor = 'verde';
        }
        
        const colorEmoji = { vermelho: 'üî¥', preto: '‚ö´', verde: 'üü¢' };
        const normalizedChoice = choice;
        
        me.cooldowns = me.cooldowns || {};
        me.cooldowns.roleta = Date.now() + 10*60*1000; // 10 minutos
        
        let text = `‚ï≠‚îÅ‚îÅ‚îÅ‚ä± üé∞ *ROLETA* ‚ä±‚îÅ‚îÅ‚îÅ‚ïÆ\n\n`;
        text += `üéØ Sua aposta: ${colorEmoji[choice]} ${bet.toLocaleString()}\n`;
        text += `üé≤ Resultado: ${colorEmoji[winColor]} ${winColor.toUpperCase()}\n\n`;
        
        if (normalizedChoice === winColor) {
          const multiplier = winColor === 'verde' ? 5 : 1.5; // multiplicadores reduzidos (era 14x e 2x)
          const winnings = Math.floor(bet * multiplier);
          me.wallet += winnings - bet;
          text += `üèÜ *VIT√ìRIA RARA!*\nüí∞ +${winnings.toLocaleString()} (${multiplier}x)`;
        } else {
          me.wallet -= bet;
          text += `üíÄ *VOC√ä PERDEU!*\nüí∏ -${bet.toLocaleString()}\nüé∞ A roleta parece viciada...`;
        }
        
        text += `\n\n‚ï∞‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚ïØ`;
        
        saveEconomy(econ);
        return reply(text);
      }
      
      // Blackjack - NERFADO
      case 'blackjack':
      case 'bj':
      case '21': {
        if (!isGroup) return reply('‚öîÔ∏è Este comando funciona apenas em grupos com Modo RPG ativo.');
        if (!groupData.modorpg) return reply(`‚öîÔ∏è Modo RPG desativado! Use ${prefix}modorpg para ativar.`);
        
        const econ = loadEconomy();
        const me = getEcoUser(econ, sender);
        
        // Cooldown de 10 minutos
        const cdBJ = me.cooldowns?.blackjack || 0;
        if (Date.now() < cdBJ) return reply(`‚è≥ Aguarde ${timeLeft(cdBJ)} para jogar blackjack novamente.`);
        
        const bet = parseInt(args[0]) || 0;
        if (bet <= 0) return reply(`üÉè *BLACKJACK*\n\nüí° Uso: ${prefix}blackjack <valor>\n\nüìú Regras: Chegue mais perto de 21 sem passar!`);
        if (bet > me.wallet) return reply('‚ùå Saldo insuficiente!');
        
        // BLACKJACK NERFADO: Dealer tem cartas viciadas
        const getPlayerCard = () => {
          // Jogador tem mais chance de pegar cartas altas (que causam bust)
          const values = ['A', '2', '3', '4', '5', '6', '7', '8', '9', '10', 'J', 'Q', 'K'];
          const weights = [5, 3, 3, 4, 5, 6, 8, 10, 12, 15, 12, 10, 7]; // Cartas altas mais prov√°veis
          const total = weights.reduce((a, b) => a + b, 0);
          let rand = Math.random() * total;
          for (let i = 0; i < values.length; i++) {
            rand -= weights[i];
            if (rand <= 0) return values[i];
          }
          return values[0];
        };
        
        const getDealerCard = () => {
          // Dealer tem mais chance de pegar cartas m√©dias (evita bust)
          const values = ['A', '2', '3', '4', '5', '6', '7', '8', '9', '10', 'J', 'Q', 'K'];
          const weights = [8, 6, 7, 8, 9, 10, 12, 10, 8, 6, 5, 5, 6]; // Cartas m√©dias mais prov√°veis
          const total = weights.reduce((a, b) => a + b, 0);
          let rand = Math.random() * total;
          for (let i = 0; i < values.length; i++) {
            rand -= weights[i];
            if (rand <= 0) return values[i];
          }
          return values[0];
        };
        
        const getValue = (cards) => {
          let total = 0;
          let aces = 0;
          cards.forEach(c => {
            if (c === 'A') { aces++; total += 11; }
            else if (['J', 'Q', 'K'].includes(c)) total += 10;
            else total += parseInt(c);
          });
          while (total > 21 && aces > 0) { total -= 10; aces--; }
          return total;
        };
        
        const playerCards = [getPlayerCard(), getPlayerCard()];
        const dealerCards = [getDealerCard(), getDealerCard()];
        
        // Simular jogo (simplificado) - jogador mais agressivo
        while (getValue(playerCards) < 17) playerCards.push(getPlayerCard());
        while (getValue(dealerCards) < 17) dealerCards.push(getDealerCard());
        
        const playerValue = getValue(playerCards);
        const dealerValue = getValue(dealerCards);
        
        me.cooldowns = me.cooldowns || {};
        me.cooldowns.blackjack = Date.now() + 10*60*1000; // 10 minutos
        
        let text = `‚ï≠‚îÅ‚îÅ‚îÅ‚ä± üÉè *BLACKJACK* ‚ä±‚îÅ‚îÅ‚îÅ‚ïÆ\n\n`;
        text += `üë§ Voc√™: ${playerCards.join(' ')} = ${playerValue}\n`;
        text += `üé∞ Dealer: ${dealerCards.join(' ')} = ${dealerValue}\n\n`;
        
        if (playerValue > 21) {
          me.wallet -= bet;
          text += `üíÄ *BUST!* Voc√™ passou de 21!\nüí∏ -${bet.toLocaleString()}\nüÉè Que azar...`;
        } else if (dealerValue > 21 || playerValue > dealerValue) {
          // Ganhos reduzidos
          const winnings = playerValue === 21 && playerCards.length === 2 ? Math.floor(bet * 1.8) : Math.floor(bet * 1.4);
          me.wallet += winnings - bet;
          text += `üèÜ *VIT√ìRIA RARA!*\nüí∞ +${(winnings - bet).toLocaleString()}`;
        } else if (playerValue === dealerValue) {
          // Empate agora perde 30% da aposta
          const loss = Math.floor(bet * 0.3);
          me.wallet -= loss;
          text += `ü§ù *EMPATE!*\nüí∏ Taxa de empate: -${loss.toLocaleString()}`;
        } else {
          me.wallet -= bet;
          text += `üíÄ *DEALER VENCEU!*\nüí∏ -${bet.toLocaleString()}\nüÉè O dealer parece ter sorte demais...`;
        }
        
        text += `\n\n‚ï∞‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚ïØ`;
        
        saveEconomy(econ);
        return reply(text);
      }
      
      // Sistema de Slots (Ca√ßa-n√≠queis) - NERFADO
      case 'slots':
      case 'slotmachine':
      case 'cacaniquel': {
        if (!isGroup) return reply('‚öîÔ∏è Este comando funciona apenas em grupos com Modo RPG ativo.');
        if (!groupData.modorpg) return reply(`‚öîÔ∏è Modo RPG desativado! Use ${prefix}modorpg para ativar.`);
        
        const econ = loadEconomy();
        const me = getEcoUser(econ, sender);
        
        // Cooldown de 8 minutos
        const cdSlots2 = me.cooldowns?.slots2 || 0;
        if (Date.now() < cdSlots2) return reply(`‚è≥ Aguarde ${timeLeft(cdSlots2)} para jogar slots novamente.`);
        
        const bet = parseInt(args[0]) || 0;
        if (bet <= 0) return reply(`üé∞ *CA√áA-N√çQUEIS*\n\nüí° Uso: ${prefix}slots <valor>\n\nüé≤ Alinhe 3 s√≠mbolos iguais para ganhar!`);
        if (bet > me.wallet) return reply('‚ùå Saldo insuficiente!');
        
        // SLOTS NERFADO: Cada posi√ß√£o tem prefer√™ncia por s√≠mbolos diferentes
        const symbols = ['üçí', 'üçã', 'üçä', 'üçá', '‚≠ê', 'üíé', '7Ô∏è‚É£'];
        
        const getSymbol = (position) => {
          // Cada posi√ß√£o tem pesos diferentes para quase nunca combinar
          const baseWeights = [25, 20, 18, 15, 12, 7, 3];
          const shifted = [...baseWeights.slice(position * 2), ...baseWeights.slice(0, position * 2)];
          const total = shifted.reduce((a, b) => a + b);
          let random = Math.random() * total;
          for (let i = 0; i < symbols.length; i++) {
            random -= shifted[i];
            if (random <= 0) return symbols[i];
          }
          return symbols[0];
        };
        
        const slot1 = getSymbol(0);
        const slot2 = getSymbol(1);
        const slot3 = getSymbol(2);
        
        // Multiplicadores reduzidos
        const multipliers = {
          'üçí': 1.5, 'üçã': 2, 'üçä': 2.5, 'üçá': 3, '‚≠ê': 5, 'üíé': 10, '7Ô∏è‚É£': 25
        };
        
        me.cooldowns = me.cooldowns || {};
        me.cooldowns.slots2 = Date.now() + 8*60*1000; // 8 minutos
        
        let text = `‚ï≠‚îÅ‚îÅ‚îÅ‚ä± üé∞ *SLOTS* ‚ä±‚îÅ‚îÅ‚îÅ‚ïÆ\n\n`;
        text += `‚îè‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îì\n`;
        text += `‚îÉ  ${slot1}  ‚îÇ  ${slot2}  ‚îÇ  ${slot3}  ‚îÉ\n`;
        text += `‚îó‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îõ\n\n`;
        
        if (slot1 === slot2 && slot2 === slot3) {
          // Jackpot! (muito raro agora)
          const multi = multipliers[slot1];
          const winnings = Math.floor(bet * multi);
          me.wallet += winnings - bet;
          text += `üéâ *JACKPOT RARO!* üéâ\n`;
          text += `üí∞ Voc√™ ganhou ${winnings.toLocaleString()}! (${multi}x)`;
        } else if (slot1 === slot2 || slot2 === slot3 || slot1 === slot3) {
          // 2 iguais - agora paga menos
          const winnings = Math.floor(bet * 1.1);
          me.wallet += winnings - bet;
          text += `‚≠ê *PAR!*\n`;
          text += `üí∞ Voc√™ ganhou ${(winnings - bet).toLocaleString()}! (1.1x)`;
        } else {
          me.wallet -= bet;
          text += `üíÄ *PERDEU!*\nüí∏ -${bet.toLocaleString()}\nüé∞ A m√°quina parece viciada...`;
        }
        
        text += `\n\n‚ï∞‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚ïØ`;
        
        saveEconomy(econ);
        return reply(text);
      }
      
      // Loteria
      case 'loteria':
      case 'lottery':
      case 'mega': {
        if (!isGroup) return reply('‚öîÔ∏è Este comando funciona apenas em grupos com Modo RPG ativo.');
        if (!groupData.modorpg) return reply(`‚öîÔ∏è Modo RPG desativado! Use ${prefix}modorpg para ativar.`);
        
        const econ = loadEconomy();
        const me = getEcoUser(econ, sender);
        
        const ticketPrice = 10000;
        const sub = (args[0] || '').toLowerCase();
        
        if (!econ.lottery) {
          econ.lottery = {
            jackpot: 100000,
            tickets: {},
            lastDraw: Date.now(),
            winners: []
          };
        }
        
        // Garantir que lastDraw seja sempre v√°lido
        if (!econ.lottery.lastDraw || econ.lottery.lastDraw === 0) {
          econ.lottery.lastDraw = Date.now();
        }
        
        if (!sub || sub === 'ver') {
          const myTickets = econ.lottery.tickets[sender] || 0;
          const totalTickets = Object.values(econ.lottery.tickets).reduce((a, b) => a + b, 0);
          const nextDrawTime = econ.lottery.lastDraw + 86400000; // +24 horas
          const nextDraw = new Date(nextDrawTime).toLocaleString('pt-BR');
          
          let text = `‚ï≠‚îÅ‚îÅ‚îÅ‚ä± üé´ *LOTERIA* ‚ä±‚îÅ‚îÅ‚îÅ‚ïÆ\n\n`;
          text += `üí∞ Jackpot: *${econ.lottery.jackpot.toLocaleString()}*\n`;
          text += `üéüÔ∏è Total de bilhetes: ${totalTickets}\n`;
          text += `üìÖ Pr√≥ximo sorteio: ${nextDraw}\n\n`;
          text += `üé´ Seus bilhetes: ${myTickets}\n`;
          text += `üíµ Pre√ßo: ${ticketPrice.toLocaleString()}/bilhete\n\n`;
          text += `üí° Use ${prefix}loteria comprar <qtd>`;
          
          return reply(text);
        }
        
        if (sub === 'comprar') {
          const qty = parseInt(args[1]) || 1;
          const totalCost = ticketPrice * qty;
          
          if (me.wallet < totalCost) {
            return reply(`‚ùå Saldo insuficiente!\n\nüí∞ Necess√°rio: ${totalCost.toLocaleString()}\nüíº Sua carteira: ${me.wallet.toLocaleString()}`);
          }
          
          me.wallet -= totalCost;
          econ.lottery.tickets[sender] = (econ.lottery.tickets[sender] || 0) + qty;
          econ.lottery.jackpot += totalCost;
          
          saveEconomy(econ);
          
          return reply(`‚ï≠‚îÅ‚îÅ‚îÅ‚ä± üé´ *BILHETES COMPRADOS* ‚ä±‚îÅ‚îÅ‚îÅ‚ïÆ\n\nüéüÔ∏è Quantidade: ${qty}\nüí∞ Total: -${totalCost.toLocaleString()}\n\nüé´ Seus bilhetes: ${econ.lottery.tickets[sender]}\nüí∞ Jackpot atual: ${econ.lottery.jackpot.toLocaleString()}\n\n‚ï∞‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚ïØ`);
        }
        
        return reply(`‚ùå Subcomando inv√°lido!\n\nüí° Use:\n${prefix}loteria - Ver informa√ß√µes\n${prefix}loteria comprar <qtd> - Comprar bilhetes`);
      }
      
      // Corrida de cavalos
      case 'corrida':
      case 'horserace':
      case 'cavalos': {
        if (!isGroup) return reply('‚öîÔ∏è Este comando funciona apenas em grupos com Modo RPG ativo.');
        if (!groupData.modorpg) return reply(`‚öîÔ∏è Modo RPG desativado! Use ${prefix}modorpg para ativar.`);
        
        const econ = loadEconomy();
        const me = getEcoUser(econ, sender);
        
        const bet = parseInt(args[0]) || 0;
        const horse = parseInt(args[1]) || 0;
        
        if (bet <= 0 || horse < 1 || horse > 5) {
          let text = `‚ï≠‚îÅ‚îÅ‚îÅ‚ä± üèá *CORRIDA DE CAVALOS* ‚ä±‚îÅ‚îÅ‚îÅ‚ïÆ\n\n`;
          text += `üí° Uso: ${prefix}corrida <valor> <cavalo 1-5>\n\n`;
          text += `üê¥ Cavalos:\n`;
          text += `1. üü§ Trov√£o (1.5x) - Favorito\n`;
          text += `2. ‚ö™ Rel√¢mpago (2x)\n`;
          text += `3. ‚ö´ Sombra (3x)\n`;
          text += `4. üü° Ouro (5x)\n`;
          text += `5. üî¥ F√™nix (10x) - Zebra\n`;
          text += `\n‚ï∞‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚ïØ`;
          return reply(text);
        }
        
        if (bet > me.wallet) return reply('‚ùå Saldo insuficiente!');
        
        const horses = [
          { name: 'üü§ Trov√£o', odds: 1.5, chance: 35 },
          { name: '‚ö™ Rel√¢mpago', odds: 2, chance: 25 },
          { name: '‚ö´ Sombra', odds: 3, chance: 20 },
          { name: 'üü° Ouro', odds: 5, chance: 12 },
          { name: 'üî¥ F√™nix', odds: 10, chance: 8 }
        ];
        
        const selectedHorse = horses[horse - 1];
        
        // Determinar vencedor
        let random = Math.random() * 100;
        let winner = 0;
        for (let i = 0; i < horses.length; i++) {
          random -= horses[i].chance;
          if (random <= 0) { winner = i + 1; break; }
        }
        
        let text = `‚ï≠‚îÅ‚îÅ‚îÅ‚ä± üèá *CORRIDA* ‚ä±‚îÅ‚îÅ‚îÅ‚ïÆ\n\n`;
        text += `üéØ Voc√™ apostou: ${selectedHorse.name}\n`;
        text += `üí∞ Valor: ${bet.toLocaleString()}\n\n`;
        text += `üèÅ E o vencedor √©...\n\n`;
        text += `üèÜ *${horses[winner - 1].name}*\n\n`;
        
        if (winner === horse) {
          const winnings = Math.floor(bet * selectedHorse.odds);
          me.wallet += winnings - bet;
          text += `üéâ *VOC√ä GANHOU!*\nüí∞ +${winnings.toLocaleString()} (${selectedHorse.odds}x)`;
        } else {
          me.wallet -= bet;
          text += `üíÄ *VOC√ä PERDEU!*\nüí∏ -${bet.toLocaleString()}`;
        }
        
        text += `\n\n‚ï∞‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚ïØ`;
        
        saveEconomy(econ);
        return reply(text);
      }
      
      // Leil√£o
      case 'leilao':
      case 'leilaorpg':
      case 'leiloar': {
        if (!isGroup) return reply('‚öîÔ∏è Este comando funciona apenas em grupos com Modo RPG ativo.');
        if (!groupData.modorpg) return reply(`‚öîÔ∏è Modo RPG desativado! Use ${prefix}modorpg para ativar.`);
        
        const econ = loadEconomy();
        const me = getEcoUser(econ, sender);
        
        if (!econ.auctions) econ.auctions = [];
        
        const sub = (args[0] || '').toLowerCase();
        
        if (!sub || sub === 'ver') {
          if (econ.auctions.length === 0) {
            return reply(`üèõÔ∏è Nenhum leil√£o ativo!\n\nüí° Use ${prefix}leilao criar <item> <pre√ßo> para criar um leil√£o`);
          }
          
          let text = `‚ï≠‚îÅ‚îÅ‚îÅ‚ä± üèõÔ∏è *LEIL√ïES ATIVOS* ‚ä±‚îÅ‚îÅ‚îÅ‚ïÆ\n\n`;
          
          econ.auctions.forEach((auction, i) => {
            const endsIn = Math.max(0, Math.floor((auction.endTime - Date.now()) / 60000));
            text += `${i + 1}. ${auction.item}\n`;
            text += `   üí∞ Lance atual: ${auction.currentBid.toLocaleString()}\n`;
            text += `   üë§ Maior lance: @${auction.highestBidder ? auction.highestBidder.split('@')[0] : 'Ningu√©m'}\n`;
            text += `   ‚è∞ Termina em: ${endsIn} min\n\n`;
          });
          
          text += `üí° ${prefix}leilao dar <n¬∫> <valor>\n`;
          text += `‚ï∞‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚ïØ`;
          
          saveEconomy(econ);
          return reply(text);
        }
        
        if (sub === 'criar') {
          const item = args[1];
          const price = parseInt(args[2]) || 0;
          
          if (!item || price < 1000) {
            return reply(`‚ùå Use: ${prefix}leilao criar <item> <pre√ßo_inicial>\n\nüìå Pre√ßo m√≠nimo: 1.000`);
          }
          
          if (!me.inventory || !me.inventory[item] || me.inventory[item] < 1) {
            return reply(`‚ùå Voc√™ n√£o tem esse item no invent√°rio!`);
          }
          
          me.inventory[item]--;
          
          econ.auctions.push({
            seller: sender,
            item: item,
            startPrice: price,
            currentBid: price,
            highestBidder: null,
            endTime: Date.now() + 3600000 // 1 hora
          });
          
          saveEconomy(econ);
          
          return reply(`‚ï≠‚îÅ‚îÅ‚îÅ‚ä± üèõÔ∏è *LEIL√ÉO CRIADO* ‚ä±‚îÅ‚îÅ‚îÅ‚ïÆ\n\nüì¶ Item: ${item}\nüí∞ Pre√ßo inicial: ${price.toLocaleString()}\n‚è∞ Dura√ß√£o: 1 hora\n\n‚ï∞‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚ïØ`);
        }
        
        if (sub === 'dar' || sub === 'bid') {
          const auctionIndex = parseInt(args[1]) - 1;
          const bidAmount = parseInt(args[2]) || 0;
          
          if (auctionIndex < 0 || auctionIndex >= econ.auctions.length) {
            return reply('‚ùå Leil√£o n√£o encontrado!');
          }
          
          const auction = econ.auctions[auctionIndex];
          
          if (auction.seller === sender) {
            return reply('‚ùå Voc√™ n√£o pode dar lance no pr√≥prio leil√£o!');
          }
          
          if (bidAmount <= auction.currentBid) {
            return reply(`‚ùå Lance deve ser maior que ${auction.currentBid.toLocaleString()}!`);
          }
          
          if (me.wallet < bidAmount) {
            return reply('‚ùå Saldo insuficiente!');
          }
          
          // Devolver dinheiro ao lance anterior
          if (auction.highestBidder) {
            const prevBidder = getEcoUser(econ, auction.highestBidder);
            prevBidder.wallet += auction.currentBid;
          }
          
          me.wallet -= bidAmount;
          auction.currentBid = bidAmount;
          auction.highestBidder = sender;
          
          saveEconomy(econ);
          
          return reply(`‚ï≠‚îÅ‚îÅ‚îÅ‚ä± üèõÔ∏è *LANCE DADO* ‚ä±‚îÅ‚îÅ‚îÅ‚ïÆ\n\nüì¶ Item: ${auction.item}\nüí∞ Seu lance: ${bidAmount.toLocaleString()}\nüèÜ Voc√™ √© o maior lance!\n\n‚ï∞‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚ïØ`);
        }
        
        return reply(`‚ùå Subcomando inv√°lido!\n\nüí° Use:\n${prefix}leilao - Ver leil√µes\n${prefix}leilao criar <item> <pre√ßo>\n${prefix}leilao dar <n¬∫> <valor>`);
      }
      
      // Ranking de riqueza global
      case 'topriqueza':
      case 'toprich':
      case 'maiores': {
        const econ = loadEconomy();
        const allUsers = Object.entries(econ.users || {});
        
        if (allUsers.length === 0) return reply('üìä Nenhum jogador registrado ainda.');
        
        const rankedUsers = allUsers.map(([id, data]) => {
          const totalWealth = (data.wallet || 0) + (data.bank || 0);
          return { id, totalWealth };
        }).sort((a, b) => b.totalWealth - a.totalWealth).slice(0, 15);
        
        let text = `‚ï≠‚îÅ‚îÅ‚îÅ‚ä± üíé *TOP RIQUEZA* ‚ä±‚îÅ‚îÅ‚îÅ‚ïÆ\n`;
        text += `‚îÇ Os 15 mais ricos do bot!\n`;
        text += `‚ï∞‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚ïØ\n\n`;
        
        const mentions = [];
        rankedUsers.forEach((user, i) => {
          const medal = i === 0 ? 'üëë' : i === 1 ? 'ü•à' : i === 2 ? 'ü•â' : `${i + 1}.`;
          text += `${medal} @${user.id.split('@')[0]}\n`;
          text += `   üí∞ ${user.totalWealth.toLocaleString()}\n`;
          mentions.push(user.id);
        });
        
        return reply(text, { mentions });
      }
      
      // Sistema de Boost/Buff tempor√°rio
      case 'boost':
      case 'buff':
      case 'impulsionar': {
        if (!isGroup) return reply('‚öîÔ∏è Este comando funciona apenas em grupos com Modo RPG ativo.');
        if (!groupData.modorpg) return reply(`‚öîÔ∏è Modo RPG desativado! Use ${prefix}modorpg para ativar.`);
        
        const econ = loadEconomy();
        const me = getEcoUser(econ, sender);
        
        const boosts = {
          xp: { name: '‚ú® Boost XP (2x)', price: 50000, duration: 3600000, effect: 'xpBoost' },
          money: { name: 'üí∞ Boost Moedas (1.5x)', price: 75000, duration: 3600000, effect: 'moneyBoost' },
          luck: { name: 'üçÄ Boost Sorte (+20%)', price: 100000, duration: 3600000, effect: 'luckBoost' },
          power: { name: '‚öîÔ∏è Boost Poder (+50%)', price: 80000, duration: 1800000, effect: 'powerBoost' },
          mega: { name: 'üî• Mega Boost (Todos)', price: 250000, duration: 1800000, effect: 'megaBoost' }
        };
        
        const rawSub = (args[0] || '');
        // Normaliza o par√¢metro do boost
        const sub = rawSub ? (resolveParamAlias(rawSub) || findKeyIgnoringAccents(boosts, rawSub) || normalizeParam(rawSub)) : '';
        
        if (!sub || sub === 'ver') {
          let text = `‚ï≠‚îÅ‚îÅ‚îÅ‚ä± ‚ö° *BOOSTS* ‚ä±‚îÅ‚îÅ‚îÅ‚ïÆ\n\n`;
          
          // Verificar boosts ativos
          if (me.activeBoosts && Object.keys(me.activeBoosts).length > 0) {
            text += `üî• *BOOSTS ATIVOS:*\n`;
            for (const [key, boost] of Object.entries(me.activeBoosts)) {
              if (Date.now() < boost.expires) {
                const remaining = Math.ceil((boost.expires - Date.now()) / 60000);
                text += `‚Ä¢ ${boosts[key]?.name || key}: ${remaining} min restantes\n`;
              }
            }
            text += `\n`;
          }
          
          text += `üì¶ *BOOSTS DISPON√çVEIS:*\n\n`;
          
          for (const [id, boost] of Object.entries(boosts)) {
            text += `${boost.name}\n`;
            text += `   üí∞ ${boost.price.toLocaleString()}\n`;
            text += `   ‚è∞ ${boost.duration / 60000} minutos\n`;
            text += `   üõí ${prefix}boost ${id}\n\n`;
          }
          
          return reply(text);
        }
        
        const boost = boosts[sub];
        if (!boost) return reply(`‚ùå Boost n√£o encontrado!\n\nüí° Use ${prefix}boost para ver dispon√≠veis`);
        
        if (me.wallet < boost.price) {
          return reply(`‚ùå Saldo insuficiente!\n\nüí∞ Necess√°rio: ${boost.price.toLocaleString()}\nüíº Sua carteira: ${me.wallet.toLocaleString()}`);
        }
        
        me.wallet -= boost.price;
        
        if (!me.activeBoosts) me.activeBoosts = {};
        me.activeBoosts[sub] = {
          expires: Date.now() + boost.duration,
          effect: boost.effect
        };
        
        saveEconomy(econ);
        
        return reply(`‚ï≠‚îÅ‚îÅ‚îÅ‚ä± ‚ö° *BOOST ATIVADO* ‚ä±‚îÅ‚îÅ‚îÅ‚ïÆ\n\n${boost.name}\n‚è∞ Dura√ß√£o: ${boost.duration / 60000} minutos\nüí∞ Custo: -${boost.price.toLocaleString()}\n\nüî• Aproveite os b√¥nus!\n\n‚ï∞‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚ïØ`);
      }
      
      // Sistema de Tributos/Impostos
      case 'tributos':
      case 'impostos':
      case 'taxes': {
        if (!isGroup) return reply('‚öîÔ∏è Este comando funciona apenas em grupos com Modo RPG ativo.');
        if (!groupData.modorpg) return reply(`‚öîÔ∏è Modo RPG desativado! Use ${prefix}modorpg para ativar.`);
        
        const econ = loadEconomy();
        const me = getEcoUser(econ, sender);
        
        const totalWealth = (me.wallet || 0) + (me.bank || 0);
        
        // Taxa de imposto baseada na riqueza
        let taxRate = 0;
        let taxBracket = '';
        
        if (totalWealth >= 10000000) {
          taxRate = 0.1; // 10%
          taxBracket = 'üíé Elite (10%)';
        } else if (totalWealth >= 5000000) {
          taxRate = 0.07; // 7%
          taxBracket = 'üèÜ Rico (7%)';
        } else if (totalWealth >= 1000000) {
          taxRate = 0.05; // 5%
          taxBracket = 'üí∞ Classe Alta (5%)';
        } else if (totalWealth >= 500000) {
          taxRate = 0.03; // 3%
          taxBracket = 'üìà Classe M√©dia (3%)';
        } else if (totalWealth >= 100000) {
          taxRate = 0.01; // 1%
          taxBracket = 'üìä Trabalhador (1%)';
        } else {
          taxRate = 0;
          taxBracket = 'üÜì Isento (0%)';
        }
        
        const dailyTax = Math.floor(totalWealth * taxRate / 7); // Semanal dividido por dia
        
        if (!me.taxes) {
          me.taxes = {
            lastPaid: 0,
            totalPaid: 0,
            exempt: false
          };
        }
        
        const sub = (args[0] || '').toLowerCase();
        
        if (!sub || sub === 'ver') {
          const daysSincePayment = Math.floor((Date.now() - (me.taxes.lastPaid || 0)) / 86400000);
          const dueAmount = daysSincePayment > 0 ? dailyTax * daysSincePayment : 0;
          
          let text = `‚ï≠‚îÅ‚îÅ‚îÅ‚ä± üè¶ *TRIBUTOS* ‚ä±‚îÅ‚îÅ‚îÅ‚ïÆ\n\n`;
          text += `üíé Riqueza Total: ${totalWealth.toLocaleString()}\n`;
          text += `üìä Faixa: ${taxBracket}\n`;
          text += `üí∞ Taxa di√°ria: ${dailyTax.toLocaleString()}\n\n`;
          text += `üìÖ Dias desde pagamento: ${daysSincePayment}\n`;
          text += `üí∏ Valor devido: ${dueAmount.toLocaleString()}\n`;
          text += `üìà Total j√° pago: ${me.taxes.totalPaid.toLocaleString()}\n\n`;
          
          if (dueAmount > 0) {
            text += `‚ö†Ô∏è Pague seus tributos!\n`;
            text += `üí° Use ${prefix}tributos pagar\n\n`;
            text += `‚ùå Penalidade: -20% trabalho se n√£o pagar`;
          } else {
            text += `‚úÖ Tributos em dia!`;
          }
          
          text += `\n\n‚ï∞‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚ïØ`;
          
          saveEconomy(econ);
          return reply(text);
        }
        
        if (sub === 'pagar') {
          const daysSincePayment = Math.floor((Date.now() - (me.taxes.lastPaid || 0)) / 86400000);
          const dueAmount = daysSincePayment > 0 ? dailyTax * daysSincePayment : 0;
          
          if (dueAmount === 0) {
            return reply('‚úÖ Voc√™ n√£o tem tributos pendentes!');
          }
          
          if (me.wallet < dueAmount) {
            return reply(`‚ùå Saldo insuficiente!\n\nüí∏ Valor devido: ${dueAmount.toLocaleString()}\nüíº Sua carteira: ${me.wallet.toLocaleString()}`);
          }
          
          me.wallet -= dueAmount;
          me.taxes.lastPaid = Date.now();
          me.taxes.totalPaid = (me.taxes.totalPaid || 0) + dueAmount;
          
          saveEconomy(econ);
          
          return reply(`‚ï≠‚îÅ‚îÅ‚îÅ‚ä± ‚úÖ *TRIBUTOS PAGOS* ‚ä±‚îÅ‚îÅ‚îÅ‚ïÆ\n\nüí∏ Valor: -${dueAmount.toLocaleString()}\nüìÖ Pr√≥ximo: Em 1 dia\n\n‚úÖ Voc√™ est√° em dia!\n\n‚ï∞‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚ïØ`);
        }
        
        return reply(`‚ùå Subcomando inv√°lido!\n\nüí° Use:\n${prefix}tributos - Ver situa√ß√£o\n${prefix}tributos pagar - Pagar tributos`);
      }
      
      // Sistema de Doa√ß√£o
      case 'doar':
      case 'donate':
      case 'doacao': {
        if (!isGroup) return reply('‚öîÔ∏è Este comando funciona apenas em grupos com Modo RPG ativo.');
        if (!groupData.modorpg) return reply(`‚öîÔ∏è Modo RPG desativado! Use ${prefix}modorpg para ativar.`);
        
        const econ = loadEconomy();
        const me = getEcoUser(econ, sender);
        
        const amount = parseInt(args[0]) || 0;
        if (amount < 1000) return reply(`üíù *DOA√á√ÉO*\n\nüí° Uso: ${prefix}doar <valor>\n\nüìå M√≠nimo: 1.000 moedas\n‚ú® Ganhe karma e reputa√ß√£o por doar!`);
        
        if (me.wallet < amount) return reply('‚ùå Saldo insuficiente!');
        
        me.wallet -= amount;
        
        // Ganhar karma e reputa√ß√£o
        if (!me.reputation) me.reputation = { points: 0, upvotes: 0, downvotes: 0, karma: 0, fame: 0 };
        const karmaGain = Math.floor(amount / 1000);
        me.reputation.karma = (me.reputation.karma || 0) + karmaGain;
        me.reputation.points = (me.reputation.points || 0) + Math.floor(karmaGain / 2);
        me.reputation.fame = (me.reputation.fame || 0) + 1;
        
        if (!me.donations) me.donations = { total: 0, count: 0 };
        me.donations.total += amount;
        me.donations.count++;
        
        // Adicionar ao tesouro do RPG
        if (!econ.treasury) econ.treasury = 0;
        econ.treasury += amount;
        
        saveEconomy(econ);
        
        return reply(`‚ï≠‚îÅ‚îÅ‚îÅ‚ä± üíù *DOA√á√ÉO* ‚ä±‚îÅ‚îÅ‚îÅ‚ïÆ\n\nüí∞ Valor: ${amount.toLocaleString()}\n‚òØÔ∏è Karma: +${karmaGain}\n‚≠ê Reputa√ß√£o: +${Math.floor(karmaGain / 2)}\n\nüìä Total doado: ${me.donations.total.toLocaleString()}\nüè¶ Tesouro: ${econ.treasury.toLocaleString()}\n\n‚ú® Obrigado pela generosidade!\n\n‚ï∞‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚ïØ`);
      }
      
      // Sistema de Presente
      case 'presente':
      case 'gift': {
        if (!isGroup) return reply('‚öîÔ∏è Este comando funciona apenas em grupos com Modo RPG ativo.');
        if (!groupData.modorpg) return reply(`‚öîÔ∏è Modo RPG desativado! Use ${prefix}modorpg para ativar.`);
        
        const econ = loadEconomy();
        const me = getEcoUser(econ, sender);
        
        const target = (menc_jid2 && menc_jid2[0]) || null;
        if (!target) return reply(`üéÅ *PRESENTE*\n\nüí° Uso: ${prefix}presente @user <item> <quantidade>\n\nüì¶ Envie itens do seu invent√°rio para outros jogadores!`);
        if (target === sender) return reply('‚ùå Voc√™ n√£o pode enviar presentes para si mesmo!');
        
        const item = (args[0] || '').toLowerCase();
        const qty = parseInt(args[1]) || 1;
        
        if (!item) return reply('‚ùå Informe o item que deseja enviar!');
        
        me.inventory = me.inventory || {};
        if (!me.inventory[item] || me.inventory[item] < qty) {
          return reply(`‚ùå Voc√™ n√£o tem ${item} suficiente!\n\nüì¶ Voc√™ tem: ${me.inventory[item] || 0}`);
        }
        
        const targetData = getEcoUser(econ, target);
        targetData.inventory = targetData.inventory || {};
        
        me.inventory[item] -= qty;
        targetData.inventory[item] = (targetData.inventory[item] || 0) + qty;
        
        saveEconomy(econ);
        
        return reply(`‚ï≠‚îÅ‚îÅ‚îÅ‚ä± üéÅ *PRESENTE ENVIADO* ‚ä±‚îÅ‚îÅ‚îÅ‚ïÆ\n\nüì¶ Item: ${item}\nüî¢ Quantidade: ${qty}\nüë§ Para: @${target.split('@')[0]}\n\n‚ú® Presente entregue!\n\n‚ï∞‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚ïØ`, { mentions: [target] });
      }
      
      // Estat√≠sticas pessoais detalhadas
      case 'meustats':
      case 'mystats':
      case 'statsrpg': {
        if (!isGroup) return reply('‚öîÔ∏è Este comando funciona apenas em grupos com Modo RPG ativo.');
        if (!groupData.modorpg) return reply(`‚öîÔ∏è Modo RPG desativado! Use ${prefix}modorpg para ativar.`);
        
        const econ = loadEconomy();
        const me = getEcoUser(econ, sender);
        
        if (!me.stats) me.stats = {};
        
        const totalWealth = (me.wallet || 0) + (me.bank || 0);
        const premiumItems = Object.keys(me.premiumItems || {}).length;
        const achievements = Object.keys(me.achievements || {}).length;
        const pets = (me.pets || []).length;
        
        let text = `‚ï≠‚îÅ‚îÅ‚îÅ‚ä± üìä *MINHAS ESTAT√çSTICAS* ‚ä±‚îÅ‚îÅ‚îÅ‚ïÆ\n`;
        text += `‚îÇ ${pushname}\n`;
        text += `‚ï∞‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚ïØ\n\n`;
        
        text += `üí∞ *FINAN√áAS*\n`;
        text += `‚îú Carteira: ${(me.wallet || 0).toLocaleString()}\n`;
        text += `‚îú Banco: ${(me.bank || 0).toLocaleString()}\n`;
        text += `‚îú Total: ${totalWealth.toLocaleString()}\n`;
        text += `‚îî Doa√ß√µes: ${(me.donations?.total || 0).toLocaleString()}\n\n`;
        
        text += `‚öîÔ∏è *COMBATE*\n`;
        text += `‚îú Batalhas vencidas: ${me.battlesWon || 0}\n`;
        text += `‚îú Batalhas perdidas: ${me.battlesLost || 0}\n`;
        text += `‚îú Duelos: ${me.stats?.duels || 0}\n`;
        text += `‚îî Crimes: ${me.stats?.crimes || 0}\n\n`;
        
        text += `üíº *TRABALHO*\n`;
        text += `‚îú Trabalhos: ${me.stats?.workCount || 0}\n`;
        text += `‚îú Minera√ß√£o: ${me.stats?.mineCount || 0}\n`;
        text += `‚îú Pesca: ${me.stats?.fishCount || 0}\n`;
        text += `‚îî Ca√ßa: ${me.stats?.huntCount || 0}\n\n`;
        
        text += `üé∞ *APOSTAS*\n`;
        text += `‚îú Ganhou: ${(me.stats?.gamblingWins || 0).toLocaleString()}\n`;
        text += `‚îú Perdeu: ${(me.stats?.gamblingLosses || 0).toLocaleString()}\n`;
        text += `‚îî Saldo: ${((me.stats?.gamblingWins || 0) - (me.stats?.gamblingLosses || 0)).toLocaleString()}\n\n`;
        
        text += `üèÜ *PROGRESSO*\n`;
        text += `‚îú Level: ${me.level || 1}\n`;
        text += `‚îú Prestige: ${me.prestige?.level || 0}\n`;
        text += `‚îú Conquistas: ${achievements}\n`;
        text += `‚îú Pets: ${pets}\n`;
        text += `‚îî Itens Premium: ${premiumItems}\n\n`;
        
        text += `‚≠ê *REPUTA√á√ÉO*\n`;
        text += `‚îú Pontos: ${me.reputation?.points || 0}\n`;
        text += `‚îú Karma: ${me.reputation?.karma || 0}\n`;
        text += `‚îî Fama: ${me.reputation?.fame || 0}`;
        
        saveEconomy(econ);
        return reply(text);
      }

      // Sistema de Evolu√ß√£o/Prestige (DIFICULDADE AUMENTADA)
      case 'evoluir':
      case 'evolucao':
      case 'prestige': {
        if (!isGroup) return reply('‚öîÔ∏è Este comando funciona apenas em grupos com Modo RPG ativo.');
        if (!groupData.modorpg) return reply(`‚öîÔ∏è Modo RPG desativado! Use ${prefix}modorpg para ativar.`);
        
        const econ = loadEconomy();
        const me = getEcoUser(econ, sender);
        
        if (!me.prestige) me.prestige = { level: 0, totalResets: 0, bonusMultiplier: 1 };
        
        // Requisitos balanceados e alcan√ß√°veis
        const requiredLevel = 50 + (me.prestige.level * 15); // Level 50, 65, 80...
        const requiredCoins = 100000 + (me.prestige.level * 50000); // 100k, 150k, 200k... (linear)
        const requiredAchievements = 3 + (me.prestige.level * 2); // 3, 5, 7... conquistas
        const requiredTotalWealth = 150000 + (me.prestige.level * 100000); // 150k, 250k, 350k...
        const requiredBattlesWon = 20 + (me.prestige.level * 15); // 20, 35, 50... batalhas
        const requiredWorkTimes = 50 + (me.prestige.level * 30); // 50, 80, 110... trabalhos
        
        const currentAchievements = Object.keys(me.achievements || {}).length;
        const currentBattlesWon = me.battlesWon || 0;
        const currentWorkTimes = me.stats?.workCount || 0;
        const currentTotalWealth = (me.wallet || 0) + (me.bank || 0);
        
        if (!q) {
          let text = `‚ï≠‚îÅ‚îÅ‚îÅ‚ä± üåü *EVOLU√á√ÉO (PRESTIGE)* ‚ä±‚îÅ‚îÅ‚îÅ‚ïÆ\n`;
          text += `‚îÇ ${pushname}\n`;
          text += `‚ï∞‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚ïØ\n\n`;
          text += `üî± Prestige Atual: ${me.prestige.level}\n`;
          text += `üîÑ Resets Totais: ${me.prestige.totalResets}\n`;
          text += `‚ú® Multiplicador: ${me.prestige.bonusMultiplier.toFixed(2)}x\n\n`;
          text += `üìä *REQUISITOS PARA PRESTIGE ${me.prestige.level + 1}:*\n`;
          text += `‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ\n`;
          text += `‚îÇ üìà Level: ${me.level || 1}/${requiredLevel} ${(me.level || 1) >= requiredLevel ? '‚úÖ' : '‚ùå'}\n`;
          text += `‚îÇ üí∞ Carteira: ${(me.wallet || 0).toLocaleString()}/${requiredCoins.toLocaleString()} ${(me.wallet || 0) >= requiredCoins ? '‚úÖ' : '‚ùå'}\n`;
          text += `‚îÇ üíé Riqueza Total: ${currentTotalWealth.toLocaleString()}/${requiredTotalWealth.toLocaleString()} ${currentTotalWealth >= requiredTotalWealth ? '‚úÖ' : '‚ùå'}\n`;
          text += `‚îÇ üèÜ Conquistas: ${currentAchievements}/${requiredAchievements} ${currentAchievements >= requiredAchievements ? '‚úÖ' : '‚ùå'}\n`;
          text += `‚îÇ ‚öîÔ∏è Batalhas: ${currentBattlesWon}/${requiredBattlesWon} ${currentBattlesWon >= requiredBattlesWon ? '‚úÖ' : '‚ùå'}\n`;
          text += `‚îÇ üíº Trabalhos: ${currentWorkTimes}/${requiredWorkTimes} ${currentWorkTimes >= requiredWorkTimes ? '‚úÖ' : '‚ùå'}\n`;
          text += `‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ\n\n`;
          
          text += `üéÅ *RECOMPENSAS DO PRESTIGE:*\n`;
          text += `‚Ä¢ Multiplicador +${((me.prestige.level + 1) * 0.15).toFixed(2)}x\n`;
          text += `‚Ä¢ B√¥nus exclusivo de prestige\n`;
          text += `‚Ä¢ T√≠tulo especial no perfil\n\n`;
          
          const allReqsMet = (me.level || 1) >= requiredLevel && 
                            (me.wallet || 0) >= requiredCoins && 
                            currentTotalWealth >= requiredTotalWealth &&
                            currentAchievements >= requiredAchievements &&
                            currentBattlesWon >= requiredBattlesWon &&
                            currentWorkTimes >= requiredWorkTimes;
          
          if (allReqsMet) {
            text += `‚úÖ *TODOS OS REQUISITOS COMPLETOS!*\n\n`;
            text += `‚ö†Ô∏è *ATEN√á√ÉO - SER√Å PERDIDO:*\n`;
            text += `‚Ä¢ Level volta para 1\n`;
            text += `‚Ä¢ Moedas da carteira resetadas\n`;
            text += `‚Ä¢ Banco reduzido em 50%\n`;
            text += `‚Ä¢ XP zerada\n\n`;
            text += `‚ú® *SER√Å MANTIDO:*\n`;
            text += `‚Ä¢ Pets e equipamentos\n`;
            text += `‚Ä¢ Fam√≠lia, cl√£ e relacionamento\n`;
            text += `‚Ä¢ Itens premium\n`;
            text += `‚Ä¢ Conquistas\n\n`;
            text += `üí° Use ${prefix}evoluir confirmar`;
          } else {
            text += `‚ùå *Complete todos os requisitos!*\n`;
            text += `üí° Dica: Trabalhe, batalhe e conquiste!`;
          }
          
          return reply(text);
        }
        
        if (q !== 'confirmar') return reply('‚ùå Use "confirmar" para prestigiar');
        
        // Verificar todos os requisitos
        if ((me.level || 1) < requiredLevel) {
          return reply(`‚ùå Voc√™ precisa ser n√≠vel ${requiredLevel}!\nüìä Atual: ${me.level || 1}`);
        }
        
        if ((me.wallet || 0) < requiredCoins) {
          return reply(`üí∞ Voc√™ precisa de ${requiredCoins.toLocaleString()} moedas na carteira!\nüìä Atual: ${(me.wallet || 0).toLocaleString()}`);
        }
        
        if (currentTotalWealth < requiredTotalWealth) {
          return reply(`üíé Voc√™ precisa de ${requiredTotalWealth.toLocaleString()} em riqueza total!\nüìä Atual: ${currentTotalWealth.toLocaleString()}`);
        }
        
        if (currentAchievements < requiredAchievements) {
          return reply(`üèÜ Voc√™ precisa de ${requiredAchievements} conquistas!\nüìä Atual: ${currentAchievements}`);
        }
        
        if (currentBattlesWon < requiredBattlesWon) {
          return reply(`‚öîÔ∏è Voc√™ precisa vencer ${requiredBattlesWon} batalhas!\nüìä Atual: ${currentBattlesWon}`);
        }
        
        if (currentWorkTimes < requiredWorkTimes) {
          return reply(`üíº Voc√™ precisa trabalhar ${requiredWorkTimes} vezes!\nüìä Atual: ${currentWorkTimes}`);
        }
        
        // Resetar com penalidades maiores (preservando estat√≠sticas de batalha e trabalho)
        me.level = 1;
        me.exp = 0;
        me.wallet = 0;
        me.bank = Math.floor((me.bank || 0) * 0.5); // Mant√©m 50% do banco
        // Preservar estat√≠sticas de batalha e trabalho para progress√£o de prestige
        const preservedBattlesWon = me.battlesWon || 0;
        const preservedStats = me.stats ? { ...me.stats } : {};
        
        me.prestige.level++;
        me.prestige.totalResets++;
        me.prestige.bonusMultiplier = 1 + (me.prestige.level * 0.15);
        
        // Restaurar estat√≠sticas preservadas
        me.battlesWon = preservedBattlesWon;
        if (!me.stats) me.stats = {};
        me.stats = { ...preservedStats };
        
        // B√¥nus especiais por prestige
        if (!me.prestigeRewards) me.prestigeRewards = {};
        me.prestigeRewards[`prestige_${me.prestige.level}`] = {
          title: `‚≠ê Prestige ${me.prestige.level}`,
          date: Date.now(),
          bonus: me.prestige.bonusMultiplier
        };
        
        let text = `‚ï≠‚îÅ‚îÅ‚îÅ‚ä± üåü‚ú® *PRESTIGIADO!* ‚ú®üåü ‚ä±‚îÅ‚îÅ‚îÅ‚ïÆ\n`;
        text += `‚ï∞‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚ïØ\n\n`;
        text += `üéâ *PARAB√âNS!*\n`;
        text += `Voc√™ alcan√ßou o Prestige ${me.prestige.level}!\n\n`;
        text += `‚ú® Novo multiplicador: ${me.prestige.bonusMultiplier.toFixed(2)}x\n`;
        text += `üîÑ Total de resets: ${me.prestige.totalResets}\n`;
        text += `üèÖ T√≠tulo: ‚≠ê Prestige ${me.prestige.level}\n\n`;
        text += `üí™ Voc√™ agora √© MUITO mais forte!\n`;
        text += `üìà Todos os ganhos multiplicados!\n\n`;
        text += `üöÄ Continue evoluindo para prestiges maiores!`;
        
        saveEconomy(econ);
        return reply(text);
        break;
      }

      // Sistema de Investimentos
      case 'investir':
      case 'invest': {
        if (!isGroup) return reply('‚öîÔ∏è Este comando funciona apenas em grupos com Modo RPG ativo.');
        if (!groupData.modorpg) return reply(`‚öîÔ∏è Modo RPG desativado! Use ${prefix}modorpg para ativar.`);
        
        const econ = loadEconomy();
        const me = getEcoUser(econ, sender);
        
        if (!me.investments) {
          me.investments = {
            stocks: {},
            totalInvested: 0,
            totalProfit: 0,
            lastDividend: 0
          };
        }
        
        if (!econ.stockMarket) {
          econ.stockMarket = {
            prices: {
              tech: 100,
              gold: 50,
              crypto: 200,
              energy: 75
            },
            lastUpdate: Date.now()
          };
        }
        
        // Atualizar pre√ßos diariamente
        const now = Date.now();
        if (now - econ.stockMarket.lastUpdate > 86400000) {
          for (const stock in econ.stockMarket.prices) {
            const change = (Math.random() - 0.5) * 20; // -10% a +10%
            econ.stockMarket.prices[stock] = Math.max(10, econ.stockMarket.prices[stock] + change);
          }
          econ.stockMarket.lastUpdate = now;
        }
        
        if (!q) {
          let text = `‚ï≠‚îÅ‚îÅ‚îÅ‚ä± üìà *MERCADO DE A√á√ïES* ‚ä±‚îÅ‚îÅ‚îÅ‚ïÆ\n`;
          text += `‚îÇ Investidor: ${pushname}\n`;
          text += `‚ï∞‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚ïØ\n\n`;
          text += `üíº *A√á√ïES DISPON√çVEIS:*\n\n`;
          
          const stocks = {
            tech: { name: 'üíª Tecnologia', emoji: 'üíª' },
            gold: { name: 'ü™ô Ouro', emoji: 'ü™ô' },
            crypto: { name: '‚Çø Cripto', emoji: '‚Çø' },
            energy: { name: '‚ö° Energia', emoji: '‚ö°' }
          };
          
          for (const [key, stock] of Object.entries(stocks)) {
            const price = Math.floor(econ.stockMarket.prices[key]);
            const owned = me.investments.stocks[key] || 0;
            text += `${stock.emoji} *${stock.name}*\n`;
            text += `‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ\n`;
            text += `‚îÇ üí∞ Pre√ßo: ${price.toLocaleString()}\n`;
            text += `‚îÇ üìä Voc√™ tem: ${owned}\n`;
            text += `‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ\n\n`;
          }
          
          text += `üí° Use ${prefix}investir <a√ß√£o> <quantidade>\n`;
          text += `üí° Use ${prefix}sell <a√ß√£o> <quantidade>`;
          
          saveEconomy(econ);
          return reply(text);
        }
        
        const args = q.split(' ');
        const stockType = args[0]?.toLowerCase();
        const amount = parseInt(args[1]) || 1;
        
        if (!econ.stockMarket.prices[stockType]) {
          return reply('‚ùå A√ß√£o inv√°lida! Escolha: tech, gold, crypto, energy');
        }
        
        const price = Math.floor(econ.stockMarket.prices[stockType]);
        const totalCost = price * amount;
        
        if (me.wallet < totalCost) {
          return reply(`üí∞ Voc√™ precisa de ${totalCost.toLocaleString()} moedas!`);
        }
        
        me.wallet -= totalCost;
        me.investments.stocks[stockType] = (me.investments.stocks[stockType] || 0) + amount;
        me.investments.totalInvested += totalCost;
        
        let text = `‚ï≠‚îÅ‚îÅ‚îÅ‚ä± üíº *INVESTIMENTO* ‚ä±‚îÅ‚îÅ‚îÅ‚ïÆ\n`;
        text += `‚ï∞‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚ïØ\n\n`;
        text += `‚úÖ Investimento realizado!\n\n`;
        text += `üìä A√ß√£o: ${stockType.toUpperCase()}\n`;
        text += `üìà Quantidade: ${amount}\n`;
        text += `üí∞ Valor: ${totalCost.toLocaleString()}\n`;
        text += `üíº Total investido: ${me.investments.totalInvested.toLocaleString()}`;
        
        saveEconomy(econ);
        return reply(text);
        break;
      }

      case 'vender':
      case 'sell': {
        if (!isGroup) return reply('‚öîÔ∏è Este comando funciona apenas em grupos com Modo RPG ativo.');
        if (!groupData.modorpg) return reply(`‚öîÔ∏è Modo RPG desativado! Use ${prefix}modorpg para ativar.`);
        
        const econ = loadEconomy();
        const me = getEcoUser(econ, sender);
        
        if (!me.investments || !econ.stockMarket) {
          return reply('‚ùå Voc√™ n√£o tem investimentos!');
        }
        
        const args = q.split(' ');
        const stockType = args[0]?.toLowerCase();
        const amount = parseInt(args[1]) || 1;
        
        if (!me.investments.stocks[stockType] || me.investments.stocks[stockType] < amount) {
          return reply('‚ùå Voc√™ n√£o tem a√ß√µes suficientes!');
        }
        
        const price = Math.floor(econ.stockMarket.prices[stockType]);
        const totalValue = price * amount;
        
        me.investments.stocks[stockType] -= amount;
        me.wallet += totalValue;
        me.investments.totalProfit += totalValue;
        
        let text = `‚ï≠‚îÅ‚îÅ‚îÅ‚ä± üíµ *VENDA* ‚ä±‚îÅ‚îÅ‚îÅ‚ïÆ\n`;
        text += `‚ï∞‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚ïØ\n\n`;
        text += `‚úÖ A√ß√µes vendidas!\n\n`;
        text += `üìä A√ß√£o: ${stockType.toUpperCase()}\n`;
        text += `üìà Quantidade: ${amount}\n`;
        text += `üí∞ Recebido: ${totalValue.toLocaleString()}\n`;
        text += `üíº Lucro total: ${me.investments.totalProfit.toLocaleString()}`;
        
        saveEconomy(econ);
        return reply(text);
        break;
      }

      // Sistema de Apostas/Cassino - NERFADO
      case 'dados':
      case 'dice': {
        if (!isGroup) return reply('‚öîÔ∏è Este comando funciona apenas em grupos com Modo RPG ativo.');
        if (!groupData.modorpg) return reply(`‚öîÔ∏è Modo RPG desativado! Use ${prefix}modorpg para ativar.`);
        
        const econ = loadEconomy();
        const me = getEcoUser(econ, sender);
        
        const bet = parseInt(q) || 0;
        if (bet < 100) return reply('üí∞ Aposta m√≠nima: 100 moedas');
        if (me.wallet < bet) return reply('üí∞ Voc√™ n√£o tem moedas suficientes!');
        
        // Cooldown de 8 minutos
        const cdDados = me.cooldowns?.dados || 0;
        if (Date.now() < cdDados) return reply(`‚è≥ Aguarde ${timeLeft(cdDados)} para jogar dados novamente.`);
        
        // DADOS NERFADO: Bot tem dados viciados (sempre rola 4-6, jogador rola 1-6)
        const playerRoll = Math.floor(Math.random() * 6) + 1;
        // Bot tem 80% de chance de rolar 5 ou 6
        let botRoll;
        const botLuck = Math.random();
        if (botLuck < 0.4) botRoll = 6;
        else if (botLuck < 0.8) botRoll = 5;
        else if (botLuck < 0.9) botRoll = 4;
        else botRoll = Math.floor(Math.random() * 3) + 1; // 1-3 apenas 10% das vezes
        
        let text = `‚ï≠‚îÅ‚îÅ‚îÅ‚ä± üé≤ *JOGO DE DADOS* üé≤ ‚ä±‚îÅ‚îÅ‚îÅ‚ïÆ\n`;
        text += `‚ï∞‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚ïØ\n\n`;
        text += `üé≤ *Voc√™:* ${playerRoll}\n`;
        text += `üé≤ *Bot:* ${botRoll}\n\n`;
        text += `‚ï≠‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚ïÆ\n`;
        
        me.cooldowns = me.cooldowns || {};
        me.cooldowns.dados = Date.now() + 8*60*1000; // 8 minutos
        
        if (playerRoll > botRoll) {
          const win = Math.floor(bet * 1.5); // ganha apenas 1.5x (era 2x)
          me.wallet += win - bet;
          text += `‚îÇ\n`;
          text += `‚îÇ üéâ *VIT√ìRIA RARA!*\n`;
          text += `‚îÇ\n`;
          text += `‚îÇ üí∞ Ganhou: *+${(win - bet).toLocaleString()}*\n`;
          text += `‚îÇ\n`;
        } else if (playerRoll < botRoll) {
          me.wallet -= bet;
          text += `‚îÇ\n`;
          text += `‚îÇ üò¢ *VOC√ä PERDEU!*\n`;
          text += `‚îÇ\n`;
          text += `‚îÇ üí∏ Perdeu: *-${bet.toLocaleString()}*\n`;
          text += `‚îÇ üé≤ Os dados parecem viciados...\n`;
          text += `‚îÇ\n`;
        } else {
          // Empate agora perde metade da aposta
          const loss = Math.floor(bet * 0.5);
          me.wallet -= loss;
          text += `‚îÇ\n`;
          text += `‚îÇ ü§ù *EMPATE!*\n`;
          text += `‚îÇ\n`;
          text += `‚îÇ üí∏ Taxa de empate: *-${loss.toLocaleString()}*\n`;
          text += `‚îÇ\n`;
        }
        
        text += `‚ï∞‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚ïØ`;
        
        saveEconomy(econ);
        return reply(text);
        break;
      }

      case 'coinflip':
      case 'moeda': {
        if (!isGroup) return reply('‚öîÔ∏è Este comando funciona apenas em grupos com Modo RPG ativo.');
        if (!groupData.modorpg) return reply(`‚öîÔ∏è Modo RPG desativado! Use ${prefix}modorpg para ativar.`);
        
        const econ = loadEconomy();
        const me = getEcoUser(econ, sender);
        
        const args = q.split(' ');
        const rawChoice = args[0] || '';
        // Normaliza "cara/coroa" com aliases (heads/tails, etc)
        const resolvedChoice = resolveParamAlias(rawChoice);
        const choice = resolvedChoice === 'cara' || resolvedChoice === 'coroa' ? resolvedChoice : null;
        const bet = parseInt(args[1]) || 0;
        
        if (!choice) {
          return reply(`üí° Use ${prefix}coinflip <cara|coroa> <valor>\n\nüìù Aceita: cara, coroa, heads, tails`);
        }
        
        if (bet < 100) return reply('üí∞ Aposta m√≠nima: 100 moedas');
        if (me.wallet < bet) return reply('üí∞ Voc√™ n√£o tem moedas suficientes!');
        
        // Cooldown de 8 minutos
        const cdCoin = me.cooldowns?.coinflip || 0;
        if (Date.now() < cdCoin) return reply(`‚è≥ Aguarde ${timeLeft(cdCoin)} para jogar novamente.`);
        
        // COINFLIP NERFADO: 5% de chance de ganhar (era 50%)
        // A moeda √© "viciada" - quase sempre cai no lado oposto
        const playerWins = Math.random() < 0.05;
        const result = playerWins ? choice : (choice === 'cara' ? 'coroa' : 'cara');
        
        let text = `‚ï≠‚îÅ‚îÅ‚îÅ‚ä± ü™ô *COIN FLIP* ‚ä±‚îÅ‚îÅ‚îÅ‚ïÆ\n`;
        text += `‚ï∞‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚ïØ\n\n`;
        text += `ü™ô Voc√™ escolheu: *${choice}*\n`;
        text += `ü™ô Resultado: *${result}*\n\n`;
        
        me.cooldowns = me.cooldowns || {};
        me.cooldowns.coinflip = Date.now() + 8*60*1000; // 8 minutos
        
        if (choice === result) {
          const win = Math.floor(bet * 1.5); // ganha apenas 1.5x (era 2x)
          me.wallet += win - bet;
          text += `üéâ *VIT√ìRIA RARA!*\n\n`;
          text += `üí∞ +${win.toLocaleString()}`;
        } else {
          me.wallet -= bet;
          text += `üò¢ *VOC√ä PERDEU!*\n\n`;
          text += `üí∏ -${bet.toLocaleString()}\nü™ô A moeda parece viciada...`;
        }
        
        saveEconomy(econ);
        return reply(text);
        break;
      }

      case 'crash': {
        if (!isGroup) return reply('‚öîÔ∏è Este comando funciona apenas em grupos com Modo RPG ativo.');
        if (!groupData.modorpg) return reply(`‚öîÔ∏è Modo RPG desativado! Use ${prefix}modorpg para ativar.`);
        
        const econ = loadEconomy();
        const me = getEcoUser(econ, sender);
        
        const bet = parseInt(q) || 0;
        if (bet < 100) return reply('üí∞ Aposta m√≠nima: 100 moedas');
        if (me.wallet < bet) return reply('üí∞ Voc√™ n√£o tem moedas suficientes!');
        
        // Cooldown de 10 minutos
        const cdCrash = me.cooldowns?.crash || 0;
        if (Date.now() < cdCrash) return reply(`‚è≥ Aguarde ${timeLeft(cdCrash)} para jogar crash novamente.`);
        
        // CRASH NERFADO: 85% de chance de crashar antes de 1.1x (perda quase garantida)
        // Crash point viciado para valores baixos
        let crashPoint;
        const crashRoll = Math.random();
        if (crashRoll < 0.85) {
          crashPoint = (1.00 + Math.random() * 0.1).toFixed(2); // 1.00x a 1.10x (crash instant√¢neo)
        } else if (crashRoll < 0.95) {
          crashPoint = (1.10 + Math.random() * 0.4).toFixed(2); // 1.10x a 1.50x
        } else {
          crashPoint = (1.50 + Math.random() * 1.5).toFixed(2); // 1.50x a 3.00x (raro)
        }
        
        // User exit tamb√©m viciado para sair tarde demais
        const userExit = (1.05 + Math.random() * 1.5).toFixed(2); // 1.05x a 2.55x
        
        let text = `‚ï≠‚îÅ‚îÅ‚îÅ‚ä± üöÄ *CRASH* ‚ä±‚îÅ‚îÅ‚îÅ‚ïÆ\n`;
        text += `‚ï∞‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚ïØ\n\n`;
        text += `üöÄ Voc√™ saiu em: ${userExit}x\n`;
        text += `üí• Crash em: ${crashPoint}x\n\n`;
        
        me.cooldowns = me.cooldowns || {};
        me.cooldowns.crash = Date.now() + 10*60*1000; // 10 minutos
        
        if (parseFloat(userExit) < parseFloat(crashPoint)) {
          const win = Math.floor(bet * (parseFloat(userExit) - 1)); // ganha apenas a diferen√ßa, n√£o o total
          me.wallet += win;
          text += `üéâ *VOC√ä GANHOU!*\n\n`;
          text += `üí∞ +${win.toLocaleString()}`;
        } else {
          me.wallet -= bet;
          text += `üí• *CRASHED!*\n\n`;
          text += `üí∏ -${bet.toLocaleString()}\nüöÄ O foguete explodiu cedo demais...`;
        }
        
        saveEconomy(econ);
        return reply(text);
        break;
      }

      // Sistema de Streaks
      case 'streak':
      case 'serie': {
        if (!isGroup) return reply('‚öîÔ∏è Este comando funciona apenas em grupos com Modo RPG ativo.');
        if (!groupData.modorpg) return reply(`‚öîÔ∏è Modo RPG desativado! Use ${prefix}modorpg para ativar.`);
        
        const econ = loadEconomy();
        const me = getEcoUser(econ, sender);
        
        if (!me.streak) {
          me.streak = {
            current: 0,
            best: 0,
            lastLogin: 0,
            lastClaim: 0,
            rewards: []
          };
        }
        
        const now = Date.now();
        const oneDay = 86400000; // 24 horas
        const twoDays = oneDay * 2;
        const timeSinceLogin = now - me.streak.lastLogin;
        
        // Verificar e atualizar streak
        if (me.streak.lastLogin === 0) {
          // Primeira vez usando o sistema
          me.streak.current = 0;
        } else if (timeSinceLogin > twoDays) {
          // Perdeu o streak (mais de 2 dias)
          me.streak.current = 0;
        } else if (timeSinceLogin >= oneDay) {
          // Passou 1 dia, pode incrementar
          const timeSinceLastClaim = now - (me.streak.lastClaim || 0);
          if (timeSinceLastClaim >= oneDay) {
            me.streak.current++;
            me.streak.lastClaim = now;
            if (me.streak.current > me.streak.best) {
              me.streak.best = me.streak.current;
            }
          }
        }
        
        // Atualiza lastLogin sempre que o comando √© usado
        me.streak.lastLogin = now;
        
        let text = `‚ï≠‚îÅ‚îÅ‚îÅ‚ä± üî• *STREAK* ‚ä±‚îÅ‚îÅ‚îÅ‚ïÆ\n`;
        text += `‚îÇ ${pushname}\n`;
        text += `‚ï∞‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚ïØ\n\n`;
        text += `üî• Streak Atual: ${me.streak.current} dias\n`;
        text += `üèÜ Melhor Streak: ${me.streak.best} dias\n\n`;
        text += `üìÖ *RECOMPENSAS:*\n`;
        text += `‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ\n`;
        text += `‚îÇ 7 dias: 10.000 üí∞\n`;
        text += `‚îÇ 15 dias: 25.000 üí∞\n`;
        text += `‚îÇ 30 dias: 100.000 üí∞\n`;
        text += `‚îÇ 60 dias: 500.000 üí∞\n`;
        text += `‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ\n\n`;
        
        const rewards = [7, 15, 30, 60];
        const hasReward = rewards.some(days => 
          me.streak.current >= days && !me.streak.rewards.includes(days)
        );
        
        if (hasReward) {
          text += `üéÅ Recompensa dispon√≠vel!\n`;
          text += `üí° Use ${prefix}reivindicar`;
        } else {
          const nextReward = rewards.find(days => me.streak.current < days);
          if (nextReward) {
            const daysLeft = nextReward - me.streak.current;
            text += `üí° Pr√≥xima recompensa em ${daysLeft} dias!\n`;
            text += `Use ${prefix}diario todos os dias para manter seu streak!`;
          } else {
            text += `üèÜ Voc√™ desbloqueou todas as recompensas!\n`;
            text += `Continue mantendo seu streak!`;
          }
        }
        
        saveEconomy(econ);
        return reply(text);
        break;
      }

      case 'reivindicar':
      case 'claim': {
        if (!isGroup) return reply('‚öîÔ∏è Este comando funciona apenas em grupos com Modo RPG ativo.');
        if (!groupData.modorpg) return reply(`‚öîÔ∏è Modo RPG desativado! Use ${prefix}modorpg para ativar.`);
        
        const econ = loadEconomy();
        const me = getEcoUser(econ, sender);
        
        // Inicializa streak se n√£o existir
        if (!me.streak || !me.streak.rewards) {
          me.streak = { current: 0, best: 0, lastLogin: 0, rewards: [] };
        }
        
        // Inicializa quests se n√£o existir
        if (!me.quests) {
          me.quests = {
            daily: [],
            lastReset: Date.now()
          };
        }
        
        // Reset di√°rio de miss√µes se necess√°rio
        const now = Date.now();
        if (now - me.quests.lastReset > 86400000) {
          me.quests.daily = [];
          me.quests.lastReset = now;
        }
        
        let claimed = false;
        let totalClaimed = 0;
        let text = `‚ï≠‚îÅ‚îÅ‚îÅ‚ä± üéÅ *RECOMPENSAS* ‚ä±‚îÅ‚îÅ‚îÅ‚ïÆ\n`;
        text += `‚ï∞‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚ïØ\n\n`;
        
        // Verifica recompensas de streak
        const streakRewards = [
          { days: 7, amount: 10000 },
          { days: 15, amount: 25000 },
          { days: 30, amount: 100000 },
          { days: 60, amount: 500000 }
        ];
        
        for (const reward of streakRewards) {
          if (me.streak.current >= reward.days && !me.streak.rewards.includes(reward.days)) {
            me.wallet += reward.amount;
            me.streak.rewards.push(reward.days);
            totalClaimed += reward.amount;
            claimed = true;
            text += `üî• Streak ${reward.days} dias: +${reward.amount.toLocaleString()}\n`;
          }
        }
        
        // Verifica recompensas de miss√µes di√°rias
        if (me.quests.daily && Array.isArray(me.quests.daily)) {
          for (const quest of me.quests.daily) {
            if (quest.progress >= quest.goal && !quest.claimed) {
              me.wallet += quest.reward || 0;
              const expGained = quest.exp || 0;
              if (expGained > 0) {
                const levelingData = loadLevelingSafe();
                const userLevel = getLevelingUser(levelingData, sender);
                userLevel.xp = (userLevel.xp || 0) + expGained;
                saveLeveling(levelingData);
              }
              quest.claimed = true;
              totalClaimed += quest.reward || 0;
              claimed = true;
              text += `üìú ${quest.name}: +${(quest.reward || 0).toLocaleString()} (+${expGained} EXP)\n`;
            }
          }
        }
        
        if (claimed) {
          text += `\nüí∞ Total recebido: ${totalClaimed.toLocaleString()}`;
          saveEconomy(econ);
          return reply(text);
        } else {
          // Verifica se h√° recompensas dispon√≠veis mas n√£o reivindicadas
          let hasAvailableRewards = false;
          let availableText = `‚ï≠‚îÅ‚îÅ‚îÅ‚ä± üéÅ *RECOMPENSAS DISPON√çVEIS* ‚ä±‚îÅ‚îÅ‚îÅ‚ïÆ\n‚ï∞‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚ïØ\n\n`;
          
          // Verifica streak
          const hasStreakReward = streakRewards.some(r => 
            me.streak.current >= r.days && !me.streak.rewards.includes(r.days)
          );
          if (hasStreakReward) {
            hasAvailableRewards = true;
            availableText += `üî• Recompensas de Streak dispon√≠veis!\n`;
            availableText += `üí° Use ${prefix}streak para ver seu progresso\n\n`;
          }
          
          // Verifica miss√µes
          if (me.quests.daily && Array.isArray(me.quests.daily)) {
            const availableQuests = me.quests.daily.filter(q => 
              q.progress >= q.goal && !q.claimed
            );
            if (availableQuests.length > 0) {
              hasAvailableRewards = true;
              availableText += `üìú ${availableQuests.length} miss√£o(√µes) completa(s)!\n`;
              availableText += `üí° Use ${prefix}missao para ver detalhes\n\n`;
            }
          }
          
          if (!hasAvailableRewards) {
            return reply('‚ùå Voc√™ n√£o tem recompensas dispon√≠veis!\n\nüí° Complete miss√µes di√°rias ou mantenha seu streak para ganhar recompensas.');
          } else {
            return reply(availableText + `üí° Use ${prefix}reivindicar novamente para coletar!`);
          }
        }
        break;
      }

      case 'speedup':
      case 'boyvoice':
      case 'vozmenino':
      case 'womenvoice':
      case 'vozmulher':
      case 'manvoice':
      case 'vozhomem':
      case 'childvoice':
      case 'vozcrianca':
      case 'vozeco':
      case 'eco':
      case 'slowvoice':
      case 'vozlenta':
      case 'audiolento':
      case 'fastvoice':
      case 'vozrapida':
      case 'audiorapido':
      case 'cavevoice':
      case 'vozcaverna':
      case 'bass':
      case 'bass2':
      case 'bass3':
      case 'volumeboost':
      case 'aumentarvolume':
      case 'reverb':
      case 'overdrive':
      case 'equalizer':
      case 'equalizar':
      case 'reverse':
      case 'audioreverso':
      case 'pitch':
      case 'flanger':
      case 'grave':
      case 'vozgrave':
      case 'chorus':
      case 'phaser':
      case 'tremolo':
      case 'vibrato':
      case 'lowpass':
        try {
          if (isMedia && !info.message.imageMessage && !info.message.videoMessage || isQuotedAudio) {
            const audioEffects = {
              speedup: 'atempo=1.06,asetrate=44100*1.25',
              boyvoice: 'atempo=1.06,asetrate=44100*1.25',
              vozmenino: 'atempo=1.06,asetrate=44100*1.25',
              womenvoice: 'asetrate=44100*1.25,atempo=0.8',
              vozmulher: 'asetrate=44100*1.25,atempo=0.8',
              manvoice: 'asetrate=44100*0.8,atempo=1.2',
              vozhomem: 'asetrate=44100*0.8,atempo=1.2',
              childvoice: 'asetrate=44100*1.4,atempo=0.9',
              vozcrianca: 'asetrate=44100*1.4,atempo=0.9',
              vozeco: 'aecho=0.8:0.88:60:0.4',
              eco: 'aecho=0.8:0.88:60:0.4',
              slowvoice: 'atempo=0.6',
              vozlenta: 'atempo=0.6',
              audiolento: 'atempo=0.6',
              fastvoice: 'atempo=1.5',
              vozrapida: 'atempo=1.5',
              audiorapido: 'atempo=1.5',
              cavevoice: 'aecho=0.6:0.3:1000:0.5',
              vozcaverna: 'aecho=0.6:0.3:1000:0.5',
              bass: 'bass=g=5',
              bass2: 'bass=g=10',
              bass3: 'bass=g=15',
              volumeboost: 'volume=1.5',
              aumentarvolume: 'volume=1.5',
              reverb: 'aecho=0.8:0.88:60:0.4',
              drive: 'afftdn=nf=-25',
              equalizer: 'equalizer=f=100:width_type=h:width=200:g=3,equalizer=f=1000:width_type=h:width=200:g=-1,equalizer=f=10000:width_type=h:width=200:g=4',
              equalizar: 'equalizer=f=100:width_type=h:width=200:g=3,equalizer=f=1000:width_type=h:width=200:g=-1,equalizer=f=10000:width_type=h:width=200:g=4',
              reverse: 'areverse',
              audioreverso: 'areverse',
              pitch: 'asetrate=44100*0.8',
              flanger: 'flanger',
              grave: 'atempo=0.9,asetrate=44100',
              vozgrave: 'atempo=0.9,asetrate=44100',
              chorus: 'chorus=0.7:0.9:55:0.4:0.25:2',
              phaser: 'aphaser=type=t:decay=0.4',
              tremolo: 'tremolo=f=6:d=0.8',
              vibrato: 'vibrato=f=6',
              lowpass: 'lowpass=f=500'
            };
            const muk = isQuotedAudio ? info.message.extendedTextMessage.contextInfo.quotedMessage.audioMessage : info.message.audioMessage;
            await reply('üéµ Processando √°udio... Por favor, aguarde alguns segundos.');
            const rane = __dirname + `/../database/tmp/${Math.random()}.mp3`;
            const buffimg = await getFileBuffer(muk, 'audio');
            fs.writeFileSync(rane, buffimg);
            const gem = rane;
            const ran = __dirname + `/../database/tmp/${Math.random()}.mp3`;
            const effect = audioEffects[command];
            exec(`ffmpeg -i ${gem} -filter:a "${effect}" ${ran}`, async (err, stderr, stdout) => {
              await fs.unlinkSync(gem);
              if (err) {
                console.error(`FFMPEG Error (Audio Effect ${command}):`, err);
                return reply(`‚ùå Erro ao aplicar o efeito *${command}* no √°udio. Verifique se o arquivo est√° v√°lido e tente novamente.`);
              }
              const hah = fs.readFileSync(ran);
              await nazu.sendMessage(from, {
                audio: hah,
                mimetype: 'audio/mpeg'
              }, {
                quoted: info
              });
              await fs.unlinkSync(ran);
            });
          } else {
            reply("ÔøΩ Para aplicar este efeito de √°udio, responda a uma mensagem que contenha um √°udio.");
          }
        } catch (e) {
          console.error(e);
          await reply("‚ùå Ocorreu um erro interno. Tente novamente em alguns minutos.");
        }
        break;
      case 'videorapido':
      case 'fastvid':
      case 'videoslow':
      case 'slowvid':
      case 'reversevid':
      case 'videolento':
      case 'videoreverso':
      case 'videoloop':
      case 'videomudo':
      case 'videobw':
      case 'pretoebranco':
      case 'tomp3':
      case 'sepia':
      case 'espelhar':
      case 'rotacionar':
      case 'mirror':
      case 'rotate':
        try {
          if (isMedia && info.message.videoMessage || isQuotedVideo) {
            const encmedia = isQuotedVideo ? info.message.extendedTextMessage.contextInfo.quotedMessage.videoMessage : info.message.videoMessage;
            await reply('üé¨ Processando v√≠deo... Por favor, aguarde alguns segundos.');
            const videoEffects = {
              videorapido: '[0:v]setpts=0.5*PTS[v];[0:a]atempo=2[a]',
              fastvid: '[0:v]setpts=0.5*PTS[v];[0:a]atempo=2[a]',
              videoslow: '[0:v]setpts=2*PTS[v];[0:a]atempo=0.5[a]',
              videolento: '[0:v]setpts=2*PTS[v];[0:a]atempo=0.5[a]',
              videoreverso: 'reverse,areverse',
              reversevid: 'reverse,areverse',
              videoloop: 'loop=2',
              videomudo: 'an',
              videobw: 'hue=s=0',
              pretoebranco: 'hue=s=0',
              tomp3: 'q:a=0 -map a',
              sepia: 'colorchannelmixer=.393:.769:.189:.349:.686:.168:.272:.534:.131',
              mirror: 'hflip',
              espelhar: 'hflip',
              rotacionar: 'rotate=90*PI/180',
              rotate: 'rotate=90*PI/180'
            };
            const rane = __dirname + `/../database/tmp/${Math.random()}.mp4`;
            const buffimg = await getFileBuffer(encmedia, 'video');
            fs.writeFileSync(rane, buffimg);
            const media = rane;
            const outputExt = command === 'tomp3' ? '.mp3' : '.mp4';
            const ran = __dirname + `/../database/tmp/${Math.random()}${outputExt}`;
            let ffmpegCmd;
            if (command === 'tomp3') {
              
              ffmpegCmd = `ffmpeg -i ${media} -q:a 0 -map a ${ran}`;
            } else if (command === 'videoloop') {
              
              ffmpegCmd = `ffmpeg -stream_loop 2 -i ${media} -c copy ${ran}`;
            } else if (command === 'videomudo') {
              
              ffmpegCmd = `ffmpeg -i ${media} -an ${ran}`;
            } else {
              const effect = videoEffects[command];
              if (['sepia', 'espelhar', 'rotacionar', 'zoom', 'glitch', 'videobw', 'pretoebranco'].includes(command)) {
                
                ffmpegCmd = `ffmpeg -i ${media} -vf "${effect}" ${ran}`;
              } else {
                
                ffmpegCmd = `ffmpeg -i ${media} -filter_complex "${effect}" -map "[v]" -map "[a]" ${ran}`;
              }
            }
            exec(ffmpegCmd, async err => {
              await fs.unlinkSync(media);
              if (err) {
                console.error(`FFMPEG Error (Video Effect ${command}):`, err);
                return reply(`‚ùå Erro ao aplicar o efeito *${command}* no v√≠deo. Verifique se o arquivo est√° v√°lido e tente novamente.`);
              }
              const buffer453 = fs.readFileSync(ran);
              const messageType = command === 'tomp3' ? {
                audio: buffer453,
                mimetype: 'audio/mpeg'
              } : {
                video: buffer453,
                mimetype: 'video/mp4'
              };
              await nazu.sendMessage(from, messageType, {
                quoted: info
              });
              await fs.unlinkSync(ran);
            });
          } else {
            reply(command === 'tomp3' ? "üé¨ Para converter v√≠deo para √°udio, responda a uma mensagem que contenha um v√≠deo." : "üé¨ Para aplicar este efeito de v√≠deo, responda a uma mensagem que contenha um v√≠deo.");
          }
        } catch (e) {
          console.error(e);
          await reply("‚ùå Ocorreu um erro interno. Tente novamente em alguns minutos.");
        }
        break;
      //INTELIGENCIA ARTIFICIAL
      case 'gemma':
        if (!q) return reply(`ü§î Qual sua d√∫vida para o Gemma? Informe a pergunta ap√≥s o comando! Exemplo: ${prefix}${command} quem descobriu o Brasil? üåç`);
        reply(`‚è≥ S√≥ um segundinho, estou consultando o Gemma... ‚ú®`).then(() => {
          ia.makeCognimaRequest('google/gemma-7b', q, null).then((response) => {
            reply(formatAIResponse(response.data.choices[0].message.content));
          }).catch((e) => {
            console.error('Erro na API Gemma:', e);
            if (e.message && e.message.includes('API key inv√°lida')) {
              
              reply('ü§ñ *Sistema de IA temporariamente indispon√≠vel*\n\nüòÖ Estou com problemas t√©cnicos no momento. O administrador j√° foi notificado!\n\n‚è∞ Tente novamente em alguns minutos.');
            } else {
              reply(`üòì Poxa, algo deu errado com o Gemma! Tente novamente em alguns instantes, t√°? üåà`);
            }
          });
        });
        break;
      case 'phi':
      case 'phi3':
        if (!q) return reply(`ü§î Qual sua d√∫vida para o Phi? Informe a pergunta ap√≥s o comando! Exemplo: ${prefix}${command} quem descobriu o Brasil? üåç`);
        reply(`‚è≥ S√≥ um segundinho, estou consultando o Phi... ‚ú®`).then(() => {
          ia.makeCognimaRequest('microsoft/phi-3-medium-4k-instruct', q, null).then((response) => {
            reply(formatAIResponse(response.data.choices[0].message.content));
          }).catch((e) => {
            console.error('Erro na API Phi:', e);
            if (e.message && e.message.includes('API key inv√°lida')) {
              
              reply('ü§ñ *Sistema de IA temporariamente indispon√≠vel*\n\nüòÖ Estou com problemas t√©cnicos no momento. O administrador j√° foi notificado!\n\n‚è∞ Tente novamente em alguns minutos.');
            } else {
              reply(`üòì Poxa, algo deu errado com o Phi! Tente novamente em alguns instantes, t√°? üåà`);
            }
          });
        });
        break;
      case 'qwen2':
        if (!q) return reply(`ü§î Qual sua d√∫vida para o Qwen2? Informe a pergunta ap√≥s o comando! Exemplo: ${prefix}${command} quem descobriu o Brasil? üåç`);
        reply(`‚è≥ S√≥ um segundinho, estou consultando o Qwen2... ‚ú®`).then(() => {
          ia.makeCognimaRequest('qwen/qwen2-7b-instruct', q, null).then((response) => {
            reply(formatAIResponse(response.data.choices[0].message.content));
          }).catch((e) => {
            console.error('Erro na API Qwen2:', e);
            if (e.message && e.message.includes('API key inv√°lida')) {
              
              reply('ü§ñ *Sistema de IA temporariamente indispon√≠vel*\n\nüòÖ Estou com problemas t√©cnicos no momento. O administrador j√° foi notificado!\n\n‚è∞ Tente novamente em alguns minutos.');
            } else {
              reply(`üòì Poxa, algo deu errado com o Qwen2! Tente novamente em alguns instantes, t√°? üåà`);
            }
          });
        });
        break;
      case 'qwen':
      case 'qwen3':
        if (!q) return reply(`ü§î Qual sua d√∫vida para o Qwen? Informe a pergunta ap√≥s o comando! Exemplo: ${prefix}${command} quem descobriu o Brasil? üåç`);
        reply(`‚è≥ S√≥ um segundinho, estou consultando o Qwen... ‚ú®`).then(() => {
          ia.makeCognimaRequest('qwen/qwen3-235b-a22b', q, null).then((response) => {
            reply(formatAIResponse(response.data.choices[0].message.content));
          }).catch((e) => {
            console.error('Erro na API Qwen:', e);
            if (e.message && e.message.includes('API key inv√°lida')) {
              
              reply('ü§ñ *Sistema de IA temporariamente indispon√≠vel*\n\nüòÖ Estou com problemas t√©cnicos no momento. O administrador j√° foi notificado!\n\n‚è∞ Tente novamente em alguns minutos.');
            } else {
              reply(`üòì Poxa, algo deu errado com o Qwen! Tente novamente em alguns instantes, t√°? üåà`);
            }
          });
        });
        break;
      case 'llama':
      case 'llama3':
        if (!q) return reply(`ü§î Qual sua d√∫vida para o Llama? Informe a pergunta ap√≥s o comando! Exemplo: ${prefix}${command} quem descobriu o Brasil? üåç`);
        reply(`‚è≥ S√≥ um segundinho, estou consultando o Llama... ‚ú®`).then(() => {
          ia.makeCognimaRequest('abacusai/dracarys-llama-3.1-70b-instruct', q, null).then((response) => {
            reply(formatAIResponse(response.data.choices[0].message.content));
          }).catch((e) => {
            console.error('Erro na API Llama:', e);
            if (e.message && e.message.includes('API key inv√°lida')) {
              reply('ü§ñ *Sistema de IA temporariamente indispon√≠vel*\n\nüòÖ Estou com problemas t√©cnicos no momento. O administrador j√° foi notificado!\n\n‚è∞ Tente novamente em alguns minutos.');
            } else {
              reply(`üòì Poxa, algo deu errado com o Llama! Tente novamente em alguns instantes, t√°? üåà`);
            }
          });
        });
        break;
      case 'baichuan':
      case 'baichuan2':
        if (!q) return reply(`ü§î Qual sua d√∫vida para o Baichuan? Informe a pergunta ap√≥s o comando! Exemplo: ${prefix}${command} quem descobriu o Brasil? üåç`);
        reply(`‚è≥ S√≥ um segundinho, estou consultando o Baichuan... ‚ú®`).then(() => {
          ia.makeCognimaRequest('baichuan-inc/baichuan2-13b-chat', q, null).then((response) => {
            reply(formatAIResponse(response.data.choices[0].message.content));
          }).catch((e) => {
            console.error('Erro na API Baichuan:', e);
            if (e.message && e.message.includes('API key inv√°lida')) {
              reply('ü§ñ *Sistema de IA temporariamente indispon√≠vel*\n\nüòÖ Estou com problemas t√©cnicos no momento. O administrador j√° foi notificado!\n\n‚è∞ Tente novamente em alguns minutos.');
            } else {
              reply(`üòì Poxa, algo deu errado com o Baichuan! Tente novamente em alguns instantes, t√°? üåà`);
            }
          });
        });
        break;
      case 'marin':
        if (!q) return reply(`ü§î Qual sua d√∫vida para o Marin? Informe a pergunta ap√≥s o comando! Exemplo: ${prefix}${command} quem descobriu o Brasil? üåç`);
        
        reply(`‚è≥ S√≥ um segundinho, estou consultando o Marin... ‚ú®`).then(() => {
          ia.makeCognimaRequest('marin/marin-8b-instruct', q, null).then((response) => {
            reply(formatAIResponse(response.data.choices[0].message.content));
          }).catch((e) => {
            console.error('Erro na API Marin:', e);
            if (e.message && e.message.includes('API key inv√°lida')) {
              reply('ü§ñ *Sistema de IA temporariamente indispon√≠vel*\n\nüòÖ Estou com problemas t√©cnicos no momento. O administrador j√° foi notificado!\n\n‚è∞ Tente novamente em alguns minutos.');
            } else {
              reply(`üòì Poxa, algo deu errado com o Marin! Tente novamente em alguns instantes, t√°? üåà`);
            }
          });
        });
        break;
      case 'kimi':
      case 'kimik2':
        if (!q) return reply(`ü§î Qual sua d√∫vida para o Kimi? Informe a pergunta ap√≥s o comando! Exemplo: ${prefix}${command} quem descobriu o Brasil? üåç`);
        
        reply(`‚è≥ S√≥ um segundinho, estou consultando o Kimi... ‚ú®`).then(() => {
          ia.makeCognimaRequest('moonshotai/kimi-k2-instruct', q, null).then((response) => {
            reply(formatAIResponse(response.data.choices[0].message.content));
          }).catch((e) => {
            console.error('Erro na API Kimi:', e);
            if (e.message && e.message.includes('API key inv√°lida')) {
              
              reply('ü§ñ *Sistema de IA temporariamente indispon√≠vel*\n\nüòÖ Estou com problemas t√©cnicos no momento. O administrador j√° foi notificado!\n\n‚è∞ Tente novamente em alguns minutos.');
            } else {
              reply(`üòì Poxa, algo deu errado com o Kimi! Tente novamente em alguns instantes, t√°? üåà`);
            }
          });
        });
        break;
      case 'mistral':
        if (!q) return reply(`ü§î Qual sua d√∫vida para o Mistral? Informe a pergunta ap√≥s o comando! Exemplo: ${prefix}${command} quem descobriu o Brasil? üåç`);
        
        reply(`‚è≥ S√≥ um segundinho, estou consultando o Mistral... ‚ú®`).then(() => {
          ia.makeCognimaRequest('mistralai/mistral-small-24b-instruct', q, null).then((response) => {
            reply(formatAIResponse(response.data.choices[0].message.content));
          }).catch((e) => {
            console.error('Erro na API Mistral:', e);
            if (e.message && e.message.includes('API key inv√°lida')) {
              
              reply('ü§ñ *Sistema de IA temporariamente indispon√≠vel*\n\nüòÖ Estou com problemas t√©cnicos no momento. O administrador j√° foi notificado!\n\n‚è∞ Tente novamente em alguns minutos.');
            } else {
              reply(`üòì Poxa, algo deu errado com o Mistral! Tente novamente em alguns instantes, t√°? üåà`);
            }
          });
        });
        break;
      case 'magistral':
        if (!q) return reply(`ü§î Qual sua d√∫vida para o Magistral? Informe a pergunta ap√≥s o comando! Exemplo: ${prefix}${command} quem descobriu o Brasil? üåç`);
        
        reply(`‚è≥ S√≥ um segundinho, estou consultando o Magistral... ‚ú®`).then(() => {
          ia.makeCognimaRequest('mistralai/magistral-small-2506', q, null).then((response) => {
            reply(formatAIResponse(response.data.choices[0].message.content));
          }).catch((e) => {
            console.error('Erro na API Magistral:', e);
            if (e.message && e.message.includes('API key inv√°lida')) {
              
              reply('ü§ñ *Sistema de IA temporariamente indispon√≠vel*\n\nüòÖ Estou com problemas t√©cnicos no momento. O administrador j√° foi notificado!\n\n‚è∞ Tente novamente em alguns minutos.');
            } else {
              reply(`üòì Poxa, algo deu errado com o Magistral! Tente novamente em alguns instantes, t√°? üåà`);
            }
          });
        });
        break;
      case 'rakutenai':
      case 'rocket':
        if (!q) return reply(`ü§î Qual sua d√∫vida para o RakutenAI? Informe a pergunta ap√≥s o comando! Exemplo: ${prefix}${command} quem descobriu o Brasil? üåç`);
        
        reply(`‚è≥ S√≥ um segundinho, estou consultando o RakutenAI... ‚ú®`).then(() => {
          ia.makeCognimaRequest('rakuten/rakutenai-7b-instruct', q, null).then((response) => {
            reply(formatAIResponse(response.data.choices[0].message.content));
          }).catch((e) => {
            console.error('Erro na API RakutenAI:', e);
            if (e.message && e.message.includes('API key inv√°lida')) {
              
              reply('ü§ñ *Sistema de IA temporariamente indispon√≠vel*\n\nüòÖ Estou com problemas t√©cnicos no momento. O administrador j√° foi notificado!\n\n‚è∞ Tente novamente em alguns minutos.');
            } else {
              reply(`üòì Poxa, algo deu errado com o RakutenAI! Tente novamente em alguns instantes, t√°? üåà`);
            }
          });
        });
        break;
      case 'yi':
        if (!q) return reply(`ü§î Qual sua d√∫vida para o Yi? Informe a pergunta ap√≥s o comando! Exemplo: ${prefix}${command} quem descobriu o Brasil? üåç`);
        
        reply(`‚è≥ S√≥ um segundinho, estou consultando o Yi... ‚ú®`).then(() => {
          ia.makeCognimaRequest('01-ai/yi-large', q, null).then((response) => {
            reply(formatAIResponse(response.data.choices[0].message.content));
          }).catch((e) => {
            console.error('Erro na API Yi:', e);
            if (e.message && e.message.includes('API key inv√°lida')) {
              
              reply('ü§ñ *Sistema de IA temporariamente indispon√≠vel*\n\nüòÖ Estou com problemas t√©cnicos no momento. O administrador j√° foi notificado!\n\n‚è∞ Tente novamente em alguns minutos.');
            } else {
              reply(`üòì Poxa, algo deu errado com o Yi! Tente novamente em alguns instantes, t√°? üåà`);
            }
          });
        });
        break;
      case 'gemma2':
        if (!q) return reply(`ü§î Qual sua d√∫vida para o Gemma2? Informe a pergunta ap√≥s o comando! Exemplo: ${prefix}${command} quem descobriu o Brasil? üåç`);
        
        reply(`‚è≥ S√≥ um segundinho, estou consultando o Gemma2... ‚ú®`).then(() => {
          ia.makeCognimaRequest('google/gemma-2-27b-it', q, null).then((response) => {
            reply(formatAIResponse(response.data.choices[0].message.content));
          }).catch((e) => {
            console.error('Erro na API Gemma2:', e);
            if (e.message && e.message.includes('API key inv√°lida')) {
              
              reply('ü§ñ *Sistema de IA temporariamente indispon√≠vel*\n\nüòÖ Estou com problemas t√©cnicos no momento. O administrador j√° foi notificado!\n\n‚è∞ Tente novamente em alguns minutos.');
            } else {
              reply(`üòì Poxa, algo deu errado com o Gemma2! Tente novamente em alguns instantes, t√°? üåà`);
            }
          });
        });
        break;
      case 'swallow':
        if (!q) return reply(`ü§î Qual sua d√∫vida para o Swallow? Informe a pergunta ap√≥s o comando! Exemplo: ${prefix}${command} quem descobriu o Brasil? üåç`);
        
        reply(`‚è≥ S√≥ um segundinho, estou consultando o Swallow... ‚ú®`).then(() => {
          ia.makeCognimaRequest('qwen/qwen3-235b-a22b', q, null).then((response) => {
            reply(formatAIResponse(response.data.choices[0].message.content));
          }).catch((e) => {
            console.error('Erro na API Swallow:', e);
            if (e.message && e.message.includes('API key inv√°lida')) {
              
              reply('ü§ñ *Sistema de IA temporariamente indispon√≠vel*\n\nüòÖ Estou com problemas t√©cnicos no momento. O administrador j√° foi notificado!\n\n‚è∞ Tente novamente em alguns minutos.');
            } else {
              reply(`üòì Poxa, algo deu errado com o Swallow! Tente novamente em alguns instantes, t√°? üåà`);
            }
          });
        });
        break;
      case 'falcon':
        if (!q) return reply(`ü§î Qual sua d√∫vida para o Falcon? Informe a pergunta ap√≥s o comando! Exemplo: ${prefix}${command} quem descobriu o Brasil? üåç`);
        
        reply(`‚è≥ S√≥ um segundinho, estou consultando o Falcon... ‚ú®`).then(() => {
          ia.makeCognimaRequest('tiiuae/falcon3-7b-instruct', q, null).then((response) => {
            reply(formatAIResponse(response.data.choices[0].message.content));
          }).catch((e) => {
            console.error('Erro na API Falcon:', e);
            if (e.message && e.message.includes('API key inv√°lida')) {
              
              reply('ü§ñ *Sistema de IA temporariamente indispon√≠vel*\n\nüòÖ Estou com problemas t√©cnicos no momento. O administrador j√° foi notificado!\n\n‚è∞ Tente novamente em alguns minutos.');
            } else {
              reply(`üòì Poxa, algo deu errado com o Falcon! Tente novamente em alguns instantes, t√°? üåà`);
            }
          });
        });
        break;
      case 'qwencoder':
        if (!q) return reply(`ü§î Qual sua d√∫vida para o Qwencoder? Informe a pergunta ap√≥s o comando! Exemplo: ${prefix}${command} quem descobriu o Brasil? üåç`);
        
        reply(`‚è≥ S√≥ um segundinho, estou consultando o Qwencoder... ‚ú®`).then(() => {
          ia.makeCognimaRequest('qwen/qwen2.5-coder-32b-instruct', q, null).then((response) => {
            reply(formatAIResponse(response.data.choices[0].message.content));
          }).catch((e) => {
            console.error('Erro na API Qwencoder:', e);
            if (e.message && e.message.includes('API key inv√°lida')) {
              
              reply('ü§ñ *Sistema de IA temporariamente indispon√≠vel*\n\nüòÖ Estou com problemas t√©cnicos no momento. O administrador j√° foi notificado!\n\n‚è∞ Tente novamente em alguns minutos.');
            } else {
              reply(`üòì Poxa, algo deu errado com o Qwencoder! Tente novamente em alguns instantes, t√°? üåà`);
            }
          });
        });
        break;
      case 'codegemma':
        if (!q) return reply(`ü§î Qual sua d√∫vida para o CodeGemma? Informe a pergunta ap√≥s o comando! Exemplo: ${prefix}${command} quem descobriu o Brasil? üåç`);
        
        reply(`‚è≥ S√≥ um segundinho, estou consultando o CodeGemma... ‚ú®`).then(() => {
          ia.makeCognimaRequest('google/codegemma-7b', q, null).then((response) => {
            reply(formatAIResponse(response.data.choices[0].message.content));
          }).catch((e) => {
            console.error('Erro na API CodeGemma:', e);
            if (e.message && e.message.includes('API key inv√°lida')) {
              
              reply('ü§ñ *Sistema de IA temporariamente indispon√≠vel*\n\nüòÖ Estou com problemas t√©cnicos no momento. O administrador j√° foi notificado!\n\n‚è∞ Tente novamente em alguns minutos.');
            } else {
              reply(`üòì Poxa, algo deu errado com o CodeGemma! Tente novamente em alguns instantes, t√°? üåà`);
            }
          });
        });
        break;
      case 'resumir':
        if (!q) return reply(`üìù *Resumidor de Texto*\n\nüí° *Como usar:*\n‚Ä¢ Envie o texto que deseja resumir ap√≥s o comando\n‚Ä¢ Ex: ${prefix}resumir [seu texto aqui]\n\n‚ú® O texto ser√° resumido de forma clara e objetiva!`);
        
        reply('‚è≥ Aguarde enquanto preparo um resumo bem caprichado... ‚ú®').then(() => {
          const prompt = `Resuma o seguinte texto em poucos par√°grafos, de forma clara e objetiva, destacando as informa√ß√µes mais importantes:\n\n${q}`;
          ia.makeCognimaRequest('qwen/qwen3-235b-a22b', prompt, null).then((response) => {
            reply(formatAIResponse(response.data.choices[0].message.content));
          }).catch((e) => {
            console.error('Erro ao resumir texto:', e);
            if (e.message && e.message.includes('API key inv√°lida')) {
              
              reply('ü§ñ *Sistema de IA temporariamente indispon√≠vel*\n\nüòÖ Estou com problemas t√©cnicos no momento. O administrador j√° foi notificado!\n\n‚è∞ Tente novamente em alguns minutos.');
            } else {
              reply('üòì Ops, n√£o consegui resumir agora! Que tal tentar de novo? üåü');
            }
          });
        });
        break;
      case 'resumirurl':
        if (!q) return reply(`üåê Quer resumir uma p√°gina? Envie a URL ap√≥s o comando ${prefix}resumirurl! Exemplo: ${prefix}resumirurl https://exemplo.com/artigo üòä`);
        
        if (!q.startsWith('http://') && !q.startsWith('https://')) {
          return reply(`üö´ Ops, parece que a URL √© inv√°lida! Certifique-se de incluir http:// ou https://. Exemplo: ${prefix}resumirurl https://exemplo.com/artigo üòä`);
        }
        reply('‚è≥ Aguarde enquanto busco e resumo a p√°gina para voc√™... ‚ú®').then(() => {
          axios.get(q, {
            timeout: 120000,
            headers: {
              'User-Agent': 'Mozilla/5.0 (compatible; Bot/1.0)'
            }
          }).then((response) => {
            const { document } = parseHTML(response.data);
            document.querySelectorAll('script, style, noscript, iframe').forEach(el => el.remove());
            const cleanText = document.body.textContent.replace(/\s+/g, ' ').trim();
            if (!cleanText || cleanText.length < 50) {
              reply(`üòì Ops, n√£o encontrei conte√∫do suficiente para resumir nessa p√°gina! Tente outra URL, t√°? üåê`);
              return;
            }
            const prompt = `Resuma o seguinte conte√∫do extra√≠do de uma p√°gina web em poucos par√°grafos, de forma clara e objetiva, destacando os pontos principais:\n\n${cleanText.substring(0, 5000)}`;
            ia.makeCognimaRequest('qwen/qwen3-235b-a22b', prompt, null).then((iaResponse) => {
              reply(formatAIResponse(iaResponse.data.choices[0].message.content));
            }).catch((e) => {
              console.error('Erro ao resumir URL (IA):', e.message);
              if (e.message && e.message.includes('API key inv√°lida')) {
                
                reply('ü§ñ *Sistema de IA temporariamente indispon√≠vel*\n\nüòÖ Estou com problemas t√©cnicos no momento. O administrador j√° foi notificado!\n\n‚è∞ Tente novamente em alguns minutos.');
              } else {
                reply('üòì Vixe, algo deu errado ao resumir a p√°gina! Tente novamente em breve, combinado? üåà');
              }
            });
          }).catch((e) => {
            console.error('Erro ao resumir URL:', e.message);
            if (e.code === 'ECONNABORTED') {
              reply('üòì Ops, a p√°gina demorou muito para responder! Tente outra URL. üåê');
            } else if (e.response) {
              reply(`üòì N√£o consegui acessar a p√°gina (c√≥digo ${e.response.status}). Verifique a URL e tente novamente, t√°? üåü`);
            } else {
              reply('üòì Vixe, algo deu errado ao resumir a p√°gina! Tente novamente em breve, combinado? üåà');
            }
          });
        });
        break;
      case 'ideias':
      case 'ideia':
        if (!q) return reply(`üí° Quer ideias criativas? Diga o tema ap√≥s o comando ${prefix}ideias! Exemplo: ${prefix}ideias nomes para um aplicativo de receitas üòä`);
        
        reply('‚è≥ Um segundinho, estou pensando em ideias incr√≠veis... ‚ú®').then(() => {
          const prompt = `Gere 15 ideias criativas e detalhadas para o seguinte tema: ${q}`;
          ia.makeCognimaRequest('qwen/qwen3-235b-a22b', prompt, null).then((response) => {
            reply(formatAIResponse(response.data.choices[0].message.content));
          }).catch((e) => {
            console.error('Erro ao gerar ideias:', e);
            if (e.message && e.message.includes('API key inv√°lida')) {
              
              reply('ü§ñ *Sistema de IA temporariamente indispon√≠vel*\n\nüòÖ Estou com problemas t√©cnicos no momento. O administrador j√° foi notificado!\n\n‚è∞ Tente novamente em alguns minutos.');
            } else {
              reply('üòì Poxa, n√£o consegui gerar ideias agora! Tente de novo em breve, t√°? üåà');
            }
          });
        });
        break;
      case 'explicar':
      case 'explique':
        if (!q) return reply(`ü§ì Quer entender algo? Diga o que deseja explicar ap√≥s o comando ${prefix}explicar! Exemplo: ${prefix}explicar o que √© intelig√™ncia artificial üòä`);
        
        reply('‚è≥ Um momentinho, estou preparando uma explica√ß√£o bem clara... ‚ú®').then(() => {
          const prompt = `Explique o seguinte conceito de forma simples e clara, como se fosse para algu√©m sem conhecimento pr√©vio: ${q}`;
          ia.makeCognimaRequest('qwen/qwen3-235b-a22b', prompt, null).then((response) => {
            reply(formatAIResponse(response.data.choices[0].message.content));
          }).catch((e) => {
            console.error('Erro ao explicar conceito:', e);
            if (e.message && e.message.includes('API key inv√°lida')) {
              
              reply('ü§ñ *Sistema de IA temporariamente indispon√≠vel*\n\nüòÖ Estou com problemas t√©cnicos no momento. O administrador j√° foi notificado!\n\n‚è∞ Tente novamente em alguns minutos.');
            } else {
              reply('üòì Vixe, n√£o consegui explicar agora! Tente de novo em alguns instantes, t√°? üåà');
            }
          });
        });
        break;
      case 'corrigir':
      case 'correcao':
        if (!q) return reply(`‚úçÔ∏è Quer corrigir um texto? Envie o texto ap√≥s o comando ${prefix}corrigir! Exemplo: ${prefix}corrigir Eu foi no mercado e comprei frutas. üòä`);
        
        reply('‚è≥ Aguarde enquanto dou um polimento no seu texto... ‚ú®').then(() => {
          const prompt = `Corrija os erros gramaticais, ortogr√°ficos e de estilo no seguinte texto, mantendo o significado original: ${q}`;
          ia.makeCognimaRequest('qwen/qwen3-235b-a22b', prompt, null).then((response) => {
            reply(formatAIResponse(response.data.choices[0].message.content));
          }).catch((e) => {
            console.error('Erro ao corrigir texto:', e);
            reply('üòì Ops, n√£o consegui corrigir o texto agora! Tente novamente, t√°? üåü');
          });
        });
        break;

      // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
      // üí¨ RESUMIDOR DE CONVERSAS DO GRUPO
      // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
      case 'resumirchat':
      case 'resumirgrupo':
      case 'resumirconversa': {
        if (!isGroup) {
          return reply('‚ö†Ô∏è Este comando s√≥ pode ser usado em grupos!');
        }
        
        

        const quantidade = parseInt(args[0]) || 50;
        const limite = Math.min(Math.max(quantidade, 10), 200); // Entre 10 e 200 mensagens

        reply(`üí¨ Coletando as √∫ltimas ${limite} mensagens para resumir... ‚è≥`).then(() => {
          // Buscar mensagens do cache
          const mensagensGrupo = [];
          
          if (messagesCache && typeof messagesCache.keys === 'function') {
            // Tentar pegar do cache de mensagens
            // Chaves est√£o no formato: remoteJid_messageId
            const cacheKeys = Array.from(messagesCache.keys());
            const groupMessages = cacheKeys
              .filter(key => key.startsWith(`${from}_`))
              .slice(-limite);
            
            for (const key of groupMessages) {
              const cachedInfo = messagesCache.get(key);
              if (cachedInfo?.message) {
                const texto = cachedInfo.message?.conversation || 
                             cachedInfo.message?.extendedTextMessage?.text ||
                             cachedInfo.message?.imageMessage?.caption ||
                             cachedInfo.message?.videoMessage?.caption || '';
                if (texto && texto.length > 0) {
                  const pushName = cachedInfo.pushName || 'Usu√°rio';
                  mensagensGrupo.push(`${pushName}: ${texto}`);
                }
              }
            }
          }

          // Se n√£o conseguiu do cache, usar store
          if (mensagensGrupo.length < 10 && store?.messages) {
            const storeMessages = store.messages[from];
            if (storeMessages?.array) {
              const msgs = storeMessages.array.slice(-limite);
              for (const msg of msgs) {
                const texto = msg.message?.conversation || 
                             msg.message?.extendedTextMessage?.text ||
                             msg.message?.imageMessage?.caption ||
                             msg.message?.videoMessage?.caption || '';
                if (texto && texto.length > 0) {
                  const pushName = msg.pushName || 'Usu√°rio';
                  if (!mensagensGrupo.includes(`${pushName}: ${texto}`)) {
                    mensagensGrupo.push(`${pushName}: ${texto}`);
                  }
                }
              }
            }
          }

          if (mensagensGrupo.length < 5) {
            return reply('üòÖ N√£o encontrei mensagens suficientes para resumir. O grupo precisa ter mais atividade recente!');
          }

          const conversaTexto = mensagensGrupo.slice(-limite).join('\n');
          
          const prompt = `Resuma a seguinte conversa de grupo do WhatsApp de forma clara e organizada em portugu√™s brasileiro.

Identifique:
1. üìå *Principais assuntos discutidos*
2. üó£Ô∏è *Participantes mais ativos*
3. üí° *Decis√µes ou conclus√µes importantes* (se houver)
4. üî• *Momentos interessantes ou engra√ßados* (se houver)

Conversa:
${conversaTexto.substring(0, 8000)}

Fa√ßa um resumo conciso mas completo, destacando o que √© mais relevante.`;

          return ia.makeCognimaRequest('abacusai/dracarys-llama-3.1-70b-instruct', prompt, null);
        }).then(response => {
          return reply(`üí¨ *Resumo da Conversa* (√∫ltimas mensagens)\n\n${formatAIResponse(response.data.choices[0].message.content)}`);
        }).catch(e => {
          console.error('Erro ao resumir conversa:', e);
          if (e.message?.includes('API key inv√°lida')) {
            
            return reply('ü§ñ *Sistema de IA temporariamente indispon√≠vel*\n\nO administrador j√° foi notificado!');
          } else {
            return reply('üòì N√£o consegui resumir a conversa agora! Tente novamente em breve. üåà');
          }
        });
        break;
      }

      // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
      // üìñ GERADOR DE HIST√ìRIAS COM IA
      // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
      case 'historia':
      case 'story':
      case 'gerarhistoria': {
        
        
        if (!q) {
          return reply(`üìñ *Gerador de Hist√≥rias*\n\nüí° *Como usar:*\n‚Ä¢ ${prefix}historia <g√™nero> <tema opcional>\n\nüìö *G√™neros dispon√≠veis:*\n‚Ä¢ fantasia, terror, romance, fic√ß√£o cient√≠fica, aventura, mist√©rio, com√©dia, drama, a√ß√£o, suspense\n\n‚ú® *Exemplos:*\n‚Ä¢ ${prefix}historia fantasia drag√µes\n‚Ä¢ ${prefix}historia terror casa abandonada\n‚Ä¢ ${prefix}historia romance escola\n‚Ä¢ ${prefix}historia fic√ß√£o cient√≠fica viagem no tempo`);
        }

        const generos = {
          'fantasia': 'uma hist√≥ria de fantasia √©pica com magia e criaturas m√≠sticas',
          'terror': 'uma hist√≥ria de terror arrepiante e assustadora',
          'romance': 'uma hist√≥ria de romance envolvente e emocionante',
          'ficcao': 'uma hist√≥ria de fic√ß√£o cient√≠fica futurista',
          'fic√ß√£o': 'uma hist√≥ria de fic√ß√£o cient√≠fica futurista',
          'fic√ß√£o cient√≠fica': 'uma hist√≥ria de fic√ß√£o cient√≠fica futurista',
          'aventura': 'uma hist√≥ria de aventura emocionante cheia de a√ß√£o',
          'misterio': 'uma hist√≥ria de mist√©rio intrigante com reviravoltas',
          'mist√©rio': 'uma hist√≥ria de mist√©rio intrigante com reviravoltas',
          'comedia': 'uma hist√≥ria de com√©dia divertida e engra√ßada',
          'com√©dia': 'uma hist√≥ria de com√©dia divertida e engra√ßada',
          'drama': 'uma hist√≥ria dram√°tica profunda e emocionante',
          'acao': 'uma hist√≥ria de a√ß√£o explosiva e empolgante',
          'a√ß√£o': 'uma hist√≥ria de a√ß√£o explosiva e empolgante',
          'suspense': 'uma hist√≥ria de suspense tenso e eletrizante'
        };

        const partes = q.toLowerCase().split(' ');
        const genero = partes[0];
        const tema = partes.slice(1).join(' ') || '';
        
        const tipoHistoria = generos[genero] || `uma hist√≥ria criativa de ${genero}`;
        const temaExtra = tema ? ` envolvendo "${tema}"` : '';

        await reply('üìñ Escrevendo sua hist√≥ria... Aguarde um momento! ‚ú®');
        
        try {
          const prompt = `Escreva ${tipoHistoria}${temaExtra} em portugu√™s brasileiro. A hist√≥ria deve ter:
- Um t√≠tulo criativo
- Introdu√ß√£o cativante
- Desenvolvimento interessante com personagens bem constru√≠dos
- Um desfecho memor√°vel
- Entre 400 e 600 palavras

Seja criativo e original. N√£o use clich√™s. A hist√≥ria deve ser envolvente do in√≠cio ao fim.`;

          const response = await ia.makeCognimaRequest('qwen/qwen3-235b-a22b', prompt, null);
          await reply(`üìñ‚ú® *Sua Hist√≥ria*\n\n${formatAIResponse(response.data.choices[0].message.content)}`);
        } catch (e) {
          console.error('Erro ao gerar hist√≥ria:', e);
          if (e.message?.includes('API key inv√°lida')) {
            
            await reply('ü§ñ *Sistema de IA temporariamente indispon√≠vel*\n\nO administrador j√° foi notificado!');
          } else {
            await reply('üòì N√£o consegui escrever a hist√≥ria agora! Tente novamente em breve. üåà');
          }
        }
        break;
      }

      // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
      // üé¨ RECOMENDADOR DE M√çDIA COM IA
      // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
      case 'recomendar':
      case 'recomendacao':
      case 'recomenda√ß√£o':
      case 'suggest': {
        
        
        if (!q) {
          return reply(`üé¨ *Recomendador de M√≠dia*\n\nüí° *Como usar:*\n‚Ä¢ ${prefix}recomendar <tipo> <g√™nero/prefer√™ncia>\n\nüì∫ *Tipos dispon√≠veis:*\n‚Ä¢ anime, jogo, musica, livro\n\n‚ú® *Exemplos:*\n‚Ä¢ ${prefix}recomendar anime a√ß√£o\n‚Ä¢ ${prefix}recomendar jogo rpg\n‚Ä¢ ${prefix}recomendar musica rock\n‚Ä¢ ${prefix}recomendar livro fantasia`);
        }

        const tipos = {
          'anime': { emoji: 'üéå', nome: 'animes' },
          'jogo': { emoji: 'üéÆ', nome: 'jogos' },
          'jogos': { emoji: 'üéÆ', nome: 'jogos' },
          'game': { emoji: 'üéÆ', nome: 'jogos' },
          'musica': { emoji: 'üéµ', nome: 'm√∫sicas/artistas' },
          'm√∫sica': { emoji: 'üéµ', nome: 'm√∫sicas/artistas' },
          'livro': { emoji: 'üìö', nome: 'livros' },
          'livros': { emoji: 'üìö', nome: 'livros' }
        };

        const partes = q.toLowerCase().split(' ');
        const tipo = partes[0];
        const preferencia = partes.slice(1).join(' ') || 'qualquer g√™nero';
        
        const tipoInfo = tipos[tipo] || { emoji: '‚ú®', nome: tipo };

        await reply(`${tipoInfo.emoji} Buscando recomenda√ß√µes de ${tipoInfo.nome}... Aguarde! ‚ú®`);
        
        try {
          const prompt = `Recomende 5 ${tipoInfo.nome} do g√™nero/estilo "${preferencia}" em portugu√™s brasileiro.

Para cada recomenda√ß√£o, forne√ßa:
1. Nome
2. Breve descri√ß√£o (2-3 linhas)
3. Por que √© bom
4. Nota de popularidade (de 1 a 10)

Seja espec√≠fico e recomende op√ß√µes variadas (populares e menos conhecidas). Formate de forma clara e organizada.`;

          const response = await ia.makeCognimaRequest('qwen/qwen3-235b-a22b', prompt, null);
          await reply(`${tipoInfo.emoji} *Recomenda√ß√µes de ${tipoInfo.nome.charAt(0).toUpperCase() + tipoInfo.nome.slice(1)}*\n\n${formatAIResponse(response.data.choices[0].message.content)}`);
        } catch (e) {
          console.error('Erro ao gerar recomenda√ß√µes:', e);
          if (e.message?.includes('API key inv√°lida')) {
            
            await reply('ü§ñ *Sistema de IA temporariamente indispon√≠vel*\n\nO administrador j√° foi notificado!');
          } else {
            await reply('üòì N√£o consegui buscar recomenda√ß√µes agora! Tente novamente em breve. üåà');
          }
        }
        break;
      }

      // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
      // üéÆ WORDLE - Jogo de adivinhar palavra
      // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
      case 'wordle':
      case 'palavra': {
        // Carregar palavras do JSON
        const wordlePath = pathz.join(__dirname, 'funcs', 'json', 'wordle.json');
        let palavrasPorTamanho = {};
        try {
          const wordleData = JSON.parse(fs.readFileSync(wordlePath, 'utf-8'));
          palavrasPorTamanho = wordleData.palavras || {};
        } catch (e) {
          console.error('Erro ao carregar wordle.json:', e);
          palavrasPorTamanho = { "5": ['amigo', 'barco', 'canto', 'dan√ßa', 'entre', 'falar', 'gosto', 'hotel', 'igual', 'jogar'] };
        }

        // Estado dos jogos de wordle ativos
        if (!global.wordleGames) global.wordleGames = {};
        const gameKey = isGroup ? from : sender;

        // Subcomando para chutar
        if (args[0] && global.wordleGames[gameKey]) {
          const game = global.wordleGames[gameKey];
          const chute = normalizar(args[0].toLowerCase());
          const tamanhoEsperado = game.palavra.length;
          
          // Validar tamanho do chute
          if (chute.length !== tamanhoEsperado) {
            return reply(`‚ùå A palavra deve ter ${tamanhoEsperado} letras!\n\nüí° Voc√™ tem um jogo ativo com palavra de ${tamanhoEsperado} letras.\n\nüìù Chute: ${prefix}wordle [palavra de ${tamanhoEsperado} letras]`);
          }
          
          game.tentativas++;
          
          // Verificar letras com l√≥gica correta do Wordle
          let resultado = '';
          const palavraArray = game.palavra.split('');
          const chuteArray = chute.split('');
          
          // Array para rastrear letras dispon√≠veis na palavra original
          const letrasDisponiveis = [...palavraArray];
          const statusLetras = new Array(tamanhoEsperado).fill(null); // null = n√£o processado
          
          // Primeira passada: marcar letras no lugar certo (verde)
          for (let i = 0; i < tamanhoEsperado; i++) {
            if (chuteArray[i] === palavraArray[i]) {
              statusLetras[i] = 'üü©'; // Verde
              // Remover essa letra do array dispon√≠vel
              const index = letrasDisponiveis.indexOf(chuteArray[i]);
              if (index !== -1) {
                letrasDisponiveis.splice(index, 1);
              }
            }
          }
          
          // Segunda passada: marcar letras no lugar errado (amarelo) ou erradas (preto)
          for (let i = 0; i < tamanhoEsperado; i++) {
            if (statusLetras[i] === null) {
              // Letra n√£o est√° no lugar certo
              if (letrasDisponiveis.includes(chuteArray[i])) {
                // Letra existe na palavra e ainda h√° ocorr√™ncias dispon√≠veis
                statusLetras[i] = 'üü®'; // Amarelo
                // Remover essa ocorr√™ncia do array dispon√≠vel
                const index = letrasDisponiveis.indexOf(chuteArray[i]);
                if (index !== -1) {
                  letrasDisponiveis.splice(index, 1);
                }
            } else {
                // Letra n√£o existe ou j√° foi usada
                statusLetras[i] = '‚¨õ'; // Preto
              }
            }
          }
          
          resultado = statusLetras.join('');
          
          game.historico.push(`${chute.toUpperCase()} ${resultado}`);
          
          if (chute === game.palavra) {
            const pontos = Math.max(100 - (game.tentativas - 1) * 15, 10);
            delete global.wordleGames[gameKey];
            return reply(`üéâ *PARAB√âNS!*\n\n${game.historico.join('\n')}\n\n‚úÖ Voc√™ acertou em ${game.tentativas}/6 tentativas!\nüèÜ +${pontos} pontos\n\nA palavra era: *${game.palavra.toUpperCase()}*`);
          }
          
          if (game.tentativas >= 6) {
            delete global.wordleGames[gameKey];
            return reply(`üò¢ *GAME OVER!*\n\n${game.historico.join('\n')}\n\n‚ùå Suas tentativas acabaram!\n\nA palavra era: *${game.palavra.toUpperCase()}*`);
          }
          
          return reply(`üéØ *WORDLE* (${game.tentativas}/6)\n\n${game.historico.join('\n')}\n\nüí° Continue chutando com: ${prefix}wordle [palavra de ${tamanhoEsperado} letras]`);
        }

        // Novo jogo
        if (global.wordleGames[gameKey]) {
          const game = global.wordleGames[gameKey];
          const tamanho = game.palavra.length;
          return reply(`üéÆ *Jogo em andamento!*\n\n${game.historico.length > 0 ? game.historico.join('\n') + '\n\n' : ''}Tentativas: ${game.tentativas}/6\nüìè Tamanho: ${tamanho} letras\n\nüí° Chute uma palavra de ${tamanho} letras:\n${prefix}wordle [palavra]\n\nüîÑ Para desistir: ${prefix}wordle desistir`);
        }

        if (args[0] === 'desistir' && global.wordleGames[gameKey]) {
          const palavra = global.wordleGames[gameKey].palavra;
          delete global.wordleGames[gameKey];
          return reply(`üè≥Ô∏è Voc√™ desistiu!\n\nA palavra era: *${palavra.toUpperCase()}*`);
        }

        // Iniciar novo jogo - escolher tamanho aleat√≥rio
        const tamanhosDisponiveis = Object.keys(palavrasPorTamanho).filter(t => palavrasPorTamanho[t] && palavrasPorTamanho[t].length > 0);
        if (tamanhosDisponiveis.length === 0) {
          return reply('‚ùå Erro: Nenhuma palavra dispon√≠vel no banco de dados!');
        }
        
        const tamanhoEscolhido = tamanhosDisponiveis[Math.floor(Math.random() * tamanhosDisponiveis.length)];
        const palavrasDoTamanho = palavrasPorTamanho[tamanhoEscolhido];
        const palavraEscolhida = palavrasDoTamanho[Math.floor(Math.random() * palavrasDoTamanho.length)];
        
        global.wordleGames[gameKey] = {
          palavra: normalizar(palavraEscolhida.toLowerCase()),
          tentativas: 0,
          historico: [],
          iniciado: Date.now()
        };

        await reply(`üéÆ *WORDLE - Adivinhe a Palavra!*\n\nüìù Tente adivinhar a palavra de ${tamanhoEscolhido} letras!\n\nüü© = Letra certa no lugar certo\nüü® = Letra certa no lugar errado\n‚¨õ = Letra n√£o existe\n\nüí° Voc√™ tem 6 tentativas!\n\n*Chute com:* ${prefix}wordle [palavra de ${tamanhoEscolhido} letras]`);
        break;
      }

      // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
      // ‚ùì QUIZ - Perguntas e Respostas
      // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
      case 'quiz':
      case 'trivia':
      case 'pergunta': {
        // Carregar perguntas do JSON
        const quizPath = pathz.join(__dirname, 'funcs', 'json', 'quiz.json');
        let quizDB = {};
        try {
          quizDB = JSON.parse(fs.readFileSync(quizPath, 'utf-8'));
        } catch (e) {
          console.error('Erro ao carregar quiz.json:', e);
          quizDB = {
            'geral': [{ p: 'Qual √© o maior planeta do sistema solar?', r: ['jupiter', 'j√∫piter'], d: 'J√∫piter' }],
            'anime': [{ p: 'Qual √© o nome do protagonista de Naruto?', r: ['naruto'], d: 'Naruto Uzumaki' }],
            'games': [{ p: 'Qual √© o nome do personagem principal de The Legend of Zelda?', r: ['link'], d: 'Link' }],
            'ciencia': [{ p: 'Qual √© a f√≥rmula qu√≠mica da √°gua?', r: ['h2o'], d: 'H2O' }],
            'historia': [{ p: 'Em que ano come√ßou a Segunda Guerra Mundial?', r: ['1939'], d: '1939' }]
          };
        }

        // Estado dos jogos de quiz ativos
        if (!global.quizGames) global.quizGames = {};
        const quizKey = isGroup ? from : sender;

        // Carregar categorias dispon√≠veis
        const categoriasDisponiveis = Object.keys(quizDB);

        // Responder quiz ativo
        if (global.quizGames[quizKey] && args.length > 0 && !categoriasDisponiveis.includes(args[0].toLowerCase())) {
          const game = global.quizGames[quizKey];
          const resposta = normalizar(args.join(' ').toLowerCase());
          
          const acertou = game.respostas.some(r => normalizar(r) === resposta || resposta.includes(normalizar(r)));
          
          delete global.quizGames[quizKey];
          
          if (acertou) {
            const tempoResposta = ((Date.now() - game.iniciado) / 1000).toFixed(1);
            const pontos = Math.max(50 - Math.floor(parseFloat(tempoResposta) * 2), 10);
            return reply(`üéâ *CORRETO!*\n\n‚úÖ Resposta: *${game.display}*\n‚è±Ô∏è Tempo: ${tempoResposta}s\nüèÜ +${pontos} pontos`);
          } else {
            return reply(`‚ùå *ERRADO!*\n\n‚úÖ A resposta correta era: *${game.display}*\n\nMais sorte na pr√≥xima!`);
          }
        }

        // Quiz ativo - mostrar pergunta atual
        if (global.quizGames[quizKey] && args.length === 0) {
          const game = global.quizGames[quizKey];
          return reply(`‚ùì *QUIZ* (${game.categoria})\n\n${game.pergunta}\n\nüí° Responda com: ${prefix}quiz [resposta]\nüîÑ Pular: ${prefix}quiz pular`);
        }

        // Pular pergunta
        if (args[0] === 'pular' && global.quizGames[quizKey]) {
          const resposta = global.quizGames[quizKey].display;
          delete global.quizGames[quizKey];
          return reply(`‚è≠Ô∏è Pergunta pulada!\n\nA resposta era: *${resposta}*`);
        }

        // Mostrar categorias
        if (!args[0]) {
          const categoriasList = Object.keys(quizDB).map(cat => `‚Ä¢ ${prefix}quiz ${cat}`).join('\n');
          return reply(`‚ùì *QUIZ - Teste seus conhecimentos!*\n\nüìö *Categorias dispon√≠veis:*\n${categoriasList}\n\nüí° Responda r√°pido para ganhar mais pontos!`);
        }

        // Nova pergunta
        const categoria = args[0].toLowerCase();
        const perguntas = quizDB[categoria];
        
        if (!perguntas) {
          const categoriasDisponiveis = Object.keys(quizDB).join(', ');
          return reply(`‚ùå Categoria "${categoria}" n√£o encontrada!\n\nüìö Categorias dispon√≠veis: ${categoriasDisponiveis}`);
        }

        const perguntaEscolhida = perguntas[Math.floor(Math.random() * perguntas.length)];
        global.quizGames[quizKey] = {
          pergunta: perguntaEscolhida.p,
          respostas: perguntaEscolhida.r,
          display: perguntaEscolhida.d,
          categoria: categoria,
          iniciado: Date.now()
        };

        await reply(`‚ùì *QUIZ* (${categoria})\n\n${perguntaEscolhida.p}\n\nüí° Responda com: ${prefix}quiz [resposta]\n‚è±Ô∏è Responda r√°pido para mais pontos!`);
        break;
      }

      // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
      // üéØ FORCA - Jogo da Forca em Grupo
      // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
      case 'forca':
      case 'hangman': {
        // Carregar palavras do JSON
        const forcaPath = pathz.join(__dirname, 'funcs', 'json', 'forca.json');
        let palavrasForca = [];
        try {
          const forcaData = JSON.parse(fs.readFileSync(forcaPath, 'utf-8'));
          palavrasForca = forcaData.palavras || [];
        } catch (e) {
          console.error('Erro ao carregar forca.json:', e);
          palavrasForca = [
          { palavra: 'elefante', dica: 'Animal grande com tromba' },
          { palavra: 'computador', dica: 'M√°quina eletr√¥nica' },
            { palavra: 'chocolate', dica: 'Doce feito de cacau' }
          ];
        }

        const desenhoForca = [
          '```\n  ‚îå‚îÄ‚îÄ‚îÄ‚îê\n  ‚îÇ   ‚îÇ\n      ‚îÇ\n      ‚îÇ\n      ‚îÇ\n‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïß‚ïê‚ïê```',
          '```\n  ‚îå‚îÄ‚îÄ‚îÄ‚îê\n  ‚îÇ   ‚îÇ\n  üòÆ  ‚îÇ\n      ‚îÇ\n      ‚îÇ\n‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïß‚ïê‚ïê```',
          '```\n  ‚îå‚îÄ‚îÄ‚îÄ‚îê\n  ‚îÇ   ‚îÇ\n  üòÆ  ‚îÇ\n  ‚îÇ   ‚îÇ\n      ‚îÇ\n‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïß‚ïê‚ïê```',
          '```\n  ‚îå‚îÄ‚îÄ‚îÄ‚îê\n  ‚îÇ   ‚îÇ\n  üòÆ  ‚îÇ\n ‚îÄ‚îÇ   ‚îÇ\n      ‚îÇ\n‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïß‚ïê‚ïê```',
          '```\n  ‚îå‚îÄ‚îÄ‚îÄ‚îê\n  ‚îÇ   ‚îÇ\n  üòÆ  ‚îÇ\n ‚îÄ‚îÇ‚îÄ  ‚îÇ\n      ‚îÇ\n‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïß‚ïê‚ïê```',
          '```\n  ‚îå‚îÄ‚îÄ‚îÄ‚îê\n  ‚îÇ   ‚îÇ\n  üòÆ  ‚îÇ\n ‚îÄ‚îÇ‚îÄ  ‚îÇ\n /    ‚îÇ\n‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïß‚ïê‚ïê```',
          '```\n  ‚îå‚îÄ‚îÄ‚îÄ‚îê\n  ‚îÇ   ‚îÇ\n  üòµ  ‚îÇ\n ‚îÄ‚îÇ‚îÄ  ‚îÇ\n / \\  ‚îÇ\n‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïß‚ïê‚ïê```'
        ];

        // Estado dos jogos de forca ativos
        if (!global.forcaGames) global.forcaGames = {};
        const forcaKey = isGroup ? from : sender;

        // Mostrar dica
        if (args[0] === 'dica' && global.forcaGames[forcaKey]) {
          const game = global.forcaGames[forcaKey];
          return reply(`${desenhoForca[game.erros]}\n\nüéØ *FORCA*\n\nüìù ${game.progresso.join(' ')}\n\nüí° *Dica:* ${game.dica}\n‚ùå Letras erradas: ${game.letrasErradas.join(', ') || 'Nenhuma'}\n‚ö†Ô∏è Erros: ${game.erros}/6\n\nüí¨ Chute com: ${prefix}forca [letra]\nüî§ Ou chute a palavra: ${prefix}forca [palavra]`);
        }

        // Chutar letra ou palavra
        if (global.forcaGames[forcaKey] && args.length > 0 && args[0] !== 'desistir' && args[0] !== 'dica') {
          const game = global.forcaGames[forcaKey];
          const chute = normalizar(args.join('').toLowerCase());
          
          // Chutar palavra inteira
          if (chute.length > 1) {
            if (chute === normalizar(game.palavra)) {
              delete global.forcaGames[forcaKey];
              return reply(`üéâ *PARAB√âNS!*\n\n‚úÖ Voc√™ acertou a palavra!\n\nüèÜ A palavra era: *${game.palavra.toUpperCase()}*`);
            } else {
              game.erros += 2;
              if (game.erros >= 6) {
                delete global.forcaGames[forcaKey];
                return reply(`${desenhoForca[6]}\n\nüíÄ *GAME OVER!*\n\n‚ùå A palavra era: *${game.palavra.toUpperCase()}*`);
              }
              return reply(`${desenhoForca[game.erros]}\n\n‚ùå Palavra errada! (+2 erros)\n\nüìù ${game.progresso.join(' ')}\n\n‚ùå Letras erradas: ${game.letrasErradas.join(', ') || 'Nenhuma'}\n‚ö†Ô∏è Erros: ${game.erros}/6\n\nüí° Use ${prefix}forca dica para ver a dica`);
            }
          }
          
          // Chutar letra
          const letra = chute[0];
          
          if (game.letrasCorretas.includes(letra) || game.letrasErradas.includes(letra)) {
            return reply(`‚ö†Ô∏è Voc√™ j√° chutou a letra "${letra.toUpperCase()}"!\n\nüìù ${game.progresso.join(' ')}\n\n‚ùå Letras erradas: ${game.letrasErradas.join(', ') || 'Nenhuma'}\n\nüí° Use ${prefix}forca dica para ver a dica`);
          }
          
          const palavraNorm = normalizar(game.palavra.toLowerCase());
          
          if (palavraNorm.includes(letra)) {
            game.letrasCorretas.push(letra);
            // Atualizar progresso
            for (let i = 0; i < palavraNorm.length; i++) {
              if (palavraNorm[i] === letra) {
                game.progresso[i] = game.palavra[i].toUpperCase();
              }
            }
            
            // Verificar vit√≥ria
            if (!game.progresso.includes('_')) {
              delete global.forcaGames[forcaKey];
              return reply(`üéâ *PARAB√âNS!*\n\nüìù ${game.progresso.join(' ')}\n\n‚úÖ Voc√™s descobriram a palavra!\nüèÜ *${game.palavra.toUpperCase()}*`);
            }
            
            return reply(`${desenhoForca[game.erros]}\n\n‚úÖ Letra "${letra.toUpperCase()}" correta!\n\nüìù ${game.progresso.join(' ')}\n\n‚ùå Letras erradas: ${game.letrasErradas.join(', ') || 'Nenhuma'}\n‚ö†Ô∏è Erros: ${game.erros}/6\n\nüí° Use ${prefix}forca dica para ver a dica`);
          } else {
            game.letrasErradas.push(letra.toUpperCase());
            game.erros++;
            
            if (game.erros >= 6) {
              delete global.forcaGames[forcaKey];
              return reply(`${desenhoForca[6]}\n\nüíÄ *GAME OVER!*\n\n‚ùå A palavra era: *${game.palavra.toUpperCase()}*`);
            }
            
            return reply(`${desenhoForca[game.erros]}\n\n‚ùå Letra "${letra.toUpperCase()}" errada!\n\nüìù ${game.progresso.join(' ')}\n\n‚ùå Letras erradas: ${game.letrasErradas.join(', ')}\n‚ö†Ô∏è Erros: ${game.erros}/6\n\nüí° Use ${prefix}forca dica para ver a dica`);
          }
        }

        // Desistir
        if (args[0] === 'desistir' && global.forcaGames[forcaKey]) {
          const palavra = global.forcaGames[forcaKey].palavra;
          delete global.forcaGames[forcaKey];
          return reply(`üè≥Ô∏è Voc√™s desistiram!\n\nA palavra era: *${palavra.toUpperCase()}*`);
        }

        // Jogo ativo
        if (global.forcaGames[forcaKey] && args.length === 0) {
          const game = global.forcaGames[forcaKey];
          return reply(`${desenhoForca[game.erros]}\n\nüéØ *FORCA*\n\nüìù ${game.progresso.join(' ')}\n\n‚ùå Letras erradas: ${game.letrasErradas.join(', ') || 'Nenhuma'}\n‚ö†Ô∏è Erros: ${game.erros}/6\n\nüí¨ Chute com: ${prefix}forca [letra]\nüî§ Ou chute a palavra: ${prefix}forca [palavra]\nüí° Ver dica: ${prefix}forca dica\nüè≥Ô∏è Desistir: ${prefix}forca desistir`);
        }

        // Novo jogo
        const escolhida = palavrasForca[Math.floor(Math.random() * palavrasForca.length)];
        const progresso = escolhida.palavra.split('').map(() => '_');
        
        global.forcaGames[forcaKey] = {
          palavra: escolhida.palavra,
          dica: escolhida.dica,
          progresso: progresso,
          letrasCorretas: [],
          letrasErradas: [],
          erros: 0,
          iniciado: Date.now()
        };

        await reply(`${desenhoForca[0]}\n\nüéØ *FORCA - Novo Jogo!*\n\nüìù ${progresso.join(' ')}\n\nüí¨ Chute uma letra: ${prefix}forca [letra]\nüî§ Ou chute a palavra: ${prefix}forca [palavra]\nüí° Ver dica: ${prefix}forca dica\nüè≥Ô∏è Desistir: ${prefix}forca desistir`);
        break;
      }

      // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
      // ‚ö° CORRIDA DE DIGITA√á√ÉO - Quem digita mais r√°pido?
      // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
      case 'digitar':
      case 'typing':
      case 'digitacao': {
        if (!isGroup) return reply('‚ö° Este jogo s√≥ funciona em grupos!');

        // Carregar frases do JSON
        const digitacaoPath = pathz.join(__dirname, 'funcs', 'json', 'digitacao.json');
        let frasesDigitacao = [];
        try {
          const digitacaoData = JSON.parse(fs.readFileSync(digitacaoPath, 'utf-8'));
          frasesDigitacao = digitacaoData.frases || [];
        } catch (e) {
          console.error('Erro ao carregar digitacao.json:', e);
          frasesDigitacao = ['A tecnologia est√° mudando o mundo rapidamente'];
        }

        // Estado dos desafios de digita√ß√£o
        if (!global.digitacaoChallenges) global.digitacaoChallenges = {};
        if (!global.digitacaoGames) global.digitacaoGames = {};

        const challengeKey = isGroup ? from : sender;

        // Desafiar algu√©m
        if (menc_os2 && menc_os2 !== sender) {
          // Limpar desafios expirados (60 segundos)
          if (global.digitacaoChallenges[challengeKey] && Date.now() - global.digitacaoChallenges[challengeKey].created > 60000) {
            delete global.digitacaoChallenges[challengeKey];
          }
          
          // Verificar se j√° existe desafio pendente
          if (global.digitacaoChallenges[challengeKey]) {
            return reply('‚ö†Ô∏è J√° existe um desafio pendente neste grupo!');
          }

          // Criar desafio
          global.digitacaoChallenges[challengeKey] = {
            challenger: sender,
            challenged: menc_os2,
            status: 'pending',
            created: Date.now()
          };

          return reply(`‚ö° *DESAFIO DE DIGITA√á√ÉO*\n\n@${sender.split('@')[0]} desafiou @${menc_os2.split('@')[0]} para uma corrida de digita√ß√£o!\n\nüí° O desafiado deve usar: ${prefix}digitar aceitar\n‚è±Ô∏è O desafio expira em 60 segundos.`, { mentions: [sender, menc_os2] });
        }

        // Aceitar desafio
        if (args[0]?.toLowerCase() === 'aceitar' || args[0]?.toLowerCase() === 'aceitar') {
          const challenge = global.digitacaoChallenges[challengeKey];
          
          if (!challenge) {
            return reply('‚ùå N√£o h√° desafio pendente para voc√™ aceitar!');
          }

          if (challenge.challenged !== sender) {
            return reply('‚ùå Este desafio n√£o √© para voc√™!');
          }

          if (challenge.status !== 'pending') {
            return reply('‚ùå Este desafio j√° foi aceito ou expirado!');
          }

          // Verificar expira√ß√£o (60 segundos)
          if (Date.now() - challenge.created > 60000) {
            delete global.digitacaoChallenges[challengeKey];
            return reply('‚è∞ O desafio expirou!');
          }

          // Iniciar jogo
          const fraseEscolhida = frasesDigitacao[Math.floor(Math.random() * frasesDigitacao.length)];
          const gameId = `game_${Date.now()}`;
          
          challenge.status = 'accepted';
          challenge.gameId = gameId;

          // Enviar frase para ambos (com delay m√≠nimo para evitar copy/paste)
          const delay = 2000; // 2 segundos de delay
          
          setTimeout(async () => {
            // Iniciar o jogo quando a frase for enviada
            global.digitacaoGames[gameId] = {
              challenger: challenge.challenger,
              challenged: challenge.challenged,
              frase: fraseEscolhida,
              fraseNormalizada: normalizar(fraseEscolhida.toLowerCase()),
              status: 'active',
              iniciado: Date.now(), // Timer come√ßa quando frase √© enviada
              resultados: {}
            };
            
            await reply(`‚ö° *CORRIDA DE DIGITA√á√ÉO INICIADA!*\n\nüìù *Digite exatamente esta frase:*\n\n"${fraseEscolhida}"\n\n‚è±Ô∏è Quem digitar primeiro e corretamente vence!\n\nüí° Digite: ${prefix}digitar ${fraseEscolhida}`, { mentions: [challenge.challenger, challenge.challenged] });
          }, delay);

          return reply(`‚úÖ Desafio aceito! A frase ser√° enviada em ${delay/1000} segundos... ‚è±Ô∏è`, { mentions: [challenge.challenger] });
        }

        // Verificar resposta (digita√ß√£o)
        if (global.digitacaoGames) {
          // Procurar jogo ativo onde o jogador participa
          for (const [gameId, game] of Object.entries(global.digitacaoGames)) {
            if (game.status === 'active' && (game.challenger === sender || game.challenged === sender)) {
              const resposta = normalizar(q.toLowerCase());
              const fraseEsperada = game.fraseNormalizada;
              
              // Verificar tempo m√≠nimo (prote√ß√£o anti-copy/paste) - 3 segundos
              const tempoDecorrido = Date.now() - game.iniciado;
              const tempoMinimo = 3000; // 3 segundos
              
              if (tempoDecorrido < tempoMinimo) {
                return reply(`‚è±Ô∏è Muito r√°pido! Aguarde pelo menos ${(tempoMinimo - tempoDecorrido) / 1000} segundos antes de responder.\n\n‚ö†Ô∏è Isso previne c√≥pia e cola!`);
              }

              // Verificar se j√° respondeu
              if (game.resultados[sender]) {
                return reply('‚ö†Ô∏è Voc√™ j√° respondeu! Aguarde o resultado.');
              }

              // Verificar se acertou
              const acertou = resposta === fraseEsperada;
              const tempoResposta = Date.now() - game.iniciado;
              
              game.resultados[sender] = {
                acertou: acertou,
                tempo: tempoResposta,
                resposta: q
              };

              // Verificar se ambos responderam
              if (game.resultados[game.challenger] && game.resultados[game.challenged]) {
                game.status = 'finished';
                
                const challengerResult = game.resultados[game.challenger];
                const challengedResult = game.resultados[game.challenged];
                
                let vencedor = null;
                let perdedor = null;
                
                if (challengerResult.acertou && challengedResult.acertou) {
                  // Ambos acertaram, quem foi mais r√°pido?
                  if (challengerResult.tempo < challengedResult.tempo) {
                    vencedor = game.challenger;
                    perdedor = game.challenged;
                  } else {
                    vencedor = game.challenged;
                    perdedor = game.challenger;
                  }
                } else if (challengerResult.acertou) {
                  vencedor = game.challenger;
                  perdedor = game.challenged;
                } else if (challengedResult.acertou) {
                  vencedor = game.challenged;
                  perdedor = game.challenger;
                }

                let resultadoMsg = `‚ö° *RESULTADO DA CORRIDA*\n\n`;
                resultadoMsg += `üìù Frase: "${game.frase}"\n\n`;
                
                if (vencedor) {
                  const vencedorResult = game.resultados[vencedor];
                  const perdedorResult = game.resultados[perdedor];
                  
                  resultadoMsg += `üèÜ *VENCEDOR:* @${vencedor.split('@')[0]}\n`;
                  resultadoMsg += `‚è±Ô∏è Tempo: ${(vencedorResult.tempo / 1000).toFixed(2)}s\n\n`;
                  resultadoMsg += `üòî *PERDEDOR:* @${perdedor.split('@')[0]}\n`;
                  resultadoMsg += `‚è±Ô∏è Tempo: ${(perdedorResult.tempo / 1000).toFixed(2)}s`;
                  
                  if (!perdedorResult.acertou) {
                    resultadoMsg += `\n‚ùå Resposta incorreta!`;
                  }
                } else {
                  resultadoMsg += `üòî *EMPATE!*\n\n`;
                  resultadoMsg += `Nenhum dos dois acertou a frase corretamente.\n\n`;
                  resultadoMsg += `@${game.challenger.split('@')[0]}: ${challengerResult.acertou ? '‚úÖ' : '‚ùå'} ${(challengerResult.tempo / 1000).toFixed(2)}s\n`;
                  resultadoMsg += `@${game.challenged.split('@')[0]}: ${challengedResult.acertou ? '‚úÖ' : '‚ùå'} ${(challengedResult.tempo / 1000).toFixed(2)}s`;
                }

                // Limpar desafio e jogo
                delete global.digitacaoChallenges[challengeKey];
                delete global.digitacaoGames[gameId];

                return reply(resultadoMsg, { mentions: [game.challenger, game.challenged] });
              } else {
                // Ainda aguardando outro jogador
                return reply(`‚úÖ Resposta recebida! Aguardando o oponente...`);
              }
            }
          }
        }

        // Mostrar ajuda
        return reply(`‚ö° *CORRIDA DE DIGITA√á√ÉO*\n\nüí° *Como jogar:*\n\n1Ô∏è‚É£ Desafie algu√©m:\n${prefix}digitar @usuario\n\n2Ô∏è‚É£ O desafiado aceita:\n${prefix}digitar aceitar\n\n3Ô∏è‚É£ Digite a frase exatamente como aparecer!\n\nüèÜ Quem digitar primeiro e corretamente vence!\n\n‚ö†Ô∏è Prote√ß√£o anti-c√≥pia: m√≠nimo de 3 segundos`);
      }

      // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
      // üö¢ BATALHA NAVAL - Jogo de estrat√©gia naval
      // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
      case 'batalhanaval':
      case 'batalha':
      case 'naval': {
        if (!isGroup) return reply('üö¢ Este jogo s√≥ funciona em grupos!');

        // Carregar configura√ß√£o do JSON
        const navalPath = pathz.join(__dirname, 'funcs', 'json', 'batalhanaval.json');
        let configNaval = {
          tamanhoTabuleiro: 10,
          navios: [
            { nome: "Porta-avi√µes", tamanho: 5, quantidade: 1 },
            { nome: "Encoura√ßado", tamanho: 4, quantidade: 1 },
            { nome: "Cruzador", tamanho: 3, quantidade: 2 },
            { nome: "Destroyer", tamanho: 2, quantidade: 2 },
            { nome: "Submarino", tamanho: 1, quantidade: 2 }
          ]
        };
        try {
          const navalData = JSON.parse(fs.readFileSync(navalPath, 'utf-8'));
          configNaval = { ...configNaval, ...navalData.config };
        } catch (e) {
          console.error('Erro ao carregar batalhanaval.json:', e);
        }

        // Estado dos jogos
        if (!global.navalGames) global.navalGames = {};
        if (!global.navalChallenges) global.navalChallenges = {};

        const gameKey = isGroup ? from : sender;

        // Fun√ß√£o para criar tabuleiro vazio
        const criarTabuleiro = (tamanho) => {
          return Array(tamanho).fill(null).map(() => Array(tamanho).fill('üåä'));
        };

        // Fun√ß√£o para posicionar navios automaticamente
        const posicionarNavios = (tabuleiro, navios) => {
          const tamanho = tabuleiro.length;
          const naviosPosicionados = [];
          
          for (const navio of navios) {
            for (let qtd = 0; qtd < navio.quantidade; qtd++) {
              let posicionado = false;
              let tentativas = 0;
              
              while (!posicionado && tentativas < 100) {
                tentativas++;
                const horizontal = Math.random() < 0.5;
                const linha = Math.floor(Math.random() * tamanho);
                const coluna = Math.floor(Math.random() * tamanho);
                
                // Verificar se cabe
                let cabe = true;
                const posicoes = [];
                
                for (let i = 0; i < navio.tamanho; i++) {
                  const l = horizontal ? linha : linha + i;
                  const c = horizontal ? coluna + i : coluna;
                  
                  if (l >= tamanho || c >= tamanho || tabuleiro[l][c] !== 'üåä') {
                    cabe = false;
                    break;
                  }
                  posicoes.push({ linha: l, coluna: c });
                }
                
                if (cabe) {
                  posicoes.forEach(pos => {
                    tabuleiro[pos.linha][pos.coluna] = 'üö¢';
                  });
                  naviosPosicionados.push({
                    nome: navio.nome,
                    tamanho: navio.tamanho,
                    posicoes: posicoes,
                    acertos: 0
                  });
                  posicionado = true;
                }
              }
            }
          }
          
          return naviosPosicionados;
        };

        // Fun√ß√£o para converter coordenada (A1, B5, etc) para √≠ndices
        const parseCoordenada = (coord) => {
          const match = coord.match(/^([A-J])(\d+)$/i);
          if (!match) return null;
          const coluna = match[1].toUpperCase().charCodeAt(0) - 65;
          const linha = parseInt(match[2]) - 1;
          if (linha < 0 || linha >= 10 || coluna < 0 || coluna >= 10) return null;
          return { linha, coluna };
        };

        // Fun√ß√£o para formatar tabuleiro para exibi√ß√£o
        const formatarTabuleiro = (tabuleiro, mostrarNavios = false) => {
          let resultado = '   A B C D E F G H I J\n';
          for (let i = 0; i < tabuleiro.length; i++) {
            resultado += `${(i + 1).toString().padStart(2)} `;
            for (let j = 0; j < tabuleiro[i].length; j++) {
              const celula = tabuleiro[i][j];
              if (celula === 'üåä') resultado += 'üåä';
              else if (celula === 'üö¢' && !mostrarNavios) resultado += 'üåä';
              else if (celula === 'üí•') resultado += 'üí•';
              else if (celula === '‚ùå') resultado += '‚ùå';
              else resultado += celula;
              resultado += ' ';
            }
            resultado += '\n';
          }
          return resultado;
        };

        // Desafiar algu√©m
        if (menc_os2 && menc_os2 !== sender) {
          // Limpar desafios expirados (60 segundos)
          if (global.navalChallenges[gameKey] && Date.now() - global.navalChallenges[gameKey].created > 60000) {
            delete global.navalChallenges[gameKey];
          }
          
          // Limpar jogos abandonados (10 minutos sem atividade)
          if (global.navalGames[gameKey] && global.navalGames[gameKey].ultimaJogada && Date.now() - global.navalGames[gameKey].ultimaJogada > 600000) {
            delete global.navalGames[gameKey];
          }
          
          if (global.navalChallenges[gameKey] || global.navalGames[gameKey]) {
            return reply('‚ö†Ô∏è J√° existe um jogo ou desafio pendente neste grupo!');
          }

          global.navalChallenges[gameKey] = {
            challenger: sender,
            challenged: menc_os2,
            status: 'pending',
            created: Date.now()
          };

          return reply(`üö¢ *DESAFIO DE BATALHA NAVAL*\n\n@${sender.split('@')[0]} desafiou @${menc_os2.split('@')[0]} para uma batalha naval!\n\nüí° O desafiado deve usar: ${prefix}batalhanaval aceitar\n‚è±Ô∏è O desafio expira em 60 segundos.`, { mentions: [sender, menc_os2] });
        }

        // Aceitar desafio
        if (args[0]?.toLowerCase() === 'aceitar') {
          const challenge = global.navalChallenges[gameKey];
          
          if (!challenge || challenge.challenged !== sender || challenge.status !== 'pending') {
            return reply('‚ùå N√£o h√° desafio pendente para voc√™ aceitar!');
          }

          if (Date.now() - challenge.created > 60000) {
            delete global.navalChallenges[gameKey];
            return reply('‚è∞ O desafio expirou!');
          }

          // Criar tabuleiros e posicionar navios
          const tabuleiro1 = criarTabuleiro(configNaval.tamanhoTabuleiro);
          const tabuleiro2 = criarTabuleiro(configNaval.tamanhoTabuleiro);
          const navios1 = posicionarNavios(tabuleiro1, configNaval.navios);
          const navios2 = posicionarNavios(tabuleiro2, configNaval.navios);

          // Criar tabuleiros de tiros (o que o jogador v√™ do oponente)
          const tiros1 = criarTabuleiro(configNaval.tamanhoTabuleiro);
          const tiros2 = criarTabuleiro(configNaval.tamanhoTabuleiro);

          global.navalGames[gameKey] = {
            jogador1: challenge.challenger,
            jogador2: challenge.challenged,
            tabuleiro1: tabuleiro1,
            tabuleiro2: tabuleiro2,
            tiros1: tiros1,
            tiros2: tiros2,
            navios1: navios1,
            navios2: navios2,
            turno: challenge.challenger, // Jogador 1 come√ßa
            status: 'active',
            ultimaJogada: Date.now()
          };

          delete global.navalChallenges[gameKey];

          return reply(`üö¢ *BATALHA NAVAL INICIADA!*\n\n@${challenge.challenger.split('@')[0]} vs @${challenge.challenged.split('@')[0]}\n\nüéØ √â a vez de @${challenge.challenger.split('@')[0]} atirar!\n\nüí° Use: ${prefix}batalhanaval [coordenada]\nüìå Exemplo: ${prefix}batalhanaval A5`, { mentions: [challenge.challenger, challenge.challenged] });
        }

        // Processar tiro
        if (global.navalGames[gameKey] && args[0]) {
          const game = global.navalGames[gameKey];
          
          if (game.status !== 'active') {
            return reply('‚ùå Este jogo j√° terminou!');
          }

          // Verificar se √© a vez do jogador
          if (game.turno !== sender) {
            return reply('‚è≥ N√£o √© sua vez! Aguarde o oponente.');
          }

          const coordenada = parseCoordenada(args[0].toUpperCase());
          if (!coordenada) {
            return reply(`‚ùå Coordenada inv√°lida! Use formato: A1, B5, J10, etc.\n\nüí° Exemplo: ${prefix}batalhanaval A5`);
          }

          // Determinar qual tabuleiro atacar e qual tabuleiro de tiros atualizar
          let tabuleiroAlvo, tirosJogador, naviosAlvo, jogadorAtual, oponente;
          
          if (sender === game.jogador1) {
            tabuleiroAlvo = game.tabuleiro2;
            tirosJogador = game.tiros1;
            naviosAlvo = game.navios2;
            jogadorAtual = game.jogador1;
            oponente = game.jogador2;
          } else {
            tabuleiroAlvo = game.tabuleiro1;
            tirosJogador = game.tiros2;
            naviosAlvo = game.navios1;
            jogadorAtual = game.jogador2;
            oponente = game.jogador1;
          }

          // Verificar se j√° atirou aqui
          if (tirosJogador[coordenada.linha][coordenada.coluna] !== 'üåä') {
            return reply('‚ö†Ô∏è Voc√™ j√° atirou nesta coordenada!');
          }

          // Processar tiro
          const celula = tabuleiroAlvo[coordenada.linha][coordenada.coluna];
          let resultado = '';
          let acertou = false;
          let navioAfundado = null;

          if (celula === 'üö¢') {
            // Acertou um navio
            acertou = true;
            tabuleiroAlvo[coordenada.linha][coordenada.coluna] = 'üí•';
            tirosJogador[coordenada.linha][coordenada.coluna] = 'üí•';
            
            // Verificar qual navio foi atingido
            let navioAtingido = null;
            for (const navio of naviosAlvo) {
              const posicao = navio.posicoes.find(p => p.linha === coordenada.linha && p.coluna === coordenada.coluna);
              if (posicao) {
                navio.acertos++;
                navioAtingido = navio;
                if (navio.acertos === navio.tamanho) {
                  navioAfundado = navio;
                }
                break;
              }
            }
            
            if (navioAfundado) {
              resultado = 'üí• *ACERTOU E AFUNDOU!*';
            } else if (navioAtingido) {
              const faltam = navioAtingido.tamanho - navioAtingido.acertos;
              resultado = `üí• *ACERTOU!*\nüö¢ Navio de ${navioAtingido.tamanho} partes\n‚úÖ Acertou: ${navioAtingido.acertos}/${navioAtingido.tamanho}\nüéØ Faltam: ${faltam} parte${faltam > 1 ? 's' : ''}`;
              
              // Verificar dire√ß√£o do navio baseado nos acertos
              if (navioAtingido.acertos >= 2) {
                const acertosPos = navioAtingido.posicoes.filter((pos, idx) => {
                  // Verificar se essa posi√ß√£o j√° foi acertada
                  return tabuleiroAlvo[pos.linha][pos.coluna] === 'üí•';
                });
                
                if (acertosPos.length >= 2) {
                  const p1 = acertosPos[0];
                  const p2 = acertosPos[1];
                  if (p1.linha === p2.linha) {
                    resultado += `\n‚û°Ô∏è Dire√ß√£o: HORIZONTAL`;
                  } else {
                    resultado += `\n‚¨áÔ∏è Dire√ß√£o: VERTICAL`;
                  }
                }
              }
            } else {
              resultado = 'üí• *ACERTOU!*';
            }
          } else {
            // Errou
            tabuleiroAlvo[coordenada.linha][coordenada.coluna] = '‚ùå';
            tirosJogador[coordenada.linha][coordenada.coluna] = '‚ùå';
            resultado = '‚ùå *√ÅGUA!*';
          }

          // Verificar vit√≥ria
          const todosNaviosAfundados = naviosAlvo.every(n => n.acertos === n.tamanho);
          
          if (todosNaviosAfundados) {
            game.status = 'finished';
            delete global.navalGames[gameKey];
            
            let msgVitoria = `üèÜ *VIT√ìRIA!*\n\n`;
            msgVitoria += `@${jogadorAtual.split('@')[0]} venceu a batalha naval!\n\n`;
            msgVitoria += `üéØ √öltimo tiro: ${args[0].toUpperCase()} - ${resultado}\n`;
            if (navioAfundado) {
              msgVitoria += `üö¢ Afundou: ${navioAfundado.nome}\n`;
            }
            
            return reply(msgVitoria, { mentions: [jogadorAtual, oponente] });
          }

          // Preparar resposta
          let resposta = `${resultado}\n\n`;
          resposta += `üéØ Coordenada: ${args[0].toUpperCase()}\n`;
          
          if (navioAfundado) {
            resposta += `\nüö¢ *${navioAfundado.nome} AFUNDADO!*\n`;
          }
          
          // Mostrar status dos navios do oponente
          const naviosAfundados = naviosAlvo.filter(n => n.acertos === n.tamanho);
          const naviosAtingidos = naviosAlvo.filter(n => n.acertos > 0 && n.acertos < n.tamanho);
          const naviosIntactos = naviosAlvo.filter(n => n.acertos === 0);
          
          resposta += `\nüìã *Status da frota inimiga:*\n`;
          resposta += `üíÄ Afundados: ${naviosAfundados.length}/${naviosAlvo.length}`;
          if (naviosAfundados.length > 0) {
            resposta += ` (${naviosAfundados.map(n => n.nome).join(', ')})`;
          }
          resposta += `\nüî• Atingidos: ${naviosAtingidos.length}`;
          if (naviosAtingidos.length > 0) {
            resposta += ` (${naviosAtingidos.map(n => `${n.nome} ${n.acertos}/${n.tamanho}`).join(', ')})`;
          }
          resposta += `\nüåä Intactos: ${naviosIntactos.length}\n`;
          
          // Trocar turno
          game.turno = oponente;
          game.ultimaJogada = Date.now();
          
          resposta += `\nüìä *Seu tabuleiro de tiros:*\n\`\`\`${formatarTabuleiro(tirosJogador)}\`\`\`\n\n`;
          resposta += `‚è≠Ô∏è Agora √© a vez de @${oponente.split('@')[0]}!\n`;
          resposta += `üí° Use: ${prefix}batalhanaval [coordenada]`;

          return reply(resposta, { mentions: [jogadorAtual, oponente] });
        }

        // Ver status do jogo
        if (global.navalGames[gameKey]) {
          const game = global.navalGames[gameKey];
          const isJogador1 = sender === game.jogador1;
          const tirosJogador = isJogador1 ? game.tiros1 : game.tiros2;
          const naviosAlvoStatus = isJogador1 ? game.navios2 : game.navios1;
          
          // Status dos navios do oponente
          const naviosAfundadosStatus = naviosAlvoStatus.filter(n => n.acertos === n.tamanho);
          const naviosAtingidosStatus = naviosAlvoStatus.filter(n => n.acertos > 0 && n.acertos < n.tamanho);
          const naviosIntactosStatus = naviosAlvoStatus.filter(n => n.acertos === 0);
          
          let status = `üö¢ *BATALHA NAVAL*\n\n`;
          status += `@${game.jogador1.split('@')[0]} vs @${game.jogador2.split('@')[0]}\n\n`;
          status += `üéØ Turno: @${game.turno.split('@')[0]}\n\n`;
          
          status += `üìã *Frota inimiga:*\n`;
          status += `üíÄ Afundados: ${naviosAfundadosStatus.length}/${naviosAlvoStatus.length}`;
          if (naviosAfundadosStatus.length > 0) {
            status += `\n   ‚îî ${naviosAfundadosStatus.map(n => n.nome).join(', ')}`;
          }
          status += `\nüî• Atingidos: ${naviosAtingidosStatus.length}`;
          if (naviosAtingidosStatus.length > 0) {
            status += `\n   ‚îî ${naviosAtingidosStatus.map(n => `${n.nome} (${n.acertos}/${n.tamanho})`).join(', ')}`;
          }
          status += `\nüåä Intactos: ${naviosIntactosStatus.length}\n\n`;
          
          status += `üìä *Seu tabuleiro de tiros:*\n\`\`\`${formatarTabuleiro(tirosJogador)}\`\`\`\n\n`;
          status += `üí° Use: ${prefix}batalhanaval [coordenada]\nüìå Exemplo: ${prefix}batalhanaval A5`;
          
          return reply(status, { mentions: [game.jogador1, game.jogador2] });
        }

        // Mostrar ajuda
        return reply(`üö¢ *BATALHA NAVAL*\n\nüí° *Como jogar:*\n\n1Ô∏è‚É£ Desafie algu√©m:\n${prefix}batalhanaval @usuario\n\n2Ô∏è‚É£ O desafiado aceita:\n${prefix}batalhanaval aceitar\n\n3Ô∏è‚É£ Atire em coordenadas:\n${prefix}batalhanaval A5\n\nüéØ Objetivo: Afundar todos os navios do oponente!\n\nüìå Coordenadas: A-J (colunas) e 1-10 (linhas)\nüí• = Acerto | ‚ùå = √Ågua`);
      }

      // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
      // üõë STOP/ADEDONHA - Jogo de palavras por categorias
      // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
      case 'stop':
      case 'adedonha': {
        if (!isGroup) return reply('üõë Este jogo s√≥ funciona em grupos!');

        // Carregar categorias do JSON
        const stopPath = pathz.join(__dirname, 'funcs', 'json', 'stop.json');
        let categoriasStop = ['Nome', 'Pa√≠s', 'Cidade', 'Animal', 'Cor', 'Fruta', 'Objeto', 'Profiss√£o'];
        try {
          const stopData = JSON.parse(fs.readFileSync(stopPath, 'utf-8'));
          categoriasStop = stopData.categorias || categoriasStop;
        } catch (e) {
          console.error('Erro ao carregar stop.json:', e);
        }

        // Estado dos jogos
        if (!global.stopGames) global.stopGames = {};

        const gameKey = isGroup ? from : sender;

        // Letras v√°lidas (sem acentos problem√°ticos)
        const letras = 'ABCDEFGHIJKLMNOPQRSTUVWXYZ'.split('');

        // Iniciar novo jogo
        if (!global.stopGames[gameKey] || global.stopGames[gameKey].status === 'finished') {
          const letraEscolhida = letras[Math.floor(Math.random() * letras.length)];
          const numCategorias = Math.min(5, categoriasStop.length);
          const categoriasEscolhidas = [];
          const categoriasDisponiveis = [...categoriasStop];
          
          for (let i = 0; i < numCategorias; i++) {
            const idx = Math.floor(Math.random() * categoriasDisponiveis.length);
            categoriasEscolhidas.push(categoriasDisponiveis.splice(idx, 1)[0]);
          }

          global.stopGames[gameKey] = {
            letra: letraEscolhida,
            categorias: categoriasEscolhidas,
            respostas: {},
            status: 'active',
            iniciado: Date.now(),
            tempoLimite: 300000 // 5 minutos
          };

          let msg = `üõë *STOP/ADEDONHA*\n\n`;
          msg += `üî§ *Letra:* ${letraEscolhida}\n\n`;
          msg += `üìã *Categorias:*\n`;
          categoriasEscolhidas.forEach((cat, idx) => {
            msg += `${idx + 1}. ${cat}\n`;
          });
          msg += `\nüí° *Como jogar:*\n`;
          msg += `Use: ${prefix}stop [categoria] [palavra]\n\n`;
          msg += `üìå *Exemplo:*\n`;
          msg += `${prefix}stop Nome Ana\n`;
          msg += `${prefix}stop Pa√≠s Argentina\n\n`;
          msg += `‚è±Ô∏è Tempo limite: 5 minutos\n`;
          msg += `üèÜ Quem completar todas as categorias primeiro vence!`;

          return reply(msg);
        }

        const game = global.stopGames[gameKey];

        // Verificar tempo limite
        if (Date.now() - game.iniciado > game.tempoLimite) {
          game.status = 'finished';
          let resultado = `‚è∞ *TEMPO ESGOTADO!*\n\n`;
          resultado += `üî§ Letra: ${game.letra}\n\n`;
          resultado += `üìä *Resultados:*\n`;
          
          const jogadores = Object.keys(game.respostas);
          if (jogadores.length === 0) {
            resultado += `Ningu√©m respondeu! üòî`;
            delete global.stopGames[gameKey];
            return reply(resultado);
          }

          // Contar pontos
          const pontos = {};
          jogadores.forEach(jogador => {
            pontos[jogador] = Object.keys(game.respostas[jogador]).length;
          });

          const sorted = jogadores.sort((a, b) => pontos[b] - pontos[a]);
          sorted.forEach((jogador, idx) => {
            const nome = jogador.split('@')[0];
            resultado += `${idx + 1}¬∫ @${nome}: ${pontos[jogador]} pontos\n`;
          });

          delete global.stopGames[gameKey];
          return reply(resultado, { mentions: jogadores });
        }

        // Processar resposta
        if (args.length >= 2) {
          const categoriaInput = args[0];
          const palavraInput = args.slice(1).join(' ');

          // Normalizar input
          const categoriaInputNorm = normalizar(categoriaInput.toLowerCase()).trim();
          
          // Encontrar categoria (case insensitive, com busca parcial)
          let categoria = null;
          
          // Primeiro tenta correspond√™ncia exata
          categoria = game.categorias.find(cat => 
            normalizar(cat.toLowerCase()) === categoriaInputNorm
          );
          
          // Se n√£o encontrou, tenta correspond√™ncia parcial (includes)
          if (!categoria) {
            const matches = game.categorias.map(cat => {
              const catNorm = normalizar(cat.toLowerCase());
              const score = {
                categoria: cat,
                exact: catNorm === categoriaInputNorm,
                startsWith: catNorm.startsWith(categoriaInputNorm),
                includes: catNorm.includes(categoriaInputNorm) || categoriaInputNorm.includes(catNorm),
                length: cat.length
              };
              return score;
            }).filter(score => score.exact || score.startsWith || score.includes);
            
            if (matches.length > 0) {
              // Prioriza: exata > come√ßa com > inclui, depois pela maior similaridade
              matches.sort((a, b) => {
                if (a.exact && !b.exact) return -1;
                if (!a.exact && b.exact) return 1;
                if (a.startsWith && !b.startsWith) return -1;
                if (!a.startsWith && b.startsWith) return 1;
                // Se ambas incluem, escolhe a mais longa (mais espec√≠fica)
                return b.length - a.length;
              });
              
              categoria = matches[0].categoria;
            }
          }

          if (!categoria) {
            return reply(`‚ùå Categoria inv√°lida!\n\nüìã Categorias dispon√≠veis:\n${game.categorias.map((c, i) => `${i + 1}. ${c}`).join('\n')}`);
          }

          // Verificar se palavra come√ßa com a letra
          const palavraNorm = normalizar(palavraInput.toLowerCase());
          const letraNorm = normalizar(game.letra.toLowerCase());

          if (palavraNorm[0] !== letraNorm) {
            return reply(`‚ùå A palavra "${palavraInput}" n√£o come√ßa com a letra "${game.letra}"!`);
          }

          // Inicializar respostas do jogador se necess√°rio
          if (!game.respostas[sender]) {
            game.respostas[sender] = {};
          }

          // Verificar se j√° respondeu esta categoria
          if (game.respostas[sender][categoria]) {
            return reply(`‚ö†Ô∏è Voc√™ j√° respondeu a categoria "${categoria}"!\n\nüìù Sua resposta: ${game.respostas[sender][categoria]}`);
          }

          // Verificar se outro jogador j√° usou esta palavra
          const palavraJaUsada = Object.values(game.respostas).some(resp => 
            Object.values(resp).some(pal => normalizar(pal.toLowerCase()) === palavraNorm)
          );

          if (palavraJaUsada) {
            return reply(`‚ö†Ô∏è Outro jogador j√° usou a palavra "${palavraInput}"!`);
          }

          // Adicionar resposta
          game.respostas[sender][categoria] = palavraInput;

          // Verificar se completou todas as categorias
          const categoriasCompletas = Object.keys(game.respostas[sender]).length;
          const totalCategorias = game.categorias.length;

          if (categoriasCompletas === totalCategorias) {
            game.status = 'finished';
            const tempoDecorrido = ((Date.now() - game.iniciado) / 1000).toFixed(1);
            
            let vitoria = `üèÜ *VIT√ìRIA!*\n\n`;
            vitoria += `@${sender.split('@')[0]} completou todas as categorias!\n\n`;
            vitoria += `üî§ Letra: ${game.letra}\n`;
            vitoria += `‚è±Ô∏è Tempo: ${tempoDecorrido}s\n\n`;
            vitoria += `üìã *Respostas:*\n`;
            game.categorias.forEach(cat => {
              vitoria += `‚Ä¢ ${cat}: ${game.respostas[sender][cat]}\n`;
            });

            delete global.stopGames[gameKey];
            return reply(vitoria, { mentions: [sender] });
          }

          // Mostrar progresso
          let progresso = `‚úÖ *Resposta aceita!*\n\n`;
          progresso += `üìã ${categoria}: ${palavraInput}\n\n`;
          progresso += `üìä *Seu progresso:* ${categoriasCompletas}/${totalCategorias}\n\n`;
          progresso += `üìù *Categorias restantes:*\n`;
          game.categorias.forEach(cat => {
            if (!game.respostas[sender][cat]) {
              progresso += `‚Ä¢ ${cat}\n`;
            }
          });

          return reply(progresso);
        }

        // Mostrar status do jogo
        let status = `üõë *STOP/ADEDONHA*\n\n`;
        status += `üî§ *Letra:* ${game.letra}\n\n`;
        status += `üìã *Categorias:*\n`;
        game.categorias.forEach((cat, idx) => {
          const resposta = game.respostas[sender]?.[cat];
          status += `${idx + 1}. ${cat}${resposta ? `: ${resposta} ‚úÖ` : ''}\n`;
        });

        const categoriasCompletas = game.respostas[sender] ? Object.keys(game.respostas[sender]).length : 0;
        status += `\nüìä *Seu progresso:* ${categoriasCompletas}/${game.categorias.length}\n\n`;
        status += `üí° Use: ${prefix}stop [categoria] [palavra]\n`;
        status += `üìå Exemplo: ${prefix}stop Nome Ana`;

        return reply(status);
      }

      // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
      // üîÄ ANAGRAMA - Descubra a palavra embaralhada
      // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
      case 'anagrama': {
        // Carregar palavras do JSON
        const anagramaPath = pathz.join(__dirname, 'funcs', 'json', 'anagrama.json');
        let palavrasAnagrama = [];
        try {
          const anagramaData = JSON.parse(fs.readFileSync(anagramaPath, 'utf-8'));
          palavrasAnagrama = anagramaData.palavras || [];
        } catch (e) {
          console.error('Erro ao carregar anagrama.json:', e);
          palavrasAnagrama = [
            { palavra: 'computador', dica: 'M√°quina eletr√¥nica' }
          ];
        }

        // Estado dos jogos
        if (!global.anagramaGames) global.anagramaGames = {};
        const gameKey = isGroup ? from : sender;

        // Fun√ß√£o para embaralhar palavra
        const embaralhar = (palavra) => {
          const letras = palavra.split('');
          for (let i = letras.length - 1; i > 0; i--) {
            const j = Math.floor(Math.random() * (i + 1));
            [letras[i], letras[j]] = [letras[j], letras[i]];
          }
          return letras.join('');
        };

        // Verificar resposta
        if (global.anagramaGames[gameKey] && args.length > 0) {
          const game = global.anagramaGames[gameKey];
          const resposta = normalizar(args.join(' ').toLowerCase());
          const palavraCorreta = normalizar(game.palavra.toLowerCase());

          if (resposta === palavraCorreta) {
            const tentativas = game.tentativas;
            const pontos = Math.max(100 - (tentativas * 10), 10);
            delete global.anagramaGames[gameKey];
            return reply(`üéâ *PARAB√âNS!*\n\n‚úÖ Voc√™ acertou!\n\nüìù Palavra: *${game.palavra.toUpperCase()}*\nüéØ Tentativas: ${tentativas}\nüèÜ Pontos: +${pontos}`);
          } else {
            game.tentativas++;
            if (game.tentativas >= 5) {
              delete global.anagramaGames[gameKey];
              return reply(`üò¢ *GAME OVER!*\n\n‚ùå Voc√™ esgotou suas tentativas!\n\nüìù A palavra era: *${game.palavra.toUpperCase()}*\nüí° Dica: ${game.dica}`);
            }
            return reply(`‚ùå Resposta incorreta!\n\nüîÄ Anagrama: ${game.embaralhada}\nüí° Dica: ${game.dica}\nüìä Tentativas: ${game.tentativas}/5\n\nüí° Tente novamente: ${prefix}anagrama [palavra]`);
          }
        }

        // Verificar se h√° jogo ativo
        if (global.anagramaGames[gameKey]) {
          const game = global.anagramaGames[gameKey];
          return reply(`üîÄ *ANAGRAMA*\n\nüìù Anagrama: *${game.embaralhada.toUpperCase()}*\nüí° Dica: ${game.dica}\nüìä Tentativas: ${game.tentativas}/5\n\nüí° Descubra a palavra: ${prefix}anagrama [palavra]`);
        }

        // Iniciar novo jogo
        const palavraEscolhida = palavrasAnagrama[Math.floor(Math.random() * palavrasAnagrama.length)];
        const palavraEmbaralhada = embaralhar(palavraEscolhida.palavra);

        global.anagramaGames[gameKey] = {
          palavra: palavraEscolhida.palavra,
          embaralhada: palavraEmbaralhada,
          dica: palavraEscolhida.dica,
          tentativas: 0,
          iniciado: Date.now()
        };

        await reply(`üîÄ *ANAGRAMA - Novo Jogo!*\n\nüìù Anagrama: *${palavraEmbaralhada.toUpperCase()}*\nüí° Dica: ${palavraEscolhida.dica}\n\nüéØ Descubra a palavra original!\nüí° Use: ${prefix}anagrama [palavra]\nüìä Voc√™ tem 5 tentativas`);
        break;
      }

      // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
      // ‚öîÔ∏è DUELO DE QUIZ - Competi√ß√£o de perguntas
      // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
      case 'dueloquiz':
      case 'duelo': {
        if (!isGroup) return reply('‚öîÔ∏è Este jogo s√≥ funciona em grupos!');

        // Carregar perguntas do JSON
        const quizPath = pathz.join(__dirname, 'funcs', 'json', 'quiz.json');
        let quizDB = {};
        try {
          quizDB = JSON.parse(fs.readFileSync(quizPath, 'utf-8'));
        } catch (e) {
          console.error('Erro ao carregar quiz.json:', e);
          quizDB = { 'geral': [{ p: 'Qual √© o maior planeta?', r: ['jupiter'], d: 'J√∫piter' }] };
        }

        // Estado dos duelos
        if (!global.dueloQuizGames) global.dueloQuizGames = {};
        if (!global.dueloQuizChallenges) global.dueloQuizChallenges = {};

        const gameKey = isGroup ? from : sender;

        // Desafiar algu√©m
        if (menc_os2 && menc_os2 !== sender) {
          // Limpar desafios expirados (60 segundos)
          if (global.dueloQuizChallenges[gameKey] && Date.now() - global.dueloQuizChallenges[gameKey].created > 60000) {
            delete global.dueloQuizChallenges[gameKey];
          }
          
          // Limpar jogos abandonados (5 minutos sem atividade)
          if (global.dueloQuizGames[gameKey] && Date.now() - global.dueloQuizGames[gameKey].iniciado > 300000) {
            delete global.dueloQuizGames[gameKey];
          }
          
          // Verificar quantidade de perguntas
          const numPerguntas = parseInt(args.find(arg => !isNaN(parseInt(arg)))) || 5;
          
          if (numPerguntas < 3 || numPerguntas > 20) {
            return reply('‚ùå N√∫mero de perguntas inv√°lido! Use entre 3 e 20 perguntas.\n\nüí° Exemplo: ${prefix}dueloquiz @usuario 10');
          }

          if (global.dueloQuizChallenges[gameKey] || global.dueloQuizGames[gameKey]) {
            return reply('‚ö†Ô∏è J√° existe um duelo ou desafio pendente neste grupo!');
          }

          global.dueloQuizChallenges[gameKey] = {
            challenger: sender,
            challenged: menc_os2,
            numPerguntas: numPerguntas,
            status: 'pending',
            created: Date.now()
          };

          return reply(`‚öîÔ∏è *DESAFIO DE QUIZ*\n\n@${sender.split('@')[0]} desafiou @${menc_os2.split('@')[0]} para um duelo de ${numPerguntas} perguntas!\n\nüí° O desafiado deve usar: ${prefix}dueloquiz aceitar\n‚è±Ô∏è O desafio expira em 60 segundos.`, { mentions: [sender, menc_os2] });
        }

        // Aceitar desafio
        if (args[0]?.toLowerCase() === 'aceitar') {
          const challenge = global.dueloQuizChallenges[gameKey];
          
          if (!challenge || challenge.challenged !== sender || challenge.status !== 'pending') {
            return reply('‚ùå N√£o h√° desafio pendente para voc√™ aceitar!');
          }

          if (Date.now() - challenge.created > 60000) {
            delete global.dueloQuizChallenges[gameKey];
            return reply('‚è∞ O desafio expirou!');
          }

          // Selecionar perguntas aleat√≥rias de categorias diferentes
          const categoriasDisponiveis = Object.keys(quizDB);
          const perguntasSelecionadas = [];
          const categoriasUsadas = new Set();
          const perguntasUsadas = new Set();

          // Coletar todas as perguntas dispon√≠veis
          const todasPerguntas = [];
          categoriasDisponiveis.forEach(cat => {
            quizDB[cat].forEach((pergunta, idx) => {
              todasPerguntas.push({
                categoria: cat,
                pergunta: pergunta,
                id: `${cat}_${idx}`
              });
            });
          });

          // Selecionar perguntas aleat√≥rias sem repetir
          while (perguntasSelecionadas.length < challenge.numPerguntas && todasPerguntas.length > 0) {
            const idx = Math.floor(Math.random() * todasPerguntas.length);
            const pergunta = todasPerguntas.splice(idx, 1)[0];
            
            if (!perguntasUsadas.has(pergunta.id)) {
              perguntasSelecionadas.push(pergunta);
              perguntasUsadas.add(pergunta.id);
              categoriasUsadas.add(pergunta.categoria);
            }
          }

          if (perguntasSelecionadas.length < challenge.numPerguntas) {
            return reply(`‚ùå N√£o h√° perguntas suficientes no banco de dados!`);
          }

          global.dueloQuizGames[gameKey] = {
            jogador1: challenge.challenger,
            jogador2: challenge.challenged,
            perguntas: perguntasSelecionadas,
            perguntaAtual: 0,
            respostas1: [],
            respostas2: [],
            turno: challenge.challenger, // Jogador 1 come√ßa
            status: 'active',
            iniciado: Date.now()
          };

          delete global.dueloQuizChallenges[gameKey];

          const primeiraPergunta = perguntasSelecionadas[0];
          return reply(`‚öîÔ∏è *DUELO DE QUIZ INICIADO!*\n\n@${challenge.challenger.split('@')[0]} vs @${challenge.challenged.split('@')[0]}\n\nüìä ${challenge.numPerguntas} perguntas\n\nüéØ *Pergunta 1/${challenge.numPerguntas}*\nüìÇ Categoria: ${primeiraPergunta.categoria}\n\n‚ùì ${primeiraPergunta.pergunta.p}\n\nüí° √â a vez de @${challenge.challenger.split('@')[0]} responder!\nUse: ${prefix}dueloquiz [resposta]`, { mentions: [challenge.challenger, challenge.challenged] });
        }

        // Processar resposta
        if (global.dueloQuizGames[gameKey] && args.length > 0 && args[0].toLowerCase() !== 'aceitar') {
          const game = global.dueloQuizGames[gameKey];
          
          if (game.status !== 'active') {
            return reply('‚ùå Este duelo j√° terminou!');
          }

          // Verificar se √© a vez do jogador
          if (game.turno !== sender) {
            return reply('‚è≥ N√£o √© sua vez! Aguarde o oponente.');
          }

          const perguntaAtual = game.perguntas[game.perguntaAtual];
          const resposta = normalizar(args.join(' ').toLowerCase());
          const acertou = perguntaAtual.pergunta.r.some(r => 
            normalizar(r) === resposta || resposta.includes(normalizar(r))
          );

          // Registrar resposta
          if (sender === game.jogador1) {
            game.respostas1.push({ acertou, tempo: Date.now() - game.iniciado });
          } else {
            game.respostas2.push({ acertou, tempo: Date.now() - game.iniciado });
          }

          // Avan√ßar pergunta
          game.perguntaAtual++;
          
          // Trocar turno
          game.turno = sender === game.jogador1 ? game.jogador2 : game.jogador1;

          // Verificar se terminou
          if (game.perguntaAtual >= game.perguntas.length) {
            game.status = 'finished';
            
            const acertos1 = game.respostas1.filter(r => r.acertou).length;
            const acertos2 = game.respostas2.filter(r => r.acertou).length;
            
            let resultado = `‚öîÔ∏è *DUELO FINALIZADO!*\n\n`;
            resultado += `üìä *Resultado:*\n`;
            resultado += `@${game.jogador1.split('@')[0]}: ${acertos1}/${game.perguntas.length} acertos\n`;
            resultado += `@${game.jogador2.split('@')[0]}: ${acertos2}/${game.perguntas.length} acertos\n\n`;

            if (acertos1 > acertos2) {
              resultado += `üèÜ *VENCEDOR:* @${game.jogador1.split('@')[0]}!`;
            } else if (acertos2 > acertos1) {
              resultado += `üèÜ *VENCEDOR:* @${game.jogador2.split('@')[0]}!`;
            } else {
              resultado += `ü§ù *EMPATE!*`;
            }

            delete global.dueloQuizGames[gameKey];
            return reply(resultado, { mentions: [game.jogador1, game.jogador2] });
          }

          // Mostrar resultado e pr√≥xima pergunta
          const proximaPergunta = game.perguntas[game.perguntaAtual];
          let respostaMsg = acertou ? `‚úÖ *CORRETO!*` : `‚ùå *ERRADO!*\n‚úÖ Resposta: ${perguntaAtual.pergunta.d}`;
          respostaMsg += `\n\nüéØ *Pergunta ${game.perguntaAtual + 1}/${game.perguntas.length}*\n`;
          respostaMsg += `üìÇ Categoria: ${proximaPergunta.categoria}\n\n`;
          respostaMsg += `‚ùì ${proximaPergunta.pergunta.p}\n\n`;
          respostaMsg += `üí° √â a vez de @${game.turno.split('@')[0]} responder!\n`;
          respostaMsg += `Use: ${prefix}dueloquiz [resposta]`;

          return reply(respostaMsg, { mentions: [game.jogador1, game.jogador2] });
        }

        // Ver status do duelo
        if (global.dueloQuizGames[gameKey]) {
          const game = global.dueloQuizGames[gameKey];
          const perguntaAtual = game.perguntas[game.perguntaAtual];
          
          let status = `‚öîÔ∏è *DUELO DE QUIZ*\n\n`;
          status += `@${game.jogador1.split('@')[0]} vs @${game.jogador2.split('@')[0]}\n\n`;
          status += `üéØ *Pergunta ${game.perguntaAtual + 1}/${game.perguntas.length}*\n`;
          status += `üìÇ Categoria: ${perguntaAtual.categoria}\n\n`;
          status += `‚ùì ${perguntaAtual.pergunta.p}\n\n`;
          status += `‚è≠Ô∏è Turno: @${game.turno.split('@')[0]}\n`;
          status += `üí° Use: ${prefix}dueloquiz [resposta]`;

          return reply(status, { mentions: [game.jogador1, game.jogador2] });
        }

        // Mostrar ajuda
        return reply(`‚öîÔ∏è *DUELO DE QUIZ*\n\nüí° *Como jogar:*\n\n1Ô∏è‚É£ Desafie algu√©m:\n${prefix}dueloquiz @usuario [n√∫mero]\n\n2Ô∏è‚É£ O desafiado aceita:\n${prefix}dueloquiz aceitar\n\n3Ô∏è‚É£ Respondam as perguntas alternadamente!\n\nüèÜ Quem acertar mais perguntas vence!\n\nüìå Exemplo: ${prefix}dueloquiz @usuario 10`);
      }

      // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
      // üîç CA√áA PALAVRAS - Encontre palavras escondidas
      // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
      case 'cacapalavras':
      case 'cacapalavra':
      case 'caca': {
        // Carregar configura√ß√£o e palavras do JSON
        const cacaPath = pathz.join(__dirname, 'funcs', 'json', 'cacapalavras.json');
        let configCaca = {
          tamanho: 15,
          dificuldades: {
            facil: { palavras: 5, tamanhoMin: 4, tamanhoMax: 6 },
            medio: { palavras: 7, tamanhoMin: 5, tamanhoMax: 8 },
            dificil: { palavras: 10, tamanhoMin: 6, tamanhoMax: 10 }
          }
        };
        let palavrasCaca = ['amor', 'fogo', 'gato', 'hora', 'jogo', 'rosa', 'vida', '√°gua', 'amigo', 'barco'];
        
        try {
          const cacaData = JSON.parse(fs.readFileSync(cacaPath, 'utf-8'));
          configCaca = { ...configCaca, ...cacaData.config };
          palavrasCaca = cacaData.palavras || palavrasCaca;
        } catch (e) {
          console.error('Erro ao carregar cacapalavras.json:', e);
        }

        // Estado dos jogos
        if (!global.cacaPalavrasGames) global.cacaPalavrasGames = {};
        const gameKey = isGroup ? from : sender;

        // Fun√ß√£o para gerar grade de ca√ßa palavras
        const gerarGrade = (palavras, tamanho) => {
          const grade = Array(tamanho).fill(null).map(() => Array(tamanho).fill(''));
          const letras = 'ABCDEFGHIJKLMNOPQRSTUVWXYZ';
          
          // Posicionar palavras
          const palavrasPosicionadas = [];
          
          for (const palavra of palavras) {
            let posicionado = false;
            let tentativas = 0;
            
            while (!posicionado && tentativas < 50) {
              tentativas++;
              const direcao = Math.floor(Math.random() * 8); // 0-7: horizontal, vertical, diagonais
              const linha = Math.floor(Math.random() * tamanho);
              const coluna = Math.floor(Math.random() * tamanho);
              
              // Verificar se cabe
              let cabe = true;
              const posicoes = [];
              
              for (let i = 0; i < palavra.length; i++) {
                let l, c;
                switch (direcao) {
                  case 0: l = linha; c = coluna + i; break; // Horizontal ‚Üí
                  case 1: l = linha; c = coluna - i; break; // Horizontal ‚Üê
                  case 2: l = linha + i; c = coluna; break; // Vertical ‚Üì
                  case 3: l = linha - i; c = coluna; break; // Vertical ‚Üë
                  case 4: l = linha + i; c = coluna + i; break; // Diagonal ‚Üò
                  case 5: l = linha + i; c = coluna - i; break; // Diagonal ‚Üô
                  case 6: l = linha - i; c = coluna + i; break; // Diagonal ‚Üó
                  case 7: l = linha - i; c = coluna - i; break; // Diagonal ‚Üñ
                }
                
                if (l < 0 || l >= tamanho || c < 0 || c >= tamanho || 
                    (grade[l][c] !== '' && grade[l][c] !== palavra[i].toUpperCase())) {
                  cabe = false;
                  break;
                }
                posicoes.push({ linha: l, coluna: c, letra: palavra[i].toUpperCase() });
              }
              
              if (cabe) {
                posicoes.forEach(pos => {
                  grade[pos.linha][pos.coluna] = pos.letra;
                });
                palavrasPosicionadas.push({
                  palavra: palavra.toUpperCase(),
                  posicoes: posicoes
                });
                posicionado = true;
              }
            }
          }
          
          // Preencher espa√ßos vazios com letras aleat√≥rias
          for (let i = 0; i < tamanho; i++) {
            for (let j = 0; j < tamanho; j++) {
              if (grade[i][j] === '') {
                grade[i][j] = letras[Math.floor(Math.random() * letras.length)];
              }
            }
          }
          
          return { grade, palavrasPosicionadas };
        };

        // Fun√ß√£o para formatar grade
        const formatarGrade = (grade) => {
          let resultado = '   ';
          for (let i = 0; i < grade.length; i++) {
            resultado += String.fromCharCode(65 + i) + ' ';
          }
          resultado += '\n';
          
          for (let i = 0; i < grade.length; i++) {
            resultado += `${(i + 1).toString().padStart(2)} `;
            for (let j = 0; j < grade[i].length; j++) {
              resultado += grade[i][j] + ' ';
            }
            resultado += '\n';
          }
          return resultado;
        };

        // Verificar resposta
        if (global.cacaPalavrasGames[gameKey] && args.length > 0) {
          const game = global.cacaPalavrasGames[gameKey];
          const palavraChutada = normalizar(args.join(' ').toUpperCase());
          
          // Verificar se a palavra est√° na lista
          const palavraEncontrada = game.palavras.find(p => 
            normalizar(p) === palavraChutada
          );
          
          if (!palavraEncontrada) {
            return reply(`‚ùå "${args.join(' ')}" n√£o est√° na lista de palavras!\n\nüìã Palavras encontradas: ${game.palavrasEncontradas.length}/${game.palavras.length}\nüí° Tente novamente: ${prefix}cacapalavras [palavra]`);
          }
          
          // Verificar se j√° encontrou
          if (game.palavrasEncontradas.includes(palavraEncontrada)) {
            return reply(`‚ö†Ô∏è Voc√™ j√° encontrou a palavra "${palavraEncontrada}"!\n\nüìã Palavras encontradas: ${game.palavrasEncontradas.length}/${game.palavras.length}`);
          }
          
          // Adicionar √† lista de encontradas
          game.palavrasEncontradas.push(palavraEncontrada);
          
          // Verificar vit√≥ria
          if (game.palavrasEncontradas.length === game.palavras.length) {
            const tempoDecorrido = ((Date.now() - game.iniciado) / 1000).toFixed(1);
            delete global.cacaPalavrasGames[gameKey];
            return reply(`üéâ *PARAB√âNS!*\n\n‚úÖ Voc√™ encontrou todas as palavras!\n\nüìã Palavras: ${game.palavras.join(', ')}\n‚è±Ô∏è Tempo: ${tempoDecorrido}s\nüèÜ Excelente trabalho!`);
          }
          
          return reply(`‚úÖ *PALAVRA ENCONTRADA!*\n\nüìù "${palavraEncontrada}"\n\nüìã Progresso: ${game.palavrasEncontradas.length}/${game.palavras.length}\nüí° Continue procurando: ${prefix}cacapalavras [palavra]`);
        }

        // Verificar se h√° jogo ativo
        if (global.cacaPalavrasGames[gameKey]) {
          const game = global.cacaPalavrasGames[gameKey];
          const restantes = game.palavras.length - game.palavrasEncontradas.length;
          let status = `üîç *CA√áA PALAVRAS*\n\n`;
          status += `üìä Progresso: ${game.palavrasEncontradas.length}/${game.palavras.length}\n`;
          status += `üîé Faltam ${restantes} palavra${restantes !== 1 ? 's' : ''} para encontrar!\n\n`;
          status += `üìã *Palavras encontradas:*\n`;
          if (game.palavrasEncontradas.length > 0) {
            status += game.palavrasEncontradas.join(', ') + '\n\n';
          } else {
            status += 'Nenhuma ainda\n\n';
          }
          status += `\`\`\`${formatarGrade(game.grade)}\`\`\`\n\n`;
          status += `üí° Use: ${prefix}cacapalavras [palavra]`;
          return reply(status);
        }

        // Escolher dificuldade
        const dificuldade = args[0]?.toLowerCase() || 'medio';
        const configDificuldade = configCaca.dificuldades[dificuldade] || configCaca.dificuldades.medio;
        
        // Filtrar palavras por tamanho
        const palavrasFiltradas = palavrasCaca.filter(p => 
          p.length >= configDificuldade.tamanhoMin && 
          p.length <= configDificuldade.tamanhoMax
        );
        
        if (palavrasFiltradas.length < configDificuldade.palavras) {
          return reply(`‚ùå N√£o h√° palavras suficientes para a dificuldade "${dificuldade}"!`);
        }
        
        // Selecionar palavras aleat√≥rias
        const palavrasSelecionadas = [];
        const palavrasDisponiveis = [...palavrasFiltradas];
        for (let i = 0; i < configDificuldade.palavras; i++) {
          const idx = Math.floor(Math.random() * palavrasDisponiveis.length);
          palavrasSelecionadas.push(palavrasDisponiveis.splice(idx, 1)[0]);
        }

        // Gerar grade
        const { grade, palavrasPosicionadas } = gerarGrade(palavrasSelecionadas, configCaca.tamanho);
        
        global.cacaPalavrasGames[gameKey] = {
          grade: grade,
          palavras: palavrasSelecionadas.map(p => p.toUpperCase()),
          palavrasEncontradas: [],
          dificuldade: dificuldade,
          iniciado: Date.now()
        };

        let msg = `üîç *CA√áA PALAVRAS - Novo Jogo!*\n\n`;
        msg += `üìä Dificuldade: ${dificuldade.toUpperCase()}\n`;
        msg += `üìã Encontre ${palavrasSelecionadas.length} palavras escondidas na grade!\n\n`;
        msg += `\`\`\`${formatarGrade(grade)}\`\`\`\n\n`;
        msg += `üîé Procure palavras na horizontal, vertical ou diagonal!\n`;
        msg += `üí° Use: ${prefix}cacapalavras [palavra]\n`;
        msg += `üìå Dica: As palavras t√™m de ${configDificuldade.tamanhoMin} a ${configDificuldade.tamanhoMax} letras`;

        await reply(msg);
        break;
      }

      // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
      // üîí VERIFICADOR DE URL - FishFish API
      // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
      case 'verificarurl':
      case 'checkurl':
      case 'urlsafe':
      case 'linkseguro': {
        if (!q) {
          return reply(`üîí *Verificador de Links*\n\nüí° *Como usar:*\n‚Ä¢ ${prefix}verificarurl <link>\n\n‚ú® Verifica se um link √© seguro ou malicioso usando a API FishFish.\n\nüìå *Exemplo:*\n${prefix}verificarurl exemplo.com`);
        }

        // Limpar a URL
        let urlToCheck = q.trim().toLowerCase();
        urlToCheck = urlToCheck.replace(/^https?:\/\//, '').replace(/\/$/, '');
        
        // Extrair dom√≠nio
        const domainMatch = urlToCheck.match(/^([^\/]+)/);
        const domain = domainMatch ? domainMatch[1] : urlToCheck;

        await reply('üîç Verificando seguran√ßa do link... Aguarde!');

        try {
          // Verificar dom√≠nio na API FishFish
          const response = await axios.get(`https://api.fishfish.gg/v1/domains/${encodeURIComponent(domain)}`, {
            timeout: 120000,
            validateStatus: (status) => status < 500
          });

          if (response.status === 404) {
            // Dom√≠nio n√£o encontrado na base de dados maliciosos = provavelmente seguro
            await reply(`‚úÖ *Link Verificado*\n\nüîó *Dom√≠nio:* ${domain}\n\nüü¢ *Status:* N√£o encontrado em listas de amea√ßas\n\n‚ö†Ô∏è *Nota:* Isso n√£o garante 100% de seguran√ßa, apenas que o link n√£o est√° em bases de dados conhecidas de malware/phishing.`);
          } else if (response.data) {
            const data = response.data;
            const categoria = data.category || 'unknown';
            
            let emoji = 'üî¥';
            let status = 'PERIGOSO';
            let descricao = 'Este link foi identificado como malicioso!';
            
            if (categoria === 'safe') {
              emoji = 'üü¢';
              status = 'SEGURO';
              descricao = 'Este link √© considerado seguro.';
            } else if (categoria === 'phishing') {
              emoji = 'üî¥';
              status = 'PHISHING';
              descricao = '‚ö†Ô∏è Este link √© usado para roubar dados pessoais!';
            } else if (categoria === 'malware') {
              emoji = 'üî¥';
              status = 'MALWARE';
              descricao = '‚ö†Ô∏è Este link pode infectar seu dispositivo!';
            }

            await reply(`üîí *Resultado da Verifica√ß√£o*\n\nüîó *Dom√≠nio:* ${domain}\n\n${emoji} *Status:* ${status}\nüìã *Categoria:* ${categoria}\n\n${descricao}${data.description ? `\n\nüìù *Detalhes:* ${data.description}` : ''}`);
          }
        } catch (e) {
          console.error('Erro ao verificar URL:', e);
          await reply(`‚ö†Ô∏è N√£o foi poss√≠vel verificar o link no momento.\n\nTente novamente mais tarde ou verifique manualmente em: https://www.virustotal.com`);
        }
        break;
      }

      // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
      // üå§Ô∏è CLIMA - Previs√£o do Tempo
      // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
      case 'clima':
      case 'tempo':
      case 'weather':
      case 'previsao': {
        if (!q) {
          return reply(`üå§Ô∏è *Previs√£o do Tempo*\n\nüí° *Como usar:*\n‚Ä¢ ${prefix}clima <cidade>\n\nüìå *Exemplos:*\n‚Ä¢ ${prefix}clima S√£o Paulo\n‚Ä¢ ${prefix}clima Rio de Janeiro\n‚Ä¢ ${prefix}clima Tokyo`);
        }

        await reply('üå§Ô∏è Consultando previs√£o do tempo... ‚è≥');

        try {
          // Usar wttr.in que √© gratuito e n√£o precisa de API key
          const cidade = encodeURIComponent(q);
          const response = await axios.get(`https://wttr.in/${cidade}?format=j1&lang=pt`, {
            timeout: 120000,
            headers: { 'User-Agent': 'curl/7.68.0' }
          });

          const data = response.data;
          const current = data.current_condition[0];
          const location = data.nearest_area[0];
          
          const tempC = current.temp_C;
          const feelsLike = current.FeelsLikeC;
          const humidity = current.humidity;
          const windKmph = current.windspeedKmph;
          const windDir = current.winddir16Point;
          const uvIndex = current.uvIndex;
          const visibility = current.visibility;
          const cloudcover = current.cloudcover;
          const descPt = current.lang_pt?.[0]?.value || current.weatherDesc[0].value;
          
          const cityName = location.areaName[0].value;
          const region = location.region[0].value;
          const country = location.country[0].value;

          // Emoji baseado na condi√ß√£o
          let weatherEmoji = '‚òÄÔ∏è';
          const desc = descPt.toLowerCase();
          if (desc.includes('chuva') || desc.includes('rain')) weatherEmoji = 'üåßÔ∏è';
          else if (desc.includes('nublado') || desc.includes('cloud')) weatherEmoji = '‚òÅÔ∏è';
          else if (desc.includes('neve') || desc.includes('snow')) weatherEmoji = '‚ùÑÔ∏è';
          else if (desc.includes('trovoada') || desc.includes('thunder')) weatherEmoji = '‚õàÔ∏è';
          else if (desc.includes('nevoeiro') || desc.includes('fog')) weatherEmoji = 'üå´Ô∏è';
          else if (desc.includes('parcialmente')) weatherEmoji = '‚õÖ';
          else if (desc.includes('sol') || desc.includes('clear')) weatherEmoji = '‚òÄÔ∏è';

          // Previs√£o dos pr√≥ximos dias
          let forecast = '';
          if (data.weather && data.weather.length > 0) {
            forecast = '\n\nüìÖ *Pr√≥ximos dias:*\n';
            data.weather.slice(0, 3).forEach((day, i) => {
              const date = day.date.split('-').reverse().join('/');
              const maxC = day.maxtempC;
              const minC = day.mintempC;
              forecast += `‚Ä¢ ${date}: ${minC}¬∞C - ${maxC}¬∞C\n`;
            });
          }

          await reply(`${weatherEmoji} *Clima em ${cityName}*\nüìç ${region}, ${country}\n\nüå°Ô∏è *Temperatura:* ${tempC}¬∞C\nü§í *Sensa√ß√£o:* ${feelsLike}¬∞C\nüíß *Umidade:* ${humidity}%\nüí® *Vento:* ${windKmph} km/h (${windDir})\n‚òÄÔ∏è *√çndice UV:* ${uvIndex}\nüëÅÔ∏è *Visibilidade:* ${visibility} km\n‚òÅÔ∏è *Nuvens:* ${cloudcover}%\n\nüìã *Condi√ß√£o:* ${descPt}${forecast}`);
        } catch (e) {
          console.error('Erro ao buscar clima:', e);
          await reply('‚ùå N√£o consegui encontrar informa√ß√µes do clima para essa cidade. Verifique o nome e tente novamente!');
        }
        break;
      }

      // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
      // üïê CONVERSOR DE FUSO HOR√ÅRIO
      // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
      case 'hora':
      case 'fuso':
      case 'horario':
      case 'timezone': {
        const fusos = {
          'brasil': 'America/Sao_Paulo',
          'br': 'America/Sao_Paulo',
          'saopaulo': 'America/Sao_Paulo',
          'sp': 'America/Sao_Paulo',
          'rio': 'America/Sao_Paulo',
          'brasilia': 'America/Sao_Paulo',
          'manaus': 'America/Manaus',
          'am': 'America/Manaus',
          'acre': 'America/Rio_Branco',
          'fernando': 'America/Noronha',
          'eua': 'America/New_York',
          'usa': 'America/New_York',
          'newyork': 'America/New_York',
          'ny': 'America/New_York',
          'losangeles': 'America/Los_Angeles',
          'la': 'America/Los_Angeles',
          'california': 'America/Los_Angeles',
          'japao': 'Asia/Tokyo',
          'japan': 'Asia/Tokyo',
          'tokyo': 'Asia/Tokyo',
          'china': 'Asia/Shanghai',
          'pequim': 'Asia/Shanghai',
          'coreia': 'Asia/Seoul',
          'korea': 'Asia/Seoul',
          'seul': 'Asia/Seoul',
          'londres': 'Europe/London',
          'london': 'Europe/London',
          'uk': 'Europe/London',
          'paris': 'Europe/Paris',
          'franca': 'Europe/Paris',
          'berlin': 'Europe/Berlin',
          'alemanha': 'Europe/Berlin',
          'portugal': 'Europe/Lisbon',
          'lisboa': 'Europe/Lisbon',
          'moscow': 'Europe/Moscow',
          'russia': 'Europe/Moscow',
          'dubai': 'Asia/Dubai',
          'india': 'Asia/Kolkata',
          'australia': 'Australia/Sydney',
          'sydney': 'Australia/Sydney',
          'argentina': 'America/Argentina/Buenos_Aires',
          'buenosaires': 'America/Argentina/Buenos_Aires'
        };

        if (!q) {
          const agora = new Date();
          const horaBrasil = agora.toLocaleString('pt-BR', { timeZone: 'America/Sao_Paulo', hour: '2-digit', minute: '2-digit', second: '2-digit' });
          const dataBrasil = agora.toLocaleDateString('pt-BR', { timeZone: 'America/Sao_Paulo', weekday: 'long', day: '2-digit', month: 'long', year: 'numeric' });
          
          return reply(`üïê *Hor√°rio Atual*\n\nüáßüá∑ *Brasil (Bras√≠lia):*\n‚è∞ ${horaBrasil}\nüìÖ ${dataBrasil}\n\nüí° *Ver outro fuso:*\n${prefix}hora <local>\n\nüìç *Locais dispon√≠veis:*\nbrasil, eua, japao, china, coreia, londres, paris, portugal, dubai, australia, argentina...`);
        }

        const local = normalizar(q.toLowerCase().replace(/\s+/g, ''));
        const timezone = fusos[local];

        if (!timezone) {
          return reply(`‚ùå Fuso hor√°rio "${q}" n√£o encontrado!\n\nüìç *Locais dispon√≠veis:*\nbrasil, eua, newyork, losangeles, japao, china, coreia, londres, paris, alemanha, portugal, russia, dubai, india, australia, argentina`);
        }

        try {
          const agora = new Date();
          const hora = agora.toLocaleString('pt-BR', { timeZone: timezone, hour: '2-digit', minute: '2-digit', second: '2-digit' });
          const data = agora.toLocaleDateString('pt-BR', { timeZone: timezone, weekday: 'long', day: '2-digit', month: 'long', year: 'numeric' });
          
          // Calcular diferen√ßa com Brasil
          const brTime = new Date(agora.toLocaleString('en-US', { timeZone: 'America/Sao_Paulo' }));
          const localTime = new Date(agora.toLocaleString('en-US', { timeZone: timezone }));
          const diffHours = Math.round((localTime - brTime) / (1000 * 60 * 60));
          const diffStr = diffHours >= 0 ? `+${diffHours}h` : `${diffHours}h`;

          await reply(`üïê *Hor√°rio em ${q}*\n\n‚è∞ *Hora:* ${hora}\nüìÖ *Data:* ${data}\n\nüáßüá∑ *Diferen√ßa do Brasil:* ${diffStr}`);
        } catch (e) {
          console.error('Erro ao converter fuso:', e);
          await reply('‚ùå Erro ao obter o hor√°rio. Tente novamente!');
        }
        break;
      }

      // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
      // üéÇ SISTEMA DE ANIVERS√ÅRIOS
      // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
      case 'aniversario':
      case 'niver':
      case 'birthday': {
        if (!isGroup) {
          return reply('‚ö†Ô∏è Este comando s√≥ funciona em grupos!');
        }

        // Carregar dados de anivers√°rios do grupo
        const aniversariosPath = pathz.join(GRUPOS_DIR, `${from}_aniversarios.json`);
        let aniversarios = {};
        try {
          if (fs.existsSync(aniversariosPath)) {
            aniversarios = JSON.parse(fs.readFileSync(aniversariosPath, 'utf-8'));
          }
        } catch (e) {
          aniversarios = {};
        }

        const subCmd = args[0]?.toLowerCase();

        // Definir anivers√°rio
        if (subCmd === 'definir' || subCmd === 'set') {
          const data = args[1];
          if (!data || !/^\d{1,2}\/\d{1,2}$/.test(data)) {
            return reply(`üéÇ *Definir Anivers√°rio*\n\nüí° Use: ${prefix}aniversario definir DD/MM\n\nüìå Exemplo: ${prefix}aniversario definir 25/12`);
          }
          
          const [dia, mes] = data.split('/').map(Number);
          if (dia < 1 || dia > 31 || mes < 1 || mes > 12) {
            return reply('‚ùå Data inv√°lida! Use o formato DD/MM');
          }

          aniversarios[sender] = { dia, mes, nome: pushname };
          fs.writeFileSync(aniversariosPath, JSON.stringify(aniversarios, null, 2));
          
          return reply(`üéÇ Anivers√°rio definido!\n\nüìÖ *Data:* ${dia.toString().padStart(2, '0')}/${mes.toString().padStart(2, '0')}\nüë§ *Nome:* ${pushname}`);
        }

        // Listar aniversariantes do m√™s
        if (subCmd === 'mes' || subCmd === 'month') {
          const mesAtual = new Date().getMonth() + 1;
          const aniversariantes = Object.entries(aniversarios)
            .filter(([_, data]) => data.mes === mesAtual)
            .sort((a, b) => a[1].dia - b[1].dia);
          
          if (aniversariantes.length === 0) {
            return reply('üìÖ Nenhum aniversariante registrado para este m√™s!');
          }

          let lista = `üéÇ *Aniversariantes de ${new Date().toLocaleDateString('pt-BR', { month: 'long' })}*\n\n`;
          aniversariantes.forEach(([id, data]) => {
            lista += `‚Ä¢ ${data.dia.toString().padStart(2, '0')}/${data.mes.toString().padStart(2, '0')} - ${data.nome}\n`;
          });

          return reply(lista);
        }

        // Listar pr√≥ximos anivers√°rios
        if (subCmd === 'proximos' || subCmd === 'next' || !subCmd) {
          const hoje = new Date();
          const diaAtual = hoje.getDate();
          const mesAtual = hoje.getMonth() + 1;

          const aniversariantes = Object.entries(aniversarios)
            .map(([id, data]) => {
              let diasAte = 0;
              if (data.mes > mesAtual || (data.mes === mesAtual && data.dia >= diaAtual)) {
                diasAte = (data.mes - mesAtual) * 30 + (data.dia - diaAtual);
              } else {
                diasAte = (12 - mesAtual + data.mes) * 30 + (data.dia - diaAtual);
              }
              return { ...data, id, diasAte };
            })
            .sort((a, b) => a.diasAte - b.diasAte)
            .slice(0, 10);

          if (aniversariantes.length === 0) {
            return reply(`üéÇ *Sistema de Anivers√°rios*\n\nNenhum anivers√°rio registrado!\n\nüí° *Comandos:*\n‚Ä¢ ${prefix}aniversario definir DD/MM\n‚Ä¢ ${prefix}aniversario mes\n‚Ä¢ ${prefix}aniversario proximos`);
          }

          let lista = 'üéÇ *Pr√≥ximos Anivers√°rios*\n\n';
          aniversariantes.forEach((data, i) => {
            const emoji = data.diasAte === 0 ? 'üéâ' : data.diasAte <= 7 ? 'üîî' : 'üìÖ';
            const status = data.diasAte === 0 ? '(HOJE!)' : `(em ${data.diasAte} dias)`;
            lista += `${emoji} ${data.dia.toString().padStart(2, '0')}/${data.mes.toString().padStart(2, '0')} - ${data.nome} ${status}\n`;
          });

          lista += `\nüí° *Comandos:*\n‚Ä¢ ${prefix}aniversario definir DD/MM\n‚Ä¢ ${prefix}aniversario mes`;

          return reply(lista);
        }

        return reply(`üéÇ *Sistema de Anivers√°rios*\n\nüí° *Comandos:*\n‚Ä¢ ${prefix}aniversario - Ver pr√≥ximos\n‚Ä¢ ${prefix}aniversario definir DD/MM\n‚Ä¢ ${prefix}aniversario mes\n‚Ä¢ ${prefix}aniversario proximos`);
      }

      // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
      // üìä ESTAT√çSTICAS DO GRUPO
      // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
      case 'groupstats':
      case 'estatisticas':
      case 'statsgrupo': {
        if (!isGroup) {
          return reply('‚ö†Ô∏è Este comando s√≥ funciona em grupos!');
        }

        await reply('üìä Calculando estat√≠sticas do grupo... ‚è≥');

        try {
          const groupMeta = await getCachedGroupMetadata(from);
          const participants = groupMeta.participants || [];
          const admins = participants.filter(p => p.admin).length;
          const members = participants.length;

          // Buscar dados do grupo
          const groupCreation = groupMeta.creation ? new Date(groupMeta.creation * 1000).toLocaleDateString('pt-BR') : 'Desconhecido';
          const groupName = groupMeta.subject || 'Grupo';
          const groupDesc = groupMeta.desc || 'Sem descri√ß√£o';

          // Estat√≠sticas de atividade do grupo (se dispon√≠vel)
          let activityStats = '';
          if (groupData.activity) {
            const totalMsgs = groupData.activity.totalMessages || 0;
            const today = new Date().toISOString().split('T')[0];
            const todayMsgs = groupData.activity.daily?.[today] || 0;
            activityStats = `\n\nüìà *Atividade:*\n‚Ä¢ Total de mensagens: ${totalMsgs.toLocaleString()}\n‚Ä¢ Mensagens hoje: ${todayMsgs}`;
          }

          // Recursos ativos
          let recursos = [];
          if (groupData.modorpg) recursos.push('‚öîÔ∏è Modo RPG');
          if (groupData.welcome) recursos.push('üëã Boas-vindas');
          if (groupData.antifake) recursos.push('üõ°Ô∏è Anti-fake');
          if (groupData.antilink) recursos.push('üîó Anti-link');
          if (groupData.antilinksoft) recursos.push('üîó Anti-link Soft');
          if (groupData.antiflood) recursos.push('üåä Anti-flood');
          
          const recursosStr = recursos.length > 0 ? `\n\n‚ú® *Recursos ativos:*\n${recursos.join('\n')}` : '';

          await reply(`üìä *Estat√≠sticas do Grupo*\n\nüìõ *Nome:* ${groupName}\nüìÖ *Criado em:* ${groupCreation}\n\nüë• *Membros:* ${members}\nüëë *Admins:* ${admins}\nüë§ *Membros comuns:* ${members - admins}${activityStats}${recursosStr}\n\nüìù *Descri√ß√£o:*\n${groupDesc.substring(0, 200)}${groupDesc.length > 200 ? '...' : ''}`);
        } catch (e) {
          console.error('Erro ao buscar estat√≠sticas:', e);
          await reply('‚ùå Erro ao obter estat√≠sticas do grupo.');
        }
        break;
      }

      case 'cog':
        if (!q) return reply(`üì¢ Ei, falta a pergunta! Me diga o que quer saber ap√≥s o comando ${prefix}cog! üò¥`);
        
        reply('‚è≥ Um momentinho, estou pensando na melhor resposta... üåü').then(() => {
          ia.makeCognimaRequest('cognima/CognimAI', q, null).then((response) => {
            reply(formatAIResponse(response.data.choices[0].message.content));
          }).catch((e) => {
            console.error('Erro na API CognimAI:', e);
            reply('üòì Vixe, algo deu errado por aqui! Tente novamente em breve, combinado? üåà');
          });
        });
        break;
      case 'tradutor':
      case 'translator':
        if (!q) return reply(`üåç Quer traduzir algo? Me diga o idioma e o texto assim: ${prefix}${command} idioma | texto
Exemplo: ${prefix}tradutor ingl√™s | Bom dia! üòä`);
        
        {
          const partes = q.split('|');
          if (partes.length < 2) {
            return reply(`Formato incorreto! üòÖ Use: ${prefix}tradutor idioma | texto
Exemplo: ${prefix}tradutor espanhol | Ol√° mundo! ‚ú®`);
          }
          const idioma = partes[0].trim();
          const texto = partes.slice(1).join('|').trim();
          reply('Aguarde um momentinho... ‚òÄÔ∏è').then(() => {
            const prompt = `Traduza o seguinte texto para ${idioma}:\n\n${texto}\n\nForne√ßa apenas a tradu√ß√£o, sem explica√ß√µes adicionais.`;
            ia.makeCognimaRequest('qwen/qwen3-235b-a22b', prompt, null).then((bahz) => {
              reply(`üåê‚ú® *Prontinho! Sua tradu√ß√£o para ${idioma.toUpperCase()} est√° aqui:*\n\n${formatAIResponse(bahz.data.choices[0].message.content)}`);
            }).catch((e) => {
              console.error("Erro ao traduzir texto:", e);
              reply("‚ùå N√£o foi poss√≠vel realizar a tradu√ß√£o no momento. Tente novamente mais tarde.");
            });
          });
        }
        break;
      case 'qrcode':
        if (!q) return reply(`üì≤ *Gerador de QR Code*\n\nüí° *Como usar:*\n‚Ä¢ Envie o texto ou link ap√≥s o comando\n‚Ä¢ Ex: ${prefix}qrcode https://exemplo.com\n‚Ä¢ Ex: ${prefix}qrcode Seu texto aqui\n\n‚ú® O QR Code ser√° gerado instantaneamente!`);
        reply('Aguarde um momentinho... ‚òÄÔ∏è').then(() => {
          const qrUrl = `https://api.qrserver.com/v1/create-qr-code/?size=500x500&data=${encodeURIComponent(q)}`;
          return nazu.sendMessage(from, {
            image: { url: qrUrl },
            caption: `üì±‚ú® *Seu QR Code super fofo est√° pronto!*\n\nConte√∫do: ${q.substring(0, 100)}${q.length > 100 ? '...' : ''}`
          }, { quoted: info });
        }).catch((e) => {
          console.error("Erro ao gerar QR Code:", e);
          reply("‚ùå Erro ao gerar QR Code. Tente novamente mais tarde.");
        });
        break;
      case 'wikipedia':
        if (!q) return reply(`üìö O que voc√™ quer pesquisar na Wikip√©dia? Me diga o termo ap√≥s o comando ${prefix}wikipedia! üòä`);
        reply("üìö Consultando a Wikip√©dia... S√≥ um instante! ‚è≥");
        try {
          let found = false;
          try {
            const respPT = await axios.get(`https://pt.wikipedia.org/api/rest_v1/page/summary/${encodeURIComponent(q)}`);
            if (respPT.data && respPT.data.extract) {
              const {
                title,
                extract,
                content_urls,
                thumbnail
              } = respPT.data;
              const link = content_urls?.desktop?.page || '';
              const thumbUrl = thumbnail?.source || '';
              let mensagem = `üìñ‚ú® *Encontrei isso na Wikip√©dia (PT):*\n\n*${title || q}*\n\n${extract}\n\n`;
              if (link) {
                
                mensagem += `üîó *Saiba mais:* ${link}\n`;
              }
              if (thumbUrl) {
                await nazu.sendMessage(from, {
                  image: {
                    url: thumbUrl
                  },
                  caption: mensagem
                }, {
                  quoted: info
                });
              } else {
                await reply(mensagem);
              }
              
              found = true;
            }
          } catch (err) {
            console.log("Busca PT falhou, tentando EN...");
          }
          if (!found) {
            try {
              const respEN = await axios.get(`https://en.wikipedia.org/api/rest_v1/page/summary/${encodeURIComponent(q)}`);
              if (respEN.data && respEN.data.extract) {
                const {
                  title,
                  extract,
                  content_urls,
                  thumbnail
                } = respEN.data;
                const link = content_urls?.desktop?.page || '';
                const thumbUrl = thumbnail?.source || '';
                let mensagem = `üìñ‚ú® *Encontrei isso na Wikip√©dia (EN):*\n\n*${title || q}*\n\n${extract}\n\n`;
                if (link) {
                  
                  mensagem += `üîó *Saiba mais:* ${link}\n`;
                }
                if (thumbUrl) {
                  await nazu.sendMessage(from, {
                    image: {
                      url: thumbUrl
                    },
                    caption: mensagem
                  }, {
                    quoted: info
                  });
                } else {
                  await reply(mensagem);
                }
                
                found = true;
              }
            } catch (err) {
              console.log("Busca EN tamb√©m falhou.");
            }
          }
          if (!found) {
            await reply("Awnn... ü•∫ N√£o consegui encontrar nada sobre isso na Wikip√©dia... Tente uma palavra diferente, talvez? üíî");
          }
        } catch (e) {
          console.error("Erro ao buscar na Wikip√©dia:", e);
          await reply("üìö Erro ao acessar a Wikip√©dia no momento. Tente novamente mais tarde.");
        }
        break;
      case 'dicionario':
      case 'dictionary':
        if (!q) return reply(`üìî Qual palavra voc√™ quer procurar no dicion√°rio? Me diga ap√≥s o comando ${prefix}${command}! üòä`);
        
        reply("üìî Procurando no dicion√°rio... Aguarde um pouquinho! ‚è≥").then(() => {
          const palavra = q.trim().toLowerCase();
          axios.get(`https://significado.herokuapp.com/${encodeURIComponent(palavra)}`).then((resp) => {
            if (resp.data && resp.data.length > 0 && resp.data[0].meanings) {
              const significados = resp.data[0];
              let mensagem = `üìò‚ú® *Significado de "${palavra.toUpperCase()}":*\n\n`;
              if (significados.class) {
                mensagem += `*Classe:* ${significados.class}\n\n`;
              }
              if (significados.meanings && significados.meanings.length > 0) {
                mensagem += `*Significados:*\n`;
                significados.meanings.forEach((significado, index) => {
                  mensagem += `${index + 1}. ${significado}\n`;
                });
                mensagem += '\n';
              }
              if (significados.etymology) {
                mensagem += `*Etimologia:* ${significados.etymology}\n\n`;
              }
              reply(mensagem);
            } else {
              throw new Error('Sem resultados');
            }
          }).catch(() => {
            console.log("API prim√°ria do dicion√°rio falhou, tentando IA...");
            const prompt = `Defina a palavra "${palavra}" em portugu√™s de forma completa e fofa. Inclua a classe gramatical, os principais significados e um exemplo de uso em uma frase curta e bonitinha.`;
            ia.makeCognimaRequest('qwen/qwen3-235b-a22b', prompt, null).then((bahz) => {
              reply(formatAIResponse(bahz.data.choices[0].message.content));
            }).catch((e) => {
              console.error("Erro geral ao buscar no dicion√°rio:", e);
              reply("‚ùå Palavra n√£o encontrada. Verifique a ortografia e tente novamente.");
            });
          });
        });
        break;
      case 'updates':
        try {
          if (!isOwner || isOwner && isSubOwner) return reply("üö´ Apenas o Dono principal pode utilizar esse comando!");
          if (!fs.existsSync(pathz.join(__dirname, '..', 'database', 'updateSave.json'))) return reply('‚ùå Sua vers√£o n√£o tem suporte a esse sistema ainda.');
          const AtualCom = await axios.get('https://api.github.com/repos/hiudyy/nazuna/commits?per_page=1', {
            headers: {
              Accept: 'application/vnd.github+json'
            }
          }).then(r => r.headers.link?.match(/page=(\d+)>;\s*rel="last"/)?.[1]);
          const {
            total
          } = JSON.parse(fs.readFileSync(pathz.join(__dirname, '..', 'database', 'updateSave.json'), 'utf-8'));
          if (AtualCom > total) {
            const TextZin = await VerifyUpdate('hiudyy/nazuna', AtualCom - total);
            await reply(TextZin);
          } else {
            await reply('Voc√™ ja esta utilizando a vers√£o mais recente da bot.');
          }
        } catch (e) {
          console.error(e);
        }
        break;
      case 'addsubdono':
        if (!isOwner) return reply("üö´ Apenas o Dono principal pode adicionar subdonos!");
        if (isSubOwner && !isOwner) return reply("üö´ Subdonos n√£o podem adicionar outros subdonos!");
        try {
          let targetUserId;
          
          if (menc_jid2 && menc_jid2.length > 0) {
            // Pegar o LID do usu√°rio mencionado
            targetUserId = menc_jid2[0];
            
            // Tentar obter o LID real do participante
            if (isGroup && groupMetadata?.participants) {
              const participant = groupMetadata.participants.find(p => 
                p.id === targetUserId || p.lid === targetUserId
              );
              if (participant && participant.lid) {
                targetUserId = participant.lid;
              }
            } else {
              // Se n√£o for grupo, usar onWhatsApp para pegar LID
              try {
                const [result] = await nazu.onWhatsApp(targetUserId.replace(/@s\.whatsapp\.net|@lid/g, ''));
                if (result && result.lid) {
                  targetUserId = result.lid;
                } else if (result && result.jid) {
                  targetUserId = result.jid;
                }
              } catch (err) {
                console.log('N√£o foi poss√≠vel obter LID via onWhatsApp:', err.message);
              }
            }
          } else if (q && q.trim()) {
            const cleanNumber = q.replace(/\D/g, '');
            if (cleanNumber.length >= 10) {
              targetUserId = `${cleanNumber}@s.whatsapp.net`;
              
              // Tentar buscar LID
              if (isGroup && groupMetadata?.participants) {
                const participant = groupMetadata.participants.find(p => 
                  p.id === targetUserId
                );
                if (participant && participant.lid) {
                  targetUserId = participant.lid;
                }
              } else {
                // Se n√£o for grupo, usar onWhatsApp para pegar LID
                try {
                  const [result] = await nazu.onWhatsApp(cleanNumber);
                  if (result && result.lid) {
                    targetUserId = result.lid;
                  } else if (result && result.jid) {
                    targetUserId = result.jid;
                  }
                } catch (err) {
                  console.log('N√£o foi poss√≠vel obter LID via onWhatsApp:', err.message);
                }
              }
            } else {
              return reply("‚ùå N√∫mero inv√°lido! Use um n√∫mero completo (ex: 5511999998888)");
            }
          } else {
            return reply(`üìù *Como usar:*\n\n1Ô∏è‚É£ Marque o usu√°rio: ${prefix}addsubdono @usuario\n2Ô∏è‚É£ Ou digite o n√∫mero: ${prefix}addsubdono 5511999998888`);
          }
          
          const result = await addSubdono(targetUserId, numerodono, nazu);
          await reply(result.message);
        } catch (e) {
          console.error("Erro ao adicionar subdono:", e);
          await reply("‚ùå Ocorreu um erro inesperado ao tentar adicionar o subdono.");
        }
        break;
      case 'remsubdono':
      case 'rmsubdono':
      case 'delsubdono':
        if (!isOwner) return reply("üö´ Apenas o Dono principal pode remover subdonos!");
        if (isSubOwner && !isOwner) return reply("üö´ Subdonos n√£o podem remover outros subdonos!");
        try {
          let targetUserId;
          
          if (menc_jid2 && menc_jid2.length > 0) {
            targetUserId = menc_jid2[0];
            
            // Tentar obter o LID real
            if (isGroup && groupMetadata?.participants) {
              const participant = groupMetadata.participants.find(p => 
                p.id === targetUserId || p.lid === targetUserId
              );
              if (participant && participant.lid) {
                targetUserId = participant.lid;
              }
            } else {
              // Se n√£o for grupo, usar onWhatsApp para pegar LID
              try {
                const [result] = await nazu.onWhatsApp(targetUserId.replace(/@s\.whatsapp\.net|@lid/g, ''));
                if (result && result.lid) {
                  targetUserId = result.lid;
                } else if (result && result.jid) {
                  targetUserId = result.jid;
                }
              } catch (err) {
                console.log('N√£o foi poss√≠vel obter LID via onWhatsApp:', err.message);
              }
            }
          } else if (q && q.trim()) {
            const cleanNumber = q.replace(/\D/g, '');
            if (cleanNumber.length >= 10) {
              targetUserId = `${cleanNumber}@s.whatsapp.net`;
              
              // Tentar buscar LID
              if (isGroup && groupMetadata?.participants) {
                const participant = groupMetadata.participants.find(p => 
                  p.id === targetUserId
                );
                if (participant && participant.lid) {
                  targetUserId = participant.lid;
                }
              } else {
                // Se n√£o for grupo, usar onWhatsApp para pegar LID
                try {
                  const [result] = await nazu.onWhatsApp(cleanNumber);
                  if (result && result.lid) {
                    targetUserId = result.lid;
                  } else if (result && result.jid) {
                    targetUserId = result.jid;
                  }
                } catch (err) {
                  console.log('N√£o foi poss√≠vel obter LID via onWhatsApp:', err.message);
                }
              }
            } else {
              const subdonos = getSubdonos();
              const index = parseInt(q) - 1;
              if (index >= 0 && index < subdonos.length) {
                targetUserId = subdonos[index];
              } else {
                return reply("‚ùå N√∫mero/√≠ndice inv√°lido! Use um n√∫mero completo ou o √≠ndice da lista de subdonos.");
              }
            }
          } else {
            return reply(`üìù *Como usar:*\n\n1Ô∏è‚É£ Marque o usu√°rio: ${prefix}remsubdono @usuario\n2Ô∏è‚É£ Digite o n√∫mero: ${prefix}remsubdono 5511999998888\n3Ô∏è‚É£ Use o √≠ndice da lista: ${prefix}remsubdono 1`);
          }
          
          const result = await removeSubdono(targetUserId, nazu);
          await reply(result.message);
        } catch (e) {
          console.error("Erro ao remover subdono:", e);
          await reply("‚ùå Ocorreu um erro inesperado ao tentar remover o subdono.");
        }
        break;
      case 'listasubdonos':
      case 'listsubdonos':
        if (!isOwnerOrSub) return reply("üö´ Apenas o Dono e Subdonos podem ver a lista!");
        try {
          const subdonos = getSubdonos();
          if (subdonos.length === 0) {
            return reply("‚ú® Nenhum subdono cadastrado no momento.");
          }
          let listaMsg = "üëë *Lista de Subdonos Atuais:*\n\n";
          const mentions = [];
          let participantsInfo = {};
          if (isGroup && groupMetadata.participants) {
            groupMetadata.participants.forEach(p => {
              participantsInfo[p.lid || p.id] = p.pushname || getUserName(p.lid || p.id);
            });
          }
          subdonos.forEach((jid, index) => {
            const nameOrNumber = participantsInfo[jid] || getUserName(jid);
            listaMsg += `${index + 1}. @${getUserName(jid)} (${nameOrNumber})\n`;
            mentions.push(jid);
          });
          await reply(listaMsg.trim(), {
            mentions
          });
        } catch (e) {
          console.error("Erro ao listar subdonos:", e);
          await reply("‚ùå Ocorreu um erro inesperado ao tentar listar os subdonos.");
        }
        break;

      case 'addsubbot':
        if (!isOwner) return reply("üö´ Apenas o Dono principal pode adicionar sub-bots!");
        try {
          const subBotManager = await import('./utils/subBotManager.js');
          
          if (!q || !q.trim()) {
            return reply(`üìù *Como usar:*\n\n${prefix}addsubbot <n√∫mero>\n\n*Exemplo:*\n${prefix}addsubbot 5511999999999\n\n‚ö†Ô∏è O n√∫mero deve incluir o c√≥digo do pa√≠s (Brasil: 55)`);
          }
          
          const phoneNumber = q.trim().replace(/\D/g, '');
          
          if (!/^\d{10,15}$/.test(phoneNumber) || !phoneNumber.startsWith('55')) {
            return reply('‚ùå N√∫mero inv√°lido! Use um n√∫mero v√°lido com c√≥digo de pa√≠s.\n\n*Exemplo:* 5511999999999');
          }
          
          await reply('‚è≥ Verificando n√∫mero e registrando sub-bot... Aguarde...');
          
          // Verifica se o n√∫mero existe no WhatsApp e pega o LID
          try {
            const [result] = await nazu.onWhatsApp(phoneNumber);
            
            if (!result || !result.exists) {
              return reply(`‚ùå O n√∫mero ${phoneNumber} n√£o est√° registrado no WhatsApp!`);
            }
            
            const subBotLid = result.lid;

            // Normalize owner to LID if possible before passing to subBotManager
            const ownerCandidate = buildUserId(numerodono, config);
            const ownerLid = await getLidFromJidCached(nazu, ownerCandidate);

            const addResult = await subBotManager.addSubBot(phoneNumber, ownerLid, subBotLid);
            
            await reply(addResult.message);
          } catch (verifyError) {
            console.error("Erro ao verificar n√∫mero:", verifyError);
            return reply(`‚ùå Erro ao verificar o n√∫mero no WhatsApp: ${verifyError.message}`);
          }
          
        } catch (error) {
          console.error("Erro ao adicionar sub-bot:", error);
          await reply(`‚ùå Erro ao criar sub-bot: ${error.message}`);
        }
        break;

      case 'removesubbot':
      case 'delsubbot':
      case 'rmsubbot':
        if (!isOwner) return reply("üö´ Apenas o Dono principal pode remover sub-bots!");
        try {
          const subBotManager = await import('./utils/subBotManager.js');
          
          if (!q || !q.trim()) {
            const listResult = subBotManager.listSubBots();
            if (!listResult.success || listResult.subbots.length === 0) {
              return reply('‚ùå Nenhum sub-bot cadastrado para remover.');
            }
            
            let msg = `üìã *Sub-Bots Dispon√≠veis:*\n\n`;
            listResult.subbots.forEach((bot, index) => {
              msg += `${index + 1}. *ID:* ${bot.id.substring(0, 20)}...\n`;
              msg += `   üì± *N√∫mero:* ${bot.phoneNumber}\n`;
              msg += `   üîå *Status:* ${bot.status}\n\n`;
            });
            msg += `\nüí° *Use:* ${prefix}removesubbot <n√∫mero>\n\n*Exemplo:*\n${prefix}removesubbot 1`;
            
            return reply(msg);
          }
          
          // Tenta remover por √≠ndice primeiro
          const listResult = subBotManager.listSubBots();
          if (listResult.success && listResult.subbots.length > 0) {
            const index = parseInt(q) - 1;
            if (index >= 0 && index < listResult.subbots.length) {
              const botId = listResult.subbots[index].id;
              await reply('‚è≥ Removendo sub-bot... Aguarde...');
              const result = await subBotManager.removeSubBot(botId);
              return reply(result.message);
            }
          }
          
          // Se n√£o for √≠ndice, tenta pelo ID direto
          await reply('‚è≥ Removendo sub-bot... Aguarde...');
          const result = await subBotManager.removeSubBot(q.trim());
          await reply(result.message);
        } catch (error) {
          console.error("Erro ao remover sub-bot:", error);
          await reply(`‚ùå Erro ao remover sub-bot: ${error.message}`);
        }
        break;

      case 'listarsubbots':
      case 'listsubbots':
      case 'subbots':
        if (!isOwner) return reply("üö´ Apenas o Dono principal pode ver os sub-bots!");
        try {
          const subBotManager = await import('./utils/subBotManager.js');
          
          const result = subBotManager.listSubBots();
          
          if (!result.success) {
            return reply(result.message);
          }
          
          if (result.subbots.length === 0) {
            return reply(`üìã *Nenhum sub-bot cadastrado.*\n\nüí° Use ${prefix}addsubbot <n√∫mero> para adicionar um sub-bot.`);
          }
          
          let msg = `ü§ñ *Sub-Bots Ativos* ü§ñ\n`;
          msg += `‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê\n\n`;
          
          result.subbots.forEach((bot, index) => {
            const statusEmoji = bot.status === 'conectado' ? 'üü¢' : bot.status === 'aguardando_pareamento' ? 'üü°' : 'üî¥';
            const activeText = bot.isActive ? '‚úÖ Ativo' : '‚è∏Ô∏è Inativo';
            
            msg += `*${index + 1}.* ${statusEmoji} ${activeText}\n`;
            msg += `üì± *N√∫mero:* ${bot.phoneNumber}\n`;
            msg += `üÜî *ID:* \`${bot.id.substring(0, 25)}...\`\n`;
            msg += `üìä *Status:* ${bot.status}\n`;
            msg += `üìÖ *Criado:* ${new Date(bot.createdAt).toLocaleString('pt-BR')}\n`;
            msg += `üîå *√öltima conex√£o:* ${bot.lastConnection !== 'Nunca' ? new Date(bot.lastConnection).toLocaleString('pt-BR') : 'Nunca'}\n`;
            msg += `\n`;
          });
          
          msg += `‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê\n`;
          msg += `Total: ${result.subbots.length} sub-bot(s)`;
          
          await reply(msg);
        } catch (error) {
          console.error("Erro ao listar sub-bots:", error);
          await reply(`‚ùå Erro ao listar sub-bots: ${error.message}`);
        }
        break;

      case 'conectarsubbot':
      case 'reconnectsubbot':
        if (!isOwner) return reply("üö´ Apenas o Dono principal pode reconectar sub-bots!");
        try {
          const subBotManager = await import('./utils/subBotManager.js');
          
          if (!q || !q.trim()) {
            return reply(`üìù *Como usar:*\n\n${prefix}conectarsubbot <id>\n\n*Exemplo:*\n${prefix}conectarsubbot subbot_1234567890_abc123\n\nüí° Use \`${prefix}listarsubbots\` para ver os IDs`);
          }
          
          const botId = q.trim();
          
          await reply('‚è≥ Conectando sub-bot... Aguarde...');
          
          const result = await subBotManager.reconnectSubBot(botId);
          
          await reply(result.message);
        } catch (error) {
          console.error("Erro ao reconectar sub-bot:", error);
          await reply(`‚ùå Erro ao reconectar sub-bot: ${error.message}`);
        }
        break;

      case 'gerarcodigo':
      case 'pairingcode':
      case 'codigosubbot':
        try {
          const subBotManager = await import('./utils/subBotManager.js');
          
          // Verifica se o usu√°rio √© um sub-bot cadastrado
          const result = await subBotManager.generatePairingCodeForSubBot(sender);
          
          if (!result.success) {
            return reply(result.message);
          }
          
          // Envia o c√≥digo no privado do sub-bot
          await reply(result.message);
          
        } catch (error) {
          console.error("Erro ao gerar c√≥digo de pareamento:", error);
          await reply(`‚ùå Erro ao gerar c√≥digo: ${error.message}`);
        }
        break;

      case 'cmdlimitar':
      case 'cmdlimit':
      case 'limitarcmd':
        try {
          const { cmdLimitAdd } = await import('./funcs/utils/cmdlimit.js');
          await cmdLimitAdd(nazu, from, q, reply, prefix, isOwnerOrSub);
        } catch (error) {
          console.error('Error in cmdlimitar:', error);
          await reply('‚ùå Erro interno!');
        }
        break;

      case 'cmddeslimitar':
      case 'cmdremovelimit':
      case 'rmcmdlimit':
        try {
          const { cmdLimitRemove } = await import('./funcs/utils/cmdlimit.js');
          await cmdLimitRemove(nazu, from, q, reply, prefix, isOwnerOrSub);
        } catch (error) {
          console.error('Error in cmddeslimitar:', error);
          await reply('‚ùå Erro interno!');
        }
        break;

      case 'cmdlimites':
      case 'cmdlimits':
      case 'listcmdlimites':
        try {
          const { cmdLimitList } = await import('./funcs/utils/cmdlimit.js');
          await cmdLimitList(nazu, from, q, reply, prefix, isOwnerOrSub);
        } catch (error) {
          console.error('Error in cmdlimites:', error);
          await reply('‚ùå Erro interno!');
        }
        break;
        
      case 'viewmsg':
        try {
          if (!isOwner) return reply(OWNER_ONLY_MESSAGE);
          if (!q) return reply(`Use: ${prefix}viewmsg [on/off]`);
          const botStateFile = DATABASE_DIR + '/botState.json';
          let botState = loadJsonFile(botStateFile, {
            status: 'on',
            viewMessages: true
          });
          if (q.toLowerCase() === 'on') {
            botState.viewMessages = true;
            writeJsonFile(botStateFile, botState);
            await reply('‚úÖ Visualiza√ß√£o de mensagens ativada!');
          } else if (q.toLowerCase() === 'off') {
            botState.viewMessages = false;
            writeJsonFile(botStateFile, botState);
            await reply('‚úÖ Visualiza√ß√£o de mensagens desativada!');
          } else {
            return reply('ü§î Use "on" para ativar ou "off" para desativar.');
          }
        } catch (e) {
          console.error('Erro no comando viewmsg:', e);
          await reply('üò• Ocorreu um erro ao alterar a visualiza√ß√£o de mensagens.');
        }
        break;
      case 'modoaluguel':
        if (!isOwner || isOwner && isSubOwner) return reply("üö´ Apenas o Dono principal pode gerenciar o modo de aluguel!");
        try {
          const action = q.toLowerCase().trim();
          if (action === 'on' || action === 'ativar') {
            if (setRentalMode(true)) {
              await reply("‚úÖ Modo de aluguel global ATIVADO! O bot agora s√≥ responder√° em grupos com aluguel ativo.");
            } else {
              await reply("‚ùå Erro ao ativar o modo de aluguel global.");
            }
          } else if (action === 'off' || action === 'desativar') {
            if (setRentalMode(false)) {
              await reply("‚úÖ Modo de aluguel global DESATIVADO! O bot responder√° em todos os grupos permitidos.");
            } else {
              await reply("‚ùå Erro ao desativar o modo de aluguel global.");
            }
          } else {
            const currentStatus = isRentalModeActive() ? 'ATIVADO' : 'DESATIVADO';
            await reply(`ü§î Uso: ${prefix}modoaluguel on|off\nStatus atual: ${currentStatus}`);
          }
        } catch (e) {
          console.error("Erro no comando modoaluguel:", e);
          await reply("‚ùå Ocorreu um erro inesperado.");
        }
        break;

      case 'atualizar':
      case 'update':
      case 'atualizarbot':
        if (!isOwner || isSubOwner) return reply("üö´ Apenas o Dono principal pode atualizar o bot!");
        
        try {
          const updateScriptPath = pathz.join(__dirname, '.scripts', 'update.js');
          
          // Verifica se o script de atualiza√ß√£o existe
          if (!fs.existsSync(updateScriptPath)) {
            return reply("‚ùå Script de atualiza√ß√£o n√£o encontrado!\n\nüìÇ Caminho esperado: dados/src/.scripts/update.js");
          }

          // Se n√£o passou o par√¢metro "sim", mostra o aviso
          if (!q || q.toLowerCase() !== 'sim') {
            const avisoMsg = `‚ö†Ô∏è *ATEN√á√ÉO - ATUALIZA√á√ÉO DO BOT* ‚ö†Ô∏è

‚îè‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ
‚îÉ üì¢ *AVISOS IMPORTANTES:*
‚î£‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ
‚îÉ
‚îÉ ‚ö†Ô∏è Edi√ß√µes manuais no c√≥digo 
‚îÉ    ser√£o *PERDIDAS*
‚îÉ
‚îÉ ‚úÖ Banco de dados ser√° 
‚îÉ    *PRESERVADO*
‚îÉ
‚îÉ ‚úÖ Configura√ß√µes (config.json)
‚îÉ    ser√£o *MANTIDAS*
‚îÉ
‚îÉ ‚úÖ M√≠dias ser√£o *PRESERVADAS*
‚îÉ
‚îÉ üîí Backup autom√°tico ser√° criado
‚îÉ
‚îÉ ‚è∏Ô∏è Processamento de mensagens
‚îÉ    ser√° *PAUSADO* durante update
‚îÉ
‚î£‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ
‚îÉ üí° *RECOMENDA√á√ÉO:*
‚îÉ Fa√ßa um backup manual antes!
‚î£‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ
‚îÉ
‚îÉ üìù Para confirmar, use:
‚îÉ ${prefix}atualizar sim
‚îÉ
‚îó‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ`;
            
            return reply(avisoMsg);
          }

          // Confirma√ß√£o recebida, iniciar atualiza√ß√£o
          await reply("üöÄ *INICIANDO ATUALIZA√á√ÉO...*\n\n‚è∏Ô∏è Pausando processamento de mensagens...");

          // Pausa o processamento de mensagens
          const messageQueueModule = await import('./connect.js');
          if (messageQueueModule.messageQueue && typeof messageQueueModule.messageQueue.pause === 'function') {
            messageQueueModule.messageQueue.pause();
            await reply("‚úÖ Processamento pausado com sucesso!\n\nüîÑ Iniciando script de atualiza√ß√£o...");
          }

          // Cria o processo de atualiza√ß√£o
          const updateProcess = spawn('node', [updateScriptPath], {
            cwd: pathz.join(__dirname, '..', '..'),
            stdio: ['ignore', 'pipe', 'pipe'],
            detached: false
          });

          let outputBuffer = '';
          const messagesSent = new Set(); // Rastreia mensagens j√° enviadas para evitar duplicatas
          const messageQueue = []; // Fila de mensagens pendentes
          let isProcessingQueue = false;

          // Mapeamento de triggers para mensagens
          const updateMessages = {
            'Verificando requisitos': 'üîç Verificando requisitos do sistema...',
            'Criando backup': 'üìÅ Criando backup dos arquivos importantes...',
            'Backup salvo': '‚úÖ Backup criado com sucesso!',
            'Baixando a vers√£o': 'üì• Baixando atualiza√ß√£o do GitHub...',
            'Download conclu√≠do': '‚úÖ Download conclu√≠do!\n\nüßπ Limpando arquivos antigos...',
            'Limpeza conclu√≠da': '‚úÖ Limpeza conclu√≠da!\n\nüöÄ Aplicando atualiza√ß√£o...',
            'Atualiza√ß√£o aplicada': '‚úÖ Atualiza√ß√£o aplicada!\n\nüìÇ Restaurando dados preservados...',
            'Backup restaurado': '‚úÖ Dados restaurados!\n\nüì¶ Instalando depend√™ncias...',
            'Instalando depend√™ncias': 'üì¶ Instalando/verificando depend√™ncias...\n‚è≥ Isso pode levar alguns minutos...',
            'Depend√™ncias instaladas': '‚úÖ Depend√™ncias instaladas com sucesso!'
          };

          // Processa a fila de mensagens sequencialmente
          const processMessageQueue = async () => {
            if (isProcessingQueue || messageQueue.length === 0) return;
            
            isProcessingQueue = true;
            while (messageQueue.length > 0) {
              const message = messageQueue.shift();
              try {
                await reply(message);
                await new Promise(resolve => setTimeout(resolve, 1500)); // Delay entre mensagens
              } catch (e) {
                console.error('Erro ao enviar update:', e);
              }
            }
            isProcessingQueue = false;
          };

          // Adiciona mensagem √† fila se n√£o foi enviada ainda
          const queueUpdate = (trigger, message) => {
            if (!messagesSent.has(trigger)) {
              messagesSent.add(trigger);
              messageQueue.push(message);
              processMessageQueue();
            }
          };

          // Captura stdout
          updateProcess.stdout.on('data', async (data) => {
            const output = data.toString();
            console.log('UPDATE:', output);
            outputBuffer += output;

            // Verifica cada trigger e enfileira a mensagem correspondente
            for (const [trigger, message] of Object.entries(updateMessages)) {
              if (output.includes(trigger)) {
                queueUpdate(trigger, message);
              }
            }
          });

          // Captura stderr
          updateProcess.stderr.on('data', (data) => {
            const error = data.toString();
            console.error('UPDATE ERROR:', error);
          });

          // Quando o processo terminar
          updateProcess.on('close', async (code) => {
            if (code === 0) {
              await reply(`‚úÖ *ATUALIZA√á√ÉO CONCLU√çDA COM SUCESSO!*

üéâ O bot foi atualizado para a vers√£o mais recente!

üîÑ Reiniciando automaticamente em 3 segundos...`);

              // Aguarda 3 segundos antes de reiniciar
              setTimeout(async () => {
                await reply('üîÑ Reiniciando agora...');
                
                // Aguarda mais 1 segundo para garantir que a mensagem foi enviada
                setTimeout(() => {
                  console.log('[UPDATE] Reiniciando ap√≥s atualiza√ß√£o...');
                  process.exit(0); // Exit code 0 indica sucesso, o gerenciador de processos deve reiniciar
                }, 1000);
              }, 3000);
            } else {
              await reply(`‚ùå *ERRO NA ATUALIZA√á√ÉO!*

‚ö†Ô∏è O processo de atualiza√ß√£o falhou com c√≥digo: ${code}

üîß *O que fazer:*
‚îÉ
‚îÉ 1Ô∏è‚É£ Verifique sua conex√£o com a internet
‚îÉ 2Ô∏è‚É£ Certifique-se de ter Git instalado
‚îÉ 3Ô∏è‚É£ Tente novamente em alguns minutos
‚îÉ 4Ô∏è‚É£ Se persistir, atualize manualmente:
‚îÉ    cd dados/src/.scripts
‚îÉ    node update.js
‚îÉ
‚îó‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ

üìÇ Backup foi preservado para seguran√ßa.`);

              // Retoma o processamento de mensagens
              if (messageQueueModule.messageQueue && typeof messageQueueModule.messageQueue.resume === 'function') {
                messageQueueModule.messageQueue.resume();
              }
            }
          });

          // Timeout de seguran√ßa (15 minutos)
          setTimeout(async () => {
            if (!updateProcess.killed) {
              updateProcess.kill();
              await reply("‚è±Ô∏è Timeout na atualiza√ß√£o (15min).\n\n‚ùå Processo cancelado por seguran√ßa.\n\nüîÑ Retomando processamento de mensagens...");
              
              if (messageQueueModule.messageQueue && typeof messageQueueModule.messageQueue.resume === 'function') {
                messageQueueModule.messageQueue.resume();
              }
            }
          }, 15 * 60 * 1000); // 15 minutos

        } catch (e) {
          console.error("Erro no comando atualizar:", e);
          await reply(`‚ùå Erro ao executar atualiza√ß√£o: ${e.message}\n\nüîÑ Retomando processamento de mensagens...`);
          
          // Garante retomar o processamento em caso de erro
          try {
            const messageQueueModule = await import('./connect.js');
            if (messageQueueModule.messageQueue && typeof messageQueueModule.messageQueue.resume === 'function') {
              messageQueueModule.messageQueue.resume();
            }
          } catch (resumeError) {
            console.error('Erro ao retomar processamento:', resumeError);
          }
        }
        break;

      case 'reiniciar':
      case 'restart':
      case 'reboot':
        if (!isOwner) return reply("üö´ Apenas o Dono principal pode reiniciar o bot!");
        
        reply(`üîÑ *REINICIANDO O BOT...*

‚è∏Ô∏è Pausando processamento de mensagens...
üîÑ O bot voltar√° online em alguns segundos!`).then(() => {
          // Pausa o processamento de mensagens
          return import('./connect.js');
        }).then((messageQueueModule) => {
          if (messageQueueModule.messageQueue && typeof messageQueueModule.messageQueue.pause === 'function') {
            messageQueueModule.messageQueue.pause();
          }

          // Aguarda 2 segundos para garantir que a mensagem foi enviada
          setTimeout(() => {
            console.log('[RESTART] Reiniciando bot via comando...');
            process.exit(0); // Exit code 0 indica rein√≠cio intencional
          }, 2000);
        }).catch((e) => {
          console.error("Erro no comando reiniciar:", e);
          reply(`‚ùå Erro ao tentar reiniciar: ${e.message}`);
        });
        break;

      case 'listaralugueis':
      case 'aluguelist':
      case 'listaluguel':
      case 'listaaluguel':
        try {
          if (!isOwner) return reply(OWNER_ONLY_MESSAGE);
          const rentalData = loadRentalData();
          const globalMode = rentalData.globalMode ? 'üü¢ Ativo' : 'üî¥ Desativado';
          const groupRentals = rentalData.groups || {};
          const groupCount = Object.keys(groupRentals).length;
          const filtro = args[0]?.toLowerCase();
          let message = `‚ï≠‚îÄ‚îÄ‚îÄ„Äå *Lista de Alugu√©is* „Äç‚îÄ‚îÄ‚îÄ‚ïÆ\n‚îÇ üåç *Modo Aluguel Global*: ${globalMode}\n‚îÇ üìä *Total de Grupos*: ${groupCount}\n‚ï∞‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚ïØ\n`;
          if (groupCount === 0) {
            
            message += 'üì™ Nenhum grupo com aluguel registrado.';
          } else {
            
            message += 'üìã *Grupos com Aluguel*:\n\n';
            let index = 1;
            for (const [groupId, info] of Object.entries(groupRentals)) {
              const groupMetadata = await getCachedGroupMetadata(groupId).catch(() => ({
                subject: 'Desconhecido'
              }));
              const groupName = groupMetadata.subject || 'Sem Nome';
              let status = 'Expirado';
              if (info.expiresAt === 'permanent') {
                
                status = 'Permanente';
              } else if (new Date(info.expiresAt) > new Date()) {
                
                status = 'Ativo';
              }
              const shouldInclude = !filtro || filtro === 'ven' && status === 'Expirado' || filtro === 'atv' && status === 'Ativo' || filtro === 'perm' && status === 'Permanente';
              if (!shouldInclude) continue;
              const expires = info.expiresAt === 'permanent' ? '‚àû Permanente' : info.expiresAt ? new Date(info.expiresAt).toLocaleString('pt-BR', {
                timeZone: 'America/Sao_Paulo'
              }) : 'N/A';
              
              message += `üîπ *${index}. ${groupName}*\n`;
              
              message += `  - *Status*: ${status}\n`;
              
              message += `  - *Expira em*: ${expires}\n\n`;
              index++;
            }
            if (index === 1) {
              
              
              message += 'üì™ Nenhum grupo encontrado com esse filtro.';
            }
          }
          await reply(message);
        } catch (e) {
          console.error('Erro no comando listaluguel:', e);
          await reply("Ocorreu um erro ao listar os alugu√©is üíî");
        }
        break;
      case 'leveling':
        if (!isGroup) return reply("Este comando s√≥ funciona em grupos.");
        if (!isGroupAdmin) return reply("Apenas administradores podem usar este comando.");
        groupData.levelingEnabled = !groupData.levelingEnabled;
    writeJsonFile(groupFile, groupData);
  // Otimiza√ß√£o: Invalida cache quando groupData √© salvo
  if (isGroup) {
    optimizer.invalidateGroup(from);
  }
        await reply(`üéöÔ∏è Sistema de leveling ${groupData.levelingEnabled ? 'ativado' : 'desativado'}!`);
        break;
      case 'level':
        const levelingDataLevel = loadLevelingSafe();
        const userDataLevel = getLevelingUser(levelingDataLevel, sender);
        const nextLevelXp = calculateNextLevelXp(userDataLevel.level || 1);
        const xpToNextLevel = nextLevelXp - (userDataLevel.xp || 0);
        const percentProgress = Math.floor(((userDataLevel.xp || 0) / nextLevelXp) * 100);
        const progressBar = '‚ñà'.repeat(Math.floor(percentProgress / 10)) + '‚ñë'.repeat(10 - Math.floor(percentProgress / 10));
        
        let levelText = `‚ï≠‚îÅ‚îÅ‚îÅ‚ä± üìä *STATUS DE N√çVEL* ‚ä±‚îÅ‚îÅ‚îÅ‚ïÆ\n`;
        levelText += `‚îÇ\n`;
        levelText += `‚îÇ üë§ *Jogador:* ${pushname}\n`;
        levelText += `‚îÇ\n`;
        levelText += `‚îú‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ\n`;
        levelText += `‚îÇ\n`;
        levelText += `‚îÇ üèÖ *N√≠vel Atual:* ${userDataLevel.level}\n`;
        levelText += `‚îÇ üéñÔ∏è *Patente:* ${userDataLevel.patent}\n`;
        levelText += `‚îÇ\n`;
        levelText += `‚îú‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ\n`;
        levelText += `‚îÇ\n`;
        levelText += `‚îÇ ‚ú® *Experi√™ncia:*\n`;
        levelText += `‚îÇ ‚îî‚îÄ ${userDataLevel.xp} / ${nextLevelXp} XP\n`;
        levelText += `‚îÇ\n`;
        levelText += `‚îÇ üìà *Progresso:*\n`;
        levelText += `‚îÇ ‚îî‚îÄ [${progressBar}] ${percentProgress}%\n`;
        levelText += `‚îÇ\n`;
        levelText += `‚îÇ üéØ *Falta:* ${xpToNextLevel} XP\n`;
        levelText += `‚îÇ\n`;
        levelText += `‚îú‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ\n`;
        levelText += `‚îÇ\n`;
        levelText += `‚îÇ üí¨ *Mensagens:* ${userDataLevel.messages || 0}\n`;
        levelText += `‚îÇ ‚ö° *Comandos:* ${userDataLevel.commands || 0}\n`;
        levelText += `‚îÇ\n`;
        levelText += `‚ï∞‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚ïØ\n\n`;
        levelText += `üí° Continue ativo para ganhar XP!`;
        
        await reply(levelText);
        break;
      case 'addxp':
        if (!isOwner) return reply("Apenas o dono pode usar este comando.");
        if (!menc_os2 || !q) return reply("Marque um usu√°rio e especifique a quantidade de XP.");
        const xpToAdd = parseInt(q);
        if (isNaN(xpToAdd)) return reply("Quantidade de XP inv√°lida.");
        const levelingDataAdd = loadLevelingSafe();
        const userDataAdd = getLevelingUser(levelingDataAdd, menc_os2);
        userDataAdd.xp = (userDataAdd.xp || 0) + xpToAdd;
        checkLevelUp(menc_os2, userDataAdd, levelingDataAdd, nazu, from);
        saveLevelingSafe(levelingDataAdd);
        await reply(`‚úÖ Adicionado ${xpToAdd} XP para @${getUserName(menc_os2)}`, {
          mentions: [menc_os2]
        });
        break;
      case 'delxp':
        if (!isOwner) return reply("Apenas o dono pode usar este comando.");
        if (!menc_os2 || !q) return reply("Marque um usu√°rio e especifique a quantidade de XP.");
        const xpToRemove = parseInt(q);
        if (isNaN(xpToRemove)) return reply("Quantidade de XP inv√°lida.");
        const levelingDataDel = loadLevelingSafe();
        const userDataDel = getLevelingUser(levelingDataDel, menc_os2);
        userDataDel.xp = Math.max(0, (userDataDel.xp || 0) - xpToRemove);
        checkLevelDown(menc_os2, userDataDel, levelingDataDel);
        saveLevelingSafe(levelingDataDel);
        await reply(`‚úÖ Removido ${xpToRemove} XP de @${getUserName(menc_os2)}`, {
          mentions: [menc_os2]
        });
        break;

      case 'dayfree':
        try {
          if (!isOwner) return reply('‚ùå Este comando √© exclusivo para o dono ou subdonos.');
          if (!q) return reply(`Uso: ${prefix}${command} <dias> [motivo opcional]\nEx: ${prefix}adddiasaluguel 7 Manuten√ß√£o compensat√≥ria`);
          const parts = q.split(' ');
          const extraDays = parseInt(parts[0]);
          if (isNaN(extraDays) || extraDays <= 0) return reply('O primeiro argumento deve ser um n√∫mero positivo de dias.');
          const motivo = parts.slice(1).join(' ') || 'N√£o especificado';
          const rentalData = loadRentalData();
          const groupIds = Object.keys(rentalData.groups);
          if (groupIds.length === 0) return reply('N√£o h√° grupos com aluguel configurado.');
          let successCount = 0;
          let failCount = 0;
          let summary = `üìä Resumo da extens√£o de aluguel:\n\n`;
          for (const groupId of groupIds) {
            const extendResult = extendGroupRental(groupId, extraDays);
            if (extendResult.success) {
              successCount++;
              summary += `‚úÖ ${groupId}: ${extendResult.message}\n`;
              try {
                const groupMeta = await getCachedGroupMetadata(groupId);
                const msg = `üéâ Aten√ß√£o, ${groupMeta.subject}! Adicionados ${extraDays} dias extras de aluguel.\nNova expira√ß√£o: ${new Date(rentalData.groups[groupId].expiresAt).toLocaleDateString('pt-BR')}.\nMotivo: ${motivo}`;
                await nazu.sendMessage(groupId, {
                  text: msg
                });
              } catch (e) {
                console.error(`Erro ao enviar mensagem para ${groupId}:`, e);
                summary += `   ‚ö†Ô∏è Falha ao avisar no grupo.\n`;
              }
            } else {
              failCount++;
              summary += `‚ùå ${groupId}: ${extendResult.message}\n`;
            }
          }
          summary += `\nTotal: ${successCount} sucessos | ${failCount} falhas`;
          await reply(summary);
        } catch (e) {
          console.error('Erro no comando adddiasaluguel:', e);
          await reply('Ocorreu um erro ao estender aluguel em todos os grupos.');
        }
        break;
      case 'addaluguel':
        if (!isOwner) return reply("üö´ Apenas o Dono principal pode adicionar aluguel!");
        if (!isGroup) return reply("Este comando s√≥ pode ser usado em grupos.");
        try {
          const parts = q.toLowerCase().trim().split(' ');
          const durationArg = parts[0];
          let durationDays = null;
          if (durationArg === 'permanente') {
            durationDays = 'permanent';
          } else if (!isNaN(parseInt(durationArg)) && parseInt(durationArg) > 0) {
            durationDays = parseInt(durationArg);
          } else {
            return reply(`ü§î Dura√ß√£o inv√°lida. Use um n√∫mero de dias (ex: 30) ou a palavra "permanente".\nExemplo: ${prefix}addaluguel 30`);
          }
          const result = setGroupRental(from, durationDays);
          await reply(result.message);
        } catch (e) {
          console.error("Erro no comando addaluguel:", e);
          await reply("‚ùå Ocorreu um erro inesperado ao adicionar o aluguel.");
        }
        break;
      
      case 'listaraluguel':
      case 'veralugueis':
      case 'listrentals':
        if (!isOwner) return reply("üö´ Apenas o Dono principal pode ver a lista de alugu√©is!");
        try {
          const rentalData = loadRentalData();
          const groupIds = Object.keys(rentalData.groups || {});
          
          if (groupIds.length === 0) {
            return reply("üì≠ Nenhum grupo com aluguel ativo no momento.");
          }
          
          let message = `‚ï≠‚îÅ‚îÅ‚îÅ‚ä± üìã *LISTA DE ALUGU√âIS* ‚ä±‚îÅ‚îÅ‚îÅ‚ïÆ\n`;
          message += `‚îÇ\n`;
          message += `‚îÇ üìä Total de grupos: ${groupIds.length}\n`;
          message += `‚îÇ\n`;
          message += `‚ï∞‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚ïØ\n\n`;
          
          const now = Date.now();
          let activeCount = 0;
          let expiredCount = 0;
          let permanentCount = 0;
          
          for (const groupId of groupIds) {
            const rental = rentalData.groups[groupId];
            
            try {
              const groupMeta = await getCachedGroupMetadata(groupId);
              const groupName = groupMeta?.subject || groupId;
              const isPermanent = rental.duration === 'permanent';
              const isExpired = !isPermanent && rental.expiresAt < now;
              
              if (isPermanent) permanentCount++;
              else if (isExpired) expiredCount++;
              else activeCount++;
              
              let statusIcon = '‚úÖ';
              let statusText = 'Ativo';
              
              if (isPermanent) {
                statusIcon = '‚ôæÔ∏è';
                statusText = 'PERMANENTE';
              } else if (isExpired) {
                statusIcon = '‚ùå';
                statusText = 'EXPIRADO';
              }
              
              message += `${statusIcon} *${groupName}*\n`;
              message += `‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ\n`;
              message += `‚îÇ üì± ID: ${groupId}\n`;
              message += `‚îÇ üìÖ Status: ${statusText}\n`;
              
              if (!isPermanent) {
                const daysLeft = Math.ceil((rental.expiresAt - now) / (1000 * 60 * 60 * 24));
                const expirationDate = new Date(rental.expiresAt).toLocaleDateString('pt-BR');
                message += `‚îÇ ‚è∞ Expira em: ${expirationDate}\n`;
                message += `‚îÇ ‚è≥ Dias restantes: ${daysLeft > 0 ? daysLeft : 0}\n`;
              }
              
              if (rental.addedAt) {
                const addedDate = new Date(rental.addedAt).toLocaleDateString('pt-BR');
                message += `‚îÇ üìÜ Adicionado em: ${addedDate}\n`;
              }
              
              message += `‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ\n\n`;
            } catch (e) {
              message += `‚ö†Ô∏è Grupo n√£o encontrado\n`;
              message += `‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ\n`;
              message += `‚îÇ üì± ID: ${groupId}\n`;
              message += `‚îÇ ‚ùå Erro ao buscar dados\n`;
              message += `‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ\n\n`;
            }
          }
          
          message += `‚ï≠‚îÅ‚îÅ‚îÅ‚ä± üìä *ESTAT√çSTICAS* ‚ä±‚îÅ‚îÅ‚îÅ‚ïÆ\n`;
          message += `‚îÇ\n`;
          message += `‚îÇ ‚úÖ Ativos: ${activeCount}\n`;
          message += `‚îÇ ‚ôæÔ∏è Permanentes: ${permanentCount}\n`;
          message += `‚îÇ ‚ùå Expirados: ${expiredCount}\n`;
          message += `‚îÇ üì¶ Total: ${groupIds.length}\n`;
          message += `‚îÇ\n`;
          message += `‚ï∞‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚ïØ\n\n`;
          message += `üí° *Comandos dispon√≠veis:*\n`;
          message += `‚Ä¢ ${prefix}removeraluguel <id>\n`;
          message += `‚Ä¢ ${prefix}estenderaluguel <id> <dias>\n`;
          message += `‚Ä¢ ${prefix}infoaluguel <id>`;
          
          await reply(message);
        } catch (e) {
          console.error("Erro no comando listaraluguel:", e);
          await reply("‚ùå Ocorreu um erro ao listar os alugu√©is.");
        }
        break;
      
      case 'removeraluguel':
      case 'deletaraluguel':
      case 'cancelaraluguel':
        if (!isOwner) return reply("üö´ Apenas o Dono principal pode remover alugu√©is!");
        try {
          let targetGroupId = q?.trim() || '';
          
          // Se n√£o passou ID e est√° no grupo, usa o grupo atual
          if (!targetGroupId && isGroup) {
            targetGroupId = from;
          } else if (!targetGroupId) {
            return reply(`üí° *Uso:* ${prefix}removeraluguel [id_do_grupo]\n\nüìù Use dentro de um grupo ou informe o ID.\nüí° Use ${prefix}listaraluguel para ver os IDs.`);
          }
          
          if (!targetGroupId.trim()) {
            return reply(`üí° *Uso:* ${prefix}removeraluguel [id_do_grupo]\n\nüìù Use dentro de um grupo ou informe o ID.`);
          }
          
          // Normaliza o ID do grupo
          if (!targetGroupId.includes('@g.us')) {
            targetGroupId += '@g.us';
          }
          
          const rentalData = loadRentalData();
          
          if (!rentalData.groups || !rentalData.groups[targetGroupId]) {
            return reply(`‚ùå Este grupo n√£o possui aluguel ativo.\n\nüí° Use ${prefix}listaraluguel para ver os grupos com aluguel.`);
          }
          
          // Busca informa√ß√µes do grupo antes de remover
          let groupName = targetGroupId;
          try {
            const groupMeta = await getCachedGroupMetadata(targetGroupId);
            groupName = groupMeta?.subject || targetGroupId;
          } catch (e) {
            console.log("Erro ao buscar metadata do grupo:", e.message);
          }
          
          // Remove o aluguel
          delete rentalData.groups[targetGroupId];
          saveRentalData(rentalData);
          
          let message = `‚ï≠‚îÅ‚îÅ‚îÅ‚ä± ‚úÖ *ALUGUEL REMOVIDO* ‚ä±‚îÅ‚îÅ‚îÅ‚ïÆ\n`;
          message += `‚îÇ\n`;
          message += `‚îÇ üóëÔ∏è O aluguel do grupo foi\n`;
          message += `‚îÇ    removido com sucesso!\n`;
          message += `‚îÇ\n`;
          message += `‚îÇ üì± Grupo: ${groupName}\n`;
          message += `‚îÇ üÜî ID: ${targetGroupId}\n`;
          message += `‚îÇ\n`;
          message += `‚ï∞‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚ïØ\n\n`;
          message += `‚ö†Ô∏è O bot n√£o funcionar√° mais neste grupo at√© que um novo aluguel seja adicionado.`;
          
          await reply(message);
          
          // Tenta notificar o grupo
          try {
            await nazu.sendMessage(targetGroupId, {
              text: `‚ö†Ô∏è *AVISO IMPORTANTE*\n\nO aluguel deste grupo foi removido pelo propriet√°rio do bot.\n\n‚ùå O bot n√£o funcionar√° mais neste grupo.\n\nPara mais informa√ß√µes, entre em contato com o dono.`
            });
          } catch (e) {
            console.log("N√£o foi poss√≠vel notificar o grupo:", e.message);
          }
        } catch (e) {
          console.error("Erro no comando removeraluguel:", e);
          await reply("‚ùå Ocorreu um erro ao remover o aluguel.");
        }
        break;
      
      case 'estenderaluguel':
      case 'adddiasaluguel':
      case 'extenderrental':
        if (!isOwner) return reply("üö´ Apenas o Dono principal pode estender alugu√©is!");
        try {
          const parts = q?.trim().split(' ') || [];
          let targetGroupId;
          let daysToAdd;
          
          // Se est√° no grupo e passou apenas 1 argumento (dias)
          if (isGroup && parts.length === 1) {
            targetGroupId = from;
            daysToAdd = parseInt(parts[0]);
          }
          // Se passou 2 argumentos (id e dias)
          else if (parts.length >= 2) {
            targetGroupId = parts[0];
            daysToAdd = parseInt(parts[1]);
          }
          // Nenhum argumento v√°lido
          else {
            return reply(`üí° *Uso:* ${prefix}estenderaluguel <dias> (no grupo)\nou\n${prefix}estenderaluguel <id_do_grupo> <dias>\n\nüìù *Exemplo:*\n${prefix}estenderaluguel 7 (no grupo)\n${prefix}estenderaluguel 5511999999999 7\n\nüí° Use ${prefix}listaraluguel para ver os IDs.`);
          }
          
          if (isNaN(daysToAdd) || daysToAdd <= 0) {
            return reply("‚ùå O n√∫mero de dias deve ser um valor positivo!");
          }
          
          // Normaliza o ID do grupo
          if (!targetGroupId.includes('@g.us')) {
            targetGroupId += '@g.us';
          }
          
          const result = extendGroupRental(targetGroupId, daysToAdd);
          
          if (!result.success) {
            return reply(`‚ùå ${result.message}`);
          }
          
          // Busca informa√ß√µes do grupo
          let groupName = targetGroupId;
          try {
            const groupMeta = await getCachedGroupMetadata(targetGroupId);
            groupName = groupMeta?.subject || targetGroupId;
          } catch (e) {
            console.log("Erro ao buscar metadata:", e.message);
          }
          
          const rentalData = loadRentalData();
          const rental = rentalData.groups[targetGroupId];
          const newExpirationDate = new Date(rental.expiresAt).toLocaleDateString('pt-BR');
          const daysLeft = Math.ceil((rental.expiresAt - Date.now()) / (1000 * 60 * 60 * 24));
          
          let message = `‚ï≠‚îÅ‚îÅ‚îÅ‚ä± ‚úÖ *ALUGUEL ESTENDIDO* ‚ä±‚îÅ‚îÅ‚îÅ‚ïÆ\n`;
          message += `‚îÇ\n`;
          message += `‚îÇ üì± Grupo: ${groupName}\n`;
          message += `‚îÇ ‚ûï Dias adicionados: ${daysToAdd}\n`;
          message += `‚îÇ üìÖ Nova expira√ß√£o: ${newExpirationDate}\n`;
          message += `‚îÇ ‚è≥ Dias restantes: ${daysLeft}\n`;
          message += `‚îÇ\n`;
          message += `‚ï∞‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚ïØ`;
          
          await reply(message);
          
          // Notifica o grupo
          try {
            await nazu.sendMessage(targetGroupId, {
              text: `üéâ *BOA NOT√çCIA!*\n\nSeu aluguel foi estendido!\n\n‚ûï Dias adicionados: *${daysToAdd}*\nüìÖ Nova data de expira√ß√£o: *${newExpirationDate}*\n‚è≥ Dias restantes: *${daysLeft}*\n\n‚ú® Continue aproveitando o bot!`
            });
          } catch (e) {
            console.log("N√£o foi poss√≠vel notificar o grupo:", e.message);
          }
        } catch (e) {
          console.error("Erro no comando estenderaluguel:", e);
          await reply("‚ùå Ocorreu um erro ao estender o aluguel.");
        }
        break;
      
      case 'infoaluguel':
      case 'statusaluguel':
      case 'detalhesaluguel':
        if (!isOwner) return reply("üö´ Apenas o Dono principal pode ver informa√ß√µes de aluguel!");
        try {
          let targetGroupId = q.trim();
          
          // Se n√£o passou ID, usa o grupo atual
          if (!targetGroupId || targetGroupId === '') {
            if (!isGroup) {
              return reply(`üí° *Uso:* ${prefix}infoaluguel <id_do_grupo>\n\nüìù Ou use este comando dentro do grupo para ver o status dele.`);
            }
            targetGroupId = from;
          } else {
            // Normaliza o ID
            if (!targetGroupId.includes('@g.us')) {
              targetGroupId += '@g.us';
            }
          }
          
          const rentalData = loadRentalData();
          const rental = rentalData.groups?.[targetGroupId];
          
          if (!rental) {
            return reply(`‚ùå Este grupo n√£o possui aluguel ativo.\n\nüí° Use ${prefix}addaluguel para adicionar.`);
          }
          
          // Busca informa√ß√µes do grupo
          let groupName = targetGroupId;
          let memberCount = 0;
          try {
            const groupMeta = await getCachedGroupMetadata(targetGroupId);
            groupName = groupMeta?.subject || targetGroupId;
            memberCount = groupMeta?.participants?.length || 0;
          } catch (e) {
            console.log("Erro ao buscar metadata:", e.message);
          }
          
          const isPermanent = rental.duration === 'permanent';
          const now = Date.now();
          
          let message = `‚ï≠‚îÅ‚îÅ‚îÅ‚ä± üìã *DETALHES DO ALUGUEL* ‚ä±‚îÅ‚îÅ‚îÅ‚ïÆ\n`;
          message += `‚îÇ\n`;
          message += `‚îÇ üì± *GRUPO:* ${groupName}\n`;
          message += `‚îÇ üÜî *ID:* ${targetGroupId}\n`;
          message += `‚îÇ üë• *Membros:* ${memberCount}\n`;
          message += `‚îÇ\n`;
          message += `‚ï∞‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚ïØ\n\n`;
          
          if (isPermanent) {
            message += `‚ôæÔ∏è *STATUS:* PERMANENTE\n\n`;
            message += `‚ú® Este grupo tem aluguel permanente!\n`;
            message += `‚è∞ N√£o h√° data de expira√ß√£o.`;
          } else {
            const isExpired = rental.expiresAt < now;
            const daysLeft = Math.ceil((rental.expiresAt - now) / (1000 * 60 * 60 * 24));
            const expirationDate = new Date(rental.expiresAt).toLocaleDateString('pt-BR');
            const expirationTime = new Date(rental.expiresAt).toLocaleTimeString('pt-BR');
            
            message += `üìÖ *STATUS:* ${isExpired ? '‚ùå EXPIRADO' : '‚úÖ ATIVO'}\n\n`;
            message += `‚è∞ *Data de expira√ß√£o:*\n`;
            message += `   ${expirationDate} √†s ${expirationTime}\n\n`;
            
            if (!isExpired) {
              message += `‚è≥ *Tempo restante:* ${daysLeft} dia${daysLeft !== 1 ? 's' : ''}\n\n`;
              
              // Alerta se est√° perto de expirar
              if (daysLeft <= 3) {
                message += `‚ö†Ô∏è *ATEN√á√ÉO:* O aluguel est√° pr√≥ximo de expirar!\n\n`;
              }
            } else {
              const daysExpired = Math.abs(daysLeft);
              message += `‚è≥ *Expirado h√°:* ${daysExpired} dia${daysExpired !== 1 ? 's' : ''}\n\n`;
            }
          }
          
          if (rental.addedAt) {
            const addedDate = new Date(rental.addedAt).toLocaleDateString('pt-BR');
            message += `\nüìÜ *Aluguel adicionado em:* ${addedDate}`;
          }
          
          message += `\n\nüí° *Comandos dispon√≠veis:*\n`;
          message += `‚Ä¢ ${prefix}estenderaluguel ${targetGroupId} <dias>\n`;
          message += `‚Ä¢ ${prefix}removeraluguel ${targetGroupId}`;
          
          await reply(message);
        } catch (e) {
          console.error("Erro no comando infoaluguel:", e);
          await reply("‚ùå Ocorreu um erro ao buscar informa√ß√µes do aluguel.");
        }
        break;
      
      case 'gerarcodigobr':
      case 'gerarcod':
        if (!isOwner) return reply("üö´ Apenas o Dono principal pode gerar c√≥digos!");
        try {
          const parts = q.trim().split(' ');
          const durationArg = parts[0]?.toLowerCase();
          const targetGroupArg = parts[1];
          let durationDays = null;
          let targetGroupId = null;
          if (!durationArg) {
            return reply(`ü§î Uso: ${prefix}gerarcodigobr <dias|permanente> [id_do_grupo_opcional]`);
          }
          if (durationArg === 'permanente') {
            durationDays = 'permanent';
          } else if (!isNaN(parseInt(durationArg)) && parseInt(durationArg) > 0) {
            durationDays = parseInt(durationArg);
          } else {
            return reply('ü§î Dura√ß√£o inv√°lida. Use um n√∫mero de dias (ex: 7) ou a palavra "permanente".');
          }
          if (targetGroupArg) {
            if (targetGroupArg.includes('@g.us')) {
              targetGroupId = targetGroupArg;
            } else if (/^\d+$/.test(targetGroupArg)) {
              targetGroupId = targetGroupArg + '@g.us';
            } else {
              const mentionedJid = info.message?.extendedTextMessage?.contextInfo?.mentionedJid?.[0];
              if (mentionedJid && mentionedJid.endsWith('@g.us')) {
                targetGroupId = mentionedJid;
              } else {
                return reply('ü§î ID do grupo alvo inv√°lido. Forne√ßa o ID completo (numero@g.us) ou deixe em branco para um c√≥digo gen√©rico.');
              }
            }
          }
          const result = generateActivationCode(durationDays, targetGroupId);
          await reply(result.message);
        } catch (e) {
          console.error("Erro no comando gerarcodigo:", e);
          await reply("‚ùå Ocorreu um erro inesperado ao gerar o c√≥digo.");
        }
        break;
      case 'limparaluguel':
        try {
          if (!isOwner) return reply("Apenas o dono pode usar este comando. üö´");
          
          await reply("üîÑ Iniciando limpeza completa de alugu√©is...");
          
          let rentalData = loadRentalData();
          let groupsCleaned = 0;
          let groupsExpired = 0;
          let groupsWithoutRental = 0;
          let groupsLeft = [];
          let chatsDeleted = 0;
          let groupConversationsCleared = 0;
          let adminsNotified = 0;
          const symbols = ['‚ú®', 'üåü', '‚ö°', 'üî•', 'üåà', 'üçÄ', 'üí´', 'üéâ'];
          
          const currentGroups = await nazu.groupFetchAllParticipating();
          const currentGroupIds = Object.keys(currentGroups);
          const rentalGroupIds = Object.keys(rentalData.groups || {});
          
          // Limpa grupos que n√£o existem mais dos registros
          for (const groupId in rentalData.groups) {
            if (!currentGroupIds.includes(groupId)) {
              delete rentalData.groups[groupId];
              groupsCleaned++;
            }
          }
          
          // Processa grupos com aluguel vencido
          for (const groupId in rentalData.groups) {
            const rentalStatus = getGroupRentalStatus(groupId);
            if (rentalStatus.active || rentalStatus.permanent) continue;
            
            const groupMetadata = await getCachedGroupMetadata(groupId).catch(() => null);
            if (!groupMetadata) {
              delete rentalData.groups[groupId];
              groupsCleaned++;
              continue;
            }
            
            groupsExpired++;
            groupsLeft.push(groupId);
            
            try {
              await nazu.sendMessage(groupId, {
                text: `‚è∞ O aluguel deste grupo (${groupMetadata.subject}) expirou. Estou saindo, mas voc√™s podem renovar o aluguel entrando em contato com o dono! At√© mais! üòä${symbols[Math.floor(Math.random() * symbols.length)]}`
              });
              
              const admins = groupMetadata.participants.filter(p => p.admin).map(p => p.id);
              for (const admin of admins) {
                const delay = Math.floor(Math.random() * (500 - 100 + 1)) + 100;
                await new Promise(resolve => setTimeout(resolve, delay));
                try {
                  await nazu.sendMessage(admin, {
                    text: `‚ö†Ô∏è Ol√°, admin do grupo *${groupMetadata.subject}*! O aluguel do grupo expirou, e por isso sa√≠. Para renovar, entre em contato com o dono. Obrigado! ${symbols[Math.floor(Math.random() * symbols.length)]}`
                  });
                  adminsNotified++;
                } catch (e) {
                  console.error(`Erro ao notificar admin ${admin}:`, e.message);
                }
              }
              
              await nazu.groupLeave(groupId);
              
              // Deleta o chat do grupo
              try {
                if (nazu.chatModify) {
                  await deleteChatByLastMessage(groupId);
                  chatsDeleted++;
                }
              } catch (e) {
                console.error(`Erro ao deletar chat ${groupId}:`, e.message);
              }
              
              // Limpa conversa do grupo
              try {
                if (nazu.chatModify) {
                  await clearChatHistorySafe(groupId);
                  groupConversationsCleared++;
                }
              } catch (e) {
                console.error(`Erro ao limpar conversa ${groupId}:`, e.message);
              }
              
              // Delay entre grupos
              await new Promise(resolve => setTimeout(resolve, 1000));
            } catch (e) {
              console.error(`Erro ao processar grupo ${groupId}:`, e.message);
            }
          }
          
          // Processa grupos sem aluguel registrado
          for (const groupId of currentGroupIds) {
            if (!rentalGroupIds.includes(groupId)) {
              groupsWithoutRental++;
              groupsLeft.push(groupId);
              
              try {
                const groupMetadata = await getCachedGroupMetadata(groupId).catch(() => null);
                const groupName = groupMetadata?.subject || 'Grupo desconhecido';
                
                await nazu.sendMessage(groupId, {
                  text: `üëã Este grupo n√£o possui aluguel registrado. Estou saindo. At√© mais! ${symbols[Math.floor(Math.random() * symbols.length)]}`
                });
                
                await nazu.groupLeave(groupId);
                
                // Deleta o chat do grupo
                try {
                  if (nazu.chatModify) {
                    await deleteChatByLastMessage(groupId);
                    chatsDeleted++;
                  }
                } catch (e) {
                  console.error(`Erro ao deletar chat ${groupId}:`, e.message);
                }
                
                // Limpa conversa do grupo
                try {
                  if (nazu.chatModify) {
                    await clearChatHistorySafe(groupId);
                    groupConversationsCleared++;
                  }
                } catch (e) {
                  console.error(`Erro ao limpar conversa ${groupId}:`, e.message);
                }
                
                // Delay entre grupos
                await new Promise(resolve => setTimeout(resolve, 1000));
              } catch (e) {
                console.error(`Erro ao processar grupo sem aluguel ${groupId}:`, e.message);
              }
            }
          }
          
          // Limpa todas as conversas de grupo restantes (mant√©m apenas privadas)
          try {
            if (nazu.chatModify) {
              // Busca todos os grupos restantes e limpa conversas
              const remainingGroups = await nazu.groupFetchAllParticipating();
              for (const groupId of Object.keys(remainingGroups)) {
                try {
                  await clearChatHistorySafe(groupId);
                  groupConversationsCleared++;
                  await new Promise(resolve => setTimeout(resolve, 500));
                } catch (e) {
                  console.error(`Erro ao limpar conversa do grupo ${groupId}:`, e.message);
                }
              }
            }
          } catch (e) {
            console.error('Erro ao limpar conversas de grupos:', e.message);
          }
          
          saveRentalData(rentalData);
          
          let summary = `üßπ *Resumo da Limpeza Completa de Alugu√©is* üßπ\n\n`;
          summary += `‚úÖ Grupos removidos dos registros: *${groupsCleaned}*\n`;
          summary += `‚è∞ Grupos vencidos processados: *${groupsExpired}*\n`;
          summary += `üö´ Grupos sem aluguel processados: *${groupsWithoutRental}*\n`;
          summary += `üì© Administradores notificados: *${adminsNotified}*\n`;
          summary += `üóëÔ∏è Chats exclu√≠dos: *${chatsDeleted}*\n`;
          summary += `üßΩ Conversas de grupos limpas: *${groupConversationsCleared}*\n`;
          summary += `üìã Total de grupos dos quais sa√≠: *${groupsLeft.length}*\n`;
          
          if (groupsLeft.length > 0) {
            summary += `\nüìã *Grupos processados:*\n${groupsLeft.slice(0, 10).map(id => `- ${id.split('@')[0]}`).join('\n')}`;
            if (groupsLeft.length > 10) {
              summary += `\n... e mais ${groupsLeft.length - 10} grupos`;
            }
          }
          
          summary += `\n\n‚ú® Limpeza conclu√≠da com sucesso!`;
          await reply(summary);
        } catch (e) {
          console.error('Erro no comando limparaluguel:', e);
          await reply("Ocorreu um erro ao limpar alugueis üíî");
        }
        break;
      case 'addautoresponse':
      case 'addauto':
        try {
          if (!isOwner) return reply(OWNER_ONLY_MESSAGE);
          if (!q || !q.includes('/')) return reply(`Por favor, forne√ßa a mensagem recebida e a resposta separadas por /. Ex: ${groupPrefix}addauto bom dia/Ol√°, bom dia!`);
          const [received, response] = q.split('/').map(s => s.trim());
          if (!received || !response) return reply("Formato inv√°lido. Use: mensagem recebida/mensagem do bot");
          
          const responseData = {
            type: 'text',
            content: response
          };
          
          if (await addAutoResponse(from, received, responseData, true)) {
            await reply(`‚úÖ Auto-resposta global adicionada!\nTrigger: ${received}\nResposta: ${response}`);
          } else {
            await reply("üò• Erro ao salvar a auto-resposta. Tente novamente!");
          }
        } catch (e) {
          console.error('Erro no comando addauto:', e);
          await reply("Ocorreu um erro ao adicionar auto-resposta üíî");
        }
        break;

      case 'addautomedia':
      case 'addautomidia':
        try {
          if (!isOwner) return reply(OWNER_ONLY_MESSAGE);
          if (!q) return reply(`üìù Como usar:\n\n1Ô∏è‚É£ ${groupPrefix}addautomidia [trigger]\n2Ô∏è‚É£ Responda uma m√≠dia (imagem, v√≠deo, √°udio ou sticker)\n3Ô∏è‚É£ Opcionalmente adicione uma legenda\n\nExemplo: ${groupPrefix}addautomidia oi (respondendo uma imagem)`);
          
          const trigger = q.trim();
          let responseData = null;
          
          // Verificar se √© resposta a uma m√≠dia
          if (quotedMessageContent) {
            if (isQuotedImage) {
              const imageBuffer = await getFileBuffer(quotedMessageContent.imageMessage, 'image');
              responseData = {
                type: 'image',
                buffer: imageBuffer.toString('base64'),
                caption: quotedMessageContent.imageMessage.caption || ''
              };
            } else if (isQuotedVideo) {
              const videoBuffer = await getFileBuffer(quotedMessageContent.videoMessage, 'video');
              responseData = {
                type: 'video',
                buffer: videoBuffer.toString('base64'),
                caption: quotedMessageContent.videoMessage.caption || ''
              };
            } else if (isQuotedAudio) {
              const audioBuffer = await getFileBuffer(quotedMessageContent.audioMessage, 'audio');
              responseData = {
                type: 'audio',
                buffer: audioBuffer.toString('base64'),
                ptt: quotedMessageContent.audioMessage.ptt || false
              };
            } else if (isQuotedSticker) {
              const stickerBuffer = await getFileBuffer(quotedMessageContent.stickerMessage, 'sticker');
              responseData = {
                type: 'sticker',
                buffer: stickerBuffer.toString('base64')
              };
            } else {
              return reply('‚ùå Por favor, responda a uma m√≠dia v√°lida (imagem, v√≠deo, √°udio ou sticker)!');
            }
          } else {
            return reply('‚ùå Por favor, responda a uma m√≠dia para adicionar como auto-resposta!');
          }
          
          if (await addAutoResponse(from, trigger, responseData, true)) {
            await reply(`‚úÖ Auto-resposta global com m√≠dia adicionada!\nTrigger: ${trigger}\nTipo: ${responseData.type}`);
          } else {
            await reply("üò• Erro ao salvar a auto-resposta. Tente novamente!");
          }
        } catch (e) {
          console.error('Erro no comando addautomidia:', e);
          await reply("Ocorreu um erro ao adicionar auto-resposta com m√≠dia üíî");
        }
        break;

      case 'addautoadm':
      case 'addautoadmin':
        try {
          if (!isGroup) return reply('üö´ Este comando s√≥ funciona em grupos!');
          if (!isGroupAdmin) return reply('üö´ Este comando √© apenas para administradores do grupo!');
          if (!q || !q.includes('/')) return reply(`Por favor, forne√ßa a mensagem recebida e a resposta separadas por /. Ex: ${groupPrefix}addautoadm oi/Ol√°! Como posso ajudar?`);
          const [received, response] = q.split('/').map(s => s.trim());
          if (!received || !response) return reply("Formato inv√°lido. Use: mensagem recebida/mensagem do bot");
          
          const responseData = {
            type: 'text',
            content: response
          };
          
          if (await addAutoResponse(from, received, responseData, false)) {
            await reply(`‚úÖ Auto-resposta do grupo adicionada!\nTrigger: ${received}\nResposta: ${response}`);
          } else {
            await reply("üò• Erro ao salvar a auto-resposta. Tente novamente!");
          }
        } catch (e) {
          console.error('Erro no comando addautoadm:', e);
          await reply("Ocorreu um erro ao adicionar auto-resposta do grupo üíî");
        }
        break;

      case 'addautoadmidia':
      case 'addautoadmmidia':
        try {
          if (!isGroup) return reply('üö´ Este comando s√≥ funciona em grupos!');
          if (!isGroupAdmin) return reply('üö´ Este comando √© apenas para administradores do grupo!');
          if (!q) return reply(`üìù Como usar:\n\n1Ô∏è‚É£ ${groupPrefix}addautoadmidia [trigger]\n2Ô∏è‚É£ Responda uma m√≠dia (imagem, v√≠deo, √°udio ou sticker)\n3Ô∏è‚É£ Opcionalmente adicione uma legenda\n\nExemplo: ${groupPrefix}addautoadmidia bemvindo (respondendo uma imagem)`);
          
          const trigger = q.trim();
          let responseData = null;
          
          // Verificar se √© resposta a uma m√≠dia
          if (quotedMessageContent) {
            if (isQuotedImage) {
              const imageBuffer = await getFileBuffer(quotedMessageContent.imageMessage, 'image');
              responseData = {
                type: 'image',
                buffer: imageBuffer.toString('base64'),
                caption: quotedMessageContent.imageMessage.caption || ''
              };
            } else if (isQuotedVideo) {
              const videoBuffer = await getFileBuffer(quotedMessageContent.videoMessage, 'video');
              responseData = {
                type: 'video',
                buffer: videoBuffer.toString('base64'),
                caption: quotedMessageContent.videoMessage.caption || ''
              };
            } else if (isQuotedAudio) {
              const audioBuffer = await getFileBuffer(quotedMessageContent.audioMessage, 'audio');
              responseData = {
                type: 'audio',
                buffer: audioBuffer.toString('base64'),
                ptt: quotedMessageContent.audioMessage.ptt || false
              };
            } else if (isQuotedSticker) {
              const stickerBuffer = await getFileBuffer(quotedMessageContent.stickerMessage, 'sticker');
              responseData = {
                type: 'sticker',
                buffer: stickerBuffer.toString('base64')
              };
            } else {
              return reply('‚ùå Por favor, responda a uma m√≠dia v√°lida (imagem, v√≠deo, √°udio ou sticker)!');
            }
          } else {
            return reply('‚ùå Por favor, responda a uma m√≠dia para adicionar como auto-resposta!');
          }
          
          if (await addAutoResponse(from, trigger, responseData, false)) {
            await reply(`‚úÖ Auto-resposta do grupo com m√≠dia adicionada!\nTrigger: ${trigger}\nTipo: ${responseData.type}`);
          } else {
            await reply("üò• Erro ao salvar a auto-resposta. Tente novamente!");
          }
        } catch (e) {
          console.error('Erro no comando addautoadmidia:', e);
          await reply("Ocorreu um erro ao adicionar auto-resposta do grupo com m√≠dia üíî");
        }
        break;
      case 'listautoresponses':
      case 'listauto':
        try {
          if (!isOwner) return reply(OWNER_ONLY_MESSAGE);
          const autoResponses = loadCustomAutoResponses();
          if (autoResponses.length === 0) return reply("üìú Nenhuma auto-resposta global definida.");
          
          let responseText = `üìú *Auto-Respostas Globais (${autoResponses.length})*\n\n`;
          autoResponses.forEach((item, index) => {
            const trigger = item.trigger || item.received;
            const responseInfo = item.response;
            
            if (typeof responseInfo === 'string') {
              // Compatibilidade com sistema antigo
              responseText += `${index + 1}. üìù **${trigger}**\n   ‚Ü≥ ${responseInfo}\n\n`;
            } else {
              // Sistema novo com m√≠dia
              const typeEmoji = {
                text: 'üìù',
                image: 'üñºÔ∏è',
                video: 'üé•',
                audio: 'üéµ',
                sticker: 'üé≠'
              };
              responseText += `${index + 1}. ${typeEmoji[responseInfo.type] || 'üìù'} **${trigger}**\n   ‚Ü≥ Tipo: ${responseInfo.type}`;
              if (responseInfo.caption) {
                responseText += `\n   ‚Ü≥ Legenda: ${responseInfo.caption}`;
              }
              responseText += `\n\n`;
            }
          });
          responseText += `üîß Use ${groupPrefix}delauto [n√∫mero] para remover`;
          await reply(responseText);
        } catch (e) {
          console.error('Erro no comando listauto:', e);
          await reply("Ocorreu um erro ao listar auto-respostas üíî");
        }
        break;

      case 'listautoadm':
      case 'listautoadmin':
        try {
          if (!isGroup) return reply('üö´ Este comando s√≥ funciona em grupos!');
          if (!isGroupAdmin) return reply('üö´ Este comando √© apenas para administradores do grupo!');
          
          const autoResponses = loadGroupAutoResponses(from);
          if (autoResponses.length === 0) return reply("üìú Nenhuma auto-resposta do grupo definida.");
          
          let responseText = `üìú *Auto-Respostas do Grupo (${autoResponses.length})*\n\n`;
          autoResponses.forEach((item, index) => {
            const responseInfo = item.response;
            
            if (typeof responseInfo === 'string') {
              responseText += `${index + 1}. üìù **${item.trigger}**\n   ‚Ü≥ ${responseInfo}\n\n`;
            } else {
              const typeEmoji = {
                text: 'üìù',
                image: 'üñºÔ∏è',
                video: 'üé•',
                audio: 'üéµ',
                sticker: 'üé≠'
              };
              responseText += `${index + 1}. ${typeEmoji[responseInfo.type] || 'üìù'} **${item.trigger}**\n   ‚Ü≥ Tipo: ${responseInfo.type}`;
              if (responseInfo.caption) {
                responseText += `\n   ‚Ü≥ Legenda: ${responseInfo.caption}`;
              }
              responseText += `\n\n`;
            }
          });
          responseText += `üîß Use ${groupPrefix}delautoadm [n√∫mero] para remover`;
          await reply(responseText);
        } catch (e) {
          console.error('Erro no comando listautoadm:', e);
          await reply("Ocorreu um erro ao listar auto-respostas do grupo üíî");
        }
        break;
      case 'delautoresponse':
      case 'delauto':
        try {
          if (!isOwner) return reply(OWNER_ONLY_MESSAGE);
          if (!q || isNaN(parseInt(q))) return reply(`Por favor, forne√ßa o n√∫mero da auto-resposta a ser removida. Ex: ${groupPrefix}delauto 1`);
          const index = parseInt(q) - 1;
          const autoResponses = loadCustomAutoResponses();
          if (index < 0 || index >= autoResponses.length) return reply(`‚ùå N√∫mero inv√°lido. Use ${groupPrefix}listauto para ver a lista.`);
          const removed = autoResponses.splice(index, 1)[0];
          if (saveCustomAutoResponses(autoResponses)) {
            const trigger = removed.trigger || removed.received;
            await reply(`üóëÔ∏è Auto-resposta global removida:\nTrigger: ${trigger}`);
          } else {
            await reply("üò• Erro ao remover a auto-resposta. Tente novamente!");
          }
        } catch (e) {
          console.error('Erro no comando delauto:', e);
          await reply("Ocorreu um erro ao remover auto-resposta üíî");
        }
        break;

      case 'delautoadm':
      case 'delautoadmin':
        try {
          if (!isGroup) return reply('üö´ Este comando s√≥ funciona em grupos!');
          if (!isGroupAdmin) return reply('üö´ Este comando √© apenas para administradores do grupo!');
          if (!q || isNaN(parseInt(q))) return reply(`Por favor, forne√ßa o n√∫mero da auto-resposta a ser removida. Ex: ${groupPrefix}delautoadm 1`);
          const index = parseInt(q) - 1;
          const autoResponses = loadGroupAutoResponses(from);
          if (index < 0 || index >= autoResponses.length) return reply(`‚ùå N√∫mero inv√°lido. Use ${groupPrefix}listautoadm para ver a lista.`);
          const removed = autoResponses.splice(index, 1)[0];
          if (saveGroupAutoResponses(from, autoResponses)) {
            await reply(`üóëÔ∏è Auto-resposta do grupo removida:\nTrigger: ${removed.trigger}`);
          } else {
            await reply("üò• Erro ao remover a auto-resposta. Tente novamente!");
          }
        } catch (e) {
          console.error('Erro no comando delautoadm:', e);
          await reply("Ocorreu um erro ao remover auto-resposta do grupo üíî");
        }
        break;

      case 'autoresponses':
      case 'autorespostas':
        try {
          if (!isGroup) return reply('üö´ Este comando s√≥ funciona em grupos!');
          if (!isGroupAdmin) return reply('üö´ Este comando √© apenas para administradores do grupo!');
          
          const globalResponses = loadCustomAutoResponses();
          const groupResponses = loadGroupAutoResponses(from);
          
          let responseText = `üìã *Sistema de Auto-Respostas*\n\n`;
          
          if (globalResponses.length > 0) {
            responseText += `üåç **Auto-Respostas Globais (${globalResponses.length})**\n`;
            globalResponses.forEach((item, index) => {
              const trigger = item.trigger || item.received;
              const responseInfo = item.response;
              
              if (typeof responseInfo === 'string') {
                responseText += `${index + 1}. üìù ${trigger}\n`;
              } else {
                const typeEmoji = {
                  text: 'üìù',
                  image: 'üñºÔ∏è',
                  video: 'üé•',
                  audio: 'üéµ',
                  sticker: 'üé≠'
                };
                responseText += `${index + 1}. ${typeEmoji[responseInfo.type] || 'üìù'} ${trigger}\n`;
              }
            });
            responseText += '\n';
          }
          
          if (groupResponses.length > 0) {
            responseText += `üë• **Auto-Respostas do Grupo (${groupResponses.length})**\n`;
            groupResponses.forEach((item, index) => {
              const responseInfo = item.response;
              
              if (typeof responseInfo === 'string') {
                responseText += `${index + 1}. üìù ${item.trigger}\n`;
              } else {
                const typeEmoji = {
                  text: 'üìù',
                  image: 'üñºÔ∏è',
                  video: 'üé•',
                  audio: 'üéµ',
                  sticker: 'üé≠'
                };
                responseText += `${index + 1}. ${typeEmoji[responseInfo.type] || 'üìù'} ${item.trigger}\n`;
              }
            });
            responseText += '\n';
          }
          
          if (globalResponses.length === 0 && groupResponses.length === 0) {
            responseText += 'üìú Nenhuma auto-resposta configurada.\n\n';
          }
          
          responseText += `üìù **Comandos Dispon√≠veis:**\n`;
          responseText += `‚Ä¢ ${groupPrefix}addautoadm [trigger]/[resposta] - Adicionar texto\n`;
          responseText += `‚Ä¢ ${groupPrefix}addautoadmidia [trigger] - Adicionar m√≠dia\n`;
          responseText += `‚Ä¢ ${groupPrefix}listautoadm - Listar do grupo\n`;
          responseText += `‚Ä¢ ${groupPrefix}delautoadm [n√∫mero] - Remover do grupo\n\n`;
          
          if (isOwner) {
            responseText += `üîß **Comandos do Dono:**\n`;
            responseText += `‚Ä¢ ${groupPrefix}addauto [trigger]/[resposta] - Adicionar global\n`;
            responseText += `‚Ä¢ ${groupPrefix}addautomidia [trigger] - Adicionar m√≠dia global\n`;
            responseText += `‚Ä¢ ${groupPrefix}listauto - Listar globais`;
          }
          
          await reply(responseText);
        } catch (e) {
          console.error('Erro no comando autoresponses:', e);
          await reply("Ocorreu um erro ao listar auto-respostas üíî");
        }
        break;
      case 'addnoprefix':
      case 'addnopref':
        try {
          if (!isOwner) return reply(OWNER_ONLY_MESSAGE);
          if (!q || !q.includes('/')) return reply(`Por favor, forne√ßa a mensagem e o comando separados por /. Ex: ${groupPrefix}addnoprefix f/grupo f\nVoc√™ pode incluir par√¢metros fixos no comando!`);
          const [trigger, ...commandParts] = q.split('/');
          const targetCommand = commandParts.join('/').trim();
          if (!trigger.trim() || !targetCommand) return reply("Formato inv√°lido. Use: mensagem/comando [par√¢metros]");
          // Otimiza√ß√£o: Cache de comandos sem prefixo
          const noPrefixCommands = await optimizer.memoize(
            `noprefix:${from}`,
            () => Promise.resolve(loadNoPrefixCommands()),
            10000 // 10 segundos
          );
          if (noPrefixCommands.some(cmd => cmd.trigger === trigger.trim())) {
            return reply(`A mensagem "${trigger.trim()}" j√° est√° mapeada para um comando.`);
          }
          const commandWords = targetCommand.split(' ');
          const baseCommand = normalizar(commandWords[0]);
          const fixedParams = commandWords.slice(1).join(' ');
          
          noPrefixCommands.push({
            trigger: trigger.trim(),
            command: baseCommand,
            fixedParams: fixedParams || ''
          });
          if (saveNoPrefixCommands(noPrefixCommands)) {
            // Invalida cache ap√≥s salvar
            optimizer.clearStatic(`noprefix:${from}`);
            await reply(`‚úÖ Comando sem prefixo adicionado!\nMensagem: ${trigger.trim()}\nComando: ${targetCommand}`);
          } else {
            await reply("üò• Erro ao salvar o comando sem prefixo. Tente novamente!");
          }
        } catch (e) {
          console.error('Erro no comando addnoprefix:', e);
          await reply("Ocorreu um erro ao adicionar comando sem prefixo üíî");
        }
        break;
      case 'listnoprefix':
      case 'listnopref':
        try {
          if (!isOwner) return reply(OWNER_ONLY_MESSAGE);
          // Otimiza√ß√£o: Cache de comandos sem prefixo
          const noPrefixCommands = await optimizer.memoize(
            `noprefix:${from}`,
            () => Promise.resolve(loadNoPrefixCommands()),
            10000 // 10 segundos
          );
          if (noPrefixCommands.length === 0) return reply("üìú Nenhum comando sem prefixo definido.");
          let responseText = `üìú *Comandos Sem Prefixo do Grupo ${groupName}*\n\n`;
          noPrefixCommands.forEach((item, index) => {
            const fullCommand = item.fixedParams ? `${item.command} ${item.fixedParams}` : item.command;
            responseText += `${index + 1}. Mensagem: ${item.trigger}\n   Comando: ${fullCommand}\n`;
          });
          await reply(responseText);
        } catch (e) {
          console.error('Erro no comando listnoprefix:', e);
          await reply("Ocorreu um erro ao listar comandos sem prefixo üíî");
        }
        break;
      case 'delnoprefix':
      case 'delnopref':
        try {
          if (!isOwner) return reply(OWNER_ONLY_MESSAGE);
          if (!q || isNaN(parseInt(q))) return reply(`Por favor, forne√ßa o n√∫mero do comando sem prefixo a ser removido. Ex: ${groupPrefix}delnoprefix 1`);
          const index = parseInt(q) - 1;
          // Otimiza√ß√£o: Cache de comandos sem prefixo
          const noPrefixCommands = await optimizer.memoize(
            `noprefix:${from}`,
            () => Promise.resolve(loadNoPrefixCommands()),
            10000 // 10 segundos
          );
          if (index < 0 || index >= noPrefixCommands.length) return reply(`‚ùå N√∫mero inv√°lido. Use ${groupPrefix}listnoprefix para ver a lista.`);
          const removed = noPrefixCommands.splice(index, 1)[0];
          if (saveNoPrefixCommands(noPrefixCommands)) {
            // Invalida cache ap√≥s salvar
            optimizer.clearStatic(`noprefix:${from}`);
            await reply(`üóëÔ∏è Comando sem prefixo removido:\nMensagem: ${removed.trigger}\nComando: ${removed.command}`);
          } else {
            await reply("üò• Erro ao remover o comando sem prefixo. Tente novamente!");
          }
        } catch (e) {
          console.error('Erro no comando delnoprefix:', e);
          await reply("Ocorreu um erro ao remover comando sem prefixo üíî");
        }
        break;
      case 'addalias':
        try {
          if (!isOwner) return reply(OWNER_ONLY_MESSAGE);
          if (!q || !q.includes('/')) return reply(`Por favor, forne√ßa o apelido e o comando separados por /. Ex: ${groupPrefix}addalias h/hidetag\nVoc√™ pode incluir par√¢metros fixos no comando!`);
          const [alias, ...commandParts] = q.split('/');
          const targetCommand = commandParts.join('/').trim();
          if (!alias.trim() || !targetCommand) return reply("Formato inv√°lido. Use: apelido/comando [par√¢metros]");
          const aliases = loadCommandAliases();
          if (aliases.some(item => item.alias === normalizar(alias.trim()))) {
            return reply(`O apelido "${alias.trim()}" j√° est√° em uso.`);
          }
          const commandWords = targetCommand.split(' ');
          const baseCommand = normalizar(commandWords[0]);
          const fixedParams = commandWords.slice(1).join(' ');
          
          aliases.push({
            alias: normalizar(alias.trim()),
            command: baseCommand,
            fixedParams: fixedParams || ''
          });
          if (saveCommandAliases(aliases)) {
            await reply(`‚úÖ Apelido adicionado!\nApelido: ${groupPrefix}${alias.trim()}\nComando: ${groupPrefix}${targetCommand}`);
          } else {
            await reply("üò• Erro ao salvar o apelido. Tente novamente!");
          }
        } catch (e) {
          console.error('Erro no comando addalias:', e);
          await reply("Ocorreu um erro ao adicionar apelido üíî");
        }
        break;
      case 'listalias':
        try {
          if (!isOwner) return reply(OWNER_ONLY_MESSAGE);
          const aliases = loadCommandAliases();
          if (aliases.length === 0) return reply("üìú Nenhum apelido de comando definido.");
          let responseText = `üìú *Apelidos de Comandos do Grupo ${groupName}*\n\n`;
          aliases.forEach((item, index) => {
            const fullCommand = item.fixedParams ? `${item.command} ${item.fixedParams}` : item.command;
            responseText += `${index + 1}. Apelido: ${groupPrefix}${item.alias}\n   Comando: ${groupPrefix}${fullCommand}\n`;
          });
          await reply(responseText);
        } catch (e) {
          console.error('Erro no comando listaliases:', e);
          await reply("Ocorreu um erro ao listar apelidos üíî");
        }
        break;
      case 'delalias':
        try {
          if (!isOwner) return reply(OWNER_ONLY_MESSAGE);
          if (!q || isNaN(parseInt(q))) return reply(`Por favor, forne√ßa o n√∫mero do apelido a ser removido. Ex: ${groupPrefix}delalias 1`);
          const index = parseInt(q) - 1;
          const aliases = loadCommandAliases();
          if (index < 0 || index >= aliases.length) return reply(`‚ùå N√∫mero inv√°lido. Use ${groupPrefix}listaliases para ver a lista.`);
          const removed = aliases.splice(index, 1)[0];
          if (saveCommandAliases(aliases)) {
            await reply(`üóëÔ∏è Apelido removido:\nApelido: ${groupPrefix}${removed.alias}\nComando: ${groupPrefix}${removed.command}`);
          } else {
            await reply("üò• Erro ao remover o apelido. Tente novamente!");
          }
        } catch (e) {
          console.error('Erro no comando delalias:', e);
          await reply("Ocorreu um erro ao remover apelido üíî");
        }
        break;

      case 'addcmd':
      case 'adicionarcmd':
        try {
          if (!isOwner) return reply(OWNER_ONLY_MESSAGE);
          
          const allTokens = q.trim().split(/ +/);
          const trigger = allTokens.shift();
          // parse meta tokens like [admin], [owner], [group], [private], [param:name:required]
          const parsed = parseCustomCommandMeta(allTokens);
          const settings = parsed.settings || {};
          const responseText = parsed.rest.join(' ');
          const addcmdHelp = `üìù *Como usar o comando addcmd:*\n\n*Adicionar texto:*\n${groupPrefix}addcmd <comando> [meta...] <resposta>\n\n*Adicionar m√≠dia:*\n${groupPrefix}addcmdmidia <comando> [meta...] (respondendo uma m√≠dia)\n\n*Metatags / Flags suportadas:*\n‚Ä¢ [owner] ‚Äî Somente o dono do bot pode usar\n‚Ä¢ [admin] ‚Äî Somente admins do grupo podem usar (somente em grupos)\n‚Ä¢ [group] ‚Äî Restrito a grupos\n‚Ä¢ [private] ‚Äî Restrito ao privado\n‚Ä¢ [param:type:name:required] ‚Äî Par√¢metro posicional (informe type e name).\n‚Ä¢ [param:type:name:rest] ‚Äî Define que o par√¢metro captura o resto da mensagem (√∫ltimo par√¢metro).\n‚Ä¢ [param:type:name:min=1:max=10:default=5] ‚Äî N√∫meros com limites e valor padr√£o.\n‚Ä¢ [param:regex:name:pattern=^\\\d+$] ‚Äî Valida√ß√£o por regex.\n‚Ä¢ [param:enum:name:enum=a|b|c] ‚Äî Valor deve ser um dos listados (enum).\n\n*Placeholders (na resposta):*\n‚Ä¢ {prefixo} - Prefixo do bot\n‚Ä¢ {nomedono} - Nome do dono\n‚Ä¢ {numerodono} - N√∫mero do dono\n‚Ä¢ {nomebot} - Nome do bot\n‚Ä¢ {user} - Nome do usu√°rio\n‚Ä¢ {grupo} - Nome do grupo\n‚Ä¢ {groupdesc} - Descri√ß√£o do grupo (se existir)\n‚Ä¢ {velocidade} ou {speed} - Lat√™ncia do bot em segundos\n‚Ä¢ {1}, {2}, ... - Argumentos por posi√ß√£o (1-based)\n‚Ä¢ {args} ou {all} - Todos os argumentos\n\n*Exemplos:*\n‚Ä¢ Texto simples:\n${groupPrefix}addcmd saudacao [param:string:name:required] [admin] Ol√° {name}! Bem-vindo ao {grupo}!\n‚Ä¢ Par√¢metro num√©rico com min/max:\n${groupPrefix}addcmd roll [param:number:count:required:min=1:max=100] Sorteando {count} vezes...\n‚Ä¢ Par√¢metro enum (apenas valores permitidos):\n${groupPrefix}addcmd cor [param:enum:color:required:enum=red|green|blue] Voc√™ escolheu {color}.\n‚Ä¢ Par√¢metro rest (captura texto com espa√ßos):\n${groupPrefix}addcmd bio [param:string:description:rest:optional] Novo perfil: {description}\n‚Ä¢ Regex validation (PIN de 4 d√≠gitos):\n${groupPrefix}addcmd pin [param:regex:pin:required:pattern=^\\\d{4}$] PIN configurado: {pin}\n‚Ä¢ Par√¢metro booleano (aceita true/false/yes/no):\n${groupPrefix}addcmd allow [param:boolean:enabled:optional] Status: {enabled}\n‚Ä¢ Edi√ß√£o de comando:\n${groupPrefix}edcmd saudacao [param:string:name:required] Ol√° {name}! (altera resposta e meta do comando existente)\n‚Ä¢ M√≠dia com legenda e par√¢metro:\n${groupPrefix}addcmdmidia logo [private] [param:string:filename:optional] (responder uma imagem com legenda que aceita {filename})\n\n*Formato de execu√ß√£o dos par√¢metros (quando definidos em m√∫ltiplos):*\n‚Ä¢ Use separadores: "/" ou "|" ou espa√ßo.\n‚Ä¢ Exemplo de execu√ß√£o: ${groupPrefix}meucomando valor1/valor2 ou ${groupPrefix}meucomando valor1 | valor2 ou ${groupPrefix}meucomando valor1 valor2.\n‚Ä¢ Se o comando foi criado com: ${groupPrefix}addcmd nomecmd <[sla:required]/[sla2:required]>, para executar: ${groupPrefix}nomecmd abc/123 que preencher√° {sla} com abc e {sla2} com 123.`;
          
          if (!responseText && !quotedMessageContent) {
            return reply(addcmdHelp);
          }
          
          const normalizedTrigger = normalizar(trigger).replace(/\s+/g, '');
          
          // Verificar se j√° existe
          const existingCmd = findCustomCommand(normalizedTrigger);
          if (existingCmd) {
            return reply(`‚ùå J√° existe um comando com o gatilho "${trigger}".\nUse ${groupPrefix}delcmd ${trigger} para remov√™-lo primeiro.`);
          }
          
          // Otimiza√ß√£o: Cache de comandos personalizados
          const commands = await optimizer.memoize(
            `customcmds:${from}`,
            () => Promise.resolve(loadCustomCommands()),
            10000 // 10 segundos
          );
          const usage = buildUsageFromParams(trigger, settings.params || []);
          commands.push({
            id: Date.now().toString(),
            trigger: normalizedTrigger,
            response: responseText,
            createdAt: new Date().toISOString(),
            createdBy: sender
          , settings: settings, usage: usage
          });
          
          if (saveCustomCommands(commands)) {
            // Invalida cache ap√≥s salvar
            optimizer.clearStatic(`customcmds:${from}`);
            const flagList = [];
            if (settings.ownerOnly) flagList.push('Dono');
            if (settings.adminOnly) flagList.push('Admin');
            if (settings.context === 'group') flagList.push('Grupo');
            if (settings.context === 'private') flagList.push('Privado');
            const flagsStr = flagList.length ? `\n*Flags:* ${flagList.join(', ')}` : '';
            const usageStr = usage ? `\n*Uso:* ${usage}` : '';
            await reply(`‚úÖ Comando personalizado criado!\n\n*Gatilho:* ${trigger}\n*Resposta:* ${responseText.substring(0, 100)}${responseText.length > 100 ? '...' : ''}${flagsStr}${usageStr}\n\n_Digite "${trigger}" para testar!_`);
          } else {
            await reply('‚ùå Erro ao salvar o comando personalizado.');
          }
        } catch (e) {
          console.error('Erro no comando addcmd:', e);
          await reply("‚ùå Ocorreu um erro ao adicionar comando personalizado.");
        }
        break;

      case 'edcmd':
      case 'editcmd':
        try {
          if (!isOwner) return reply(OWNER_ONLY_MESSAGE);
          if (!q) return reply(`‚ùå Forne√ßa o gatilho do comando a ser editado. Ex: ${groupPrefix}edcmd saudacao [param:name:required] Nova resposta aqui`);
          const allTokens = q.trim().split(/ +/);
          const trigger = allTokens.shift();
          if (!trigger) return reply(`‚ùå Forne√ßa o gatilho do comando a ser editado.`);
          const normalizedTrigger = normalizar(trigger).replace(/\s+/g, '');
          const existingCmd = findCustomCommand(normalizedTrigger);
          if (!existingCmd) return reply(`‚ùå Comando ${trigger} n√£o encontrado.`);
          const parsed = parseCustomCommandMeta(allTokens);
          const settings = parsed.settings || existingCmd.settings || {};
          const responseText = parsed.rest.join(' ');
          const updatedCmd = { ...existingCmd };
          if (responseText) updatedCmd.response = responseText;
          updatedCmd.settings = settings;
          updatedCmd.usage = buildUsageFromParams(updatedCmd.trigger, settings.params || []);
          // Otimiza√ß√£o: Cache de comandos personalizados
          const commands = await optimizer.memoize(
            `customcmds:${from}`,
            () => Promise.resolve(loadCustomCommands()),
            10000 // 10 segundos
          );
          const idx = commands.findIndex(c => c.trigger === existingCmd.trigger);
          if (idx !== -1) {
            commands[idx] = updatedCmd;
            if (saveCustomCommands(commands)) {
            // Invalida cache ap√≥s salvar
            optimizer.clearStatic(`customcmds:${from}`);
              await reply(`‚úÖ Comando atualizado: ${trigger}\n*Uso:* ${updatedCmd.usage}`);
            } else {
              await reply('‚ùå Erro ao salvar edi√ß√£o do comando.');
            }
          } else {
            return reply('‚ùå N√£o foi poss√≠vel localizar o comando para editar.');
          }
        } catch (e) {
          console.error('Erro no comando edcmd:', e);
          await reply('‚ùå Ocorreu um erro ao editar o comando.');
        }
        break;

      case 'edcmdmidia':
      case 'editcmdmidia':
        try {
          if (!isOwner) return reply(OWNER_ONLY_MESSAGE);
          if (!q) return reply(`‚ùå Forne√ßa o gatilho do comando a ser editado. Ex: ${groupPrefix}edcmdmidia logo (responda imagem)`);
          const allTokens = q.trim().split(/ +/);
          const trigger = allTokens.shift();
          if (!trigger) return reply(`‚ùå Forne√ßa o gatilho do comando a ser editado.`);
          const normalizedTrigger = normalizar(trigger).replace(/\s+/g, '');
          const existingCmd = findCustomCommand(normalizedTrigger);
          if (!existingCmd) return reply(`‚ùå Comando ${trigger} n√£o encontrado.`);
          const parsed = parseCustomCommandMeta(allTokens);
          const settings = parsed.settings || existingCmd.settings || {};
          const caption = parsed.rest.join(' ');
          if (!quotedMessageContent) return reply('‚ùå Por favor responda uma m√≠dia para atualizar a resposta do comando.');
          let responseData = null;
          if (isQuotedImage) {
            const imageBuffer = await getFileBuffer(quotedMessageContent.imageMessage, 'image');
            responseData = { type: 'image', buffer: imageBuffer.toString('base64'), caption };
          } else if (isQuotedVideo) {
            const videoBuffer = await getFileBuffer(quotedMessageContent.videoMessage, 'video');
            responseData = { type: 'video', buffer: videoBuffer.toString('base64'), caption };
          } else if (isQuotedAudio) {
            const audioBuffer = await getFileBuffer(quotedMessageContent.audioMessage, 'audio');
            responseData = { type: 'audio', buffer: audioBuffer.toString('base64'), ptt: quotedMessageContent.audioMessage.ptt || false };
          } else if (isQuotedSticker) {
            const stickerBuffer = await getFileBuffer(quotedMessageContent.stickerMessage, 'sticker');
            responseData = { type: 'sticker', buffer: stickerBuffer.toString('base64') };
          } else {
            return reply('‚ùå Por favor, responda a uma m√≠dia v√°lida (imagem, v√≠deo, √°udio ou sticker)!');
          }
          const updatedCmd = { ...existingCmd };
          if (responseData) updatedCmd.response = responseData;
          updatedCmd.settings = settings;
          updatedCmd.usage = buildUsageFromParams(updatedCmd.trigger, settings.params || []);
          // Otimiza√ß√£o: Cache de comandos personalizados
          const commands = await optimizer.memoize(
            `customcmds:${from}`,
            () => Promise.resolve(loadCustomCommands()),
            10000 // 10 segundos
          );
          const idx = commands.findIndex(c => c.trigger === existingCmd.trigger);
          if (idx !== -1) {
            commands[idx] = updatedCmd;
            if (saveCustomCommands(commands)) {
            // Invalida cache ap√≥s salvar
            optimizer.clearStatic(`customcmds:${from}`);
              await reply(`‚úÖ Comando de m√≠dia atualizado: ${trigger}\n*Uso:* ${updatedCmd.usage}`);
            } else {
              await reply('‚ùå Erro ao salvar edi√ß√£o do comando de m√≠dia.');
            }
          } else {
            return reply('‚ùå N√£o foi poss√≠vel localizar o comando para editar.');
          }
        } catch (e) {
          console.error('Erro no comando edcmdmidia:', e);
          await reply('‚ùå Ocorreu um erro ao editar o comando de m√≠dia.');
        }
        break;

      case 'addcmdmidia':
      case 'addcmdmedia':
        try {
          if (!isOwner) return reply(OWNER_ONLY_MESSAGE);
          
          if (!q) {
            return reply(`üìù *Como usar o comando addcmdmidia:*\n\n1Ô∏è‚É£ Responda uma m√≠dia (imagem, v√≠deo, √°udio ou figurinha)\n2Ô∏è‚É£ Use: ${groupPrefix}addcmdmidia <comando> <legenda opcional>\n\n*Par√¢metros dispon√≠veis na legenda:*\n‚Ä¢ {prefixo} - Prefixo do bot\n‚Ä¢ {nomedono} - Nome do dono\n‚Ä¢ {numerodono} - N√∫mero do dono\n‚Ä¢ {nomebot} - Nome do bot\n‚Ä¢ {user} - Nome do usu√°rio\n‚Ä¢ {grupo} - Nome do grupo\n\n*Exemplo:*\n${groupPrefix}addcmdmidia logo (respondendo uma imagem)`);
          }
          
          const allTokens = q.trim().split(/ +/);
          const trigger = allTokens.shift();
          const parsed = parseCustomCommandMeta(allTokens);
          const settings = parsed.settings || {};
          const caption = parsed.rest.join(' ') || '';
          const addcmdMidiaHelp = `üìù *Como usar o comando addcmdmidia:*\n\n1Ô∏è‚É£ Responda uma m√≠dia (imagem, v√≠deo, √°udio ou figurinha)\n2Ô∏è‚É£ Use: ${groupPrefix}addcmdmidia <comando> [meta...] <legenda opcional>\n\n*Metatags / Flags suportadas:*\n‚Ä¢ [owner] ‚Äî Somente o dono do bot pode usar\n‚Ä¢ [admin] ‚Äî Somente admins do grupo podem usar (somente em grupos)\n‚Ä¢ [group] ‚Äî Restrito a grupos\n‚Ä¢ [private] ‚Äî Restrito ao privado\n‚Ä¢ [param:type:name:required] ‚Äî Par√¢metro posicional\n‚Ä¢ [param:type:name:rest] ‚Äî Captura resto da mensagem para legenda\n‚Ä¢ [param:type:name:min=1:max=10:default=5] ‚Äî Min/max/default para n√∫meros\n‚Ä¢ [param:regex:name:pattern=^\\\d+$] ‚Äî Regex para validar\n\n*Placeholders (na legenda):*\n‚Ä¢ {prefixo} - Prefixo do bot\n‚Ä¢ {nomedono} - Nome do dono\n‚Ä¢ {numerodono} - N√∫mero do dono\n‚Ä¢ {nomebot} - Nome do bot\n‚Ä¢ {user} - Nome do usu√°rio\n‚Ä¢ {grupo} - Nome do grupo\n‚Ä¢ {1}, {2}, ... - Argumentos por posi√ß√£o (1-based)\n‚Ä¢ {args} ou {all} - Todos os argumentos\n\n*Exemplos:*\n‚Ä¢ Responder imagem com legenda que usa par√¢metro de arquivo:\n${groupPrefix}addcmdmidia logo [private] [param:string:filename:optional] (responder uma imagem com legenda que aceita {filename})`;
          
          if (!trigger) {
            return reply(addcmdMidiaHelp);
          }
          
          const normalizedTrigger = normalizar(trigger).replace(/\s+/g, '');
          
          // Verificar se j√° existe
          const existingCmd = findCustomCommand(normalizedTrigger);
          if (existingCmd) {
            return reply(`‚ùå J√° existe um comando com o gatilho "${trigger}".\nUse ${groupPrefix}delcmd ${trigger} para remov√™-lo primeiro.`);
          }
          
          let responseData = null;
          
          // Verificar se respondeu uma m√≠dia
          if (quotedMessageContent) {
            if (isQuotedImage) {
              const imageBuffer = await getFileBuffer(quotedMessageContent.imageMessage, 'image');
              responseData = {
                type: 'image',
                buffer: imageBuffer.toString('base64'),
                caption: caption
              };
            } else if (isQuotedVideo) {
              const videoBuffer = await getFileBuffer(quotedMessageContent.videoMessage, 'video');
              responseData = {
                type: 'video',
                buffer: videoBuffer.toString('base64'),
                caption: caption
              };
            } else if (isQuotedAudio) {
              const audioBuffer = await getFileBuffer(quotedMessageContent.audioMessage, 'audio');
              responseData = {
                type: 'audio',
                buffer: audioBuffer.toString('base64'),
                ptt: quotedMessageContent.audioMessage.ptt || false
              };
            } else if (isQuotedSticker) {
              const stickerBuffer = await getFileBuffer(quotedMessageContent.stickerMessage, 'sticker');
              responseData = {
                type: 'sticker',
                buffer: stickerBuffer.toString('base64')
              };
            } else {
              return reply('‚ùå Por favor, responda a uma m√≠dia v√°lida (imagem, v√≠deo, √°udio ou sticker)!');
            }
          } else {
            return reply('‚ùå Por favor, responda a uma m√≠dia para adicionar como comando!');
          }
          
          // Otimiza√ß√£o: Cache de comandos personalizados
          const commands = await optimizer.memoize(
            `customcmds:${from}`,
            () => Promise.resolve(loadCustomCommands()),
            10000 // 10 segundos
          );
          const usage = buildUsageFromParams(trigger, settings.params || []);
          commands.push({
            id: Date.now().toString(),
            trigger: normalizedTrigger,
            response: responseData,
            createdAt: new Date().toISOString(),
            createdBy: sender
          , settings: settings, usage: usage
          });
          
          if (saveCustomCommands(commands)) {
            // Invalida cache ap√≥s salvar
            optimizer.clearStatic(`customcmds:${from}`);
            const flagList = [];
            if (settings.ownerOnly) flagList.push('Dono');
            if (settings.adminOnly) flagList.push('Admin');
            if (settings.context === 'group') flagList.push('Grupo');
            if (settings.context === 'private') flagList.push('Privado');
            const flagsStr = flagList.length ? `\n*Flags:* ${flagList.join(', ')}` : '';
            const usageStr = usage ? `\n*Uso:* ${usage}` : '';
            await reply(`‚úÖ Comando personalizado com m√≠dia criado!\n\n*Gatilho:* ${trigger}\n*Tipo:* ${responseData.type}\n${caption ? `*Legenda:* ${caption}\n` : ''}${flagsStr}${usageStr}\n_Digite "${trigger}" para testar!_`);
          } else {
            await reply('‚ùå Erro ao salvar o comando personalizado.');
          }
        } catch (e) {
          console.error('Erro no comando addcmdmidia:', e);
          await reply("‚ùå Ocorreu um erro ao adicionar comando personalizado com m√≠dia.");
        }
        break;

      case 'listcmd':
      case 'listarcmd':
      case 'comandospersonalizados':
        try {
          if (!isOwner) return reply(OWNER_ONLY_MESSAGE);
          
          // Otimiza√ß√£o: Cache de comandos personalizados
          const commands = await optimizer.memoize(
            `customcmds:${from}`,
            () => Promise.resolve(loadCustomCommands()),
            10000 // 10 segundos
          );
          if (commands.length === 0) {
            return reply(`üìú *Nenhum comando personalizado criado.*\n\nUse ${groupPrefix}addcmd para criar um!`);
          }
          
          let responseText = `üìú *Comandos Personalizados (${commands.length})*\n\n`;
          
          commands.forEach((cmd, index) => {
            const responseInfo = cmd.response;
            const displayTrigger = cmd.trigger;
            const settings = cmd.settings || {};
            const flags = [];
            if (settings.ownerOnly) flags.push('üîê Dono');
            if (settings.adminOnly) flags.push('üîê Admin');
            if (settings.context === 'group') flags.push('üìç Grupo');
            if (settings.context === 'private') flags.push('üìÆ Privado');
            const flagsText = flags.length ? ` ${flags.join(' ')}` : '';
            
            if (typeof responseInfo === 'string') {
              const preview = responseInfo.length > 50 ? responseInfo.substring(0, 50) + '...' : responseInfo;
              responseText += `${index + 1}. üìù *${displayTrigger}*${flagsText}\n   ‚Ü≥ ${preview}\n${cmd.usage ? `   ‚Ü≥ Uso: ${cmd.usage}\n` : ''}\n`;
            } else if (responseInfo && typeof responseInfo === 'object') {
              const typeEmoji = {
                text: 'üìù',
                image: 'üñºÔ∏è',
                video: 'üé•',
                audio: 'üéµ',
                sticker: 'üé≠'
              };
              responseText += `${index + 1}. ${typeEmoji[responseInfo.type] || 'üìù'} *${displayTrigger}*${flagsText}\n   ‚Ü≥ Tipo: ${responseInfo.type}${cmd.usage ? `\n   ‚Ü≥ Uso: ${cmd.usage}` : ''}`;
              if (responseInfo.caption) {
                responseText += `\n   ‚Ü≥ Legenda: ${responseInfo.caption.substring(0, 40)}${responseInfo.caption.length > 40 ? '...' : ''}`;
              }
              responseText += `\n\n`;
            }
          });
          
          responseText += `\nüîß *Comandos dispon√≠veis:*\n`;
          responseText += `‚Ä¢ ${groupPrefix}addcmd <cmd> <resposta>\n`;
          responseText += `‚Ä¢ ${groupPrefix}addcmdmidia <cmd> (com m√≠dia)\n`;
          responseText += `‚Ä¢ ${groupPrefix}delcmd <n√∫mero>\n`;
          responseText += `‚Ä¢ ${groupPrefix}testcmd <cmd>`;
          responseText += `\n\n*Placeholders dispon√≠veis para respostas:*
‚Ä¢ {args} ou {all} - Todos os argumentos passados ap√≥s o gatilho
‚Ä¢ {1}, {2}, ... - Argumentos por posi√ß√£o (1-based)
‚Ä¢ {mention} - Men√ß√£o ao primeiro usu√°rio marcado na mensagem
‚Ä¢ {mentions} - Men√ß√£o a todos os marcados na mensagem
‚Ä¢ {quoted} - Texto da mensagem citada (quando houver)`;
          
          await reply(responseText);
        } catch (e) {
          console.error('Erro no comando listcmd:', e);
          await reply("‚ùå Ocorreu um erro ao listar comandos personalizados.");
        }
        break;

      case 'delcmd':
      case 'removercmd':
        try {
          if (!isOwner) return reply(OWNER_ONLY_MESSAGE);
          
          if (!q) {
            return reply(`‚ùå Forne√ßa o n√∫mero ou nome do comando.\n\nExemplo:\n‚Ä¢ ${groupPrefix}delcmd 1\n‚Ä¢ ${groupPrefix}delcmd bemvindo`);
          }
          
          const arg = q.trim();
          let result;
          
          // Tentar por n√∫mero primeiro
          if (!isNaN(parseInt(arg))) {
            const index = parseInt(arg) - 1;
            // Otimiza√ß√£o: Cache de comandos personalizados
          const commands = await optimizer.memoize(
            `customcmds:${from}`,
            () => Promise.resolve(loadCustomCommands()),
            10000 // 10 segundos
          );
            
            if (index < 0 || index >= commands.length) {
              return reply(`‚ùå N√∫mero inv√°lido. Use ${groupPrefix}listcmd para ver a lista.`);
            }
            
            const removed = commands[index];
            result = removeCustomCommand(cmd => cmd.id === removed.id);
            
            if (result.removed) {
              await reply(`üóëÔ∏è *Comando removido!*\n\n*Gatilho:* ${removed.trigger}\n*Tipo:* ${typeof removed.response === 'string' ? 'texto' : removed.response.type}`);
            } else {
              await reply('‚ùå Erro ao remover o comando.');
            }
          } else {
            // Remover por nome
            const normalizedTrigger = normalizar(arg).replace(/\s+/g, '');
            const cmd = findCustomCommand(normalizedTrigger);
            
            if (!cmd) {
              return reply(`‚ùå Comando "${arg}" n√£o encontrado.\n\nUse ${groupPrefix}listcmd para ver todos os comandos.`);
            }
            
            result = removeCustomCommand(c => c.id === cmd.id);
            
            if (result.removed) {
              await reply(`üóëÔ∏è *Comando removido!*\n\n*Gatilho:* ${cmd.trigger}\n*Tipo:* ${typeof cmd.response === 'string' ? 'texto' : cmd.response.type}`);
            } else {
              await reply('‚ùå Erro ao remover o comando.');
            }
          }
        } catch (e) {
          console.error('Erro no comando delcmd:', e);
          await reply("‚ùå Ocorreu um erro ao remover comando personalizado.");
        }
        break;

      case 'testcmd':
      case 'testarcmd':
        try {
          if (!isOwner) return reply(OWNER_ONLY_MESSAGE);
          
          if (!q) {
            return reply(`‚ùå Forne√ßa o nome do comando para testar.\n\nExemplo: ${groupPrefix}testcmd bemvindo`);
          }
          
          const rawParts = q.trim().split(/ +/);
          const testTrigger = rawParts[0] || '';
          const testArgsStr = rawParts.slice(1).join(' ');
          const normalizedTrigger = normalizar(testTrigger).replace(/\s+/g, '');
          const cmd = findCustomCommand(normalizedTrigger);
          const settings = cmd?.settings || {};
          if (settings && settings.params && settings.params.length) {
            const argsForTest = testArgsStr || '';
            let argsListTest = parseArgsFromString(argsForTest);
            const restIndexTest = settings.params.findIndex(p => p.rest);
            if (restIndexTest !== -1 && restIndexTest < settings.params.length) {
              if (argsListTest.length > restIndexTest) {
                const restVal = argsListTest.slice(restIndexTest).join(' ');
                argsListTest = argsListTest.slice(0, restIndexTest);
                argsListTest[restIndexTest] = restVal;
              }
            }
            // Support named args in test mode (key=value)
            if (Array.isArray(argsListTest) && argsListTest.some(t => t.includes('='))) {
              const namedMapTest = {};
              const remainingPos = [];
              for (const t of argsListTest) {
                const idxEq = t.indexOf('=');
                if (idxEq > 0) {
                  const k = normalizar(t.slice(0, idxEq)).replace(/\s+/g, '_');
                  const v = t.slice(idxEq + 1);
                  namedMapTest[k] = v;
                } else {
                  remainingPos.push(t);
                }
              }
              const finalTestArgs = [];
              for (let i = 0; i < settings.params.length; i++) {
                const p = settings.params[i];
                if (Object.prototype.hasOwnProperty.call(namedMapTest, p.name)) finalTestArgs[i] = namedMapTest[p.name];
                else finalTestArgs[i] = remainingPos.length ? remainingPos.shift() : '';
              }
              // join rest if any
              if (restIndexTest !== -1) {
                const restVal = finalTestArgs.slice(restIndexTest).join(' ');
                finalTestArgs.splice(restIndexTest, finalTestArgs.length - restIndexTest, restVal);
              }
              argsListTest = finalTestArgs;
            }
            const missingTest = [];
            for (let i = 0; i < settings.params.length; i++) {
              const p = settings.params[i];
              let val = typeof argsListTest[i] !== 'undefined' ? argsListTest[i] : '';
              if ((val === '' || typeof val === 'undefined') && typeof p.default !== 'undefined') {
                val = p.default;
                argsListTest[i] = val;
              }
              if (p.required && (typeof val === 'undefined' || val === '')) missingTest.push(p.name);
              if (typeof val !== 'undefined' && val !== '') {
                const check = validateParamValue(val, p);
                if (!check.ok) return reply(`‚ùå Par√¢metro inv√°lido: ${check.message}`);
              }
            }
            if (missingTest.length) {
              const usage = cmd.usage || buildUsageFromParams(cmd.trigger, settings.params);
              return reply(`‚ùå Faltam par√¢metros obrigat√≥rios: ${missingTest.map(m => m.name).join(', ')}\nUso: ${usage}`);
            }
          }
          
          if (!cmd) {
            return reply(`‚ùå Comando "${q}" n√£o encontrado.\n\nUse ${groupPrefix}listcmd para ver todos os comandos.`);
          }
          
          await reply(`üß™ *Testando comando: ${cmd.trigger}*\n\n_Executando..._`);
          
          // Simular execu√ß√£o
          const responseData = cmd.response;
          let processedResponse = responseData;
          
          if (typeof processedResponse === 'string') {
            processedResponse = processedResponse
              .replace(/{prefixo}/gi, groupPrefix)
              .replace(/{prefix}/gi, groupPrefix)
              .replace(/{nomedono}/gi, nomedono)
              .replace(/{numerodono}/gi, numerodono)
              .replace(/{nomebot}/gi, nomebot)
              .replace(/{user}/gi, pushname || 'Usu√°rio')
              .replace(/{grupo}/gi, isGroup ? groupName : 'Privado');
            // extras de teste: args/posi√ß√µes/men√ß√£o/quoted
            const testArgs = testArgsStr || '';
            const argsListTest = parseArgsFromString(testArgs);
            const paramsMapTest = {};
            if (Array.isArray(settings.params)) {
              for (let i = 0; i < settings.params.length; i++) {
                const p = settings.params[i];
                paramsMapTest[p.name] = argsListTest[i] || '';
              }
            }
            processedResponse = processedResponse.replace(/\{(?:args|all)\}/gi, testArgs);
            processedResponse = processedResponse.replace(/\{(\d+)\}/g, (m, idx) => {
              const i = parseInt(idx, 10) - 1;
              return argsListTest[i] || '';
            });
            // Named param replacements in test mode
            for (const nm in paramsMapTest) {
              if (!Object.prototype.hasOwnProperty.call(paramsMapTest, nm)) continue;
              const val = paramsMapTest[nm];
              if (typeof val === 'undefined' || val === '') continue;
              try {
                const re = new RegExp('\\{' + escapeRegExp(nm) + '\\}', 'gi');
                processedResponse = processedResponse.replace(re, val);
              } catch (err) {
                console.warn('Warn: Invalid param name during test regex replace:', nm, err.message);
              }
            }
            const mentionedJidsTest = info.message?.extendedTextMessage?.contextInfo?.mentionedJid || [];
            let mentionsToIncludeTest = Array.isArray(mentionedJidsTest) ? mentionedJidsTest : [];
            if (!mentionsToIncludeTest.length && typeof menc_os2 !== 'undefined' && menc_os2) mentionsToIncludeTest = [menc_os2];
            const mentionsTextTest = Array.isArray(mentionsToIncludeTest) && mentionsToIncludeTest.length ? mentionsToIncludeTest.map(m => '@' + getUserName(m)).join(' ') : '';
            processedResponse = processedResponse.replace(/\{mention\}/gi, mentionsTextTest);
            processedResponse = processedResponse.replace(/\{mentions\}/gi, mentionsTextTest);
            const quotedTextTest = (quotedMessageContent && (quotedMessageContent.conversation || quotedMessageContent.extendedTextMessage?.text)) || '';
            processedResponse = processedResponse.replace(/\{quoted\}/gi, quotedTextTest);
            const groupDescTest = (groupMetadata && groupMetadata.desc) ? groupMetadata.desc : '';
            const latencyTest = info?.messageTimestamp ? ((Date.now() - info.messageTimestamp * 1000) / 1000).toFixed(3) : null;
            if (groupDescTest) processedResponse = processedResponse.replace(/\{(?:groupdesc|descricao|desc)\}/gi, groupDescTest);
            if (latencyTest !== null) processedResponse = processedResponse.replace(/\{(?:velocidade|speed|latency)\}/gi, `${latencyTest}s`);
            
            const mentionedJidsExec = info.message?.extendedTextMessage?.contextInfo?.mentionedJid || [];
            const mentionsToIncludeExec = Array.isArray(mentionedJidsExec) ? mentionedJidsExec : [];
            if (mentionsToIncludeExec.length > 0) {
              await reply(processedResponse, { mentions: mentionsToIncludeExec });
            } else {
              await reply(processedResponse);
            }
          } else if (processedResponse.type === 'text') {
            let content = processedResponse.content || 'Resposta personalizada';
            // replacing with test args
            const allArgsExec = testArgsStr || '';
            const argsListExec = parseArgsFromString(allArgsExec);
            const paramsMapExec = {};
            if (Array.isArray(settings.params)) {
              for (let i = 0; i < settings.params.length; i++) {
                const p = settings.params[i];
                paramsMapExec[p.name] = argsListExec[i] || '';
              }
            }
            content = content.replace(/\{(?:args|all)\}/gi, allArgsExec);
            content = content.replace(/\{(\d+)\}/g, (m, idx) => {
              const i = parseInt(idx, 10) - 1;
              return argsListExec[i] || '';
            });
            // replace named params
            for (const nm in paramsMapExec) {
              if (!Object.prototype.hasOwnProperty.call(paramsMapExec, nm)) continue;
              const val = paramsMapExec[nm];
              if (typeof val === 'undefined' || val === '') continue;
              try {
                const re = new RegExp('\\{' + escapeRegExp(nm) + '\\}', 'gi');
                content = content.replace(re, val);
              } catch (err) {
                console.warn('Warn: Invalid param name during exec regex replace:', nm, err.message);
              }
            }
            const mentionedJidsExec = info.message?.extendedTextMessage?.contextInfo?.mentionedJid || [];
            let mentionsToIncludeExec = Array.isArray(mentionedJidsExec) ? mentionedJidsExec : [];
            if (!mentionsToIncludeExec.length && typeof menc_os2 !== 'undefined' && menc_os2) {
              mentionsToIncludeExec = [menc_os2];
            }
            const mentionTextExec = mentionsToIncludeExec.length > 0 ? mentionsToIncludeExec.map(m => '@' + getUserName(m)).join(' ') : '';
            content = content.replace(/\{mention\}/gi, mentionTextExec);
            content = content.replace(/\{mentions\}/gi, mentionTextExec);
            const quotedEx = (quotedMessageContent && (quotedMessageContent.conversation || quotedMessageContent.extendedTextMessage?.text)) || '';
            content = content.replace(/\{quoted\}/gi, quotedEx);
            const groupDescText = (groupMetadata && groupMetadata.desc) ? groupMetadata.desc : '';
            const latencyText = info?.messageTimestamp ? ((Date.now() - info.messageTimestamp * 1000) / 1000).toFixed(3) : null;
            if (groupDescText) content = content.replace(/\{(?:groupdesc|descricao|desc)\}/gi, groupDescText);
            if (latencyText !== null) content = content.replace(/\{(?:velocidade|speed|latency)\}/gi, `${latencyText}s`);
            if (mentionsToIncludeExec.length > 0) {
              await reply(content, { mentions: mentionsToIncludeExec });
            } else {
              await reply(content);
            }
          } else if (processedResponse.type === 'image') {
            const imageBuffer = processedResponse.buffer ? Buffer.from(processedResponse.buffer, 'base64') : null;
            if (imageBuffer) {
              let caption = processedResponse.caption || '';
              caption = caption
                .replace(/{prefixo}/gi, groupPrefix)
                .replace(/{prefix}/gi, groupPrefix)
                .replace(/{nomedono}/gi, nomedono)
                .replace(/{numerodono}/gi, numerodono)
                .replace(/{nomebot}/gi, nomebot)
                .replace(/{user}/gi, pushname || 'Usu√°rio')
                .replace(/{grupo}/gi, isGroup ? groupName : 'Privado');
              // extras: args/posi√ß√µes/men√ß√£o/quoted
              caption = caption.replace(/\{(?:args|all)\}/gi, testArgsStr || '');
              caption = caption.replace(/\{(\d+)\}/g, (m, idx) => {
                const i = parseInt(idx, 10) - 1;
                return argsListTest[i] || '';
              });
              // Named param replacements in caption for media
              for (const nm in paramsMapTest) {
                if (!Object.prototype.hasOwnProperty.call(paramsMapTest, nm)) continue;
                const val = paramsMapTest[nm];
                if (typeof val === 'undefined' || val === '') continue;
                try {
                  const re = new RegExp('\\{' + escapeRegExp(nm) + '\\}', 'gi');
                  caption = caption.replace(re, val);
                } catch (err) {
                  console.warn('Warn: Invalid param name during caption test regex replace:', nm, err.message);
                }
              }
              const mentionedJidsTest = info.message?.extendedTextMessage?.contextInfo?.mentionedJid || [];
              let mentionsToIncludeTest = Array.isArray(mentionedJidsTest) ? mentionedJidsTest : [];
              if (!mentionsToIncludeTest.length && typeof menc_os2 !== 'undefined' && menc_os2) mentionsToIncludeTest = [menc_os2];
              const mentionsTextTest = Array.isArray(mentionsToIncludeTest) && mentionsToIncludeTest.length ? mentionsToIncludeTest.map(m => '@' + getUserName(m)).join(' ') : '';
              caption = caption.replace(/\{mention\}/gi, mentionsTextTest);
              caption = caption.replace(/\{mentions\}/gi, mentionsTextTest);
              const quotedTextTest = (quotedMessageContent && (quotedMessageContent.conversation || quotedMessageContent.extendedTextMessage?.text)) || '';
              caption = caption.replace(/\{quoted\}/gi, quotedTextTest);
              const groupDescMediaTest = (groupMetadata && groupMetadata.desc) ? groupMetadata.desc : '';
              const latencyMediaTest = info?.messageTimestamp ? ((Date.now() - info.messageTimestamp * 1000) / 1000).toFixed(3) : null;
              if (groupDescMediaTest) caption = caption.replace(/\{(?:groupdesc|descricao|desc)\}/gi, groupDescMediaTest);
              if (latencyMediaTest !== null) caption = caption.replace(/\{(?:velocidade|speed|latency)\}/gi, `${latencyMediaTest}s`);
              
              await nazu.sendMessage(from, {
                image: imageBuffer,
                caption: caption
              }, { quoted: info, mentions: mentionsToIncludeTest });
            }
          } else if (processedResponse.type === 'video') {
            const videoBuffer = processedResponse.buffer ? Buffer.from(processedResponse.buffer, 'base64') : null;
            if (videoBuffer) {
              let caption = processedResponse.caption || '';
              caption = caption
                .replace(/{prefixo}/gi, groupPrefix)
                .replace(/{prefix}/gi, groupPrefix)
                .replace(/{nomedono}/gi, nomedono)
                .replace(/{numerodono}/gi, numerodono)
                .replace(/{nomebot}/gi, nomebot)
                .replace(/{user}/gi, pushname || 'Usu√°rio')
                .replace(/{grupo}/gi, isGroup ? groupName : 'Privado');
                caption = caption.replace(/\{(?:args|all)\}/gi, testArgsStr || '');
                caption = caption.replace(/\{(\d+)\}/g, (m, idx) => {
                  const i = parseInt(idx, 10) - 1;
                  return argsListTest[i] || '';
                });
                // Named param replacements in video caption
                for (const nm in paramsMapTest) {
                  if (!Object.prototype.hasOwnProperty.call(paramsMapTest, nm)) continue;
                  const val = paramsMapTest[nm];
                  if (typeof val === 'undefined' || val === '') continue;
                  try {
                    const re = new RegExp('\\{' + escapeRegExp(nm) + '\\}', 'gi');
                    caption = caption.replace(re, val);
                  } catch (err) {
                    console.warn('Warn: Invalid param name during video caption test regex replace:', nm, err.message);
                  }
                }
                const mentionedJidsTest = info.message?.extendedTextMessage?.contextInfo?.mentionedJid || [];
                const mentionsTextTest = Array.isArray(mentionedJidsTest) && mentionedJidsTest.length ? mentionedJidsTest.map(m => '@' + getUserName(m)).join(' ') : '';
                caption = caption.replace(/\{mention\}/gi, mentionsTextTest);
                caption = caption.replace(/\{mentions\}/gi, mentionsTextTest);
                const quotedTextTest = (quotedMessageContent && (quotedMessageContent.conversation || quotedMessageContent.extendedTextMessage?.text)) || '';
                caption = caption.replace(/\{quoted\}/gi, quotedTextTest);
              
              await nazu.sendMessage(from, {
                video: videoBuffer,
                caption: caption
              }, { quoted: info, mentions: mentionsToIncludeTest });
            }
          } else if (processedResponse.type === 'audio') {
            const audioBuffer = processedResponse.buffer ? Buffer.from(processedResponse.buffer, 'base64') : null;
            if (audioBuffer) {
              await nazu.sendMessage(from, {
                audio: audioBuffer,
                mimetype: 'audio/mp4',
                ptt: processedResponse.ptt || false
              }, { quoted: info });
            }
          } else if (processedResponse.type === 'sticker') {
            const stickerBuffer = processedResponse.buffer ? Buffer.from(processedResponse.buffer, 'base64') : null;
            if (stickerBuffer) {
              await nazu.sendMessage(from, {
                sticker: stickerBuffer
              }, { quoted: info });
            }
          }
        } catch (e) {
          console.error('Erro no comando testcmd:', e);
          await reply("‚ùå Ocorreu um erro ao testar o comando personalizado.");
        }
        break;

      case 'addblackglobal':
        try {
          if (!isOwner) return reply("Apenas o dono pode adicionar usu√°rios √† blacklist global.");
          if (!menc_os2 && !q) return reply(`Marque o usu√°rio ou forne√ßa o n√∫mero (ex: ${prefix}addblackglobal @usuario motivo).`);
          const reason = args.length > 1 ? args.slice(1).join(' ') : 'N√£o especificado';
          let targetUser = menc_os2 || (q.split(' ')[0].includes('@') ? q.split(' ')[0] : (isValidJid(q.split(' ')[0]) || isValidLid(q.split(' ')[0])) ? q.split(' ')[0] : null);

          // Se informou apenas n√∫mero, tenta obter LID via onWhatsApp/cache
          if (!targetUser && q) {
            const cleanNumber = q.split(' ')[0].replace(/\D/g, '');
            if (cleanNumber.length >= 10) {
              const candidateJid = buildUserId(cleanNumber, config);
              // Se estamos em grupo, tentar buscar participando via metadata
              if (isGroup && groupMetadata?.participants) {
                const participant = groupMetadata.participants.find(p => p.id === candidateJid || p.lid === candidateJid || (p.lid && p.lid.includes(cleanNumber)));
                if (participant && participant.lid) {
                  targetUser = participant.lid;
                }
              }

              if (!targetUser) {
                // Tenta usar cache/onWhatsApp, mas permite JID como fallback
                try {
                  const lid = await getLidFromJidCached(nazu, candidateJid);
                  if (lid && lid.includes('@lid')) {
                    targetUser = lid;
                  } else {
                    targetUser = candidateJid;
                  }
                } catch (err) {
                  console.log('Erro ao obter LID via onWhatsApp:', err?.message || err);
                  targetUser = candidateJid;
                }
              }
            } else {
              return reply('‚ùå N√∫mero inv√°lido! Use um n√∫mero completo (ex: 5511999998888)');
            }
          }
          const result = await addGlobalBlacklist(targetUser, reason, pushname, nazu);
          await reply(result.message, {
            mentions: [targetUser]
          });
        } catch (e) {
          console.error('Erro no comando addblackglobal:', e);
          await reply("Ocorreu um erro ao adicionar √† blacklist global üíî");
        }
        break;
      case 'rmblackglobal':
        try {
          if (!isOwner) return reply("Apenas o dono pode remover usu√°rios da blacklist global.");
          if (!menc_os2 && !q) return reply(`Marque o usu√°rio ou forne√ßa o n√∫mero (ex: ${prefix}remblackglobal @usuario).`);
          let targetUser = menc_os2 || (q.split(' ')[0].includes('@') ? q.split(' ')[0] : (isValidJid(q.split(' ')[0]) || isValidLid(q.split(' ')[0])) ? q.split(' ')[0] : null);
          if (!targetUser && q) {
            const cleanNumber = q.split(' ')[0].replace(/\D/g, '');
            if (cleanNumber.length >= 10) {
              const candidateJid = buildUserId(cleanNumber, config);
              if (isGroup && groupMetadata?.participants) {
                const participant = groupMetadata.participants.find(p => p.id === candidateJid || p.lid === candidateJid || (p.lid && p.lid.includes(cleanNumber)));
                if (participant && participant.lid) {
                  targetUser = participant.lid;
                }
              }
              if (!targetUser) {
                try {
                  const lid = await getLidFromJidCached(nazu, candidateJid);
                  if (lid && lid.includes('@lid')) {
                    targetUser = lid;
                  } else {
                    targetUser = candidateJid;
                  }
                } catch (err) {
                  console.log('Erro ao obter LID via onWhatsApp:', err?.message || err);
                  targetUser = candidateJid;
                }
              }
            } else {
              return reply('‚ùå N√∫mero inv√°lido! Use um n√∫mero completo (ex: 5511999998888)');
            }
          }
          const result = await removeGlobalBlacklist(targetUser, nazu);
          await reply(result.message, {
            mentions: [targetUser]
          });
        } catch (e) {
          console.error('Erro no comando remblackglobal:', e);
          await reply("Ocorreu um erro ao remover da blacklist global üíî");
        }
        break;
      case 'listblackglobal':
        try {
          if (!isOwner) return reply("Apenas o dono pode listar a blacklist global.");
          const blacklistData = getGlobalBlacklist();
          if (Object.keys(blacklistData.users).length === 0) {
            return reply("üõë A blacklist global est√° vazia.");
          }
          let message = `üõë *Blacklist Global* üõë\n\n`;
          for (const [userId, data] of Object.entries(blacklistData.users)) {
            
            message += `‚û§ @${getUserName(userId)}\n   Motivo: ${data.reason}\n   Adicionado por: ${data.addedBy}\n   Data: ${new Date(data.addedAt).toLocaleString('pt-BR', { timeZone: 'America/Sao_Paulo' })}\n\n`;
          }
          await reply(message, {
            mentions: Object.keys(blacklistData.users)
          });
        } catch (e) {
          console.error('Erro no comando listblackglobal:', e);
          await reply("Ocorreu um erro ao listar a blacklist global üíî");
        }
        break;
      //FERRAMENTAS
      case 'encurtalink':
      case 'tinyurl':
        try {
          if (!q) return reply(`‚ùåÔ∏è *Forma incorreta, use est√° como exemplo:* ${prefix + command} https://instagram.com/hiudyyy_`);
          const shortResponse = await axios.post("https://spoo.me/api/v1/shorten", { 
            long_url: q, 
            alias: `nazuna_${Math.floor(10000 + Math.random() * 90000)}` 
          });
          reply(`‚úÖ *Link encurtado com sucesso!*\n\nüîó *Link curto:* ${shortResponse.data.short_url}\nüìé *Link original:* ${shortResponse.data.long_url}`);
        } catch (e) {
          console.error(e);
          await reply("‚ùå Ocorreu um erro interno. Tente novamente em alguns minutos.");
        }
        break;
      case 'nick':
      case 'gerarnick':
      case 'nickgenerator':
        try {
          if (!q) return reply(`üéÆ *GERADOR DE NICK*\n\nüìù *Como usar:*\n‚Ä¢ Digite o nick ap√≥s o comando\n‚Ä¢ Ex: ${prefix}nick nazuna`);
          var datzn;
          datzn = await styleText(q);
          await reply(datzn.join('\n'));
        } catch (e) {
          console.error(e);
          await reply("‚ùå Ocorreu um erro interno. Tente novamente em alguns minutos.");
        }
        break;
      case 'printsite':
      case 'ssweb':
        try {
          if (!q) return reply(`Cade o link?`);
          await nazu.sendMessage(from, {
            image: {
              url: `https://image.thum.io/get/fullpage/${q}`
            }
          }, {
            quoted: info
          });
        } catch (e) {
          console.error(e);
          await reply("‚ùå Ocorreu um erro interno. Tente novamente em alguns minutos.");
        }
        break;
      case 'upload':
      case 'imgpralink':
      case 'videopralink':
      case 'gerarlink':
        try {
          if (!isQuotedImage && !isQuotedVideo && !isQuotedDocument && !isQuotedAudio) return reply(`Marque um video, uma foto, um audio ou um documento`);
          var foto1 = isQuotedImage ? info.message.extendedTextMessage.contextInfo.quotedMessage.imageMessage : {};
          var video1 = isQuotedVideo ? info.message.extendedTextMessage.contextInfo.quotedMessage.videoMessage : {};
          var docc1 = isQuotedDocument ? info.message.extendedTextMessage.contextInfo.quotedMessage.documentMessage : {};
          var audio1 = isQuotedAudio ? info.message.extendedTextMessage.contextInfo.quotedMessage.audioMessage : "";
          let media = {};
          if (isQuotedDocument) {
            media = await getFileBuffer(docc1, "document");
          } else if (isQuotedVideo) {
            media = await getFileBuffer(video1, "video");
          } else if (isQuotedImage) {
            media = await getFileBuffer(foto1, "image");
          } else if (isQuotedAudio) {
            media = await getFileBuffer(audio1, "audio");
          }
          let linkz = await upload(media);
          await reply(`${linkz}`);
        } catch (e) {
          console.error(e);
          await reply("‚ùå Ocorreu um erro interno. Tente novamente em alguns minutos.");
        }
        break;
      
      // VERIFICADOR DE LINKS (FishFish API)
      case 'verificar':
      case 'checklink':
      case 'scanlink':
      case 'urlscan':
        try {
          if (!q) return reply(`üîí *Verificador de Links*\n\n‚ùå Por favor, envie um link ou dom√≠nio para verificar.\n\nüìù *Uso:* ${prefix}${command} <link>\n\nüìå *Exemplos:*\n${prefix}${command} google.com\n${prefix}${command} https://exemplo.com/pagina`);
          
          // Extrair dom√≠nio do link
          let urlToCheck = q.trim();
          let domain = urlToCheck;
          
          try {
            // Tentar extrair dom√≠nio de uma URL completa
            if (urlToCheck.includes('://')) {
              const urlObj = new URL(urlToCheck);
              domain = urlObj.hostname;
            } else if (urlToCheck.includes('/')) {
              domain = urlToCheck.split('/')[0];
            }
          } catch {
            // Se falhar, usar o valor original
            domain = urlToCheck.replace(/^(https?:\/\/)?/, '').split('/')[0];
          }
          
          await reply('üîç Verificando seguran√ßa do link...');
          
          // Verificar dom√≠nio na API FishFish
          const fishResponse = await axios.get(`https://api.fishfish.gg/v1/domains/${encodeURIComponent(domain)}`, {
            timeout: 120000,
            validateStatus: (status) => status < 500
          });
          
          if (fishResponse.status === 404) {
            // Dom√≠nio n√£o encontrado na base de dados = provavelmente seguro
            await reply(`‚úÖ *Resultado da Verifica√ß√£o*\n\nüîó *Link:* ${urlToCheck}\nüåê *Dom√≠nio:* ${domain}\n\nüìä *Status:* N√£o encontrado na base de amea√ßas\n\nüíö *An√°lise:* Este dom√≠nio n√£o est√° listado como malicioso na base de dados FishFish. Isso geralmente indica que √© seguro, mas sempre tenha cuidado ao acessar links desconhecidos!\n\n‚ö†Ô∏è *Dica:* Mesmo links "seguros" podem ter conte√∫do prejudicial. Navegue com cautela!`);
          } else if (fishResponse.status === 200) {
            const data = fishResponse.data;
            const category = data.category || 'unknown';
            const createdAt = data.created ? new Date(data.created).toLocaleDateString('pt-BR') : 'N/A';
            
            let statusEmoji = '‚ö†Ô∏è';
            let statusText = 'Suspeito';
            let riskLevel = 'M√©dio';
            
            if (category === 'phishing') {
              statusEmoji = 'üö®';
              statusText = 'PHISHING DETECTADO';
              riskLevel = 'CR√çTICO';
            } else if (category === 'malware') {
              statusEmoji = '‚ò†Ô∏è';
              statusText = 'MALWARE DETECTADO';
              riskLevel = 'CR√çTICO';
            } else if (category === 'safe') {
              statusEmoji = '‚úÖ';
              statusText = 'Seguro';
              riskLevel = 'Baixo';
            }
            
            let warningMsg = '';
            if (category === 'phishing' || category === 'malware') {
              warningMsg = '\n\nüö´ *N√ÉO ACESSE ESTE LINK!*\nEste dom√≠nio foi identificado como perigoso e pode roubar seus dados ou infectar seu dispositivo!';
            }
            
            await reply(`${statusEmoji} *Resultado da Verifica√ß√£o*\n\nüîó *Link:* ${urlToCheck}\nüåê *Dom√≠nio:* ${domain}\n\nüìä *Status:* ${statusText}\nüè∑Ô∏è *Categoria:* ${category}\n‚ö° *N√≠vel de Risco:* ${riskLevel}\nüìÖ *Registrado em:* ${createdAt}${warningMsg}\n\nüîí *Verificado por:* FishFish Security API`);
          } else {
            await reply('‚ùå Erro ao verificar o link. Tente novamente mais tarde.');
          }
        } catch (e) {
          console.error('Erro no comando verificar:', e);
          
          if (e.code === 'ECONNABORTED' || e.message?.includes('timeout')) {
            return reply('‚è∞ Tempo esgotado! O servidor de verifica√ß√£o est√° demorando para responder.');
          }
          
          reply('‚ùå Ocorreu um erro ao verificar o link. Tente novamente.');
        }
        break;
      
      // FUSO HOR√ÅRIO MUNDIAL (vers√£o alternativa)
      case 'horamundial':
      case 'worldtime':
      case 'fusohorario':
      case 'horariomundial':
        try {
          if (!q) return reply(`üïê *Consulta de Hor√°rio Mundial*\n\nüìù *Uso:* ${prefix}${command} <cidade/pa√≠s>\n\nüìå *Exemplos:*\n${prefix}${command} tokyo\n${prefix}${command} new york\n${prefix}${command} london\n${prefix}${command} s√£o paulo\n\nüí° *Dica:* Use nomes em ingl√™s para melhores resultados!`);
          
          const location = q.trim();
          
          // Mapa de fusos hor√°rios comuns
          const timezoneMap = {
            'brasil': 'America/Sao_Paulo', 'brazil': 'America/Sao_Paulo', 's√£o paulo': 'America/Sao_Paulo', 'sao paulo': 'America/Sao_Paulo',
            'rio': 'America/Sao_Paulo', 'rio de janeiro': 'America/Sao_Paulo', 'brasilia': 'America/Sao_Paulo',
            'tokyo': 'Asia/Tokyo', 'toquio': 'Asia/Tokyo', 'japao': 'Asia/Tokyo', 'japan': 'Asia/Tokyo',
            'new york': 'America/New_York', 'nova york': 'America/New_York', 'ny': 'America/New_York',
            'los angeles': 'America/Los_Angeles', 'la': 'America/Los_Angeles', 'california': 'America/Los_Angeles',
            'london': 'Europe/London', 'londres': 'Europe/London', 'uk': 'Europe/London', 'england': 'Europe/London',
            'paris': 'Europe/Paris', 'franca': 'Europe/Paris', 'france': 'Europe/Paris',
            'berlin': 'Europe/Berlin', 'alemanha': 'Europe/Berlin', 'germany': 'Europe/Berlin',
            'moscow': 'Europe/Moscow', 'moscou': 'Europe/Moscow', 'russia': 'Europe/Moscow',
            'dubai': 'Asia/Dubai', 'uae': 'Asia/Dubai',
            'beijing': 'Asia/Shanghai', 'pequim': 'Asia/Shanghai', 'china': 'Asia/Shanghai', 'shanghai': 'Asia/Shanghai',
            'sydney': 'Australia/Sydney', 'australia': 'Australia/Sydney',
            'seoul': 'Asia/Seoul', 'korea': 'Asia/Seoul', 'coreia': 'Asia/Seoul',
            'mumbai': 'Asia/Kolkata', 'india': 'Asia/Kolkata', 'delhi': 'Asia/Kolkata',
            'singapore': 'Asia/Singapore', 'singapura': 'Asia/Singapore',
            'hong kong': 'Asia/Hong_Kong', 'hongkong': 'Asia/Hong_Kong',
            'bangkok': 'Asia/Bangkok', 'thailand': 'Asia/Bangkok', 'tailandia': 'Asia/Bangkok',
            'mexico': 'America/Mexico_City', 'mexico city': 'America/Mexico_City',
            'argentina': 'America/Argentina/Buenos_Aires', 'buenos aires': 'America/Argentina/Buenos_Aires',
            'chile': 'America/Santiago', 'santiago': 'America/Santiago',
            'portugal': 'Europe/Lisbon', 'lisbon': 'Europe/Lisbon', 'lisboa': 'Europe/Lisbon',
            'madrid': 'Europe/Madrid', 'espanha': 'Europe/Madrid', 'spain': 'Europe/Madrid',
            'rome': 'Europe/Rome', 'roma': 'Europe/Rome', 'italy': 'Europe/Rome', 'italia': 'Europe/Rome',
            'amsterdam': 'Europe/Amsterdam', 'holanda': 'Europe/Amsterdam', 'netherlands': 'Europe/Amsterdam',
            'toronto': 'America/Toronto', 'canada': 'America/Toronto',
            'miami': 'America/New_York', 'chicago': 'America/Chicago', 'denver': 'America/Denver'
          };
          
          const locationLower = location.toLowerCase();
          let timezone = timezoneMap[locationLower];
          
          if (!timezone) {
            // Tentar encontrar correspond√™ncia parcial
            for (const [key, tz] of Object.entries(timezoneMap)) {
              if (key.includes(locationLower) || locationLower.includes(key)) {
                timezone = tz;
                break;
              }
            }
          }
          
          if (!timezone) {
            return reply(`‚ùå *Local n√£o encontrado!*\n\nüîç N√£o consegui encontrar o fuso hor√°rio para "${location}".\n\nüí° *Tente usar:*\n‚Ä¢ Nomes de cidades grandes (Tokyo, London, New York)\n‚Ä¢ Nomes de pa√≠ses (Brasil, Japan, USA)\n‚Ä¢ Nomes em ingl√™s geralmente funcionam melhor`);
          }
          
          // Obter hor√°rio atual no fuso especificado
          const now = new Date();
          const options = {
            timeZone: timezone,
            weekday: 'long',
            year: 'numeric',
            month: 'long',
            day: 'numeric',
            hour: '2-digit',
            minute: '2-digit',
            second: '2-digit',
            hour12: false
          };
          
          const formatter = new Intl.DateTimeFormat('pt-BR', options);
          const formattedTime = formatter.format(now);
          
          // Calcular diferen√ßa com Brasil
          const brTime = new Date().toLocaleString('en-US', { timeZone: 'America/Sao_Paulo' });
          const targetTime = new Date().toLocaleString('en-US', { timeZone: timezone });
          const brDate = new Date(brTime);
          const targetDate = new Date(targetTime);
          const diffHours = Math.round((targetDate - brDate) / (1000 * 60 * 60));
          
          let diffText = '';
          if (diffHours === 0) {
            diffText = 'Mesmo hor√°rio do Brasil';
          } else if (diffHours > 0) {
            diffText = `+${diffHours}h em rela√ß√£o ao Brasil`;
          } else {
            diffText = `${diffHours}h em rela√ß√£o ao Brasil`;
          }
          
          await reply(`üïê *Hor√°rio em ${location.charAt(0).toUpperCase() + location.slice(1)}*\n\nüìÖ ${formattedTime}\n\nüåç *Fuso:* ${timezone}\n‚è∞ *Diferen√ßa:* ${diffText}`);
        } catch (e) {
          console.error('Erro no comando hora:', e);
          reply('‚ùå Ocorreu um erro ao consultar o hor√°rio. Tente novamente.');
        }
        break;
      
      // CLIMA / PREVIS√ÉO DO TEMPO (vers√£o alternativa)
      case 'clima2':
      case 'tempo2':
      case 'weather2':
      case 'previsao2':
        if (!q) return reply(`üå§Ô∏è *Previs√£o do Tempo*\n\nüìù *Uso:* ${prefix}${command} <cidade>\n\nüìå *Exemplos:*\n${prefix}${command} S√£o Paulo\n${prefix}${command} Tokyo\n${prefix}${command} New York`);
        
        const city = q.trim();
        
        // Usando a API wttr.in (gratuita, n√£o precisa de API key)
        axios.get(`https://wttr.in/${encodeURIComponent(city)}?format=j1&lang=pt`, {
          timeout: 120000
        }).then((weatherResponse) => {
          if (!weatherResponse.data || !weatherResponse.data.current_condition) {
            return reply('‚ùå Cidade n√£o encontrada. Verifique o nome e tente novamente.');
          }
          
          const current = weatherResponse.data.current_condition[0];
          const location_data = weatherResponse.data.nearest_area[0];
          const forecast = weatherResponse.data.weather;
          
          // Mapear condi√ß√µes do tempo para emojis
          const getWeatherEmoji = (code) => {
            const weatherCodes = {
              '113': '‚òÄÔ∏è', '116': '‚õÖ', '119': '‚òÅÔ∏è', '122': '‚òÅÔ∏è',
              '143': 'üå´Ô∏è', '176': 'üå¶Ô∏è', '179': 'üå®Ô∏è', '182': 'üå®Ô∏è',
              '185': 'üå®Ô∏è', '200': '‚õàÔ∏è', '227': '‚ùÑÔ∏è', '230': '‚ùÑÔ∏è',
              '248': 'üå´Ô∏è', '260': 'üå´Ô∏è', '263': 'üåßÔ∏è', '266': 'üåßÔ∏è',
              '281': 'üå®Ô∏è', '284': 'üå®Ô∏è', '293': 'üåßÔ∏è', '296': 'üåßÔ∏è',
              '299': 'üåßÔ∏è', '302': 'üåßÔ∏è', '305': 'üåßÔ∏è', '308': 'üåßÔ∏è',
              '311': 'üå®Ô∏è', '314': 'üå®Ô∏è', '317': 'üå®Ô∏è', '320': 'üå®Ô∏è',
              '323': 'üå®Ô∏è', '326': 'üå®Ô∏è', '329': '‚ùÑÔ∏è', '332': '‚ùÑÔ∏è',
              '335': '‚ùÑÔ∏è', '338': '‚ùÑÔ∏è', '350': 'üå®Ô∏è', '353': 'üå¶Ô∏è',
              '356': 'üåßÔ∏è', '359': 'üåßÔ∏è', '362': 'üå®Ô∏è', '365': 'üå®Ô∏è',
              '368': 'üå®Ô∏è', '371': 'üå®Ô∏è', '374': 'üå®Ô∏è', '377': 'üå®Ô∏è',
              '386': '‚õàÔ∏è', '389': '‚õàÔ∏è', '392': '‚õàÔ∏è', '395': '‚ùÑÔ∏è'
            };
            return weatherCodes[code] || 'üå°Ô∏è';
          };
          
          const emoji = getWeatherEmoji(current.weatherCode);
          const cityName = location_data.areaName[0].value;
          const country = location_data.country[0].value;
          
          let forecastText = '';
          if (forecast && forecast.length > 0) {
            forecastText = '\n\nüìÖ *Previs√£o dos pr√≥ximos dias:*';
            for (let i = 0; i < Math.min(3, forecast.length); i++) {
              const day = forecast[i];
              const dayEmoji = getWeatherEmoji(day.hourly[4]?.weatherCode || '113');
              const date = new Date(day.date).toLocaleDateString('pt-BR', { weekday: 'short', day: 'numeric' });
              forecastText += `\n${dayEmoji} *${date}:* ${day.mintempC}¬∞C - ${day.maxtempC}¬∞C`;
            }
          }
          
          return reply(`${emoji} *Clima em ${cityName}, ${country}*\n\nüå°Ô∏è *Temperatura:* ${current.temp_C}¬∞C (sensa√ß√£o ${current.FeelsLikeC}¬∞C)\nüíß *Umidade:* ${current.humidity}%\nüí® *Vento:* ${current.windspeedKmph} km/h\nüëÅÔ∏è *Visibilidade:* ${current.visibility} km\n‚òÅÔ∏è *Condi√ß√£o:* ${current.lang_pt?.[0]?.value || current.weatherDesc[0].value}${forecastText}`);
        }).catch((e) => {
          console.error('Erro no comando clima:', e);
          
          if (e.response?.status === 404 || e.message?.includes('404')) {
            return reply('‚ùå Cidade n√£o encontrada. Verifique o nome e tente novamente.');
          }
          
          reply('‚ùå Ocorreu um erro ao consultar o clima. Tente novamente.');
        });
        break;
        
      //DOWNLOADS

      case 'mcplugin':
      case 'mcplugins':
        if (!q) return reply('Cad√™ o nome do plugin para eu pesquisar? ü§î');
        mcPlugin(q).then((datz) => {
          if (!datz.ok) return reply(datz.msg);
          return axios.post("https://spoo.me/api/v1/shorten", { 
            long_url: datz.url, 
            alias: `nazuna_${Math.floor(10000 + Math.random() * 90000)}` 
          }).then((shortLinkPlugin) => {
            return nazu.sendMessage(from, {
              image: { url: datz.image },
              caption: `üîç Encontrei esse plugin aqui:\n\n*Nome*: _${datz.name}_\n*Publicado por*: _${datz.creator}_\n*Descri√ß√£o*: _${datz.desc}_\n*Link para download*: _${shortLinkPlugin.data.short_url}_\n\n> üíñ `
            }, { quoted: info });
          });
        }).catch((e) => {
          console.error(e);
          reply("‚ùå Ocorreu um erro interno. Tente novamente em alguns minutos.");
        });
        break;
      /*case 'play':
case 'ytmp3':
  try {
    if (!q) {
      return reply(`‚ï≠‚îÅ‚îÅ‚îÅ‚ä± üéµ *YOUTUBE MP3* üéµ ‚ä±‚îÅ‚îÅ‚îÅ‚ïÆ
‚îÇ
‚îÇ üìù Digite o nome da m√∫sica ou
‚îÇ     um link do YouTube
‚îÇ
‚îÇ  *Exemplos:*
‚îÇ  ${prefix + command} Back to Black
‚îÇ  ${prefix + command} https://youtube.com/...
‚îÇ
‚ï∞‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚ïØ`);
    }

    let videoUrl;
    let videoInfo;

    if (q.includes('youtube.com') || q.includes('youtu.be')) {
      videoUrl = q;
      await reply('Aguarde um momentinho... ‚òÄÔ∏è');

      youtube.mp3(videoUrl, 128)
        .then(async (dlRes) => {
          if (!dlRes.ok)
            return nazu.sendMessage(from, { text: `‚ùå Erro ao baixar o √°udio: ${dlRes.msg}` }, { quoted: info });

          try {
            await nazu.sendMessage(from, {
              audio: dlRes.buffer,
              mimetype: 'audio/mpeg'
            }, { quoted: info });
          } catch (audioError) {
            if (String(audioError).includes("ENOSPC") || String(audioError).includes("size")) {
              await nazu.sendMessage(from, { text: 'üì¶ Arquivo muito grande para enviar como √°udio, enviando como documento...' }, { quoted: info });
              await nazu.sendMessage(from, {
                document: dlRes.buffer,
                fileName: `${dlRes.filename}`,
                mimetype: 'audio/mpeg'
              }, { quoted: info });
            } else {
              console.error('Erro ao enviar √°udio (link direto):', audioError);
              nazu.sendMessage(from, { text: '‚ùå Ocorreu um erro ao enviar o √°udio.' }, { quoted: info });
            }
          }
        })
        .catch((downloadError) => {
          console.error('Erro no download (link direto):', downloadError);
          if (String(downloadError).includes("age")) {
            nazu.sendMessage(from, { text: `üîû Este conte√∫do possui restri√ß√£o de idade e n√£o pode ser baixado.` }, { quoted: info });
          } else {
            nazu.sendMessage(from, { text: `‚ùå Ocorreu um erro ao baixar o √°udio: ${downloadError.message}` }, { quoted: info });
          }
        });

      return;
    }

    // Mensagem de pesquisa
    await reply(`üîç *Pesquisando no YouTube...*\n\nüéµ M√∫sica: *${q}*\n\n‚è≥ Aguarde um momento...`);

    // Usando .then em vez de await para a pesquisa do YouTube
    youtube.search(q)
        .then((result) => {
          if (!result.ok) return reply(`‚ùå Erro na pesquisa: ${result.msg}`);
          videoInfo = result;
          videoUrl = result.data.url;

          if (videoInfo.data.seconds > 1800) return reply(`‚ö†Ô∏è Este v√≠deo √© muito longo (${videoInfo.data.timestamp}).\nPor favor, escolha um v√≠deo com menos de 30 minutos.`);

          const views = typeof videoInfo.data.views === 'number'
            ? videoInfo.data.views.toLocaleString('pt-BR')
            : videoInfo.data.views;

          const description = videoInfo.data.description
            ? videoInfo.data.description.slice(0, 100) + (videoInfo.data.description.length > 100 ? '...' : '')
            : 'Sem descri√ß√£o dispon√≠vel';

          const caption = `üéµ *M√∫sica Encontrada* üéµ\n\nüìå *T√≠tulo:* ${videoInfo.data.title}\nüë§ *Artista/Canal:* ${videoInfo.data.author.name}\n‚è± *Dura√ß√£o:* ${videoInfo.data.timestamp} (${videoInfo.data.seconds} segundos)\nüëÄ *Visualiza√ß√µes:* ${views}\nüìÖ *Publicado:* ${videoInfo.data.ago}\nüìú *Descri√ß√£o:* ${description}\nüîó *Link:* ${videoInfo.data.url}\n\nüéß *Baixando e processando sua m√∫sica, aguarde...*`;

          nazu.sendMessage(from, {
            image: { url: videoInfo.data.thumbnail },
            caption,
            footer: `${nomebot} ‚Ä¢ Vers√£o ${botVersion}`
          }, { quoted: info }).catch((sendErr) => console.error('Erro ao enviar mensagem de resultado (busca):', sendErr));

          youtube.mp3(videoUrl, 128)
            .then(async (dlRes) => {
              if (!dlRes.ok) return nazu.sendMessage(from, { text: `‚ùå Erro ao baixar o √°udio: ${dlRes.msg}` }, { quoted: info });

              try {
                await nazu.sendMessage(from, {
                  audio: dlRes.buffer,
                  mimetype: 'audio/mpeg'
                }, { quoted: info });
              } catch (audioError) {
                if (String(audioError).includes("ENOSPC") || String(audioError).includes("size")) {
                  await nazu.sendMessage(from, { text: 'üì¶ Arquivo muito grande para enviar como √°udio, enviando como documento...' }, { quoted: info });
                  await nazu.sendMessage(from, {
                    document: dlRes.buffer,
                    fileName: `${dlRes.filename}`,
                    mimetype: 'audio/mpeg'
                  }, { quoted: info });
                } else {
                  console.error('Erro ao enviar √°udio (busca):', audioError);
                  nazu.sendMessage(from, { text: '‚ùå Ocorreu um erro ao enviar o √°udio.' }, { quoted: info });
                }
              }
            })
            .catch((downloadError) => {
              console.error('Erro no download (busca):', downloadError);
              if (downloadError.message?.includes('API key inv√°lida')) {
                nazu.sendMessage(from, { text: 'ü§ñ *Sistema de YouTube temporariamente indispon√≠vel*' }, { quoted: info });
              } else if (String(downloadError).includes("age")) {
                nazu.sendMessage(from, { text: `üîû Este conte√∫do possui restri√ß√£o de idade e n√£o pode ser baixado.` }, { quoted: info });
              } else {
                nazu.sendMessage(from, { text: `‚ùå Ocorreu um erro ao baixar o √°udio: ${downloadError.message}` }, { quoted: info });
              }
            });
        })
        .catch((error) => {
          console.error('Erro ao buscar v√≠deo no YouTube:', error);
          return reply(`‚ùå Erro ao buscar v√≠deo: ${error.message}`);
        });

      // Retornar ap√≥s iniciar a pesquisa em modo promisse para n√£o continuar executando o bloco
      return;

  } catch (error) {
    console.error('Erro no comando play/ytmp3 (bloco principal):', error);

    if (String(error).includes("age"))
      return reply(`üîû Este conte√∫do possui restri√ß√£o de idade e n√£o pode ser processado.`);

    reply("‚ùå Ocorreu um erro ao processar sua solicita√ß√£o. Por favor, tente novamente mais tarde.");
  }
  break;*/
  
case 'play':
case 'p': {
  try {
    if (!q) {
      return reply(`‚ï≠‚îÅ‚îÅ‚îÅ‚ä± üéµ *YOUTUBE MP3* üéµ ‚ä±‚îÅ‚îÅ‚îÅ‚ïÆ
‚îÇ
‚îÇ üìù Digite o nome da m√∫sica ou
‚îÇ     um link do YouTube
‚îÇ
‚îÇ  *Exemplos:*
‚îÇ  ${prefix + command} Back to Black
‚îÇ  ${prefix + command} https://youtube.com/...
‚îÇ
‚ï∞‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚ïØ`)
    }

    await reply(
      `üîç *Pesquisando no YouTube...*\n\nüéµ M√∫sica: *${q}*\n\n‚è≥ Aguarde um momento...`
    )

    // üîç Pesquisa no YouTube
    const result = await youtube.search(q)
    if (!result || !result.ok) {
      return reply(`‚ùå Erro na pesquisa.`)
    }

    const videoInfo = result.data
    const videoUrl = videoInfo.url

    if (videoInfo.seconds > 1800) {
      return reply(
        `‚ö†Ô∏è Este v√≠deo √© muito longo (${videoInfo.timestamp}).\nEscolha um v√≠deo com menos de 30 minutos.`
      )
    }

    const views =
      typeof videoInfo.views === 'number'
        ? videoInfo.views.toLocaleString('pt-BR')
        : videoInfo.views

    const description = videoInfo.description
      ? videoInfo.description.slice(0, 100) +
        (videoInfo.description.length > 100 ? '...' : '')
      : 'Sem descri√ß√£o dispon√≠vel'

    const caption = `üéµ *M√∫sica Encontrada* üéµ

üìå *T√≠tulo:* ${videoInfo.title}
üë§ *Canal:* ${videoInfo.author.name}
‚è± *Dura√ß√£o:* ${videoInfo.timestamp}
üëÄ *Visualiza√ß√µes:* ${views}
üìÖ *Publicado:* ${videoInfo.ago}
üìú *Descri√ß√£o:* ${description}
üîó *Link:* ${videoUrl}

üéß *Baixando sua m√∫sica...*`

    await nazu.sendMessage(
      from,
      {
        image: { url: videoInfo.thumbnail },
        caption,
        footer: `${nomebot} ‚Ä¢ Vers√£o ${botVersion}`
      },
      { quoted: info }
    )

    // üéµ Download do √°udio
const apiUrl = `https://blacksystemofc.com.br/api/yt/audio2?url=${videoUrl}&apikey=system82384738kk`
const res = await fetch(apiUrl)
const BCD = await res.json()

// ‚úÖ valida√ß√£o correta
if (!BCD || !BCD.resultado || !BCD.resultado.status || !BCD.resultado.download_url) {
  console.log('ERRO NA API:', BCD)
  return reply('‚ùå N√£o consegui baixar essa m√∫sica. Tente outra.')
}

try {
  await nazu.sendMessage(from, {
    audio: { url: BCD.resultado.download_url },
    mimetype: 'audio/mpeg'
  }, { quoted: info })
} catch (audioError) {
  await nazu.sendMessage(from, {
    document: { url: BCD.resultado.download_url },
    fileName: `${videoInfo.data.title}.mp3`,
    mimetype: 'audio/mpeg'
  }, { quoted: info })
}

  } catch (err) {
    console.error('ERRO PLAY:', err)
    reply('‚ùå Ocorreu um erro ao processar a m√∫sica.')
  }
}
break;

case 'spotifydl':
case 'spotify':
  try {
    if (!q) {
      return reply(`‚ï≠‚îÅ‚îÅ‚îÅ‚ä± üéµ *SPOTIFY DOWNLOAD* üéµ ‚ä±‚îÅ‚îÅ‚îÅ‚ïÆ
‚îÇ
‚îÇ üìù Digite o link da m√∫sica do Spotify
‚îÇ
‚îÇ  *Exemplo:*
‚îÇ  ${prefix + command} https://open.spotify.com/track/...
‚îÇ
‚ï∞‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚ïØ`);
    }

    if (!q.includes('open.spotify.com/track/')) {
      return reply('‚ùå Por favor, envie um link v√°lido do Spotify.\n\nüí° Dica: Use o comando play2 para buscar por nome!');
    }

    await reply('üéµ Baixando do Spotify... Aguarde um momento!');

    const downloadResult = await spotifyModule.download(q);

    if (!downloadResult.ok) {
      return reply(`‚ùå ${downloadResult.msg}`);
    }

    const caption = `üéµ *M√∫sica Baixada do Spotify!* üéµ\n\n` +
      `üìå *T√≠tulo:* ${downloadResult.title}\n` +
      `üë§ *Artista(s):* ${Array.isArray(downloadResult.artists) ? downloadResult.artists.join(', ') : downloadResult.artists}\n` +
      `${downloadResult.year ? `üìÖ *Ano:* ${downloadResult.year}\n` : ''}` +
      `üéß *Enviando √°udio...*`;

    try {
      await reply(caption);
    } catch (err) {
      console.error('Erro ao enviar caption:', err);
    }

    try {
      await nazu.sendMessage(from, {
        audio: downloadResult.buffer,
        mimetype: 'audio/mpeg',
        fileName: downloadResult.filename
      }, { quoted: info });
    } catch (audioError) {
      if (String(audioError).includes("ENOSPC") || String(audioError).includes("size")) {
        await reply('üì¶ Arquivo muito grande, enviando como documento...');
        await nazu.sendMessage(from, {
          document: downloadResult.buffer,
          fileName: downloadResult.filename,
          mimetype: 'audio/mpeg'
        }, { quoted: info });
      } else {
        console.error('Erro ao enviar √°udio do Spotify:', audioError);
        reply('‚ùå Ocorreu um erro ao enviar o √°udio.');
      }
    }

  } catch (error) {
    console.error('Erro no comando spotifydl:', error);
    reply("‚ùå Ocorreu um erro ao processar sua solicita√ß√£o.");
  }
  break;

case 'play2':
case 'playspotify':
  try {
    if (!q) {
      return reply(`‚ï≠‚îÅ‚îÅ‚îÅ‚ä± üéµ *SPOTIFY PLAY* üéµ ‚ä±‚îÅ‚îÅ‚îÅ‚ïÆ
‚îÇ
‚îÇ üìù Digite o nome da m√∫sica ou artista
‚îÇ
‚îÇ  *Exemplos:*
‚îÇ  ${prefix + command} Te vi de canto
‚îÇ  ${prefix + command} R√¥ Rosa
‚îÇ
‚ï∞‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚ïØ`);
    }

    await reply('üîé Buscando no Spotify... Aguarde!');

    // 1. Buscar a m√∫sica
    const searchResult = await spotifyModule.search(q, 1);

    if (!searchResult.ok || !searchResult.results?.length) {
      return reply('‚ùå Nenhuma m√∫sica encontrada com esse nome.');
    }

    const track = searchResult.results[0];

    const searchCaption = `üéµ *M√∫sica Encontrada!* üéµ\n\n` +
      `üîç *Busca:* ${q}\n\n` +
      `üìå *T√≠tulo:* ${track.name}\n` +
      `üîó *Link:* ${track.link}\n\n` +
      `üì• *Baixando...*`;

    await reply(searchCaption);

    // 2. Baixar a m√∫sica
    const downloadResult = await spotifyModule.download(track.link);

    if (!downloadResult.ok) {
      return reply(`‚ùå ${downloadResult.msg}`);
    }

    try {
      await nazu.sendMessage(from, {
        audio: downloadResult.buffer,
        mimetype: 'audio/mpeg',
        fileName: downloadResult.filename
      }, { quoted: info });
    } catch (audioError) {
      if (String(audioError).includes("ENOSPC") || String(audioError).includes("size")) {
        await reply('üì¶ Arquivo muito grande, enviando como documento...');
        await nazu.sendMessage(from, {
          document: downloadResult.buffer,
          fileName: downloadResult.filename,
          mimetype: 'audio/mpeg'
        }, { quoted: info });
      } else {
        console.error('Erro ao enviar √°udio do Spotify:', audioError);
        reply('‚ùå Ocorreu um erro ao enviar o √°udio.');
      }
    }

  } catch (error) {
    console.error('Erro no comando play2:', error);
    reply("‚ùå Ocorreu um erro ao processar sua solicita√ß√£o.");
  }
  break;

case 'soundclouddl':
case 'soundcloud':
  try {
    if (!q) {
      return reply(`‚ï≠‚îÅ‚îÅ‚îÅ‚ä± üéµ *SOUNDCLOUD DOWNLOAD* üéµ ‚ä±‚îÅ‚îÅ‚îÅ‚ïÆ
‚îÇ
‚îÇ üìù Digite o link da m√∫sica do SoundCloud
‚îÇ
‚îÇ  *Exemplo:*
‚îÇ  ${prefix + command} https://soundcloud.com/...
‚îÇ
‚ï∞‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚ïØ`);
    }


    if (!q.includes('soundcloud.com/')) {
      return reply('‚ùå Por favor, envie um link v√°lido do SoundCloud.\n\nüí° Dica: Use o comando play3 para buscar por nome!');
    }

    await reply('üéµ Baixando do SoundCloud... Aguarde um momento!');

    soundcloud.download(q)
      .then(async (result) => {
        if (!result.ok) {
          return reply(`‚ùå Erro: ${result.msg}`);
        }

        const caption = `üéµ *M√∫sica Baixada com Sucesso!* üéµ\n\n` +
          `üìå *T√≠tulo:* ${result.title}\n` +
          `üë§ *Artista:* ${result.artist}\n\n` +
          `üéß *Enviando √°udio...*`;

        try {
          await nazu.sendMessage(from, {
            image: { url: result.thumbnail },
            caption
          }, { quoted: info });
        } catch (imgErr) {
          console.error('Erro ao enviar thumbnail do SoundCloud:', imgErr);
        }

        try {
          await nazu.sendMessage(from, {
            audio: result.buffer,
            mimetype: 'audio/mpeg',
            fileName: result.filename
          }, { quoted: info });
        } catch (audioError) {
          if (String(audioError).includes("ENOSPC") || String(audioError).includes("size")) {
            await reply('üì¶ Arquivo muito grande, enviando como documento...');
            await nazu.sendMessage(from, {
              document: result.buffer,
              fileName: result.filename,
              mimetype: 'audio/mpeg'
            }, { quoted: info });
          } else {
            console.error('Erro ao enviar √°udio do SoundCloud:', audioError);
            reply('‚ùå Ocorreu um erro ao enviar o √°udio.');
          }
        }
      })
      .catch((error) => {
        console.error('Erro no download do SoundCloud:', error);
          reply(`‚ùå Erro ao baixar do SoundCloud: ${error.message}`);
      });

  } catch (error) {
    console.error('Erro no comando soundclouddl:', error);
    reply("‚ùå Ocorreu um erro ao processar sua solicita√ß√£o.");
  }
  break;

case 'play3':
case 'playsoundcloud':
  try {
    if (!q) {
      return reply(`‚ï≠‚îÅ‚îÅ‚îÅ‚ä± üéµ *SOUNDCLOUD PLAY* üéµ ‚ä±‚îÅ‚îÅ‚îÅ‚ïÆ
‚îÇ
‚îÇ üìù Digite o nome da m√∫sica ou artista
‚îÇ
‚îÇ  *Exemplos:*
‚îÇ  ${prefix + command} Te vi de canto
‚îÇ  ${prefix + command} R√¥ Rosa
‚îÇ
‚ï∞‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚ïØ`);
    }



    await reply('üîé Buscando no SoundCloud... Aguarde!');

    soundcloud.searchDownload(q)
      .then(async (result) => {
        if (!result.ok) {
          if (result.msg.includes('API key inv√°lida')) {
            return reply('ü§ñ *Sistema de SoundCloud temporariamente indispon√≠vel*\n\nüòÖ Estou com problemas t√©cnicos no momento. O administrador j√° foi notificado!');
          }
          return reply(`‚ùå Erro: ${result.msg}`);
        }

        const formatDuration = (seconds) => {
          const mins = Math.floor(seconds / 60);
          const secs = seconds % 60;
          return `${mins}:${secs.toString().padStart(2, '0')}`;
        };

        const formatNumber = (num) => {
          if (num >= 1000000) return `${(num / 1000000).toFixed(1)}M`;
          if (num >= 1000) return `${(num / 1000).toFixed(1)}K`;
          return num.toString();
        };

        const caption = `üéµ *M√∫sica Encontrada!* üéµ\n\n` +
          `üîç *Busca:* ${result.query}\n\n` +
          `üìå *T√≠tulo:* ${result.track.title}\n` +
          `üë§ *Artista:* ${result.artist}\n` +
          `‚è±Ô∏è *Dura√ß√£o:* ${formatDuration(result.track.duration)}\n` +
          `‚ñ∂Ô∏è *Reprodu√ß√µes:* ${formatNumber(result.track.playback_count)}\n` +
          `‚ù§Ô∏è *Curtidas:* ${formatNumber(result.track.likes_count)}\n` +
          `üéº *G√™nero:* ${result.track.genre || 'Desconhecido'}\n` +
          `üîó *Link:* ${result.track.permalink_url}\n\n` +
          `üéß *Baixando e processando...*`;

        try {
          await nazu.sendMessage(from, {
            image: { url: result.thumbnail },
            caption
          }, { quoted: info });
        } catch (imgErr) {
          console.error('Erro ao enviar thumbnail do SoundCloud:', imgErr);
        }

        try {
          await nazu.sendMessage(from, {
            audio: result.buffer,
            mimetype: 'audio/mpeg',
            fileName: result.filename
          }, { quoted: info });
        } catch (audioError) {
          if (String(audioError).includes("ENOSPC") || String(audioError).includes("size")) {
            await reply('üì¶ Arquivo muito grande, enviando como documento...');
            await nazu.sendMessage(from, {
              document: result.buffer,
              fileName: result.filename,
              mimetype: 'audio/mpeg'
            }, { quoted: info });
          } else {
            console.error('Erro ao enviar √°udio do SoundCloud:', audioError);
            reply('‚ùå Ocorreu um erro ao enviar o √°udio.');
          }
        }
      })
      .catch((error) => {
        console.error('Erro na busca/download do SoundCloud:', error);
        if (error.message?.includes('API key inv√°lida')) {
          reply('ü§ñ *Sistema de SoundCloud temporariamente indispon√≠vel*');
        } else {
          reply(`‚ùå Erro ao buscar no SoundCloud: ${error.message}`);
        }
      });

  } catch (error) {
    console.error('Erro no comando play3:', error);
    reply("‚ùå Ocorreu um erro ao processar sua solicita√ß√£o.");
  }
  break;

      case 'playvid':
      case 'ytmp4':
        try {
          if (!q) return reply(`Digite o nome do v√≠deo ou um link do YouTube.\n> Ex: ${prefix + command} Back to Black`);

          let videoUrl;
          
          if (q.includes('youtube.com') || q.includes('youtu.be')) {
            videoUrl = q;
            reply('Aguarde um momentinho... ‚òÄÔ∏è');
            youtube.mp4(videoUrl, 360)
              .then(async (dlRes) => {
                if (!dlRes.ok) return reply(dlRes.msg);

                try {
                  await nazu.sendMessage(from, {
                    video: dlRes.buffer,
                    fileName: `${dlRes.filename}`,
                    mimetype: 'video/mp4'
                  }, {
                    quoted: info
                  });
                } catch (videoError) {
                  if (String(videoError).includes("ENOSPC") || String(videoError).includes("size")) {
                    await reply('Arquivo muito grande, enviando como documento...');
                    await nazu.sendMessage(from, {
                      document: dlRes.buffer,
                      fileName: `${dlRes.filename}`,
                      mimetype: 'video/mp4'
                    }, {
                      quoted: info
                    });
                  } else {
                    throw videoError;
                  }
                }
              })
              .catch((e) => {
                console.error('Erro ao baixar/enviar v√≠deo direto (promise):', e);
                reply('‚ùå Ocorreu um erro ao processar sua solicita√ß√£o. Por favor, tente novamente mais tarde.');
              });
            return;
          } else {
            // Use Promise .then for search
            youtube.search(q)
              .then((videoInfo) => {
                if (!videoInfo.ok) return reply(videoInfo.msg);
                videoUrl = videoInfo.data.url;

                const caption = `\nüé¨ *V√≠deo Encontrado* üé¨\n\nüìå *T√≠tulo:* ${videoInfo.data.title}\nüë§ *Artista/Canal:* ${videoInfo.data.author.name}\n‚è± *Dura√ß√£o:* ${videoInfo.data.timestamp} (${videoInfo.data.seconds} segundos)\nüëÄ *Visualiza√ß√µes:* ${videoInfo.data.views.toLocaleString()}\nüìÖ *Publicado:* ${videoInfo.data.ago}\nüìú *Descri√ß√£o:* ${videoInfo.data.description.slice(0, 100)}${videoInfo.data.description.length > 100 ? '...' : ''}\nüîó *Link:* ${videoInfo.data.url}\n\nüìπ *Enviando seu v√≠deo, aguarde!*`;

                nazu.sendMessage(from, {
                  image: { url: videoInfo.data.thumbnail },
                  caption: caption,
                  footer: `By: ${nomebot}`
                }, { quoted: info }).catch((sendErr) => console.error('Erro ao enviar mensagem de resultado (playvid):', sendErr));

                return youtube.mp4(videoUrl, 360);
              })
              .then(async (dlRes) => {
                if (!dlRes.ok) return reply(dlRes.msg);

                try {
                  await nazu.sendMessage(from, {
                    video: dlRes.buffer,
                    fileName: `${dlRes.filename}`,
                    mimetype: 'video/mp4'
                  }, { quoted: info });
                } catch (videoError) {
                  if (String(videoError).includes("ENOSPC") || String(videoError).includes("size")) {
                    await reply('Arquivo muito grande, enviando como documento...');
                    await nazu.sendMessage(from, {
                      document: dlRes.buffer,
                      fileName: `${dlRes.filename}`,
                      mimetype: 'video/mp4'
                    }, { quoted: info });
                  } else {
                    throw videoError;
                  }
                }
              })
              .catch((e) => {
                console.error('Erro no download/playvid:', e);
                reply("‚ùå Ocorreu um erro ao processar sua solicita√ß√£o. Por favor, tente novamente mais tarde.");
              });

            return;
          }
          
          // O fluxo de busca/baixar j√° foi tratado via promessas acima.
        } catch (e) {
          console.error('Erro no comando playvid/ytmp4:', e);
          
          reply("‚ùå Ocorreu um erro ao processar sua solicita√ß√£o. Por favor, tente novamente mais tarde.");
        }
        break;
      case 'letra':
      case 'lyrics':
        try {
          if (!q) return reply('cade o nome da musica?');
          await reply('Aguarde um momentinho... ‚òÄÔ∏è');
          await reply(await Lyrics(q));
        } catch (e) {
          console.error(e);
          reply("ocorreu um erro üíî");
        }
        break;

      case 'tiktok':
      case 'tiktokaudio':
      case 'tiktokvideo':
      case 'tiktoks':
      case 'tiktoksearch':
      case 'ttk':
      case 'tkk':
        try {
          if (!q) return reply(`Digite um nome ou o link de um v√≠deo.\n> Ex: ${prefix}${command} Gato`);
          
          // Verificar se tem API key
          

          reply('Aguarde um momentinho... ‚òÄÔ∏è');
          let isTikTokUrl = q.includes('tiktok');
          const tiktokPromise = isTikTokUrl ? tiktok.dl(q) : tiktok.search(q);

          tiktokPromise
            .then(async (datinha) => {
              if (!datinha.ok) return reply(datinha.msg);

              for (const urlz of datinha.urls) {
                await nazu.sendMessage(from, {
                  [datinha.type]: {
                    url: urlz
                  }
                }, {
                  quoted: info
                });
              }

              if (datinha.audio) await nazu.sendMessage(from, {
                audio: {
                  url: datinha.audio
                },
                mimetype: 'audio/mp4'
              }, {
                quoted: info
              });
            })
            .catch(async (e) => {
              console.error('Erro no comando TikTok (promise):', e);
              reply("‚ùå Ocorreu um erro ao processar sua solicita√ß√£o. Por favor, tente novamente mais tarde.");
            });

          return;
        } catch (e) {
          console.error('Erro no comando TikTok:', e);
          
          reply("‚ùå Ocorreu um erro ao processar sua solicita√ß√£o. Por favor, tente novamente mais tarde.");
        }
        break;

case 'facebook':
case 'fb':
case 'fbdl':
case 'facebookdl':
  try {
    if (!q) {
      return reply(`‚ï≠‚îÅ‚îÅ‚îÅ‚ä± üìπ *FACEBOOK DOWNLOAD HD* üìπ ‚ä±‚îÅ‚îÅ‚îÅ‚ïÆ
‚îÇ
‚îÇ üìù Digite o link do v√≠deo do Facebook
‚îÇ
‚îÇ  *Exemplo:*
‚îÇ  ${prefix + command} https://www.facebook.com/...
‚îÇ
‚ï∞‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚ïØ`);
    }

    if (!q.includes('facebook.com/')) {
      return reply('‚ùå Por favor, envie um link v√°lido do Facebook.');
    }

    await reply('üìπ Baixando v√≠deo do Facebook em HD... Aguarde!');

    facebook.downloadHD(q)
      .then(async (result) => {
        if (!result.ok) {
          return reply(`‚ùå Erro: ${result.msg}`);
        }

        const qualityList = result.allQualities.map((q, i) => 
          `${i + 1}. ${q.resolution}`
        ).join('\n');

        const caption = `üìπ *V√≠deo Baixado com Sucesso!* üìπ\n\n` +
          `üìä *Qualidade:* ${result.resolution}\n` +
          (result.allQualities.length > 0 ? `\nüé¨ *Qualidades dispon√≠veis:*\n${qualityList}\n` : '') +
          `\nüì• *Enviando v√≠deo...*`;

        try {
          await nazu.sendMessage(from, {
            image: { url: result.thumbnail },
            caption
          }, { quoted: info });
        } catch (imgErr) {
          console.error('Erro ao enviar thumbnail do Facebook:', imgErr);
        }

        try {
          await nazu.sendMessage(from, {
            video: result.buffer,
            mimetype: 'video/mp4',
            fileName: result.filename
          }, { quoted: info });
        } catch (videoError) {
          if (String(videoError).includes("ENOSPC") || String(videoError).includes("size")) {
            await reply('üì¶ V√≠deo muito grande, enviando como documento...');
            await nazu.sendMessage(from, {
              document: result.buffer,
              fileName: result.filename,
              mimetype: 'video/mp4'
            }, { quoted: info });
          } else {
            console.error('Erro ao enviar v√≠deo do Facebook:', videoError);
            reply('‚ùå Ocorreu um erro ao enviar o v√≠deo.');
          }
        }
      })
      .catch((error) => {
        console.error('Erro no download do Facebook:', error);
        reply(`‚ùå Erro ao baixar do Facebook: ${error.message}`);
      });

  } catch (error) {
    console.error('Erro no comando facebook:', error);
    reply("‚ùå Ocorreu um erro ao processar sua solicita√ß√£o.");
  }
  break;

      case 'instagram':
      case 'igdl':
      case 'ig':
      case 'instavideo':
      case 'igstory':
        try {
          if (!q) return reply(`Digite um link do Instagram.\n> Ex: ${prefix}${command} https://www.instagram.com/reel/DFaq_X7uoiT/?igsh=M3Q3N2ZyMWU1M3Bo`);
          
          // Verificar se tem API key
          

          reply('Aguarde um momentinho... ‚òÄÔ∏è');
          igdl.dl(q)
            .then(async (datinha) => {
              if (!datinha.ok) return reply(datinha.msg);

              for (const item of datinha.data) {
                await nazu.sendMessage(from, {
                  [item.type]: item.buff
                }, {
                  quoted: info
                });
              }
            })
            .catch(async (e) => {
              console.error('Erro no comando Instagram (promise):', e);
              reply("‚ùå Ocorreu um erro ao processar sua solicita√ß√£o. Por favor, tente novamente mais tarde.");
            });
          return;
        } catch (e) {
          console.error('Erro no comando Instagram:', e);
          reply("‚ùå Ocorreu um erro ao processar sua solicita√ß√£o. Por favor, tente novamente mais tarde.");
        }
        break;
      case 'gdrive':
      case 'googledrive':
      case 'drive':
      case 'gd':
        try {
          if (!q) return reply(`üìÅ *Google Drive Download*\n\n‚ùå Por favor, envie o link do arquivo do Google Drive.\n\nüìù *Uso:* ${prefix}${command} <link>\n\nüìå *Formatos suportados:*\n‚Ä¢ https://drive.google.com/file/d/ID/view\n‚Ä¢ https://drive.google.com/open?id=ID\n‚Ä¢ https://drive.google.com/uc?id=ID`);
          
          // Validar se √© um link do Google Drive
          const gdriveRegex = /(?:https?:\/\/)?(?:drive\.google\.com\/(?:file\/d\/|open\?id=|uc\?id=)|docs\.google\.com\/(?:document|spreadsheets|presentation)\/d\/)([a-zA-Z0-9_-]+)/i;
          if (!gdriveRegex.test(q)) {
            return reply('‚ùå Link inv√°lido! Por favor, envie um link v√°lido do Google Drive.');
          }
          
          await reply('‚è≥ Buscando informa√ß√µes do arquivo...');
          
          // Usar implementa√ß√£o local do gdrive
          const gdriveResult = await gdriveGetInfo(q);
          
          if (!gdriveResult.ok) {
            return reply(`‚ùå ${gdriveResult.msg || 'Erro ao obter informa√ß√µes do arquivo'}`);
          }
          
          const { fileName, fileSize, fileSizeBytes, downloadUrl, mimetype } = gdriveResult;
          
          // Verificar tamanho do arquivo (limite de 100MB para envio no WhatsApp)
          const maxSize = 100 * 1024 * 1024; // 100MB
          if (fileSizeBytes > maxSize) {
            const shortLinkGdrive = await axios.post("https://spoo.me/api/v1/shorten", { 
              long_url: downloadUrl, 
              alias: `nazuna_${Math.floor(10000 + Math.random() * 90000)}` 
            });
            return reply(`üìÅ *Arquivo encontrado!*\n\nüìÑ *Nome:* ${fileName}\nüìä *Tamanho:* ${fileSize}\nüìã *Tipo:* ${mimetype}\n\n‚ö†Ô∏è *Arquivo muito grande para enviar!*\nO limite do WhatsApp √© 100MB.\n\nüîó *Link direto:*\n${shortLinkGdrive.data.short_url}`);
          }
          
          await reply(`üìÅ *Baixando arquivo...*\n\nüìÑ *Nome:* ${fileName}\nüìä *Tamanho:* ${fileSize}\nüìã *Tipo:* ${mimetype}`);
          
          // Baixar o arquivo
          const fileResponse = await axios.get(downloadUrl, {
            responseType: 'arraybuffer',
            timeout: 120000,
            maxContentLength: maxSize,
            headers: {
              'User-Agent': 'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36'
            }
          });
          
          const fileBuffer = Buffer.from(fileResponse.data);
          
          // Determinar o tipo de m√≠dia e enviar
          if (mimetype.startsWith('image/')) {
            await nazu.sendMessage(from, {
              image: fileBuffer,
              caption: `üìÅ *${fileName}*\nüìä Tamanho: ${fileSize}`,
              mimetype: mimetype
            }, { quoted: info });
          } else if (mimetype.startsWith('video/')) {
            await nazu.sendMessage(from, {
              video: fileBuffer,
              caption: `üìÅ *${fileName}*\nüìä Tamanho: ${fileSize}`,
              mimetype: mimetype
            }, { quoted: info });
          } else if (mimetype.startsWith('audio/')) {
            await nazu.sendMessage(from, {
              audio: fileBuffer,
              mimetype: mimetype,
              ptt: false
            }, { quoted: info });
          } else {
            // Enviar como documento para outros tipos
            await nazu.sendMessage(from, {
              document: fileBuffer,
              fileName: fileName,
              mimetype: mimetype,
              caption: `üìÅ *Google Drive Download*\nüìä Tamanho: ${fileSize}`
            }, { quoted: info });
          }
          
          reply('‚úÖ Download conclu√≠do!');
        } catch (e) {
          console.error('Erro no comando gdrive:', e);
          
          if (e.code === 'ECONNABORTED' || e.message?.includes('timeout')) {
            return reply('‚è∞ Tempo esgotado! O arquivo pode ser muito grande ou a conex√£o est√° lenta.');
          }
          
          reply('‚ùå Ocorreu um erro ao baixar o arquivo. Verifique se o link est√° correto e tente novamente.');
        }
        break;
      case 'mediafire':
      case 'mf':
        try {
          if (!q) return reply(`üìÅ *MediaFire Download*\n\n‚ùå Por favor, envie o link do arquivo do MediaFire.\n\nüìù *Uso:* ${prefix}${command} <link>\n\nüìå *Exemplo:*\n${prefix}${command} https://www.mediafire.com/file/abc123/arquivo.zip/file`);
          
          // Validar se √© um link do MediaFire
          const mediafireRegex = /(?:https?:\/\/)?(?:www\.)?mediafire\.com\/(?:file|view|download)\/([a-zA-Z0-9]+)/i;
          if (!mediafireRegex.test(q)) {
            return reply('‚ùå Link inv√°lido! Por favor, envie um link v√°lido do MediaFire.');
          }
          
          await reply('‚è≥ Buscando informa√ß√µes do arquivo...');
          
          // Usar implementa√ß√£o local do mediafire
          const mfResult = await mediafireGetInfo(q);
          
          if (!mfResult.ok) {
            return reply(`‚ùå ${mfResult.msg || 'Erro ao obter informa√ß√µes do arquivo'}`);
          }
          
          const { fileName, fileSize, uploadDate, mimetype, extension, downloadUrl } = mfResult;
          
          // Converter tamanho para bytes para verifica√ß√£o
          const sizeMatch = fileSize.match(/([\d.]+)\s*(KB|MB|GB)/i);
          let fileSizeBytes = 0;
          if (sizeMatch) {
            const size = parseFloat(sizeMatch[1]);
            const unit = sizeMatch[2].toUpperCase();
            if (unit === 'KB') fileSizeBytes = size * 1024;
            else if (unit === 'MB') fileSizeBytes = size * 1024 * 1024;
            else if (unit === 'GB') fileSizeBytes = size * 1024 * 1024 * 1024;
          }
          
          // Verificar tamanho do arquivo (limite de 100MB para envio no WhatsApp)
          const maxSize = 100 * 1024 * 1024; // 100MB
          if (fileSizeBytes > maxSize) {
            const shortLinkMf = await axios.post("https://spoo.me/api/v1/shorten", { 
              long_url: downloadUrl, 
              alias: `nazuna_${Math.floor(10000 + Math.random() * 90000)}` 
            });
            return reply(`üìÅ *Arquivo encontrado!*\n\nüìÑ *Nome:* ${fileName}\nüìä *Tamanho:* ${fileSize}\nüìÖ *Upload:* ${uploadDate || 'N/A'}\nüìã *Tipo:* ${extension || mimetype}\n\n‚ö†Ô∏è *Arquivo muito grande para enviar!*\nO limite do WhatsApp √© 100MB.\n\nüîó *Link direto:*\n${shortLinkMf.data.short_url}`);
          }
          
          await reply(`üìÅ *Baixando arquivo...*\n\nüìÑ *Nome:* ${fileName}\nüìä *Tamanho:* ${fileSize}\nüìÖ *Upload:* ${uploadDate || 'N/A'}`);
          
          // Baixar o arquivo
          const fileResponse = await axios.get(downloadUrl, {
            responseType: 'arraybuffer',
            timeout: 120000,
            maxContentLength: maxSize,
            headers: {
              'User-Agent': 'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36'
            }
          });
          
          const fileBuffer = Buffer.from(fileResponse.data);
          const mimeType = mimetype || 'application/octet-stream';
          
          // Determinar o tipo de m√≠dia e enviar
          if (mimeType.startsWith('image/')) {
            await nazu.sendMessage(from, {
              image: fileBuffer,
              caption: `üìÅ *${fileName}*\nüìä Tamanho: ${fileSize}`,
              mimetype: mimeType
            }, { quoted: info });
          } else if (mimeType.startsWith('video/')) {
            await nazu.sendMessage(from, {
              video: fileBuffer,
              caption: `üìÅ *${fileName}*\nüìä Tamanho: ${fileSize}`,
              mimetype: mimeType
            }, { quoted: info });
          } else if (mimeType.startsWith('audio/')) {
            await nazu.sendMessage(from, {
              audio: fileBuffer,
              mimetype: mimeType,
              ptt: false
            }, { quoted: info });
          } else {
            // Enviar como documento para outros tipos
            await nazu.sendMessage(from, {
              document: fileBuffer,
              fileName: fileName,
              mimetype: mimeType,
              caption: `üìÅ *MediaFire Download*\nüìä Tamanho: ${fileSize}`
            }, { quoted: info });
          }
          
          reply('‚úÖ Download conclu√≠do!');
        } catch (e) {
          console.error('Erro no comando mediafire:', e);
          
          if (e.code === 'ECONNABORTED' || e.message?.includes('timeout')) {
            return reply('‚è∞ Tempo esgotado! O arquivo pode ser muito grande ou a conex√£o est√° lenta.');
          }
          
          reply('‚ùå Ocorreu um erro ao baixar o arquivo. Verifique se o link est√° correto e tente novamente.');
        }
        break;
      case 'twitter':
      case 'twitterdl':
      case 'twt':
      case 'x':
      case 'xdl':
        try {
          if (!q) return reply(`üê¶ *Twitter/X Download*\n\n‚ùå Por favor, envie o link do tweet.\n\nüìù *Uso:* ${prefix}${command} <link>\n\nüìå *Formatos suportados:*\n‚Ä¢ https://twitter.com/user/status/ID\n‚Ä¢ https://x.com/user/status/ID`);
          
          // Validar se √© um link do Twitter/X
          const twitterRegex = /(?:https?:\/\/)?(?:www\.)?(?:twitter\.com|x\.com)\/(?:\w+\/status|i\/status)\/(\d+)/i;
          if (!twitterRegex.test(q)) {
            return reply('‚ùå Link inv√°lido! Por favor, envie um link v√°lido do Twitter/X.');
          }
          
          await reply('‚è≥ Buscando informa√ß√µes do tweet...');
          
          // Usar implementa√ß√£o local do twitter
          const twitterResult = await twitterGetInfo(q);
          
          if (!twitterResult.ok) {
            return reply(`‚ùå ${twitterResult.msg || 'Erro ao obter informa√ß√µes do tweet'}`);
          }
          
          const { text, author, stats, media, hasMedia, type } = twitterResult;
          
          // Formatar caption
          const caption = `üê¶ *Twitter/X Download*\n\nüë§ *${author?.name || 'Usu√°rio'}* (@${author?.username || 'unknown'})\n\nüí¨ ${text || ''}\n\n‚ù§Ô∏è ${stats?.likes || 0} ‚Ä¢ üîÅ ${stats?.retweets || 0} ‚Ä¢ üí¨ ${stats?.replies || 0}`;
          
          if (!hasMedia || !media || media.length === 0) {
            return reply(`${caption}\n\n‚ö†Ô∏è Este tweet n√£o cont√©m m√≠dia para download.`);
          }
          
          // Enviar cada m√≠dia
          for (const item of media) {
            try {
              if (item.type === 'video') {
                // Usar a melhor qualidade dispon√≠vel
                const videoUrl = item.bestQuality?.url || item.url;
                
                await nazu.sendMessage(from, {
                  video: { url: videoUrl },
                  caption: caption,
                  mimetype: 'video/mp4'
                }, { quoted: info });
                
              } else if (item.type === 'photo' || item.type === 'image') {
                await nazu.sendMessage(from, {
                  image: { url: item.url },
                  caption: caption
                }, { quoted: info });
                
              } else if (item.type === 'gif' || item.type === 'animated_gif') {
                await nazu.sendMessage(from, {
                  video: { url: item.url },
                  caption: caption,
                  gifPlayback: true
                }, { quoted: info });
              }
            } catch (mediaError) {
              console.error('Erro ao enviar m√≠dia do Twitter:', mediaError);
            }
          }
          
          reply('‚úÖ Download conclu√≠do!');
        } catch (e) {
          console.error('Erro no comando twitter:', e);
          
          if (e.code === 'ECONNABORTED' || e.message?.includes('timeout')) {
            return reply('‚è∞ Tempo esgotado! Tente novamente.');
          }
          
          reply('‚ùå Ocorreu um erro ao baixar o tweet. Verifique se o link est√° correto e tente novamente.');
        }
        break;
      case 'google':
      case 'pesquisar':
      case 'buscar':
      case 'search':
        try {
          if (!q) return reply(`üîç *Pesquisa Web*\n\n‚ùå Digite o que deseja pesquisar.\n\nüìù *Uso:* ${prefix}${command} <termo>\n\nüìå *Exemplo:*\n${prefix}${command} intelig√™ncia artificial`);
          
          await reply('üîç Pesquisando...');
          
          // Usar implementa√ß√£o local de search
          const searchResult = await search(q, 10);
          
          if (!searchResult.ok) {
            return reply('‚ùå Nenhum resultado encontrado.');
          }
          
          const { query, results } = searchResult;
          
          let response = `üîç *Resultados para:* "${query}"\n\n`;
          
          results.slice(0, 8).forEach((result, index) => {
            response += `*${index + 1}. ${result.title}*\n`;
            response += `üìù ${result.description?.substring(0, 150) || 'Sem descri√ß√£o'}${result.description?.length > 150 ? '...' : ''}\n`;
            response += `üîó ${result.url}\n\n`;
          });
          
          reply(response.trim());
        } catch (e) {
          console.error('Erro no comando google:', e);
          reply('‚ùå Ocorreu um erro na pesquisa. Tente novamente.');
        }
        break;
      case 'noticias':
      case 'news':
      case 'noticia':
        try {
          if (!q) return reply(`üì∞ *Pesquisa de Not√≠cias*\n\n‚ùå Digite o que deseja pesquisar.\n\nüìù *Uso:* ${prefix}${command} <termo>\n\nüìå *Exemplo:*\n${prefix}${command} tecnologia brasil`);
          
          await reply('üì∞ Buscando not√≠cias...');
          
          // Usar implementa√ß√£o local de searchNews
          const newsResult = await searchNews(q, 10);
          
          if (!newsResult.ok) {
            return reply('‚ùå Nenhuma not√≠cia encontrada.');
          }
          
          const { query: newsQuery, results: newsResults } = newsResult;
          
          let newsText = `üì∞ *Not√≠cias sobre:* "${newsQuery}"\n\n`;
          
          newsResults.slice(0, 8).forEach((news, index) => {
            newsText += `*${index + 1}. ${news.title}*\n`;
            newsText += `üìù ${news.description?.substring(0, 120) || 'Sem descri√ß√£o'}${news.description?.length > 120 ? '...' : ''}\n`;
            newsText += `üîó ${news.url}\n\n`;
          });
          
          reply(newsText.trim());
        } catch (e) {
          console.error('Erro no comando noticias:', e);
          reply('‚ùå Ocorreu um erro na pesquisa. Tente novamente.');
        }
        break;
      case 'pinterest':
      case 'pin':
        try {
          if (!q) return reply('Digite o termo para pesquisar no Pinterest. Exemplo: ' + prefix + 'pinterest gatinhos /3');

          // Detecta se √© URL de Pinterest antes de qualquer split
          const PIN_URL_REGEX = /^(?:https?:\/\/)?(?:[a-zA-Z0-9-]+\.)?pinterest\.\w{2,6}(?:\.\w{2})?\/pin\/([0-9a-zA-Z]+)|^https?:\/\/pin\.it\/[a-zA-Z0-9]+/i;
          let maxImages = 5;
          let searchTerm = q.trim();

          // S√≥ extrai limite \/N se N√ÉO for URL
          if (!PIN_URL_REGEX.test(searchTerm)) {
            const limitMatch = searchTerm.match(/\s\/\s*(\d{1,2})\s*$/);
            if (limitMatch) {
              const parsed = parseInt(limitMatch[1]);
              maxImages = Math.max(1, Math.min(parsed, 10));
              searchTerm = searchTerm.replace(/\s\/\s*\d{1,2}\s*$/, '').trim();
            }
          } else {
            // Para URL, baixa 1 m√≠dia (padr√£o)
            maxImages = 1;
          }

          const isPinUrl = PIN_URL_REGEX.test(searchTerm);
          // Ensure API key is configured
          
          const pinPromise = isPinUrl ? pinterest.dl(searchTerm) : pinterest.search(searchTerm);

          pinPromise
            .then(async (datinha) => {
              if (!datinha.ok || !datinha.urls || datinha.urls.length === 0) {
                return reply(isPinUrl ? 'N√£o foi poss√≠vel baixar este link do Pinterest. üòï' : 'Nenhuma imagem encontrada para o termo pesquisado. üòï');
              }

              const itemsToSend = datinha.urls.slice(0, maxImages);
              for (const url of itemsToSend) {
            const message = isPinUrl && datinha.type === 'video'
              ? { video: { url }, caption: 'üìå Download do Pinterest' }
              : { image: { url }, caption: isPinUrl ? 'üìå Download do Pinterest' : `üìå Resultado da pesquisa por "${searchTerm}"` };
            await nazu.sendMessage(from, message, { quoted: info });
              }
            })
            .catch((e) => {
              console.error('Erro no comando pinterest (promise):', e);
              reply("Ocorreu um erro ao processar o Pinterest üíî");
            });
          return;
        } catch (e) {
          console.error('Erro no comando pinterest:', e);
          reply("Ocorreu um erro ao processar o Pinterest üíî");
        }
        break;
 
      case 'menu':
      case 'help':
      case 'comandos':
      case 'commands':
        try {
          // Verifica se o grupo tem personaliza√ß√£o
          let customBotName = nomebot;
          let customMediaPath = null;
          
          if (isGroup && isGroupCustomizationEnabled()) {
            const groupCustom = getGroupCustomization(from);
            if (groupCustom) {
              if (groupCustom.customName) {
                customBotName = groupCustom.customName;
              }
              if (groupCustom.customPhoto && fs.existsSync(groupCustom.customPhoto)) {
                customMediaPath = groupCustom.customPhoto;
              }
            }
          }
          
          // Define a m√≠dia a ser usada
          let mediaPath, useVideo, mediaBuffer;
          
          if (customMediaPath) {
            // Usa a foto personalizada do grupo
            mediaPath = customMediaPath;
            useVideo = false;
            mediaBuffer = fs.readFileSync(mediaPath);
          } else {
            // Usa a m√≠dia padr√£o
            const menuVideoPath = __dirname + '/../midias/menu.mp4';
            const menuImagePath = __dirname + '/../midias/menu.jpg';
            useVideo = fs.existsSync(menuVideoPath);
            mediaPath = useVideo ? menuVideoPath : menuImagePath;
            mediaBuffer = fs.readFileSync(mediaPath);
          }
          
          const customDesign = getMenuDesignWithDefaults(customBotName, pushname);
          const menuText = await menu(prefix, customBotName, pushname, customDesign);
          const lerMaisPrefix = getMenuLerMaisText();
          
          // Envia o √°udio primeiro se configurado
          if (isMenuAudioEnabled()) {
            const audioPath = getMenuAudioPath();
            if (audioPath && fs.existsSync(audioPath)) {
              const audioBuffer = fs.readFileSync(audioPath);
              await nazu.sendMessage(from, {
                audio: audioBuffer,
                mimetype: 'audio/mpeg',
                ptt: false
              }, {
                quoted: info
              }).then(async () => {
                // Depois envia o menu
                await nazu.sendMessage(from, {
                  [useVideo ? 'video' : 'image']: mediaBuffer,
                  caption: lerMaisPrefix + menuText,
                  gifPlayback: useVideo,
                  mimetype: useVideo ? 'video/mp4' : 'image/jpeg'
                }, {
                  quoted: info
                });
              });
            } else {
              // Se n√£o tem √°udio v√°lido, envia s√≥ o menu
              await nazu.sendMessage(from, {
                [useVideo ? 'video' : 'image']: mediaBuffer,
                caption: lerMaisPrefix + menuText,
                gifPlayback: useVideo,
                mimetype: useVideo ? 'video/mp4' : 'image/jpeg'
              }, {
                quoted: info
              });
            }
          } else {
            // Se √°udio n√£o est√° ativo, envia s√≥ o menu
            await nazu.sendMessage(from, {
              [useVideo ? 'video' : 'image']: mediaBuffer,
              caption: lerMaisPrefix + menuText,
              gifPlayback: useVideo,
              mimetype: useVideo ? 'video/mp4' : 'image/jpeg'
            }, {
              quoted: info
            });
          }
        } catch (error) {
          console.error('Erro ao enviar menu:', error);
          const customDesign = getMenuDesignWithDefaults(nomebot, pushname);
          const menuText = await menu(prefix, nomebot, pushname, customDesign);
          await reply(`${menuText}\n\n‚ö†Ô∏è *Nota*: Ocorreu um erro ao carregar a m√≠dia do menu.`);
        }
        break;
      case 'alteradores':
      case 'menualterador':
      case 'menualteradores':
      case 'changersmenu':
      case 'changers':
        try {
          await sendMenuWithMedia('alteradores', menuAlterador);
        } catch (error) {
          console.error('Erro ao enviar menu de alteradores:', error);
          await reply("‚ùå Ocorreu um erro ao carregar o menu de alteradores");
        }
        break;
      case 'menuia':
      case 'aimenu':
      case 'menuias':
        try {
          await sendMenuWithMedia('ia', menuIa);
        } catch (error) {
          console.error('Erro ao enviar menu de IA:', error);
          await reply("‚ùå Ocorreu um erro ao carregar o menu de IA");
        }
        break;
      case 'menubn':
      case 'menubrincadeira':
      case 'menubrincadeiras':
      case 'gamemenu':
        try {
          const customDesign = getMenuDesignWithDefaults(nomebot, pushname);
          let menuContent = await menubn(prefix, nomebot, pushname, isModoLite, customDesign);
          await sendMenuWithMedia('brincadeiras', async () => menuContent);
        } catch (error) {
          console.error('Erro ao enviar menu de brincadeiras:', error);
          await reply("‚ùå Ocorreu um erro ao carregar o menu de brincadeiras");
        }
        break;
      case 'menudown':
      case 'menudownload':
      case 'menudownloads':
      case 'downmenu':
      case 'downloadmenu':
        try {
          await sendMenuWithMedia('downloads', menudown);
        } catch (error) {
          console.error('Erro ao enviar menu de downloads:', error);
          await reply("‚ùå Ocorreu um erro ao carregar o menu de downloads");
        }
        break;
      case 'ferramentas':
      case 'menuferramentas':
      case 'menuferramenta':
      case 'toolsmenu':
      case 'tools':
        try {
          await sendMenuWithMedia('ferramentas', menuFerramentas);
        } catch (error) {
          console.error('Erro ao enviar menu de ferramentas:', error);
          await reply("‚ùå Ocorreu um erro ao carregar o menu de ferramentas");
        }
        break;
      case 'menuadm':
      case 'menuadmin':
      case 'menuadmins':
      case 'admmenu':
        try {
          await sendMenuWithMedia('admin', menuadm);
        } catch (error) {
          console.error('Erro ao enviar menu de administra√ß√£o:', error);
          await reply("‚ùå Ocorreu um erro ao carregar o menu de administra√ß√£o");
        }
        break;
      case 'menumembros':
      case 'menumemb':
      case 'menugeral':
      case 'membmenu':
      case 'membermenu':
        try {
          await sendMenuWithMedia('membros', menuMembros);
        } catch (error) {
          console.error('Erro ao enviar menu de membros:', error);
          await reply("‚ùå Ocorreu um erro ao carregar o menu de membros");
        }
        break;
      case 'configcmdnotfound':
      case 'setcmdmsg':
        if (!isOwner) return reply(OWNER_ONLY_MESSAGE);
        
        const cmdNotFoundConfig = loadCmdNotFoundConfig();
        const subcommand = args[0]?.toLowerCase();
        
        if (!subcommand) {
          return reply(`üìù *Uso do ${prefix}configcmdnotfound:*\n\n` +
            `‚Ä¢ ${prefix}configcmdnotfound activate - Ativar mensagens de comando n√£o encontrado\n` +
            `‚Ä¢ ${prefix}configcmdnotfound deactivate - Desativar mensagens de comando n√£o encontrado\n` +
            `‚Ä¢ ${prefix}configcmdnotfound set <mensagem> - Definir mensagem personalizada\n` +
            `‚Ä¢ ${prefix}configcmdnotfound style <estilo> - Definir estilo (friendly, formal, casual, emoji)\n` +
            `‚Ä¢ ${prefix}configcmdnotfound preview - Pr√©-visualizar mensagem atual\n` +
            `‚Ä¢ ${prefix}configcmdnotfound reset - Restaurar configura√ß√µes padr√£o\n\n` +
            `üìå *Vari√°veis dispon√≠veis:*\n` +
            `{command} - Comando digitado\n` +
            `{prefix} - Prefixo do bot\n` +
            `{user} - Usu√°rio que digitou\n` +
            `{botName} - Nome do bot\n` +
            `{userName} - Nome do usu√°rio`);
        }
        
        switch (subcommand) {
          case 'activate':
            cmdNotFoundConfig.enabled = true;
            if (saveCmdNotFoundConfig(cmdNotFoundConfig, 'ativado')) {
              reply('‚úÖ Mensagens de comando n√£o encontrados foram ativadas!');
            }
            break;
            
          case 'deactivate':
            cmdNotFoundConfig.enabled = false;
            if (saveCmdNotFoundConfig(cmdNotFoundConfig, 'desativado')) {
              reply('‚úÖ Mensagens de comando n√£o encontrados foram desativadas!');
            }
            break;
            
          case 'set':
            const newMessage = args.slice(1).join(' ');
            if (!newMessage) {
              return reply('‚ùå Por favor, forne√ßa uma mensagem personalizada.\n\nExemplo: ' +
                prefix + 'configcmdnotfound set O comando {command} n√£o existe! Tente {prefix}menu');
            }
            
            // Validate the message template
            const validation = validateMessageTemplate(newMessage);
            if (!validation.valid) {
              return reply('‚ùå A mensagem cont√©m problemas:\n\n‚Ä¢ ' + validation.issues.join('\n‚Ä¢ ') + '\n\nCorrija esses problemas e tente novamente.');
            }
            
            cmdNotFoundConfig.message = newMessage;
            if (saveCmdNotFoundConfig(cmdNotFoundConfig)) {
              reply('‚úÖ Mensagem personalizada salva com sucesso!');
              console.log(`üîß Comando n√£o encontrado: Mensagem alterada por ${pushname} (${sender})`);
            } else {
              reply('‚ùå Ocorreu um erro ao salvar a mensagem. Tente novamente.');
            }
            break;
            
          case 'style':
            const style = args[1]?.toLowerCase();
            const validStyles = ['friendly', 'formal', 'casual', 'emoji'];
            if (!validStyles.includes(style)) {
              return reply('‚ùå Estilo inv√°lido! Estilos dispon√≠veis: ' + validStyles.join(', '));
            }
            
            cmdNotFoundConfig.style = style;
            if (saveCmdNotFoundConfig(cmdNotFoundConfig, `estilo alterado para ${style}`)) {
              reply(`‚úÖ Estilo alterado para "${style}" com sucesso!`);
            }
            break;
            
          case 'preview':
            const userName = pushname || getUserName(sender);
            const previewMessage = formatMessageWithFallback(
              cmdNotFoundConfig.message,
              {
                command: 'exemplo',
                prefix: prefixo,
                user: sender,
                botName: nomebot,
                userName: userName
              },
              '‚ùå Comando n√£o encontrado! Tente ' + prefixo + 'menu para ver todos os comandos dispon√≠veis.'
            );
            reply(`üîç *Pr√©-visualiza√ß√£o da mensagem:*\n\n${previewMessage}\n\n‚úÖ *Status da configura√ß√£o:*\n‚Ä¢ Ativado: ${cmdNotFoundConfig.enabled ? 'Sim' : 'N√£o'}\n‚Ä¢ Estilo: ${cmdNotFoundConfig.style}\n‚Ä¢ √öltima atualiza√ß√£o: ${new Date(cmdNotFoundConfig.lastUpdated || Date.now()).toLocaleString('pt-BR')}`);
            break;
            
          case 'reset':
            cmdNotFoundConfig.enabled = true;
            cmdNotFoundConfig.message = '‚ùå Comando n√£o encontrado! Tente {prefix}menu para ver todos os comandos dispon√≠veis.';
            cmdNotFoundConfig.style = 'friendly';
            cmdNotFoundConfig.variables = {
              command: '{command}',
              prefix: '{prefix}',
              user: '{user}',
              botName: '{botName}',
              userName: '{userName}'
            };
            
            if (saveCmdNotFoundConfig(cmdNotFoundConfig, 'resetado para padr√£o')) {
              reply('‚úÖ Configura√ß√µes de comando n√£o encontradas restauradas para o padr√£o!');
            }
            break;
            
          default:
            reply('‚ùå Subcomando inv√°lido! Use ' + prefix + 'configcmdnotfound para ver a lista de comandos dispon√≠veis.');
        }
        break;

      // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
      // TUTORIAL - Guia completo para configura√ß√£o do bot
      // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
      case 'tutorial':
      case 'guia':
      case 'ajuda':
        try {
          if (!isOwner) {
            await reply("‚ö†Ô∏è Este comando √© exclusivo para o dono do bot.");
            return;
          }

          const tutorialText = `üìö *TUTORIAL COMPLETO - ${nomebot}*

Bem-vindo ao guia completo de configura√ß√£o e personaliza√ß√£o! Vamos aprender passo a passo como aproveitar ao m√°ximo seu bot.

‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ
üìã *√çNDICE*
‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ

1Ô∏è‚É£ Configura√ß√µes B√°sicas
2Ô∏è‚É£ Personaliza√ß√£o Visual  
3Ô∏è‚É£ Sistema de Comandos
4Ô∏è‚É£ Automa√ß√£o e Respostas
5Ô∏è‚É£ Gerenciamento de Usu√°rios
6Ô∏è‚É£ Sistema de Aluguel
7Ô∏è‚É£ Sub-Bots
8Ô∏è‚É£ Sistema VIP/Premium
9Ô∏è‚É£ Controle e Manuten√ß√£o
üîü Monitoramento e An√°lise
1Ô∏è‚É£1Ô∏è‚É£ Transmiss√µes

‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ
1Ô∏è‚É£ *CONFIGURA√á√ïES B√ÅSICAS*
‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ

üîπ *Alterando o Prefixo*
Use: ${prefix}prefixo <novo_prefixo>
Exemplo: ${prefix}prefixo .
‚Ä¢ Define qual s√≠mbolo inicia os comandos
‚Ä¢ Pode ser: ! . / # $ ou qualquer caractere

üîπ *Mensagem de Prefixo*
Use: ${prefix}msgprefix <mensagem>
Exemplo: ${prefix}msgprefix Use #prefixo# antes do comando!
‚Ä¢ Mensagem mostrada quando esquecem o prefixo
‚Ä¢ Use #prefixo# onde o prefixo deve aparecer
‚Ä¢ Para desativar: ${prefix}msgprefix off

üîπ *Nome do Bot*
Use: ${prefix}nomebot <nome>
Exemplo: ${prefix}nomebot Nazuna
‚Ä¢ Altera o nome exibido nos menus
‚Ä¢ Use nomes curtos e memor√°veis

üîπ *Nome do Dono*
Use: ${prefix}nomedono <nome>
Exemplo: ${prefix}nomedono Jo√£o
‚Ä¢ Seu nome nos cr√©ditos do bot

üîπ *N√∫mero do Dono*
Use: ${prefix}numerodono <n√∫mero>
Exemplo: ${prefix}numerodono 5511999999999
‚Ä¢ Formato: DDI + DDD + n√∫mero
‚Ä¢ Usado para permiss√µes de dono

üîπ *Mensagem de Comando N√£o Encontrado*
Use: ${prefix}configcmdnotfound <a√ß√£o>
A√ß√µes dispon√≠veis:
‚Ä¢ activate - Ativar mensagens personalizadas
‚Ä¢ deactivate - Desativar mensagens
‚Ä¢ set <texto> - Definir mensagem customizada
‚Ä¢ style <estilo> - Mudar estilo (friendly/formal/casual/emoji)
‚Ä¢ preview - Ver como ficar√° a mensagem
‚Ä¢ reset - Restaurar configura√ß√µes padr√£o

Vari√°veis dispon√≠veis:
{command} - Comando digitado
{prefix} - Prefixo do bot
{user} - Usu√°rio que digitou
{botName} - Nome do bot
{userName} - Nome do usu√°rio

Exemplo: ${prefix}configcmdnotfound set ‚ùå {command} n√£o existe! Veja: {prefix}menu

üîπ *Personaliza√ß√£o de Grupos*
Use: ${prefix}personalizargrupo
‚Ä¢ Ativa/desativa personaliza√ß√£o por grupo
‚Ä¢ Quando ativo, admins podem:
  - Mudar foto do menu do grupo
  - Personalizar nome do bot no grupo

‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ
2Ô∏è‚É£ *PERSONALIZA√á√ÉO VISUAL*
‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ

üé® *Design do Menu*
Use: ${prefix}designmenu
‚Ä¢ Mostra design atual

üîπ *Personalizando Elementos:*

‚Ä¢ Borda Superior:
  ${prefix}setborda ‚ï≠‚îÅ‚îÅ‚îÅ‚ä± ‚ä∞‚îÅ‚îÅ‚îÅ‚ïÆ

‚Ä¢ Borda Inferior:
  ${prefix}setbordafim ‚ï∞‚îÅ‚îÅ‚îÅ‚ä± ‚ä∞‚îÅ‚îÅ‚îÅ‚ïØ

‚Ä¢ Borda do Meio:
  ${prefix}setbordameio ‚îÇ

‚Ä¢ √çcone de Itens:
  ${prefix}setitem ‚û§

‚Ä¢ Separador:
  ${prefix}setseparador ‚ùñ

‚Ä¢ √çcone de T√≠tulo:
  ${prefix}settitulo ‚ú¶

‚Ä¢ Cabe√ßalho Personalizado:
  ${prefix}setheader ‚ï≠‚îÅ‚îÅ‚îÅ‚ùñ Ol√°, #user# ‚ùñ‚îÅ‚îÅ‚îÅ‚ïÆ

üîÑ *Resetar Design*
Use: ${prefix}resetdesign
‚Ä¢ Volta ao design padr√£o

üì∏ *M√≠dia do Menu*

‚Ä¢ Foto do Menu: ${prefix}fotomenu
  Responda uma imagem
  
‚Ä¢ V√≠deo do Menu: ${prefix}videomenu
  Responda um v√≠deo
  
‚Ä¢ √Åudio do Menu: ${prefix}audiomenu
  Responda um √°udio
  Para remover: ${prefix}audiomenu off
  
‚Ä¢ Foto do Bot (perfil): ${prefix}fotobot
  Responda uma imagem

üì± *"Ler Mais" nos Menus*
Use: ${prefix}lermais
‚Ä¢ Ativa/desativa caracteres invis√≠veis no in√≠cio do menu
‚Ä¢ Quando ativo, WhatsApp mostra "Ler mais"
‚Ä¢ Deixa os menus mais limpos na pr√©via

‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ
3Ô∏è‚É£ *SISTEMA DE COMANDOS*
‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ

‚ú® *Criar Comandos Personalizados*

üîπ *Comando de Texto:*
${prefix}addcmd <nome> | <resposta>
Exemplo: ${prefix}addcmd oi | Ol√°! Tudo bem?

üîπ *Comando com M√≠dia:*
${prefix}addcmdmidia <nome> | <legenda>
‚Ä¢ Responda uma imagem/v√≠deo/√°udio
Exemplo: ${prefix}addcmdmidia bemvindo | Seja bem-vindo!

üîπ *Gerenciar Comandos:*
‚Ä¢ Listar: ${prefix}listcmd
‚Ä¢ Deletar: ${prefix}delcmd <nome>
‚Ä¢ Testar: ${prefix}testcmd <nome>
‚Ä¢ Definir resposta: ${prefix}setcmdmsg (mesmo que configcmdnotfound)

üîÄ *Sistema de Alias*
‚Ä¢ Adicionar: ${prefix}addalias <comando_existente> | <novo_nome>
  Exemplo: ${prefix}addalias sticker | fig
‚Ä¢ Listar: ${prefix}listalias
‚Ä¢ Remover: ${prefix}delalias <alias>

üö´ *Limitar Comandos*
‚Ä¢ Limitar: ${prefix}cmdlimitar <comando> <max_usos> <tempo_em_segundos>
  Exemplo: ${prefix}cmdlimitar gpt 3 60
  (3 usos a cada 60 segundos)
‚Ä¢ Deslimitar: ${prefix}cmddeslimitar <comando>
‚Ä¢ Ver limites: ${prefix}cmdlimites

‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ
4Ô∏è‚É£ *AUTOMA√á√ÉO E RESPOSTAS*
‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ

ü§ñ *Respostas Autom√°ticas*

üîπ *Resposta de Texto:*
${prefix}addauto <palavra> | <resposta>
Exemplo: ${prefix}addauto oi | Ol√°! Como posso ajudar?

üîπ *Resposta com M√≠dia:*
${prefix}addautomidia <palavra> | <legenda>
‚Ä¢ Responda uma imagem/v√≠deo
‚Ä¢ A m√≠dia ser√° enviada quando algu√©m digitar a palavra

üîπ *Gerenciar:*
‚Ä¢ Listar: ${prefix}listauto
‚Ä¢ Deletar: ${prefix}delauto <palavra>

üòä *Rea√ß√µes Autom√°ticas*
‚Ä¢ Adicionar: ${prefix}addreact <palavra> <emoji>
  Exemplo: ${prefix}addreact obrigado üôè
‚Ä¢ Listar: ${prefix}listreact
‚Ä¢ Deletar: ${prefix}delreact <id>

üîì *Comandos Sem Prefixo*
‚Ä¢ Adicionar: ${prefix}addnopref <comando>
  Exemplo: ${prefix}addnopref menu
‚Ä¢ Listar: ${prefix}listnopref
‚Ä¢ Deletar: ${prefix}delnopref <comando>

‚è∞ *Mensagens Autom√°ticas (em grupos)*
üìå Comando s√≥ funciona em grupos!

‚Ä¢ Adicionar: ${prefix}automsg add HH:MM | descri√ß√£o
  Responda uma mensagem (texto/imagem/v√≠deo/√°udio/documento/sticker)
  Exemplo: ${prefix}automsg add 08:00 | Bom dia!
  
‚Ä¢ Listar: ${prefix}automsg list
  Mostra todas as mensagens autom√°ticas do grupo
  
‚Ä¢ Deletar: ${prefix}automsg del <id>
  Remove uma mensagem autom√°tica
  
‚Ä¢ Ativar: ${prefix}automsg on <id>
  Ativa uma mensagem desativada
  
‚Ä¢ Desativar: ${prefix}automsg off <id>
  Desativa sem deletar

üí° As mensagens ser√£o enviadas no hor√°rio definido, todos os dias!

‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ
5Ô∏è‚É£ *GERENCIAMENTO DE USU√ÅRIOS*
‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ

üëë *Sub-Donos*
‚Ä¢ Adicionar: ${prefix}addsubdono @usuario
‚Ä¢ Remover: ${prefix}delsubdono @usuario
‚Ä¢ Listar: ${prefix}listasubdonos
‚Ä¢ Sub-donos t√™m acesso a comandos de dono

üíé *Usu√°rios Premium*
‚Ä¢ Adicionar: ${prefix}addpremium @usuario
‚Ä¢ Remover: ${prefix}delpremium @usuario
‚Ä¢ Listar: ${prefix}listprem
‚Ä¢ Resetar gold: ${prefix}resetgold @usuario
  (Remove todo ouro/pontos do usu√°rio)

üéÅ *Sistema de Indica√ß√µes*
‚Ä¢ Adicionar indica√ß√£o: ${prefix}addindicacao @usuario
  Adiciona +1 indica√ß√£o ao usu√°rio
  
‚Ä¢ Ver ranking: ${prefix}topindica
  Mostra top 10 usu√°rios com mais indica√ß√µes
  
‚Ä¢ Remover indica√ß√µes: ${prefix}delindicacao @usuario [quantidade]
  Se n√£o especificar quantidade, remove todas
  Exemplo: ${prefix}delindicacao @usuario 5
  Remove 5 indica√ß√µes

üö´ *Blacklist Global*
‚Ä¢ Banir: ${prefix}addblackglobal @usuario | motivo
  ou: ${prefix}addblackglobal 5511999999999 | motivo
‚Ä¢ Desbanir: ${prefix}rmblackglobal @usuario
  ou: ${prefix}rmblackglobal 5511999999999
‚Ä¢ Listar: ${prefix}listblackglobal
‚Ä¢ Usu√°rio banido √© removido automaticamente dos grupos

üö∑ *Banimento de Grupos*
‚Ä¢ Banir grupo: ${prefix}bangp
  Bane o grupo atual
‚Ä¢ Desbanir: ${prefix}unbangp <id_grupo>
‚Ä¢ Listar: ${prefix}listbangp

üîí *Bloqueios Espec√≠ficos*
‚Ä¢ Bloquear comando: ${prefix}blockcmdg <comando> <grupo_id>
‚Ä¢ Bloquear usu√°rio: ${prefix}blockuserg @usuario <grupo_id>
‚Ä¢ Desbloquear comando: ${prefix}unblockcmdg <comando> <grupo_id>
‚Ä¢ Desbloquear usu√°rio: ${prefix}unblockuserg @usuario <grupo_id>
‚Ä¢ Listar bloqueios: ${prefix}listblocks

‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ
6Ô∏è‚É£ *SISTEMA DE ALUGUEL*
‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ

üí∞ *Configura√ß√£o Inicial*
1. Ativar sistema: ${prefix}modoaluguel on
2. Configurar divulga√ß√£o: ${prefix}setdiv (responda mensagem)

üìù *Gerenciar Alugu√©is*

‚Ä¢ Adicionar aluguel:
  ${prefix}addaluguel <dias> <id_grupo>
  Exemplo: ${prefix}addaluguel 30 120363...@g.us

‚Ä¢ Gerar c√≥digo de ativa√ß√£o:
  ${prefix}gerarcod <dias> <quantidade>
  Exemplo: ${prefix}gerarcod 30 5

‚Ä¢ Estender aluguel:
  ${prefix}estenderaluguel <dias> <id_grupo>

‚Ä¢ Ver informa√ß√µes:
  ${prefix}infoaluguel <id_grupo>

‚Ä¢ Listar todos:
  ${prefix}listaraluguel
  ou ${prefix}listaluguel

‚Ä¢ Remover aluguel:
  ${prefix}removeraluguel <id_grupo>

‚Ä¢ Limpar vencidos:
  ${prefix}limparaluguel

‚Ä¢ Dia gr√°tis:
  ${prefix}dayfree <id_grupo>

üéÅ *Divulga√ß√£o Autom√°tica*
Use: ${prefix}divulgar
‚Ä¢ Envia mensagem de divulga√ß√£o em todos os grupos

‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ
7Ô∏è‚É£ *SUB-BOTS*
‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ

ü§ñ *Sistema de Sub-Bots*

üì± *Para o Dono Principal:*

1. Adicionar sub-bot:
   ${prefix}addsubbot <numero> | <nome>
   Exemplo: ${prefix}addsubbot 5511988887777 | Bot Auxiliar

2. Gerar c√≥digo de conex√£o:
   ${prefix}gerarcodigo <numero>

3. Listar sub-bots:
   ${prefix}listarsubbots

4. Remover sub-bot:
   ${prefix}removesubbot <numero>

5. Conectar manualmente:
   ${prefix}conectarsubbot <numero>

üì± *Para o Sub-Bot:*

1. Receba o c√≥digo do dono
2. Use: ${prefix}conectar <c√≥digo>
3. Pronto! Seu sub-bot est√° conectado

‚ÑπÔ∏è *Informa√ß√µes Importantes:*
‚Ä¢ Sub-bots compartilham comandos e configura√ß√µes
‚Ä¢ Podem responder em grupos diferentes
‚Ä¢ √ötil para atender mais usu√°rios

‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ
8Ô∏è‚É£ *SISTEMA VIP/PREMIUM*
‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ

üíé *Comandos Exclusivos VIP*

‚Ä¢ Tornar comando VIP:
  ${prefix}addcmdvip <comando>
  Exemplo: ${prefix}addcmdvip gpt4

‚Ä¢ Remover restri√ß√£o:
  ${prefix}removecmdvip <comando>

‚Ä¢ Listar comandos VIP:
  ${prefix}listcmdvip

‚Ä¢ Ativar/Desativar sistema:
  ${prefix}togglecmdvip

‚Ä¢ Estat√≠sticas:
  ${prefix}statsvip

‚Ä¢ Menu VIP personalizado:
  ${prefix}menuvip

‚Ä¢ Informa√ß√µes VIP de usu√°rio:
  ${prefix}infovip @usuario

‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ
9Ô∏è‚É£ *CONTROLE E MANUTEN√á√ÉO*
‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ

üîß *Controle do Bot*

‚Ä¢ Atualizar bot:
  ${prefix}atualizar
  Baixa e aplica atualiza√ß√µes do reposit√≥rio

‚Ä¢ Reiniciar:
  ${prefix}reiniciar
  Reinicia o bot completamente

‚Ä¢ Entrar em grupo:
  ${prefix}entrar <link>
  Faz o bot entrar em um grupo via link

‚Ä¢ Sair de grupo:
  ${prefix}sairgp
  Bot sai do grupo atual

‚Ä¢ Virar ADM:
  ${prefix}seradm
  Bot vira administrador (voc√™ deve promov√™-lo)

‚Ä¢ Virar membro:
  ${prefix}sermembro
  Remove privil√©gios de admin do bot

üõ°Ô∏è *Prote√ß√£o Anti-Ban*
Use: ${prefix}antibanmarcar <a√ß√£o>
A√ß√µes: on, off, status

Protege o bot de banimento ao usar comandos de marca√ß√£o em massa (hidetag, marcar, etc) em grupos com 150+ membros.

‚Ä¢ on - Ativar prote√ß√£o (limite de 5 usos a cada 5h)
‚Ä¢ off - Desativar prote√ß√£o
‚Ä¢ status - Ver status atual e usos restantes

üßπ *Limpeza e Manuten√ß√£o*

‚Ä¢ Limpar banco de dados:
  ${prefix}limpardb
  Remove dados antigos/desnecess√°rios

‚Ä¢ Limpar ranking de grupos:
  ${prefix}limparrankg
  Reseta rankings de todos os grupos

‚Ä¢ Reviver QR Code:
  ${prefix}reviverqr
  Gera novo QR para reconex√£o

‚Ä¢ Nuke (CUIDADO!):
  ${prefix}nuke
  Limpa TUDO - use apenas se necess√°rio

‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ
üîü *MONITORAMENTO E AN√ÅLISE*
‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ

üìä *Monitoramento de Grupos*

‚Ä¢ Listar todos os grupos:
  ${prefix}listagp
  Mostra todos os grupos onde o bot est√°

‚Ä¢ Visualiza√ß√£o de mensagens:
  ${prefix}viewmsg on/off
  Ativa/desativa o status de visualiza√ß√£o do bot

ü§ñ *Monitoramento de IA*

‚Ä¢ Status da IA:
  ${prefix}iastatus
  Estat√≠sticas de uso da IA

‚Ä¢ Limpar cache de IA:
  ${prefix}iaclear
  Limpa hist√≥rico de conversas da IA

‚Ä¢ Recuperar IA:
  ${prefix}iarecovery
  Recupera IA de erros

üíª *Desenvolvimento*

‚Ä¢ Ver cases dispon√≠veis:
  ${prefix}cases
  Lista todos os comandos dispon√≠veis

‚Ä¢ Ver c√≥digo de comando:
  ${prefix}getcase <comando>
  Mostra o c√≥digo-fonte do comando

üîí *Controles de Privacidade*

‚Ä¢ Anti-PV - N√≠vel 1:
  ${prefix}antipv
  Ignora mensagens no privado

‚Ä¢ Anti-PV - N√≠vel 2:
  ${prefix}antipv2
  Responde e bloqueia automaticamente

‚Ä¢ Anti-PV - N√≠vel 3:
  ${prefix}antipv3
  Bloqueia imediatamente

‚Ä¢ Anti-PV - N√≠vel 4:
  ${prefix}antipv4
  Modo ultra-restritivo

‚Ä¢ Mensagem do Anti-PV:
  ${prefix}antipvmsg <texto>
  Personaliza mensagem de bloqueio

‚Ä¢ Anti-spam de comandos:
  ${prefix}antispamcmd
  Ativa/desativa prote√ß√£o anti-spam

üåç *Modo Lite Global*
Use: ${prefix}modoliteglobal
‚Ä¢ Ativa/desativa filtro de conte√∫do inapropriado
‚Ä¢ Quando ativo, filtra conte√∫do adulto em todos os grupos
‚Ä¢ Ideal para ambientes familiares

‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ
1Ô∏è‚É£1Ô∏è‚É£ *TRANSMISS√ïES*
‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ

üì° *Enviar Mensagens em Massa*

üîπ *Transmiss√£o em Grupos:*
${prefix}tm <mensagem>
‚Ä¢ Envia mensagem para todos os grupos
‚Ä¢ Use com responsabilidade
‚Ä¢ Pode incluir texto, imagens, v√≠deos

Exemplo: ${prefix}tm Novidade! Bot atualizado üéâ

üîπ *Transmiss√£o Privada:*
${prefix}tm2 <mensagem>
‚Ä¢ Envia para usu√°rios inscritos no PV
‚Ä¢ Usu√°rios se inscrevem com: ${prefix}inscrevertm
‚Ä¢ S√≥ funciona no privado do usu√°rio

üìä *Status da Transmiss√£o:*
${prefix}statustm
‚Ä¢ Ver quantos usu√°rios est√£o inscritos
‚Ä¢ Estat√≠sticas de envios
‚Ä¢ √öltima transmiss√£o realizada

üí° *Dicas para Transmiss√µes:*
‚Ä¢ Use com modera√ß√£o para n√£o ser bloqueado
‚Ä¢ Envie conte√∫do relevante
‚Ä¢ Respeite os usu√°rios

‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ
üìö *RECURSOS EXTRAS*
‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ

üí° *Dicas Gerais:*

‚úÖ Use sempre com modera√ß√£o
‚úÖ Teste comandos antes de divulgar
‚úÖ Mantenha backups das configura√ß√µes
‚úÖ Acompanhe os logs do bot
‚úÖ Configure API keys para IA
‚úÖ Ative prote√ß√£o anti-ban em grupos grandes
‚úÖ Use o sistema de aluguel para monetizar

‚ö†Ô∏è *Avisos Importantes:*

‚Ä¢ Comando ${prefix}nuke deleta TUDO - use com cuidado!
‚Ä¢ Anti-PV n√≠veis 3 e 4 bloqueiam todos no privado
‚Ä¢ Transmiss√µes em massa podem resultar em ban
‚Ä¢ Sempre teste novos comandos em grupos pequenos
‚Ä¢ Mantenha o bot atualizado regularmente

‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ
üìû *SUPORTE*
‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ

Precisa de ajuda? Entre em contato:
‚Ä¢ Dono: ${nomedono}
‚Ä¢ N√∫mero: ${numerodono}

‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ

‚ú® *Pr√≥ximos Passos:*
1. Configure o b√°sico (prefixo, nome, API keys)
2. Personalize o visual do menu
3. Adicione comandos e automa√ß√µes personalizadas
4. Configure o sistema de aluguel (se for monetizar)
5. Teste tudo em um grupo privado
6. Adicione o bot aos seus grupos!

üìö Use ${prefix}tutorial a qualquer momento para consultar este guia novamente.

üéâ *Aproveite seu bot ${nomebot}!*`;

          await reply(tutorialText);
        } catch (error) {
          console.error('Erro no comando tutorial:', error);
          await reply('‚ùå Ocorreu um erro ao exibir o tutorial.');
        }
        break;
        
      case 'menudono':
      case 'ownermenu':
        try {
          if (!isOwner) {
            await reply("‚ö†Ô∏è Este menu √© exclusivo para o dono do bot.");
            return;
          }
          await sendMenuWithMedia('dono', menuDono);
        } catch (error) {
          console.error('Erro ao enviar menu do dono:', error);
          await reply("‚ùå Ocorreu um erro ao carregar o menu do dono");
        }
        break;
      case 'stickermenu':
      case 'menusticker':
      case 'menufig':
        try {
          await sendMenuWithMedia('stickers', menuSticker);
        } catch (error) {
          console.error('Erro ao enviar menu de stickers:', error);
          await reply("‚ùå Ocorreu um erro ao carregar o menu de stickers");
        }
        break;
        async function sendMenuWithMedia(menuType, menuFunction) {
          // Verifica se o grupo tem personaliza√ß√£o
          let customBotName = nomebot;
          let customMediaPath = null;
          
          if (isGroup && isGroupCustomizationEnabled()) {
            const groupCustom = getGroupCustomization(from);
            if (groupCustom) {
              if (groupCustom.customName) {
                customBotName = groupCustom.customName;
              }
              if (groupCustom.customPhoto && fs.existsSync(groupCustom.customPhoto)) {
                customMediaPath = groupCustom.customPhoto;
              }
            }
          }
          
          // Define a m√≠dia a ser usada
          let mediaPath, useVideo, mediaBuffer;
          
          if (customMediaPath) {
            // Usa a foto personalizada do grupo
            mediaPath = customMediaPath;
            useVideo = false;
            mediaBuffer = fs.readFileSync(mediaPath);
          } else {
            // Usa a m√≠dia padr√£o
            const menuVideoPath = __dirname + '/../midias/menu.mp4';
            const menuImagePath = __dirname + '/../midias/menu.jpg';
            useVideo = fs.existsSync(menuVideoPath);
            mediaPath = useVideo ? menuVideoPath : menuImagePath;
            mediaBuffer = fs.readFileSync(mediaPath);
          }
          
          // Obt√©m o design personalizado do menu
          const customDesign = getMenuDesignWithDefaults(customBotName, pushname);
          
          // Aplica o design personalizado ao menu
          const menuText = typeof menuFunction === 'function' ? 
            (typeof menuFunction.then === 'function' ? 
              await menuFunction : 
              await menuFunction(prefix, customBotName, pushname, customDesign)) : 
            'Menu n√£o dispon√≠vel';
          
          const lerMaisPrefix = getMenuLerMaisText();
          
          await nazu.sendMessage(from, {
            [useVideo ? 'video' : 'image']: mediaBuffer,
            caption: lerMaisPrefix + menuText,
            gifPlayback: useVideo,
            mimetype: useVideo ? 'video/mp4' : 'image/jpeg'
          }, {
            quoted: info
          });
        }
      case 'antipv3':
        try {
          if (!isOwner) return reply("Este comando √© apenas para o meu dono üíî");
          antipvData.mode = antipvData.mode === 'antipv3' ? null : 'antipv3';
          writeJsonFile(ANTIPV_FILE, antipvData);
          await reply(`‚úÖ Antipv3 ${antipvData.mode ? 'ativado' : 'desativado'}! O bot agora ${antipvData.mode ? 'bloqueia usu√°rios que usam comandos no privado' : 'responde normalmente no privado'}.`);
        } catch (e) {
          console.error(e);
          await reply("Ocorreu um erro üíî");
        }
        break;
      case 'antipv2':
        try {
          if (!isOwner) return reply("Este comando √© apenas para o meu dono üíî");
          antipvData.mode = antipvData.mode === 'antipv2' ? null : 'antipv2';
          writeJsonFile(ANTIPV_FILE, antipvData);
          await reply(`‚úÖ Antipv2 ${antipvData.mode ? 'ativado' : 'desativado'}! O bot agora ${antipvData.mode ? 'avisa que comandos s√≥ funcionam em grupos no privado' : 'responde normalmente no privado'}.`);
        } catch (e) {
          console.error(e);
          await reply("Ocorreu um erro üíî");
        }
        break;
      case 'antipv4':
        try {
          if (!isOwner) return reply("Este comando √© apenas para o meu dono üíî");
          antipvData.mode = antipvData.mode === 'antipv4' ? null : 'antipv4';
          writeJsonFile(ANTIPV_FILE, antipvData);
          await reply(`‚úÖ Antipv4 ${antipvData.mode ? 'ativado' : 'desativado'}! O bot agora ${antipvData.mode ? 'avisa que o bot so funciona em grupos' : 'responde normalmente no privado'}.`);
        } catch (e) {
          console.error(e);
          await reply("Ocorreu um erro üíî");
        }
        break;
      case 'antipvmessage':
      case 'antipvmsg':
        try {
          if (!isOwner) return reply(OWNER_ONLY_MESSAGE);
          if (!q) return reply(`Por favor, forne√ßa a nova mensagem para o antipv. Exemplo: ${prefix}antipvmessage Comandos no privado est√£o desativados!`);
          const antipvFile = DATABASE_DIR + '/antipv.json';
          let antipvData = loadJsonFile(antipvFile, {
            mode: 'off',
            message: 'üö´ Este comando s√≥ funciona em grupos!'
          });
          antipvData.message = q.trim();
          writeJsonFile(antipvFile, antipvData);
          await reply(`‚úÖ Mensagem do antipv atualizada para: "${antipvData.message}"`);
        } catch (e) {
          console.error('Erro no comando setantipvmensagem:', e);
          await reply("Ocorreu um erro ao configurar a mensagem do antipv üíî");
        }
        break;
      case 'antipv':
        try {
          if (!isOwner) return reply("Este comando √© apenas para o meu dono üíî");
          antipvData.mode = antipvData.mode === 'antipv' ? null : 'antipv';
          writeJsonFile(ANTIPV_FILE, antipvData);
          await reply(`‚úÖ Antipv ${antipvData.mode ? 'ativado' : 'desativado'}! O bot agora ${antipvData.mode ? 'ignora mensagens no privado' : 'responde normalmente no privado'}.`);
        } catch (e) {
          console.error(e);
          await reply("Ocorreu um erro üíî");
        }
        break;
      case 'entrar':
        try {
          if (!isOwner) return reply("Este comando √© apenas para o meu dono üíî");
          if (!q || !q.includes('chat.whatsapp.com')) return reply('Digite um link de convite v√°lido! Exemplo: ' + prefix + 'entrar https://chat.whatsapp.com/...');
          const code = q.split('https://chat.whatsapp.com/')[1];
          await nazu.groupAcceptInvite(code).then(res => {
            reply(`‚úÖ Entrei no grupo com sucesso!`);
          }).catch(err => {
            reply('‚ùå Erro ao entrar no grupo. Link inv√°lido ou permiss√£o negada.');
          });
        } catch (e) {
          console.error(e);
          await reply("Ocorreu um erro üíî");
        }
        break;
      case 'sairgp':
        try {
          if (!isOwner) return reply("Este comando √© apenas para o meu dono üíî");
          
          let groupId = null;
          
          if (q && q.trim()) {
            // Se forneceu um ID, usa ele
            groupId = q.trim();
            // Garante que tem @g.us se n√£o tiver
            if (!groupId.includes('@')) {
              groupId = groupId + '@g.us';
            }
          } else {
            // Se n√£o forneceu ID, usa o grupo atual
            if (!isGroup) return reply('‚ùå Voc√™ precisa estar em um grupo ou fornecer o ID do grupo! Exemplo: ' + prefix + 'sairgp 120363123456789012@g.us');
            groupId = from;
          }
          
          // Verifica se √© um ID de grupo v√°lido
          if (!groupId.endsWith('@g.us')) {
            return reply('‚ùå ID de grupo inv√°lido! Deve terminar com @g.us');
          }
          
          // Tenta obter informa√ß√µes do grupo para confirmar
          try {
            const groupMetadata = await nazu.groupMetadata(groupId).catch(() => null);
            if (!groupMetadata) {
              return reply('‚ùå Grupo n√£o encontrado ou n√£o tenho acesso a ele.');
            }
            
            const groupName = groupMetadata.subject || 'Grupo desconhecido';
            
            // Sai do grupo
            await nazu.groupLeave(groupId);
            await reply(`‚úÖ Sai do grupo "${groupName}" com sucesso!`);
          } catch (error) {
            // Tenta sair mesmo assim
            await nazu.groupLeave(groupId).catch(() => {});
            await reply(`‚úÖ Comando de sa√≠da executado para o grupo ${groupId}`);
          }
        } catch (e) {
          console.error(e);
          await reply("Ocorreu um erro üíî");
        }
        break;
      case 'tm':
        try {
          if (!isOwner) return reply("Este comando √© apenas para o meu dono üíî");
          if (!q && !isImage && !isVideo && !isQuotedImage && !isQuotedVideo) return reply('Digite uma mensagem ou marque uma imagem/v√≠deo! Exemplo: ' + prefix + 'tm Ol√° a todos!');
          
          const cabecalho = `‚ïî‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê\n‚ïë  üì° *TRANSMISS√ÉO DA BOT* üì°\n‚ïö‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê\n\n`;
          const genSuffix = () => Math.floor(100 + Math.random() * 900).toString();
          
          let baseMessage = {};
          
          // Verifica se a mensagem atual tem imagem
          if (isImage) {
            const image = await getFileBuffer(info.message.imageMessage, 'image');
            const captionOriginal = info.message.imageMessage?.caption || '';
            const textoFinal = q || captionOriginal;
            
            baseMessage = {
              image,
              caption: textoFinal ? `${cabecalho}${textoFinal}` : cabecalho.trim()
            };
          } 
          // Verifica se a mensagem atual tem v√≠deo
          else if (isVideo) {
            const video = await getFileBuffer(info.message.videoMessage, 'video');
            const captionOriginal = info.message.videoMessage?.caption || '';
            const textoFinal = q || captionOriginal;
            
            baseMessage = {
              video,
              caption: textoFinal ? `${cabecalho}${textoFinal}` : cabecalho.trim()
            };
          }
          // Verifica se cita uma imagem
          else if (isQuotedImage) {
            const image = await getFileBuffer(info.message.extendedTextMessage.contextInfo.quotedMessage.imageMessage, 'image');
            
            baseMessage = {
              image,
              caption: q ? `${cabecalho}${q}` : cabecalho.trim()
            };
          } 
          // Verifica se cita um v√≠deo
          else if (isQuotedVideo) {
            const video = await getFileBuffer(info.message.extendedTextMessage.contextInfo.quotedMessage.videoMessage, 'video');
            
            baseMessage = {
              video,
              caption: q ? `${cabecalho}${q}` : cabecalho.trim()
            };
          } 
          // Apenas texto
          else {
            baseMessage = {
              text: `${cabecalho}${q}`
            };
          }
          
          const groups = await nazu.groupFetchAllParticipating();
          const totalGroups = Object.keys(groups).length;
          let enviados = 0;
          
          for (const group of Object.values(groups)) {
            try {
              const suffix = genSuffix();
              const message = { ...baseMessage };
              
              if (message.caption) {
                message.caption = `${message.caption}\n\n> ID: ${suffix}`;
              }
              if (message.text) {
                message.text = `${message.text}\n\n> ID: ${suffix}`;
              }
              
              await nazu.sendMessage(group.id, message);
              enviados++;
              
              if (enviados < totalGroups) {
                const delay = Math.floor(Math.random() * 1000) + 1000;
                await new Promise(resolve => setTimeout(resolve, delay));
              }
            } catch (error) {
              console.error(`Erro ao enviar para grupo ${group.id}:`, error.message);
            }
          }
          
          await reply(`‚úÖ Transmiss√£o enviada para ${enviados}/${totalGroups} grupos!`);
        } catch (e) {
          console.error(e);
          await reply("Ocorreu um erro üíî");
        }
        break;
      
      // Sistema de transmiss√£o privada (tm2)
      case 'inscrevertm':
      case 'inscrevertm2':
        try {
          if (isGroup) return reply('‚ö†Ô∏è Este comando s√≥ funciona no privado! Me chama no PV para se inscrever.');
          
          // Verifica se o usu√°rio j√° est√° inscrito
          if (transmissao.isSubscribed(sender)) {
            const stats = transmissao.getStats();
            return reply(`‚úÖ Voc√™ j√° est√° inscrito nas transmiss√µes!\n\nüìä *Estat√≠sticas:*\n‚Ä¢ Total de inscritos: ${stats.totalSubscribers}\n‚Ä¢ Mensagens enviadas: ${stats.totalMessages}\n‚Ä¢ √öltima transmiss√£o: ${stats.lastBroadcast || 'Nenhuma ainda'}`);
          }
          
          // Inscreve o usu√°rio
          transmissao.subscribe(sender, pushname || 'Usu√°rio');
          
          reply(`üéâ *Inscri√ß√£o confirmada!*\n\nVoc√™ agora receber√° as transmiss√µes da bot diretamente no seu privado.\n\nüí° *Como funciona:*\n‚Ä¢ Voc√™ receber√° mensagens importantes da equipe\n‚Ä¢ Para cancelar, use: ${prefix}desinscrever\n\n‚ú® Obrigado por se inscrever!`);
        } catch (e) {
          console.error('[INSCREVERTM ERROR]', e);
          await reply("‚ùå Ocorreu um erro ao processar sua inscri√ß√£o. Tente novamente mais tarde.");
        }
        break;
      
      case 'desinscrever':
      case 'desinscrevertm':
      case 'cancelartm':
        try {
          if (isGroup) return reply('‚ö†Ô∏è Este comando s√≥ funciona no privado!');
          
          // Verifica se o usu√°rio est√° inscrito
          if (!transmissao.isSubscribed(sender)) {
            return reply('‚ö†Ô∏è Voc√™ n√£o est√° inscrito nas transmiss√µes.');
          }
          
          // Remove a inscri√ß√£o
          transmissao.unsubscribe(sender);
          
          reply(`‚úÖ *Inscri√ß√£o cancelada!*\n\nVoc√™ n√£o receber√° mais as transmiss√µes.\n\nüí° Para se inscrever novamente, use: ${prefix}inscrevertm`);
        } catch (e) {
          console.error('[DESINSCREVER ERROR]', e);
          await reply("‚ùå Ocorreu um erro ao processar sua solicita√ß√£o.");
        }
        break;
      
      case 'tm2':
        try {
          if (!isOwner) return reply("üö´ Este comando √© apenas para o meu dono üíî");
          if (!q && !isImage && !isVideo && !isQuotedImage && !isQuotedVideo) return reply('Digite uma mensagem ou marque uma imagem/v√≠deo! Exemplo: ' + prefix + 'tm2 Ol√° inscritos!');
          
          // Obt√©m lista de inscritos
          const subscribers = transmissao.getSubscribers();
          
          if (subscribers.length === 0) {
            return reply('‚ö†Ô∏è Ainda n√£o h√° inscritos para enviar a transmiss√£o.\n\nüí° Os usu√°rios devem usar o comando /inscrevertm no privado para se inscrever.');
          }
          
          const cabecalho = `‚ïî‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê\n‚ïë  üì° *TRANSMISS√ÉO PRIVADA* üì°\n‚ïö‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê\n\n`;
          const genSuffix = () => Math.floor(100 + Math.random() * 900).toString();
          
          let baseMessage = {};
          
          // Verifica se a mensagem atual tem imagem
          if (isImage) {
            const image = await getFileBuffer(info.message.imageMessage, 'image');
            const captionOriginal = info.message.imageMessage?.caption || '';
            const textoFinal = q || captionOriginal;
            
            baseMessage = {
              image,
              caption: textoFinal ? `${cabecalho}${textoFinal}` : cabecalho.trim()
            };
          } 
          // Verifica se a mensagem atual tem v√≠deo
          else if (isVideo) {
            const video = await getFileBuffer(info.message.videoMessage, 'video');
            const captionOriginal = info.message.videoMessage?.caption || '';
            const textoFinal = q || captionOriginal;
            
            baseMessage = {
              video,
              caption: textoFinal ? `${cabecalho}${textoFinal}` : cabecalho.trim()
            };
          }
          // Verifica se cita uma imagem
          else if (isQuotedImage) {
            const image = await getFileBuffer(info.message.extendedTextMessage.contextInfo.quotedMessage.imageMessage, 'image');
            
            baseMessage = {
              image,
              caption: q ? `${cabecalho}${q}` : cabecalho.trim()
            };
          } 
          // Verifica se cita um v√≠deo
          else if (isQuotedVideo) {
            const video = await getFileBuffer(info.message.extendedTextMessage.contextInfo.quotedMessage.videoMessage, 'video');
            
            baseMessage = {
              video,
              caption: q ? `${cabecalho}${q}` : cabecalho.trim()
            };
          } 
          // Apenas texto
          else {
            baseMessage = {
              text: `${cabecalho}${q}`
            };
          }
          
          const totalSubscribers = subscribers.length;
          let enviados = 0;
          let falhas = 0;
          
          // Envia para cada inscrito
          for (const subscriber of subscribers) {
            try {
              const suffix = genSuffix();
              const message = { ...baseMessage };
              
              if (message.caption) {
                message.caption = `${message.caption}\n\n> ID: ${suffix}`;
              }
              if (message.text) {
                message.text = `${message.text}\n\n> ID: ${suffix}`;
              }
              
              await nazu.sendMessage(subscriber.id, message);
              enviados++;
              
              // Incrementa contador de mensagens recebidas pelo usu√°rio
              transmissao.incrementMessageCount(subscriber.id);
              
              // Delay aleat√≥rio entre envios para evitar ban
              if (enviados < totalSubscribers) {
                const delay = Math.floor(Math.random() * 2000) + 1500; // 1.5s a 3.5s
                await new Promise(resolve => setTimeout(resolve, delay));
              }
            } catch (error) {
              console.error(`Erro ao enviar para ${subscriber.id}:`, error.message);
              falhas++;
              
              // Se o erro for por conta bloqueada/n√∫mero inv√°lido, remove da lista
              if (error.message.includes('not-authorized') || error.message.includes('invalid')) {
                transmissao.removeSubscriber(subscriber.id);
                console.log(`Inscrito ${subscriber.id} removido automaticamente (conta inv√°lida)`);
              }
            }
          }
          
          const stats = transmissao.getStats();
          await reply(`‚úÖ *Transmiss√£o conclu√≠da!*\n\nüìä *Resultado:*\n‚Ä¢ Enviados: ${enviados}\n‚Ä¢ Falhas: ${falhas}\n‚Ä¢ Total de inscritos: ${stats.totalSubscribers}\n\nüïê ${new Date().toLocaleString('pt-BR')}`);
        } catch (e) {
          console.error('[TM2 ERROR]', e);
          await reply("‚ùå Ocorreu um erro ao enviar a transmiss√£o.");
        }
        break;
      
      case 'statustm':
      case 'statustm2':
        try {
          if (!isOwner) return reply("üö´ Este comando √© apenas para o meu dono üíî");
          
          const stats = transmissao.getStats();
          const subscribers = transmissao.getSubscribers();
          
          let message = `üìä *STATUS DA TRANSMISS√ÉO TM2*\n\n`;
          message += `üë• *Inscritos:* ${stats.totalSubscribers}\n`;
          message += `üì® *Mensagens enviadas:* ${stats.totalMessages}\n`;
          message += `üïê *√öltima transmiss√£o:* ${stats.lastBroadcast || 'Nenhuma ainda'}\n\n`;
          
          if (subscribers.length > 0) {
            message += `üìã *Lista de inscritos:*\n`;
            subscribers.slice(0, 20).forEach((sub, i) => {
              const nome = sub.name || 'Sem nome';
              const msgs = sub.messagesReceived || 0;
              message += `${i + 1}. ${nome} (${msgs} msgs)\n`;
            });
            
            if (subscribers.length > 20) {
              message += `\n... e mais ${subscribers.length - 20} inscritos.`;
            }
          } else {
            message += `‚ö†Ô∏è Ainda n√£o h√° inscritos.`;
          }
          
          reply(message);
        } catch (e) {
          console.error('[STATUSTM ERROR]', e);
          await reply("‚ùå Ocorreu um erro ao consultar as estat√≠sticas.");
        }
        break;
      
      case 'reviverqr':
        if (!isOwner) return reply('üö´ Este comando √© exclusivo para o propriet√°rio!');
        const qrcodeDir = pathz.join(__dirname, '..', 'database', 'qr-code');
        const filePatterns = ['pre-key', 'sender', 'session'];
        let totalDeleted = 0;
        const deletedByCategory = {};
        try {
          filePatterns.forEach(pattern => deletedByCategory[pattern] = 0);
          const files = fs.readdirSync(qrcodeDir);
          for (const file of files) {
            for (const pattern of filePatterns) {
              if (file.startsWith(pattern)) {
                const filePath = pathz.join(qrcodeDir, file);
                fs.unlinkSync(filePath);
                deletedByCategory[pattern]++;
                totalDeleted++;
              }
            }
          }
          let message = 'üßπ Limpeza de arquivos conclu√≠da!\n\n';
          
          message += 'üìä Arquivos exclu√≠dos por categoria:\n';
          for (const [category, count] of Object.entries(deletedByCategory)) {
            
            message += `- ${category}: ${count} arquivo(s)\n`;
          }
          
          message += `\nüìà Total de arquivos exclu√≠dos: ${totalDeleted}\n`;
          
          message += 'üîÑ Reiniciando o sistema em 2 segundos...';
          reply(message);
          setTimeout(() => {
            reply('üîÑ Reiniciando agora...');
            setTimeout(() => {
              process.exit();
            }, 1200);
          }, 2000);
        } catch (error) {
          reply(`‚ùå Erro ao executar a limpeza: ${error.message}`);
        }
        break;
      case 'cases':
        if (!isOwner) return reply("Este comando √© apenas para o meu dono");
        try {
          const indexContent = fs.readFileSync(__dirname + '/index.js', 'utf-8');
          const caseRegex = /case\s+'([^']+)'\s*:/g;
          const cases = new Set();
          let match;
          while ((match = caseRegex.exec(indexContent)) !== null) {
            cases.add(match[1]);
          }
          const multiCaseRegex = /case\s+'([^']+)'\s*:\s*case\s+'([^']+)'\s*:/g;
          while ((match = multiCaseRegex.exec(indexContent)) !== null) {
            cases.add(match[1]);
            cases.add(match[2]);
          }
          const caseList = Array.from(cases).sort();
          await reply(`üìú *Lista de Comandos (Cases)*:\n\n${caseList.join('\n')}\n\nTotal: ${caseList.length} comandos`);
        } catch (e) {
          console.error(e);
          await reply("‚ùå Ocorreu um erro interno. Tente novamente em alguns minutos.");
        }
        break;
      case 'getcase':
        if (!isOwner) return reply("Este comando √© apenas para o meu dono");
        try {
          if (!q) return reply('‚ùå Digite o nome do comando. Exemplo: ' + prefix + 'getcase menu');
          var caseCode;
          caseCode = (fs.readFileSync(__dirname + "/index.js", "utf-8").match(new RegExp(`case\\s*["'\`]${q}["'\`]\\s*:[\\s\\S]*?break\\s*;?`, "i")) || [])[0];
          await nazu.sendMessage(from, {
            document: Buffer.from(caseCode, 'utf-8'),
            mimetype: 'text/plain',
            fileName: `${q}.txt`
          }, {
            quoted: info
          });
        } catch (e) {
          console.error(e);
          await reply("‚ùå Ocorreu um erro interno. Tente novamente em alguns minutos.");
        }
        break;
      case 'boton':
      case 'botoff':
        if (!isOwner) return reply("Este comando √© apenas para o meu dono");
        try {
          const botStateFile = pathz.join(DATABASE_DIR, 'botState.json');
          const isOn = botState.status === 'on';
          if (command === 'boton' && isOn) {
            return reply('üåü O bot j√° est√° ativado!');
          }
          if (command === 'botoff' && !isOn) {
            return reply('üåô O bot j√° est√° desativado!');
          }
          botState.status = command === 'boton' ? 'on' : 'off';
          writeJsonFile(botStateFile, botState);
          const message = command === 'boton' ? '‚úÖ *Bot ativado!* Agora todos podem usar os comandos.' : '‚úÖ *Bot desativado!* Apenas o dono pode usar comandos.';
          await reply(message);
        } catch (e) {
          console.error(e);
          await reply("‚ùå Ocorreu um erro interno. Tente novamente em alguns minutos.");
        }
        break;
      case 'blockcmdg':
        if (!isOwner) return reply("Este comando √© apenas para o meu dono");
        try {
          const cmdToBlock = q?.toLowerCase().split(' ')[0];
          const reason = q?.split(' ').slice(1).join(' ') || 'Sem motivo informado';
          if (!cmdToBlock) return reply('‚ùå Informe o comando a bloquear! Ex.: ' + prefix + 'blockcmd sticker');
          const blockFile = pathz.join(DATABASE_DIR, 'globalBlocks.json');
          globalBlocks.commands = globalBlocks.commands || {};
          globalBlocks.commands[cmdToBlock] = {
            reason,
            timestamp: Date.now()
          };
          writeJsonFile(blockFile, globalBlocks);
          await reply(`‚úÖ Comando *${cmdToBlock}* bloqueado globalmente!\nMotivo: ${reason}`);
        } catch (e) {
          console.error(e);
          await reply("‚ùå Ocorreu um erro interno. Tente novamente em alguns minutos.");
        }
        break;
      case 'unblockcmdg':
        if (!isOwner) return reply("Este comando √© apenas para o meu dono");
        try {
          const cmdToUnblock = q?.toLowerCase().split(' ')[0];
          if (!cmdToUnblock) return reply('‚ùå Informe o comando a desbloquear! Ex.: ' + prefix + 'unblockcmd sticker');
          const blockFile = pathz.join(DATABASE_DIR, 'globalBlocks.json');
          if (!globalBlocks.commands || !globalBlocks.commands[cmdToUnblock]) {
            return reply(`‚ùå O comando *${cmdToUnblock}* n√£o est√° bloqueado!`);
          }
          delete globalBlocks.commands[cmdToUnblock];
          writeJsonFile(blockFile, globalBlocks);
          await reply(`‚úÖ Comando *${cmdToUnblock}* desbloqueado globalmente!`);
        } catch (e) {
          console.error(e);
          await reply("‚ùå Ocorreu um erro interno. Tente novamente em alguns minutos.");
        }
        break;
      case 'blockuserg':
        if (!isOwner) return reply("Este comando √© apenas para o meu dono");
        try {
          if (!menc_os2) return reply("Marque algu√©m üôÑ");
          var reason;
          reason = q ? q.includes('@') ? q.includes(' ') ? q.split(' ').slice(1).join(' ') : "N√£o informado" : q : 'N√£o informado';
          var menc_os3;
          menc_os3 = (menc_os2 && menc_os2.includes(' ')) ? menc_os2.split(' ')[0] : menc_os2;
          if (!menc_os3) return reply("Erro ao processar usu√°rio mencionado");
          const blockFile = pathz.join(DATABASE_DIR, 'globalBlocks.json');
          globalBlocks.users = globalBlocks.users || {};
          globalBlocks.users[menc_os3] = {
            reason,
            timestamp: Date.now()
          };
          writeJsonFile(blockFile, globalBlocks);
          await reply(`‚úÖ Usu√°rio @${getUserName(menc_os3)} bloqueado globalmente!\nMotivo: ${reason}`, {
            mentions: [menc_os3]
          });
        } catch (e) {
          console.error(e);
          await reply("‚ùå Ocorreu um erro interno. Tente novamente em alguns minutos.");
        }
        break;
      case 'unblockuserg':
        if (!isOwner) return reply("Este comando √© apenas para o meu dono");
        try {
          if (!menc_os2) return reply("Marque algu√©m üôÑ");
          const blockFile = pathz.join(DATABASE_DIR, 'globalBlocks.json');
          if (!globalBlocks.users) {
            return reply(`‚ÑπÔ∏è N√£o h√° usu√°rios bloqueados globalmente.`);
          }
          const userToUnblock = globalBlocks.users[menc_os2] ? menc_os2 :
                               globalBlocks.users[getUserName(menc_os2)] ? getUserName(menc_os2) : null;
          if (!userToUnblock) {
            return reply(`‚ùå O usu√°rio @${getUserName(menc_os2)} n√£o est√° bloqueado globalmente!`, {
              mentions: [menc_os2]
            });
          }
          delete globalBlocks.users[userToUnblock];
          writeJsonFile(blockFile, globalBlocks);
          await reply(`‚úÖ Usu√°rio @${getUserName(menc_os2)} desbloqueado globalmente!`, {
            mentions: [menc_os2]
          });
        } catch (e) {
          console.error(e);
          await reply("‚ùå Ocorreu um erro interno. Tente novamente em alguns minutos.");
        }
        break;
      case 'listblocks':
        if (!isOwner) return reply("Este comando √© apenas para o meu dono");
        try {
          const blockFile = pathz.join(DATABASE_DIR, 'globalBlocks.json');
          const blockedCommands = globalBlocks.commands ? Object.entries(globalBlocks.commands).map(([cmd, data]) => `üîß *${cmd}* - Motivo: ${data.reason}`).join('\n') : 'Nenhum comando bloqueado.';
          const blockedUsers = globalBlocks.users ? Object.entries(globalBlocks.users).map(([user, data]) => {
            return `üë§ *${getUserName(user)}* - Motivo: ${data.reason}`;
          }).join('\n') : 'Nenhum usu√°rio bloqueado.';
          const message = `üîí *Bloqueios Globais - ${nomebot}* üîí\n\nüìú *Comandos Bloqueados*:\n${blockedCommands}\n\nüë• *Usu√°rios Bloqueados*:\n${blockedUsers}`;
          await reply(message);
        } catch (e) {
          console.error(e);
          await reply("‚ùå Ocorreu um erro interno. Tente novamente em alguns minutos.");
        }
        break;
      case 'seradm':
        try {
          if (!isOwner) return reply("Este comando √© apenas para o meu dono");
          await nazu.groupParticipantsUpdate(from, [sender], "promote");
        } catch (e) {
          console.error(e);
          await reply("‚ùå Ocorreu um erro interno. Tente novamente em alguns minutos.");
        }
        break;
      case 'sermembro':
        try {
          if (!isOwner) return reply("Este comando √© apenas para o meu dono");
          await nazu.groupParticipantsUpdate(from, [sender], "demote");
        } catch (e) {
          console.error(e);
          await reply("‚ùå Ocorreu um erro interno. Tente novamente em alguns minutos.");
        }
        break;
      case 'prefixo':
      case 'prefix':
        try {
          if (!isOwner) return reply("Este comando √© exclusivo para o meu dono!");
          if (!q) return reply(`‚öôÔ∏è *Configura√ß√£o de Prefixo*\n\nüìù *Como usar:*\n‚Ä¢ Digite o novo prefixo ap√≥s o comando\n‚Ä¢ Ex: ${prefix}${command} /\n‚Ä¢ Ex: ${prefix}${command} !\n\n‚úÖ O prefixo do bot ser√° atualizado para o valor especificado!`);
          
          let newPrefix = q.trim();
          
          // Bloqueia o uso de $ como prefixo e converte automaticamente para /
          if (newPrefix === '$') {
            newPrefix = '/';
            await reply(`‚ö†Ô∏è O s√≠mbolo "$" √© reservado e n√£o pode ser usado como prefixo.\n‚úÖ Prefixo alterado automaticamente para "/" globalmente!`);
          }
          
          let config = JSON.parse(fs.readFileSync(CONFIG_FILE));
          config.prefixo = newPrefix;
          writeJsonFile(CONFIG_FILE, config);
          
          // Se n√£o foi convertido, envia mensagem normal
          if (newPrefix !== '/') {
            await reply(`Prefixo alterado com sucesso para "${newPrefix}"!`);
          }
        } catch (e) {
          console.error(e);
          await reply("üêù Ops! Ocorreu um erro inesperado. Tente novamente em alguns instantes, por favor! ü•∫");
        }
        break;
      case 'numerodono':
      case 'numero-dono':
        try {
          if (!isOwner) return reply("Este comando √© exclusivo para o meu dono!");
          if (!q) return reply(`Por favor, digite o novo n√∫mero do dono.\nExemplo: ${prefix}${command} +553391967445`);
          let config = JSON.parse(fs.readFileSync(CONFIG_FILE));
          config.numerodono = q;
          writeJsonFile(CONFIG_FILE, config);
          await reply(`N√∫mero do dono alterado com sucesso para "${q}"!`);
        } catch (e) {
          console.error(e);
          await reply("üêù Ops! Ocorreu um erro inesperado. Tente novamente em alguns instantes, por favor! ü•∫");
        }
        break;
      case 'nomedono':
      case 'nome-dono':
        try {
          if (!isOwner) return reply("Este comando √© exclusivo para o meu dono!");
          if (!q) return reply(`Por favor, digite o novo nome do dono.\nExemplo: ${prefix}${command} Hiudy`);
          let config = JSON.parse(fs.readFileSync(CONFIG_FILE));
          config.nomedono = q;
          writeJsonFile(CONFIG_FILE, config);
          await reply(`Nome do dono alterado com sucesso para "${q}"!`);
        } catch (e) {
          console.error(e);
          await reply("üêù Ops! Ocorreu um erro inesperado. Tente novamente em alguns instantes, por favor! ü•∫");
        }
        break;
      case 'nomebot':
      case 'botname':
      case 'nome-bot':
        try {
          if (!isOwner) return reply("Este comando √© exclusivo para o meu dono!");
          if (!q) return reply(`Por favor, digite o novo nome do bot.\nExemplo: ${prefix}${command} Nazuna`);
          let config = JSON.parse(fs.readFileSync(CONFIG_FILE));
          config.nomebot = q;
          writeJsonFile(CONFIG_FILE, config);
          await reply(`Nome do bot alterado com sucesso para "${q}"!`);
        } catch (e) {
          console.error(e);
          await reply("üêù Ops! Ocorreu um erro inesperado. Tente novamente em alguns instantes, por favor! ü•∫");
        }
        break;
      case 'fotomenu':
      case 'videomenu':
      case 'mediamenu':
      case 'midiamenu':
        try {
          if (!isOwner) return reply("Este comando √© apenas para o meu dono");
          if (fs.existsSync(__dirname + '/../midias/menu.jpg')) fs.unlinkSync(__dirname + '/../midias/menu.jpg');
          if (fs.existsSync(__dirname + '/../midias/menu.mp4')) fs.unlinkSync(__dirname + '/../midias/menu.mp4');
          var RSM = info.message?.extendedTextMessage?.contextInfo?.quotedMessage;
          var boij2 = RSM?.imageMessage || info.message?.imageMessage || RSM?.viewOnceMessageV2?.message?.imageMessage || info.message?.viewOnceMessageV2?.message?.imageMessage || info.message?.viewOnceMessage?.message?.imageMessage || RSM?.viewOnceMessage?.message?.imageMessage;
          var boij = RSM?.videoMessage || info.message?.videoMessage || RSM?.viewOnceMessageV2?.message?.videoMessage || info.message?.viewOnceMessageV2?.message?.videoMessage || info.message?.viewOnceMessage?.message?.videoMessage || RSM?.viewOnceMessage?.message?.videoMessage;
          if (!boij && !boij2) return reply(`Marque uma imagem ou um v√≠deo, com o comando: ${prefix + command} (mencionando a m√≠dia)`);
          var isVideo2 = !!boij;
          var buffer = await getFileBuffer(isVideo2 ? boij : boij2, isVideo2 ? 'video' : 'image');
          fs.writeFileSync(__dirname + '/../midias/menu.' + (isVideo2 ? 'mp4' : 'jpg'), buffer);
          await reply('‚úÖ M√≠dia do menu atualizada com sucesso.');
        } catch (e) {
          console.error(e);
          reply("ocorreu um erro üíî");
        }
        break;
      
      case 'audiomenu':
      case 'menuaudio':
      case 'setmenuaudio':
        try {
          if (!isOwner) return reply("Este comando √© apenas para o meu dono üíî");
          
          // Verifica se √© para remover
          if (q && (q.toLowerCase() === 'off' || q.toLowerCase() === 'del' || q.toLowerCase() === 'delete' || q.toLowerCase() === 'remover')) {
            if (!isMenuAudioEnabled()) {
              return reply("‚ÑπÔ∏è N√£o h√° √°udio configurado para o menu.");
            }
            
            removeMenuAudio();
            return reply("‚úÖ √Åudio do menu removido com sucesso!\n\n" +
              "O menu voltar√° a ser enviado sem √°udio.");
          }
          
          const RSMAudio = info.message?.extendedTextMessage?.contextInfo?.quotedMessage;
          const audioMsg = RSMAudio?.audioMessage || info.message?.audioMessage;
          
          if (!audioMsg) {
            const statusMsg = isMenuAudioEnabled() 
              ? `‚ÑπÔ∏è *√Åudio do menu est√° ATIVO*\n\n` +
                `üéµ Um √°udio est√° configurado para ser enviado com o menu.\n\n` +
                `üìù *Comandos dispon√≠veis:*\n` +
                `‚Ä¢ ${prefix}${command} - Enviar/marcar √°udio para configurar\n` +
                `‚Ä¢ ${prefix}${command} off - Remover o √°udio\n` +
                `‚Ä¢ ${prefix}${command} del - Remover o √°udio`
              : `‚ùå *Envie ou marque um √°udio* com o comando: ${prefix}${command}\n\n` +
                `üéµ Este √°udio ser√° enviado junto com o menu principal.\n\n` +
                `üí° Para remover depois, use: ${prefix}${command} off`;
            
            return reply(statusMsg);
          }
          
          // Baixa o √°udio
          const audioBuffer = await getFileBuffer(audioMsg, 'audio');
          
          // Salva o √°udio
          const audioPath = __dirname + '/../midias/menu_audio.mp3';
          fs.writeFileSync(audioPath, audioBuffer);
          
          // Atualiza a configura√ß√£o
          setMenuAudio(audioPath);
          
          await reply('‚úÖ *√Åudio do menu configurado com sucesso!*\n\n' +
            'üéµ O √°udio ser√° enviado junto com o menu principal.\n\n' +
            `üí° Para remover, use: ${prefix}${command} off`);
        } catch (e) {
          console.error('Erro no comando audiomenu:', e);
          await reply("‚ùå Ocorreu um erro ao configurar o √°udio do menu üíî");
        }
        break;
      
      case 'lermais':
      case 'lermaismenus':
      case 'menulermais':
        try {
          if (!isOwner) return reply("Este comando √© apenas para o meu dono üíî");
          
          const currentState = isMenuLerMaisEnabled();
          const newState = setMenuLerMais(!currentState);
          
          const statusMsg = newState
            ? `‚úÖ *"Ler Mais" ATIVADO nos menus!*\n\n` +
              `üì± Os menus agora exibem caracteres invis√≠veis no in√≠cio, fazendo o WhatsApp mostrar "Ler mais".\n\n` +
              `üí° Isso deixa os menus mais limpos na pr√©via da conversa.`
            : `‚ùå *"Ler Mais" DESATIVADO nos menus!*\n\n` +
              `üì± Os menus n√£o ter√£o mais os caracteres invis√≠veis.\n\n` +
              `üí° O conte√∫do completo aparecer√° direto sem precisar expandir.`;
          
          await reply(statusMsg);
        } catch (e) {
          console.error('Erro no comando lermais:', e);
          await reply("‚ùå Ocorreu um erro ao alterar a configura√ß√£o üíî");
        }
        break;
      
      case 'fotobot':
      case 'fotoperfil':
      case 'setppbot':
      case 'perfilbot':
      case 'avatarbot':
        try {
          if (!isOwner) return reply("Este comando √© apenas para o meu dono üíî");
          if (!isQuotedImage && !isImage) return reply('‚ùå Envie ou marque uma imagem para definir como foto de perfil do bot.\n\nüìù *Uso:* Envie uma imagem com o comando ou responda uma imagem com ' + prefix + 'fotobot');
          
          const messageToUse = isQuotedImage ? quotedMessageContent : info.message;
          const mediaInfo = getMediaInfo(messageToUse);
          if (!mediaInfo || mediaInfo.type !== 'image') return reply('‚ùå M√≠dia inv√°lida. Envie uma imagem.');
          
          const imageBuffer = await getFileBuffer(mediaInfo.media, 'image');
          
          try {
            // Processa a imagem com ffmpeg antes de atualizar
            const processedBuffer = await processImageForProfile(imageBuffer);
            await nazu.updateProfilePicture(nazu.user.id, processedBuffer);
            reply('‚úÖ Foto de perfil do bot alterada com sucesso!');
          } catch (updateError) {
            console.error('Erro ao alterar foto de perfil:', updateError);
            reply('‚ùå Ocorreu um erro ao alterar a foto de perfil. Verifique se o ffmpeg est√° instalado e a imagem √© v√°lida.');
          }
        } catch (e) {
          console.error('Erro no comando fotobot:', e);
          reply("‚ùå Ocorreu um erro ao alterar a foto de perfil üíî");
        }
        break;
      
      // ========== SISTEMA DE PERSONALIZA√á√ÉO DE GRUPO ==========
      case 'personalizargrupo':
      case 'ativarperso':
        try {
          if (!isOwner) return reply("Este comando √© apenas para o meu dono üíî");
          
          const currentState = isGroupCustomizationEnabled();
          const newState = setGroupCustomizationEnabled(!currentState);
          
          const statusMsg = newState 
            ? `‚úÖ *Sistema de Personaliza√ß√£o Ativado!*\n\n` +
              `Agora os donos dos grupos podem:\n` +
              `üì∏ Mudar a foto do menu (${prefix}fotomenugrupo)\n` +
              `‚úèÔ∏è Mudar o nome do bot (${prefix}nomegrupo)\n\n` +
              `üí° As personaliza√ß√µes s√≥ afetam o grupo onde foram configuradas.`
            : `‚ùå *Sistema de Personaliza√ß√£o Desativado!*\n\n` +
              `Os donos dos grupos n√£o podem mais personalizar o bot.`;
          
          await reply(statusMsg);
        } catch (e) {
          console.error(e);
          await reply("‚ùå Ocorreu um erro üíî");
        }
        break;
      
      case 'fotomenugrupo':
      case 'setmenupic':
        try {
          if (!isGroup) return reply("Este comando s√≥ funciona em grupos üíî");
          if (!isGroupAdmin) return reply("Voc√™ precisa ser admin do grupo üíî");
          
          if (!isGroupCustomizationEnabled()) {
            return reply("‚ö†Ô∏è O sistema de personaliza√ß√£o est√° desativado. Pe√ßa ao dono do bot para ativar com o comando: " + prefix + "personalizargrupo");
          }
          
          if (!isQuotedImage && !isImage) {
            return reply(`‚ùå Envie ou marque uma imagem para definir como foto do menu deste grupo.\n\n` +
              `üìù *Uso:* Envie uma imagem com o comando ou responda uma imagem com ${prefix}fotomenugrupo\n\n` +
              `üí° Para remover a personaliza√ß√£o, use: ${prefix}removerfotomenu`);
          }
          
          const messageToUse = isQuotedImage ? quotedMessageContent : info.message;
          const mediaInfo = getMediaInfo(messageToUse);
          if (!mediaInfo || mediaInfo.type !== 'image') return reply('‚ùå M√≠dia inv√°lida. Envie uma imagem.');
          
          const imageBuffer = await getFileBuffer(mediaInfo.media, 'image');
          
          // Salva a imagem no diret√≥rio de grupos
          const customPhotoPath = __dirname + `/../database/grupos/${from}_menu.jpg`;
          fs.writeFileSync(customPhotoPath, imageBuffer);
          
          setGroupCustomPhoto(from, customPhotoPath);
          
          await reply(`‚úÖ *Foto do menu personalizada com sucesso!*\n\n` +
            `üé® Esta foto ser√° exibida apenas neste grupo quando algu√©m usar o comando ${prefix}menu`);
        } catch (e) {
          console.error('Erro no comando fotomenugrupo:', e);
          await reply("‚ùå Ocorreu um erro ao personalizar a foto do menu üíî");
        }
        break;
      
      case 'removerfotomenu':
      case 'resetfotomenu':
        try {
          if (!isGroup) return reply("Este comando s√≥ funciona em grupos üíî");
          if (!isGroupAdmin) return reply("Voc√™ precisa ser admin do grupo üíî");
          
          if (!isGroupCustomizationEnabled()) {
            return reply("‚ö†Ô∏è O sistema de personaliza√ß√£o est√° desativado.");
          }
          
          const customization = getGroupCustomization(from);
          if (!customization || !customization.customPhoto) {
            return reply("‚ÑπÔ∏è Este grupo n√£o possui foto personalizada.");
          }
          
          removeGroupCustomPhoto(from);
          await reply("‚úÖ Foto personalizada removida! O menu voltar√° a usar a foto padr√£o.");
        } catch (e) {
          console.error(e);
          await reply("‚ùå Ocorreu um erro üíî");
        }
        break;
      
      case 'nomegrupo':
      case 'nomebotgrupo':
      case 'setbotname':
        try {
          if (!isGroup) return reply("Este comando s√≥ funciona em grupos üíî");
          if (!isGroupAdmin) return reply("Voc√™ precisa ser admin do grupo üíî");
          
          if (!isGroupCustomizationEnabled()) {
            return reply("‚ö†Ô∏è O sistema de personaliza√ß√£o est√° desativado. Pe√ßa ao dono do bot para ativar com o comando: " + prefix + "personalizargrupo");
          }
          
          if (!q) {
            return reply(`üìù *Definir nome personalizado do bot neste grupo*\n\n` +
              `Uso: ${prefix}nomegrupo <nome>\n\n` +
              `Exemplo: ${prefix}nomegrupo MeuBot\n\n` +
              `üí° Para remover a personaliza√ß√£o, use: ${prefix}removernome`);
          }
          
          const customName = q.trim();
          if (customName.length > 50) {
            return reply("‚ùå O nome n√£o pode ter mais de 50 caracteres.");
          }
          
          setGroupCustomName(from, customName);
          
          await reply(`‚úÖ *Nome do bot personalizado com sucesso!*\n\n` +
            `ü§ñ Nome: *${customName}*\n\n` +
            `üí° Este nome ser√° exibido apenas neste grupo nos menus e comandos.`);
        } catch (e) {
          console.error('Erro no comando nomegrupo:', e);
          await reply("‚ùå Ocorreu um erro ao personalizar o nome üíî");
        }
        break;
      
      case 'removernome':
      case 'resetnome':
        try {
          if (!isGroup) return reply("Este comando s√≥ funciona em grupos üíî");
          if (!isGroupAdmin) return reply("Voc√™ precisa ser admin do grupo üíî");
          
          if (!isGroupCustomizationEnabled()) {
            return reply("‚ö†Ô∏è O sistema de personaliza√ß√£o est√° desativado.");
          }
          
          const customization = getGroupCustomization(from);
          if (!customization || !customization.customName) {
            return reply("‚ÑπÔ∏è Este grupo n√£o possui nome personalizado.");
          }
          
          removeGroupCustomName(from);
          await reply("‚úÖ Nome personalizado removido! O bot voltar√° a usar o nome padr√£o.");
        } catch (e) {
          console.error(e);
          await reply("‚ùå Ocorreu um erro üíî");
        }
        break;
      
      case 'infoperso':
      case 'personalizacao':
        try {
          if (!isGroup) return reply("Este comando s√≥ funciona em grupos üíî");
          
          if (!isGroupCustomizationEnabled()) {
            return reply("‚ö†Ô∏è O sistema de personaliza√ß√£o est√° desativado.");
          }
          
          const customization = getGroupCustomization(from);
          
          if (!customization || (!customization.customName && !customization.customPhoto)) {
            return reply(`‚ÑπÔ∏è *Este grupo n√£o possui personaliza√ß√µes.*\n\n` +
              `üìå Comandos dispon√≠veis para admins:\n` +
              `‚Ä¢ ${prefix}nomegrupo <nome> - Personalizar nome do bot\n` +
              `‚Ä¢ ${prefix}fotomenugrupo - Personalizar foto do menu\n` +
              `‚Ä¢ ${prefix}removernome - Remover nome personalizado\n` +
              `‚Ä¢ ${prefix}removerfotomenu - Remover foto personalizada`);
          }
          
          let msg = `üé® *Personaliza√ß√µes deste Grupo*\n\n`;
          
          if (customization.customName) {
            msg += `ü§ñ *Nome personalizado:* ${customization.customName}\n`;
          }
          
          if (customization.customPhoto) {
            msg += `üì∏ *Foto de menu:* Personalizada\n`;
          }
          
          msg += `\nüí° Admins podem usar ${prefix}removernome ou ${prefix}removerfotomenu para resetar.`;
          
          await reply(msg);
        } catch (e) {
          console.error(e);
          await reply("‚ùå Ocorreu um erro üíî");
        }
        break;
      
      // ================================
      // COMANDOS DE DESIGN DO MENU
      // ================================
      
      case 'setborda':
      case 'setbordatopo':
      case 'settopborder':
        try {
          if (!isOwner) return reply("Este comando √© apenas para o meu dono");
          if (!q) return reply(`Uso: ${prefix + command} <emoji/texto>\n\nExemplo: ${prefix + command} ‚ï≠‚îÄ‚ä∞`);
          
          const currentDesign = loadMenuDesign();
          currentDesign.menuTopBorder = q;
          
          if (saveMenuDesign(currentDesign)) {
            await reply(`‚úÖ Borda superior do menu definida como: ${q}`);
          } else {
            await reply("‚ùå Erro ao salvar configura√ß√µes do design do menu.");
          }
        } catch (e) {
          console.error(e);
          await reply("üêù Ops! Ocorreu um erro inesperado. Tente novamente em alguns instantes! ü•∫");
        }
        break;

      case 'setbordafim':
      case 'setbottomborder':
      case 'setbordabaixo':
        try {
          if (!isOwner) return reply("Este comando √© apenas para o meu dono");
          if (!q) return reply(`Uso: ${prefix + command} <emoji/texto>\n\nExemplo: ${prefix + command} ‚ï∞‚îÄ‚îà‚îà‚îà‚îà‚îà‚óú‚ùÅ‚óû‚îà‚îà‚îà‚îà‚îà‚îÄ‚ïØ`);
          
          const currentDesign = loadMenuDesign();
          currentDesign.bottomBorder = q;
          
          if (saveMenuDesign(currentDesign)) {
            await reply(`‚úÖ Borda inferior do menu definida como: ${q}`);
          } else {
            await reply("‚ùå Erro ao salvar configura√ß√µes do design do menu.");
          }
        } catch (e) {
          console.error(e);
          await reply("üêù Ops! Ocorreu um erro inesperado. Tente novamente em alguns instantes! ü•∫");
        }
        break;

      case 'setbordameio':
      case 'setmiddleborder':
      case 'setbordamiddle':
        try {
          if (!isOwner) return reply("Este comando √© apenas para o meu dono");
          if (!q) return reply(`Uso: ${prefix + command} <emoji/texto>\n\nExemplo: ${prefix + command} ‚îä`);
          
          const currentDesign = loadMenuDesign();
          currentDesign.middleBorder = q;
          
          if (saveMenuDesign(currentDesign)) {
            await reply(`‚úÖ Borda do meio do menu definida como: ${q}`);
          } else {
            await reply("‚ùå Erro ao salvar configura√ß√µes do design do menu.");
          }
        } catch (e) {
          console.error(e);
          await reply("üêù Ops! Ocorreu um erro inesperado. Tente novamente em alguns instantes! ü•∫");
        }
        break;

      case 'setitemicon':
      case 'seticoneitem':
      case 'setitem':
        try {
          if (!isOwner) return reply("Este comando √© apenas para o meu dono");
          if (!q) return reply(`Uso: ${prefix + command} <emoji/texto>\n\nExemplo: ${prefix + command} ‚Ä¢.Ãáñ•®÷óüçì‚≠ü`);
          
          const currentDesign = loadMenuDesign();
          currentDesign.menuItemIcon = q;
          
          if (saveMenuDesign(currentDesign)) {
            await reply(`‚úÖ √çcone dos itens do menu definido como: ${q}`);
          } else {
            await reply("‚ùå Erro ao salvar configura√ß√µes do design do menu.");
          }
        } catch (e) {
          console.error(e);
          await reply("üêù Ops! Ocorreu um erro inesperado. Tente novamente em alguns instantes! ü•∫");
        }
        break;

      case 'setseparador':
      case 'setseparatoricon':
      case 'seticoneseparador':
        try {
          if (!isOwner) return reply("Este comando √© apenas para o meu dono");
          if (!q) return reply(`Uso: ${prefix + command} <emoji/texto>\n\nExemplo: ${prefix + command} ‚ùÅ`);
          
          const currentDesign = loadMenuDesign();
          currentDesign.separatorIcon = q;
          
          if (saveMenuDesign(currentDesign)) {
            await reply(`‚úÖ √çcone separador do menu definido como: ${q}`);
          } else {
            await reply("‚ùå Erro ao salvar configura√ß√µes do design do menu.");
          }
        } catch (e) {
          console.error(e);
          await reply("üêù Ops! Ocorreu um erro inesperado. Tente novamente em alguns instantes! ü•∫");
        }
        break;

      case 'settitleicon':
      case 'seticonetitulo':
      case 'settitulo':
        try {
          if (!isOwner) return reply("Este comando √© apenas para o meu dono");
          if (!q) return reply(`Uso: ${prefix + command} <emoji/texto>\n\nExemplo: ${prefix + command} üçß‡∏∫Íï∏‚ñ∏`);
          
          const currentDesign = loadMenuDesign();
          currentDesign.menuTitleIcon = q;
          
          if (saveMenuDesign(currentDesign)) {
            await reply(`‚úÖ √çcone do t√≠tulo do menu definido como: ${q}`);
          } else {
            await reply("‚ùå Erro ao salvar configura√ß√µes do design do menu.");
          }
        } catch (e) {
          console.error(e);
          await reply("üêù Ops! Ocorreu um erro inesperado. Tente novamente em alguns instantes! ü•∫");
        }
        break;

      case 'setheader':
      case 'setcabecalho':
      case 'setheadermenu':
        try {
          if (!isOwner) return reply("Este comando √© apenas para o meu dono");
          if (!q) return reply(`Uso: ${prefix + command} <texto>\n\nExemplo: ${prefix + command} ‚ï≠‚îà‚ä∞ üå∏ „Äé *{botName}* „Äè\\n‚îäOl√°, {userName}!\\n‚ï∞‚îÄ‚îà‚îà‚îà‚îà‚îà‚óú‚ùÅ‚óû‚îà‚îà‚îà‚îà‚îà‚îÄ‚ïØ\n\n*Placeholders dispon√≠veis:*\n{botName} - Nome do bot\n{userName} - Nome do usu√°rio`);
          
          const currentDesign = loadMenuDesign();
          // Processa quebras de linha expl√≠citas
          currentDesign.header = q.replace(/\\n/g, '\n');
          
          if (saveMenuDesign(currentDesign)) {
            await reply(`‚úÖ Cabe√ßalho do menu definido com sucesso!\n\n*Preview:*\n${currentDesign.header.replace(/{botName}/g, nomebot).replace(/{userName}/g, pushname)}`);
          } else {
            await reply("‚ùå Erro ao salvar configura√ß√µes do design do menu.");
          }
        } catch (e) {
          console.error(e);
          await reply("üêù Ops! Ocorreu um erro inesperado. Tente novamente em alguns instantes! ü•∫");
        }
        break;

      case 'resetdesign':
      case 'resetarmenu':
      case 'resetdesignmenu':
        try {
          if (!isOwner) return reply("Este comando √© apenas para o meu dono");
          
          const defaultDesign = {
            header: `‚ï≠‚îà‚ä∞ üå∏ „Äé *{botName}* „Äè\n‚îäOl√°, {userName}!\n‚ï∞‚îÄ‚îà‚îà‚îà‚îà‚îà‚óú‚ùÅ‚óû‚îà‚îà‚îà‚îà‚îà‚îÄ‚ïØ`,
            menuTopBorder: "‚ï≠‚îà",
            bottomBorder: "‚ï∞‚îÄ‚îà‚îà‚îà‚îà‚îà‚óú‚ùÅ‚óû‚îà‚îà‚îà‚îà‚îà‚îÄ‚ïØ",
            menuTitleIcon: "üçß‡∏∫Íï∏‚ñ∏",
            menuItemIcon: "‚Ä¢.Ãáñ•®÷óüçì‚≠ü",
            separatorIcon: "‚ùÅ",
            middleBorder: "‚îä"
          };
          
          if (saveMenuDesign(defaultDesign)) {
            await reply("‚úÖ Design do menu resetado para o padr√£o com sucesso!");
          } else {
            await reply("‚ùå Erro ao resetar o design do menu.");
          }
        } catch (e) {
          console.error(e);
          await reply("üêù Ops! Ocorreu um erro inesperado. Tente novamente em alguns instantes! ü•∫");
        }
        break;

      case 'designmenu':
      case 'verdesign':
      case 'configmenu':
        try {
          if (!isOwner) return reply("Este comando √© apenas para o meu dono");
          
          const currentDesign = loadMenuDesign();
          const designText = `‚ï≠‚îÄ‚ä∞ üé® *CONFIGURA√á√ïES DO DESIGN* üé® ‚ä±‚îÄ‚ïÆ
‚îä
‚îä üî∏ *Cabe√ßalho:*
‚îä ${currentDesign.header.replace(/{botName}/g, nomebot).replace(/{userName}/g, pushname)}
‚îä
‚îä üî∏ *Borda Superior:* ${currentDesign.menuTopBorder}
‚îä üî∏ *Borda Inferior:* ${currentDesign.bottomBorder}
‚îä üî∏ *Borda do Meio:* ${currentDesign.middleBorder}
‚îä üî∏ *√çcone do Item:* ${currentDesign.menuItemIcon}
‚îä üî∏ *√çcone Separador:* ${currentDesign.separatorIcon}
‚îä üî∏ *√çcone do T√≠tulo:* ${currentDesign.menuTitleIcon}
‚îä
‚îä üìù *Comandos dispon√≠veis:*
‚îä ${prefix}setborda - Alterar borda superior
‚îä ${prefix}setbordafim - Alterar borda inferior  
‚îä ${prefix}setbordameio - Alterar borda do meio
‚îä ${prefix}setitem - Alterar √≠cone dos itens
‚îä ${prefix}setseparador - Alterar √≠cone separador
‚îä ${prefix}settitulo - Alterar √≠cone do t√≠tulo
‚îä ${prefix}setheader - Alterar cabe√ßalho
‚îä ${prefix}resetdesign - Resetar para padr√£o
‚îä
‚ï∞‚îÄ‚îà‚îà‚îà‚îà‚îà‚óú‚ùÅ‚óû‚îà‚îà‚îà‚îà‚îà‚îÄ‚ïØ`;
          
          await reply(designText);
        } catch (e) {
          console.error(e);
          await reply("üêù Ops! Ocorreu um erro inesperado. Tente novamente em alguns instantes! ü•∫");
        }
        break;

      case 'listagp':
      case 'listgp':
        try {
          if (!isOwner) return reply('‚õî Desculpe, este comando √© exclusivo para o meu dono!');
          const getGroups = await nazu.groupFetchAllParticipating();
          const groups = Object.entries(getGroups).slice(0).map(entry => entry[1]);
          const sortedGroups = groups.sort((a, b) => a.subject.localeCompare(b.subject));
          let teks = `üåü *Lista de Grupos e Comunidades* üåü\nüìä *Total de Grupos:* ${sortedGroups.length}\n\n`;
          for (let i = 0; i < sortedGroups.length; i++) {
            
            teks += `üîπ *${i + 1}. ${sortedGroups[i].subject}*\n` + `üÜî *ID:* ${sortedGroups[i].id}\n` + `üë• *Participantes:* ${sortedGroups[i].participants.length}\n\n`;
          }
          await reply(teks);
        } catch (e) {
          console.log(e);
          await reply("‚ùå Ocorreu um erro interno. Tente novamente em alguns minutos.");
        }
        break;
      case 'listbangp':
        try {
          if (!isOwner) return reply('‚õî Desculpe, este comando √© exclusivo para o meu dono!');

          const bannedGroups = Object.keys(banGpIds || {}).filter(id => banGpIds[id]);
          if (bannedGroups.length === 0) {
            return reply('‚úÖ Nenhum grupo banido no momento.');
          }

          const maxItems = 50;
          let teks = `üö´ *Grupos Banidos* (${bannedGroups.length})\n\n`;

          for (let i = 0; i < Math.min(bannedGroups.length, maxItems); i++) {
            const groupId = bannedGroups[i];
            let subject = 'Desconhecido';
            try {
              const meta = await getCachedGroupMetadata(groupId);
              subject = meta?.subject || subject;
            } catch {}

            teks += `${i + 1}. ${subject}\nüÜî ${groupId}\n\n`;
          }

          if (bannedGroups.length > maxItems) {
            teks += `... e mais ${bannedGroups.length - maxItems} grupo(s).`;
          }

          await reply(teks);
        } catch (e) {
          console.error(e);
          await reply("‚ùå Ocorreu um erro interno. Tente novamente em alguns minutos.");
        }
        break;
      case 'bangp':
      case 'unbangp':
      case 'desbangp':
        try {
          if (!isGroup) return reply("isso so pode ser usado em grupo üíî");
          if (!isOwner) return reply("Este comando √© apenas para o meu dono");
          banGpIds[from] = !banGpIds[from];
          if (banGpIds[from]) {
            await reply('üö´ Grupo banido, apenas usuarios premium ou meu dono podem utilizar o bot aqui agora.');
          } else {
            await reply('‚úÖ Grupo desbanido, todos podem utilizar o bot novamente.');
          }
          fs.writeFileSync(__dirname + `/../database/dono/bangp.json`, JSON.stringify(banGpIds));
        } catch (e) {
          console.error(e);
          await reply("‚ùå Ocorreu um erro interno. Tente novamente em alguns minutos.");
        }
        break;
      case 'addpremium':
      case 'addvip':
        try {
          if (!isOwner) return reply("Este comando √© apenas para o meu dono");
          if (!menc_os2) return reply("Marque algu√©m üôÑ");
          if (!!premiumListaZinha[menc_os2]) return reply('O usu√°rio ja esta na lista premium.');
          premiumListaZinha[menc_os2] = true;
          await nazu.sendMessage(from, {
            text: `‚úÖ @${getUserName(menc_os2)} foi adicionado(a) a lista premium.`,
            mentions: [menc_os2]
          }, {
            quoted: info
          });
          fs.writeFileSync(__dirname + `/../database/dono/premium.json`, JSON.stringify(premiumListaZinha));
        } catch (e) {
          console.error(e);
          reply("ocorreu um erro üíî");
        }
        break;
      case 'delpremium':
      case 'delvip':
      case 'rmpremium':
      case 'rmvip':
        try {
          if (!isOwner) return reply("Este comando √© apenas para o meu dono");
          if (!menc_os2) return reply("Marque algu√©m üôÑ");
          if (!premiumListaZinha[menc_os2]) return reply('O usu√°rio n√£o esta na lista premium.');
          delete premiumListaZinha[menc_os2];
          await nazu.sendMessage(from, {
            text: `ü´° @${getUserName(menc_os2)} foi removido(a) da lista premium.`,
            mentions: [menc_os2]
          }, {
            quoted: info
          });
          fs.writeFileSync(__dirname + `/../database/dono/premium.json`, JSON.stringify(premiumListaZinha));
        } catch (e) {
          console.error(e);
          reply("ocorreu um erro üíî");
        }
        break;
      case 'addpremiumgp':
      case 'addvipgp':
        try {
          if (!isOwner) return reply("Este comando √© apenas para o meu dono");
          if (!isGroup) return reply("isso so pode ser usado em grupo üíî");
          if (!!premiumListaZinha[from]) return reply('O grupo ja esta na lista premium.');
          premiumListaZinha[from] = true;
          await nazu.sendMessage(from, {
            text: `‚úÖ O grupo foi adicionado a lista premium.`
          }, {
            quoted: info
          });
          fs.writeFileSync(__dirname + `/../database/dono/premium.json`, JSON.stringify(premiumListaZinha));
        } catch (e) {
          console.error(e);
          reply("ocorreu um erro üíî");
        }
        break;
      case 'delpremiumgp':
      case 'delvipgp':
      case 'rmpremiumgp':
      case 'rmvipgp':
        try {
          if (!isOwner) return reply("Este comando √© apenas para o meu dono");
          if (!isGroup) return reply("isso so pode ser usado em grupo üíî");
          if (!premiumListaZinha[from]) return reply('O grupo n√£o esta na lista premium.');
          delete premiumListaZinha[from];
          await nazu.sendMessage(from, {
            text: `ü´° O grupo foi removido da lista premium.`
          }, {
            quoted: info
          });
          fs.writeFileSync(__dirname + `/../database/dono/premium.json`, JSON.stringify(premiumListaZinha));
        } catch (e) {
          console.error(e);
          reply("ocorreu um erro üíî");
        }
        break;
      case 'listapremium':
      case 'listavip':
      case 'premiumlist':
      case 'listpremium':
      case 'listprem':
        try {
          if (!isOwner) return reply('‚õî Desculpe, este comando √© exclusivo para o meu dono!');
          const premiumList = premiumListaZinha || {};
          const usersPremium = Object.keys(premiumList).filter(id => isUserId(id));
          const groupsPremium = Object.keys(premiumList).filter(id => id.includes('@g.us'));
          let teks = `‚ú® *Lista de Membros Premium* ‚ú®\n\n`;
          
          teks += `üë§ *Usu√°rios Premium* (${usersPremium.length})\n`;
          if (usersPremium.length > 0) {
            usersPremium.forEach((user, i) => {
              const userNumber = getUserName(user);
              
              teks += `üîπ ${i + 1}. @${userNumber}\n`;
            });
          } else {
            
            teks += `   Nenhum usu√°rio premium encontrado.\n`;
          }
          
          teks += `\nüë• *Grupos Premium* (${groupsPremium.length})\n`;
          if (groupsPremium.length > 0) {
            for (let i = 0; i < groupsPremium.length; i++) {
              try {
                const groupInfo = await getCachedGroupMetadata(groupsPremium[i]);
                
                teks += `üîπ ${i + 1}. ${groupInfo.subject}\n`;
              } catch {
                
                teks += `üîπ ${i + 1}. Grupo ID: ${groupsPremium[i]}\n`;
              }
            }
          } else {
            
            teks += `   Nenhum grupo premium encontrado.\n`;
          }
          await nazu.sendMessage(from, {
            text: teks,
            mentions: usersPremium
          }, {
            quoted: info
          });
        } catch (e) {
          console.error(e);
          await reply('üòî Ops, algo deu errado. Tente novamente mais tarde!');
        }
        break;
      case 'resetgold':
        try {
          if (!isOwner) return reply('‚õî Desculpe, este comando √© exclusivo para o meu dono!');
          if (!menc_os2) return reply('Marque algu√©m üôÑ');

          const econ = loadEconomy();
          const targetData = getEcoUser(econ, menc_os2);

          targetData.wallet = 0;
          targetData.bank = 0;
          saveEconomy(econ);

          await nazu.sendMessage(from, {
            text: `üßπ @${getUserName(menc_os2)} teve o gold resetado (carteira e banco).`,
            mentions: [menc_os2]
          }, {
            quoted: info
          });
        } catch (e) {
          console.error(e);
          await reply('‚ùå Ocorreu um erro interno. Tente novamente em alguns minutos.');
        }
        break;
      
      // ============= SISTEMA DE COMANDOS VIP =============
      case 'menuvip':
      case 'vip':
      case 'vipmenu':
        try {
          await sendMenuWithMedia('vip', async () => {
            const customDesign = getMenuDesignWithDefaults(nomebot, pushname);
            return await menuVIP(prefix, nomebot, pushname, customDesign);
          });
        } catch (error) {
          console.error('Erro ao enviar menu VIP:', error);
          await reply(`‚ùå Erro ao carregar menu VIP. Use ${prefix}infovip para mais informa√ß√µes.`);
        }
        break;

      case 'infovip':
      case 'vipinfo':
        try {
          const customDesign = getMenuDesignWithDefaults(nomebot, pushname);
          const infoText = await menuVIP(prefix, nomebot, pushname, customDesign);
          await reply(infoText);
        } catch (error) {
          console.error('Erro ao enviar info VIP:', error);
          await reply('‚ùå Erro ao carregar informa√ß√µes VIP.');
        }
        break;

      case 'addcmdvip':
      case 'addvipcommand':
      case 'adicionarcmdvip':
        try {
          if (!isOwner) return reply('üö´ Este comando √© apenas para o dono do bot!');
          
          if (!q) {
            return reply(`üìù *Como adicionar comandos VIP:*

*Formato:*
${prefix}addcmdvip <comando> | <descri√ß√£o> | <categoria>

*Categorias dispon√≠veis:*
‚Ä¢ download - Downloads
‚Ä¢ diversao - Divers√£o/Jogos
‚Ä¢ utilidade - Utilidades
‚Ä¢ ia - Intelig√™ncia Artificial
‚Ä¢ editor - Editores
‚Ä¢ info - Informa√ß√£o
‚Ä¢ outros - Outros

*Exemplo:*
${prefix}addcmdvip premium_ia | IA avan√ßada exclusiva | ia
${prefix}addcmdvip premium_ia | IA avan√ßada exclusiva | ia | premium_ia <pergunta>

*Adicionar todos de um menu:*
${prefix}addcmdvip <nomeMenu> all

*Exemplos:*
${prefix}addcmdvip menubuscas all
${prefix}addcmdvip menuadm all
${prefix}addcmdvip menudown all`);
          }
          
          // Verifica se √© para adicionar todos os comandos de um menu
          const menuAllMatch = q.toLowerCase().trim().match(/^(\w+)\s+all$/);
          if (menuAllMatch) {
            const menuName = menuAllMatch[1];
            
            // Mapeia nomes de menus para suas fun√ß√µes
            const menuMap = {
              'menubuscas': menuBuscas,
              'menuadm': menuadm,
              'menudono': menuDono,
              'menu': menu,
              'menudown': menudown,
              'menubn': menubn,
              'menufig': menuSticker,
              'menuia': menuIa,
              'menurpg': menuRPG,
              'menuvip': menuVIP,
              'ferramentas': menuFerramentas,
              'alteradores': menuAlterador,
              'menumemb': menuMembros
            };
            
            const menuFunction = menuMap[menuName];
            
            if (!menuFunction) {
              return reply(`‚ùå Menu "${menuName}" n√£o encontrado!\n\n*Menus dispon√≠veis:*\n${Object.keys(menuMap).map(m => `‚Ä¢ ${m}`).join('\n')}`);
            }
            
            try {
              // Gera o menu para extrair os comandos
              const customDesign = getMenuDesignWithDefaults(nomebot, pushname);
              const menuText = await menuFunction(prefix, nomebot, pushname, customDesign);
              
              // Extrai comandos do menu usando regex
              // O menu j√° foi processado, ent√£o ${prefix} foi substitu√≠do pelo prefixo real
              const commands = new Set();
              
              // Padr√£o 1: Procura por ${prefix}comando (caso ainda n√£o tenha sido substitu√≠do)
              const templatePattern = new RegExp(`\\$\\{prefix\\}([a-zA-Z0-9_]+)(?:\\s*<[^>]*>)?`, 'g');
              let match;
              while ((match = templatePattern.exec(menuText)) !== null) {
                const cmd = match[1];
                if (cmd && cmd.length > 0) {
                  commands.add(cmd);
                }
              }
              
              // Padr√£o 2: Procura por prefixoComando <param> (j√° processado)
              // Escapa o prefixo para usar na regex
              const escapedPrefix = prefix.replace(/[.*+?^${}()|[\]\\]/g, '\\$&');
              
              // Procura por linhas que contenham o prefixo seguido de comando
              const processedPattern = new RegExp(`${escapedPrefix}([a-zA-Z0-9_]+)(?:\\s*<[^>]*>)?`, 'g');
              while ((match = processedPattern.exec(menuText)) !== null) {
                const cmd = match[1];
                if (cmd && cmd.length > 0 && !cmd.startsWith('menu') && cmd !== 'ferramentas' && cmd !== 'alteradores') {
                  commands.add(cmd);
                }
              }
              
              // Padr√£o 3: Procura por comandos com pontos: prefixoComando.sub
              const dotPattern = new RegExp(`${escapedPrefix}([a-zA-Z0-9_]+(?:\\.[a-zA-Z0-9_]+)+)`, 'g');
              while ((match = dotPattern.exec(menuText)) !== null) {
                const cmd = match[1];
                if (cmd && cmd.length > 0) {
                  commands.add(cmd);
                }
              }
              
              // Padr√£o 4: Procura por qualquer ocorr√™ncia do prefixo seguido de palavra
              // Isso captura comandos mesmo que o formato do menu seja diferente
              const genericPattern = new RegExp(`(?:^|\\s|\\n|\\r)${escapedPrefix}([a-zA-Z0-9_]+)(?:\\s*<[^>]*>)?(?:\\s|$|\\n|\\r)`, 'gm');
              while ((match = genericPattern.exec(menuText)) !== null) {
                const cmd = match[1];
                if (cmd && cmd.length > 0 && 
                    !cmd.startsWith('menu') && 
                    cmd !== 'ferramentas' && 
                    cmd !== 'alteradores' &&
                    cmd.length < 50) { // Evita capturar coisas muito longas
                  commands.add(cmd);
                }
              }
              
              // Padr√£o 4: Procura por ${prefix}comando.sub (template)
              const templateDotPattern = new RegExp(`\\$\\{prefix\\}([a-zA-Z0-9_]+(?:\\.[a-zA-Z0-9_]+)+)`, 'g');
              while ((match = templateDotPattern.exec(menuText)) !== null) {
                const cmd = match[1];
                if (cmd && cmd.length > 0) {
                  commands.add(cmd);
                }
              }
              
              if (commands.size === 0) {
                // Debug: mostra um trecho do menu para ajudar a identificar o problema
                const menuPreview = menuText.substring(0, 500).replace(/\n/g, '\\n');
                console.log(`[DEBUG] Menu "${menuName}" gerado (primeiros 500 chars):`, menuPreview);
                console.log(`[DEBUG] Prefix usado: "${prefix}"`);
                return reply(`‚ùå Nenhum comando encontrado no menu "${menuName}"!\n\n*Debug:* Prefixo usado: "${prefix}"\nVerifique o console para mais detalhes.`);
              }
              
              const commandsArray = Array.from(commands).sort();
              let added = 0;
              let skipped = 0;
              
              for (const cmdName of commandsArray) {
                // Pula comandos que s√£o outros menus
                if (cmdName.startsWith('menu') || cmdName === 'ferramentas' || cmdName === 'alteradores') {
                  continue;
                }
                
                const result = vipCommandsManager.addVipCommand(
                  cmdName,
                  `Comando do menu ${menuName}`,
                  'outros',
                  `${cmdName}`
                );
                
                if (result.success) {
                  added++;
                  console.log(`[VIP CMD] Comando "${cmdName}" adicionado por ${pushname} (${sender})`);
                } else {
                  skipped++;
                }
              }
              
              await reply(`‚úÖ *Comandos do menu "${menuName}" adicionados!*

üìä *Resultado:*
‚Ä¢ ‚úÖ Adicionados: ${added}
‚Ä¢ ‚è≠Ô∏è J√° existiam: ${skipped}
‚Ä¢ üì¶ Total encontrados: ${commandsArray.length}

üí° Use ${prefix}listcmdvip para ver todos os comandos VIP.`);
            } catch (error) {
              console.error(`Erro ao processar menu ${menuName}:`, error);
              return reply(`‚ùå Erro ao processar o menu "${menuName}": ${error.message}`);
            }
            break;
          }
          
          const parts = q.split('|').map(p => p.trim());
          
          if (parts.length < 2) {
            return reply('‚ùå Formato inv√°lido! Use:\n' + prefix + 'addcmdvip <comando> | <descri√ß√£o> | <categoria>');
          }
          
          const cmdName = parts[0];
          const cmdDesc = parts[1];
          const cmdCategory = parts[2] || 'outros';
          const cmdUsage = parts[3] || '';
          
          const result = vipCommandsManager.addVipCommand(cmdName, cmdDesc, cmdCategory, cmdUsage);
          
          await reply(result.message);
          
          if (result.success) {
            console.log(`[VIP CMD] Comando "${cmdName}" adicionado por ${pushname} (${sender})`);
          }
        } catch (error) {
          console.error('Erro ao adicionar comando VIP:', error);
          await reply('‚ùå Erro ao adicionar comando VIP.');
        }
        break;

      case 'removecmdvip':
      case 'removevipcommand':
      case 'rmcmdvip':
      case 'delcmdvip':
        try {
          if (!isOwner) return reply('üö´ Este comando √© apenas para o dono do bot!');
          
          if (!q) {
            return reply(`üìù *Como remover comandos VIP:*

*Formato:*
${prefix}removecmdvip <comando>

*Exemplo:*
${prefix}removecmdvip premium_ia`);
          }
          
          const cmdName = q.trim();
          const result = vipCommandsManager.removeVipCommand(cmdName);
          
          await reply(result.message);
          
          if (result.success) {
            console.log(`[VIP CMD] Comando "${cmdName}" removido por ${pushname} (${sender})`);
          }
        } catch (error) {
          console.error('Erro ao remover comando VIP:', error);
          await reply('‚ùå Erro ao remover comando VIP.');
        }
        break;

      case 'listcmdvip':
      case 'listvipcommands':
      case 'comandosvip':
        try {
          if (!isOwner && !isPremium) {
            return reply('üö´ Este comando √© apenas para o dono ou usu√°rios VIP!');
          }
          
          const customDesign = getMenuDesignWithDefaults(nomebot, pushname);
          const listText = await menuVIP(prefix, nomebot, pushname, customDesign);
          
          await reply(listText);
        } catch (error) {
          console.error('Erro ao listar comandos VIP:', error);
          await reply('‚ùå Erro ao listar comandos VIP.');
        }
        break;

      case 'togglecmdvip':
      case 'ativarcmdvip':
      case 'desativarcmdvip':
        try {
          if (!isOwner) return reply('üö´ Este comando √© apenas para o dono do bot!');
          
          if (!args[0] || !args[1]) {
            return reply(`üìù *Como ativar/desativar comandos VIP:*

*Formato:*
${prefix}togglecmdvip <comando> <on/off>

*Exemplo:*
${prefix}togglecmdvip premium_ia on
${prefix}togglecmdvip premium_ia off`);
          }
          
          const cmdName = args[0].trim();
          const action = args[1].toLowerCase();
          
          if (!['on', 'off', 'ativar', 'desativar'].includes(action)) {
            return reply('‚ùå Use "on" para ativar ou "off" para desativar!');
          }
          
          const enabled = ['on', 'ativar'].includes(action);
          const result = vipCommandsManager.toggleVipCommand(cmdName, enabled);
          
          await reply(result.message);
          
          if (result.success) {
            console.log(`[VIP CMD] Comando "${cmdName}" ${enabled ? 'ativado' : 'desativado'} por ${pushname} (${sender})`);
          }
        } catch (error) {
          console.error('Erro ao alternar comando VIP:', error);
          await reply('‚ùå Erro ao alternar status do comando VIP.');
        }
        break;

      case 'statsvip':
      case 'vipstats':
      case 'estatisticasvip':
        try {
          if (!isOwner) return reply('üö´ Este comando √© apenas para o dono do bot!');
          
          const stats = vipCommandsManager.getVipStats();
          
          let statsText = `üìä *ESTAT√çSTICAS DO SISTEMA VIP*\n\n`;
          statsText += `‚ï≠‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚ïÆ\n`;
          statsText += `‚îÇ üìà *RESUMO GERAL*\n`;
          statsText += `‚ï∞‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚ïØ\n\n`;
          statsText += `‚Ä¢ Total de comandos: ${stats.total}\n`;
          statsText += `‚Ä¢ Comandos ativos: ${stats.active}\n`;
          statsText += `‚Ä¢ Comandos inativos: ${stats.inactive}\n`;
          statsText += `‚Ä¢ Total de categorias: ${stats.categories}\n\n`;
          
          if (stats.byCategory && stats.byCategory.length > 0) {
            statsText += `‚ï≠‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚ïÆ\n`;
            statsText += `‚îÇ üìÇ *POR CATEGORIA*\n`;
            statsText += `‚ï∞‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚ïØ\n\n`;
            
            stats.byCategory.forEach(cat => {
              statsText += `‚Ä¢ ${cat.category}: ${cat.count}\n`;
            });
          }
          
          statsText += `\n‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ\n\n`;
          statsText += `üí° Use ${prefix}listcmdvip para ver todos os comandos`;
          
          await reply(statsText);
        } catch (error) {
          console.error('Erro ao obter estat√≠sticas VIP:', error);
          await reply('‚ùå Erro ao obter estat√≠sticas VIP.');
        }
        break;
      
      // SISTEMA DE INDICA√á√ïES
      case 'addindicacao':
      case 'addindicar':
      case 'addindica':
        try {
          if (!isOwner) return reply("üö´ Este comando √© apenas para o dono do bot!");
          
          if (!menc_os2) return reply("‚ùå Voc√™ precisa marcar algu√©m para adicionar uma indica√ß√£o!\n\nüí° Exemplo: " + prefix + "addindicacao @usuario");
          
          const indicacoesFile = pathz.join(DATABASE_DIR, 'indicacoes.json');
          let indicacoesData = loadJsonFile(indicacoesFile, { users: {} });
          
          if (!indicacoesData.users[menc_os2]) {
            indicacoesData.users[menc_os2] = {
              count: 0,
              addedBy: [],
              createdAt: new Date().toISOString()
            };
          }
          
          indicacoesData.users[menc_os2].count += 1;
          indicacoesData.users[menc_os2].addedBy.push({
            by: sender,
            at: new Date().toISOString()
          });
          indicacoesData.users[menc_os2].lastUpdate = new Date().toISOString();
          
          writeJsonFile(indicacoesFile, indicacoesData);
          
          await nazu.sendMessage(from, {
            text: `‚úÖ *Indica√ß√£o adicionada com sucesso!*\n\nüë§ @${getUserName(menc_os2)} agora tem *${indicacoesData.users[menc_os2].count}* indica√ß√£o(√µes)! üéâ`,
            mentions: [menc_os2]
          }, { quoted: info });
          
        } catch (e) {
          console.error('Erro no comando addindicacao:', e);
          reply("‚ùå Ocorreu um erro ao adicionar a indica√ß√£o.");
        }
        break;
        
      case 'topindica':
      case 'topindicacao':
      case 'rankindicacao':
      case 'rankindicacoes':
        try {
          const indicacoesFile = pathz.join(DATABASE_DIR, 'indicacoes.json');
          let indicacoesData = loadJsonFile(indicacoesFile, { users: {} });
          
          const usersArray = Object.entries(indicacoesData.users)
            .map(([userId, data]) => ({ userId, count: data.count }))
            .sort((a, b) => b.count - a.count);
          
          if (usersArray.length === 0) {
            return reply("üìä Ainda n√£o h√° indica√ß√µes registradas no sistema.");
          }
          
          let mensagem = 'üèÜ *TOP INDICA√á√ïES DA BOT* üèÜ\n\n';
          mensagem += '‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê\n\n';
          
          const topEmojis = ['ü•á', 'ü•à', 'ü•â'];
          const maxShow = Math.min(usersArray.length, 10);
          
          for (let i = 0; i < maxShow; i++) {
            const emoji = i < 3 ? topEmojis[i] : `${i + 1}.`;
            const user = usersArray[i];
            mensagem += `${emoji} @${getUserName(user.userId)}\n`;
            mensagem += `   ‚îî‚îÄ üìà *${user.count}* indica√ß√£o(√µes)\n\n`;
          }
          
          mensagem += '‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê\n';
          mensagem += `üìä Total de usu√°rios: ${usersArray.length}\n`;
          mensagem += `üìä Total de indica√ß√µes: ${usersArray.reduce((sum, u) => sum + u.count, 0)}`;
          
          const mentions = usersArray.slice(0, maxShow).map(u => u.userId);
          
          await nazu.sendMessage(from, {
            text: mensagem,
            mentions: mentions
          }, { quoted: info });
          
        } catch (e) {
          console.error('Erro no comando topindica:', e);
          reply("‚ùå Ocorreu um erro ao buscar o ranking de indica√ß√µes.");
        }
        break;
        
      case 'delindicacao':
      case 'rmindicacao':
      case 'removerindicacao':
        try {
          if (!isOwner) return reply("üö´ Este comando √© apenas para o dono do bot!");
          
          if (!menc_os2) return reply("‚ùå Voc√™ precisa marcar algu√©m para remover a indica√ß√£o!\n\nüí° Exemplo: " + prefix + "delindicacao @usuario");
          
          const indicacoesFile = pathz.join(DATABASE_DIR, 'indicacoes.json');
          let indicacoesData = loadJsonFile(indicacoesFile, { users: {} });
          
          if (!indicacoesData.users[menc_os2] || indicacoesData.users[menc_os2].count === 0) {
            return reply("‚ùå Este usu√°rio n√£o possui indica√ß√µes registradas!");
          }
          
          const countBefore = indicacoesData.users[menc_os2].count;
          
          if (q && !isNaN(q)) {
            const removeCount = parseInt(q);
            indicacoesData.users[menc_os2].count = Math.max(0, indicacoesData.users[menc_os2].count - removeCount);
          } else {
            delete indicacoesData.users[menc_os2];
          }
          
          writeJsonFile(indicacoesFile, indicacoesData);
          
          const finalMsg = q && !isNaN(q) 
            ? `‚úÖ Removidas *${Math.min(parseInt(q), countBefore)}* indica√ß√£o(√µes) de @${getUserName(menc_os2)}!\n\nüìä Total restante: *${indicacoesData.users[menc_os2]?.count || 0}*`
            : `‚úÖ Todas as indica√ß√µes de @${getUserName(menc_os2)} foram removidas! (Total: *${countBefore}*)`;
          
          await nazu.sendMessage(from, {
            text: finalMsg,
            mentions: [menc_os2]
          }, { quoted: info });
          
        } catch (e) {
          console.error('Erro no comando delindicacao:', e);
          reply("‚ùå Ocorreu um erro ao remover a indica√ß√£o.");
        }
        break;
      
      //COMANDOS GERAIS
      case 'rvisu':
      case 'open':
      case 'revelar':
        try {
          var RSMM = info.message?.extendedTextMessage?.contextInfo?.quotedMessage;
          var boij22 = RSMM?.imageMessage || info.message?.imageMessage || RSMM?.viewOnceMessageV2?.message?.imageMessage || info.message?.viewOnceMessageV2?.message?.imageMessage || info.message?.viewOnceMessage?.message?.imageMessage || RSMM?.viewOnceMessage?.message?.imageMessage;
          var boijj = RSMM?.videoMessage || info.message?.videoMessage || RSMM?.viewOnceMessageV2?.message?.videoMessage || info.message?.viewOnceMessageV2?.message?.videoMessage || info.message?.viewOnceMessage?.message?.videoMessage || RSMM?.viewOnceMessage?.message?.videoMessage;
          var boij33 = RSMM?.audioMessage || info.message?.audioMessage || RSMM?.viewOnceMessageV2?.message?.audioMessage || info.message?.viewOnceMessageV2?.message?.audioMessage || info.message?.viewOnceMessage?.message?.audioMessage || RSMM?.viewOnceMessage?.message?.audioMessage;
          if (boijj) {
            var px = boijj;
            px.viewOnce = false;
            px.video = {
              url: px.url
            };
            await nazu.sendMessage(from, px, {
              quoted: info
            });
          } else if (boij22) {
            var px = boij22;
            px.viewOnce = false;
            px.image = {
              url: px.url
            };
            await nazu.sendMessage(from, px, {
              quoted: info
            });
          } else if (boij33) {
            var px = boij33;
            px.viewOnce = false;
            px.audio = {
              url: px.url
            };
            await nazu.sendMessage(from, px, {
              quoted: info
            });
          } else {
            return reply('Por favor, *mencione uma imagem, video ou √°udio em visualiza√ß√£o √∫nica* para executar o comando.');
          }
        } catch (e) {
          console.error(e);
          await reply("‚ùå Ocorreu um erro interno. Tente novamente em alguns minutos.");
        }
        break;
      case 'limpardb':
        try {
          if (!isOwner) return reply("Apenas o dono pode limpar o banco de dados.");
          const allGroups = await nazu.groupFetchAllParticipating();
          const currentGroupIds = Object.keys(allGroups);
          const groupFiles = fs.readdirSync(GRUPOS_DIR).filter(file => file.endsWith('.json'));
          let removedCount = 0;
          let removedGroups = [];
          groupFiles.forEach(file => {
            const groupId = file.replace('.json', '');
            if (!currentGroupIds.includes(groupId)) {
              fs.unlinkSync(pathz.join(GRUPOS_DIR, file));
              removedCount++;
              removedGroups.push(groupId);
            }
          });
          await reply(`üßπ Limpeza do DB conclu√≠da!\n\nRemovidos ${removedCount} grupos obsoletos:\n${removedGroups.map(id => `‚Ä¢ ${id}`).join('\n') || 'Nenhum grupo obsoleto encontrado.'}`);
        } catch (e) {
          console.error('Erro no comando limpardb:', e);
          await reply("Ocorreu um erro ao limpar o DB üíî");
        }
        break;
      case 'mantercontador':
      case 'preservarcontador':
        try {
          if (!isGroup) return reply("Este comando s√≥ funciona em grupos.");
          if (!isGroupAdmin) return reply("Apenas administradores podem configurar esta op√ß√£o.");
          
          // Inicializa a configura√ß√£o se n√£o existir
          if (groupData.preservarContador === undefined) {
            groupData.preservarContador = false;
          }
          
          // Alterna o estado
          groupData.preservarContador = !groupData.preservarContador;
          
          // Salva a configura√ß√£o
          writeJsonFile(groupFile, groupData);
          if (isGroup) {
            optimizer.invalidateGroup(from);
          }
          
          const status = groupData.preservarContador ? 'ativado' : 'desativado';
          const emoji = groupData.preservarContador ? '‚úÖ' : '‚ùå';
          
          await reply(`${emoji} *Preserva√ß√£o do contador ${status}!*\n\n${groupData.preservarContador ? 'üîí O bot n√£o remover√° mais do contador quem sair do grupo.\nüìä Os dados dos membros que sa√≠rem ser√£o mantidos no rank de atividade.' : 'üîì O bot voltar√° a remover do contador quem sair do grupo.\nüßπ Use o comando *limparrank* para limpar usu√°rios ausentes manualmente.'}`);
        } catch (e) {
          console.error('[MANTER CONTADOR] Erro:', e);
          await reply("‚ùå Ocorreu um erro ao configurar a preserva√ß√£o do contador. Tente novamente mais tarde.");
        }
        break;
      case 'limparrank':
        try {
          if (!isGroup) return reply("Este comando s√≥ funciona em grupos.");
          if (!isGroupAdmin) return reply("Apenas administradores podem limpar o rank de atividade.");
          
          // Verifica se a preserva√ß√£o do contador est√° ativada
          const preservarContador = groupData.preservarContador === true;
          
          if (preservarContador) {
            return reply("‚ö†Ô∏è *Preserva√ß√£o do contador ativada!*\n\nüîí A remo√ß√£o autom√°tica do contador est√° desativada neste grupo.\n\nüí° Para limpar o rank manualmente, primeiro desative a preserva√ß√£o com:\n*" + prefix + "mantercontador*");
          }
          
          // Get current group members with proper LID/JID handling
          const currentMembers = AllgroupMembers;
          const oldContador = groupData.contador || [];
          let removedCount = 0;
          let removedUsers = [];
          let invalidUsers = [];
          
          // Enhanced filtering with better error handling
          groupData.contador = oldContador.filter(user => {
            try {
              if (!user || !user.id) {
                invalidUsers.push('Invalid user entry');
                return false;
              }
              
              // Check if user is still in the group
              const isMember = currentMembers.includes(user.id);
              
              if (!isMember) {
                removedCount++;
                const userName = getUserName(user.id);
                removedUsers.push(userName);
                console.log(`[LIMPAR RANK] Removed departed user: ${user.id} (${userName})`);
                return false;
              }
              
              return true;
            } catch (e) {
              console.log(`[LIMPAR RANK] Error processing user ${user?.id}:`, e.message);
              invalidUsers.push(user?.id || 'Unknown');
              return false;
            }
          });
          
          // Save the updated data
    writeJsonFile(groupFile, groupData);
  // Otimiza√ß√£o: Invalida cache quando groupData √© salvo
  if (isGroup) {
    optimizer.invalidateGroup(from);
  }
          
          // Prepare response message
          let responseMessage = `üßπ Limpeza do rank de atividade conclu√≠da!\n\n`;
          responseMessage += `‚úÖ Removidos ${removedCount} usu√°rios ausentes:\n`;
          responseMessage += `${removedUsers.map(name => `‚Ä¢ @${name}`).join('\n') || 'Nenhum usu√°rio ausente encontrado.'}`;
          
          if (invalidUsers.length > 0) {
            responseMessage += `\n\n‚ö†Ô∏è ${invalidUsers.length} entradas inv√°lidas foram removidas silenciosamente.`;
          }
          
          // Send response with proper mentions
          await reply(responseMessage, {
            mentions: removedUsers.map(name => buildUserId(name, config))
          });
          
          // Log the action
          console.log(`[LIMPAR RANK] Action completed in group ${from}. Removed ${removedCount} users, ${invalidUsers.length} invalid entries.`);
        } catch (e) {
          console.error('[LIMPAR RANK] Error:', e);
          await reply("‚ùå Ocorreu um erro ao limpar o rank. Tente novamente mais tarde.");
        }
        break;
      case 'resetrank':
        try {
          if (!isGroup) return reply("Este comando s√≥ funciona em grupos.");
          if (!isGroupAdmin) return reply("Apenas administradores podem resetar o rank de atividade.");
          const oldCount = (groupData.contador || []).length;
          groupData.contador = [];
          fs.writeFileSync(groupFile, JSON.stringify(groupData, null, 2));
          await reply(`üîÑ Reset do rank de atividade conclu√≠do!\n\nRemovidas ${oldCount} entradas de usu√°rios. O rank agora est√° vazio.`);
        } catch (e) {
          console.error('Erro no comando resetarrank:', e);
          await reply("Ocorreu um erro ao resetar o rank üíî");
        }
        break;
      case 'limparrankg':
        try {
          if (!isOwner) return reply("Apenas o dono pode limpar os ranks de todos os grupos.");
          
          const groupFiles = fs.readdirSync(GRUPOS_DIR).filter(file => file.endsWith('.json'));
          let totalRemoved = 0;
          let totalInvalid = 0;
          let summary = [];
          let failedGroups = [];
          
          console.log(`[LIMPAR RANK GLOBAL] Starting cleanup for ${groupFiles.length} groups`);
          
          for (const file of groupFiles) {
            try {
              const groupId = file.replace('.json', '');
              const groupPath = pathz.join(GRUPOS_DIR, file);
              
              // Skip if file doesn't exist or can't be read
              if (!fs.existsSync(groupPath)) {
                console.log(`[LIMPAR RANK GLOBAL] Skipping non-existent file: ${groupPath}`);
                continue;
              }
              
              let gData;
              try {
                gData = JSON.parse(fs.readFileSync(groupPath));
              } catch (parseError) {
                console.log(`[LIMPAR RANK GLOBAL] Error reading group file ${groupId}:`, parseError.message);
                failedGroups.push(`${groupId}: Erro ao ler arquivo`);
                continue;
              }
              
              // Get group metadata with error handling
              let metadata;
              try {
                metadata = await getCachedGroupMetadata(groupId).catch(() => null);
              } catch (metaError) {
                console.log(`[LIMPAR RANK GLOBAL] Error getting metadata for group ${groupId}:`, metaError.message);
                failedGroups.push(`${groupId}: Erro ao obter metadados`);
                continue;
              }
              
              if (!metadata) {
                console.log(`[LIMPAR RANK GLOBAL] No metadata for group ${groupId}, skipping`);
                continue;
              }
              
              // Get current members with proper LID/JID handling
              const currentMembers = metadata.participants?.map(p => p.lid || p.id) || [];
              const oldContador = gData.contador || [];
              let removedInGroup = 0;
              let invalidInGroup = 0;
              
              // Verifica se a preserva√ß√£o do contador est√° ativada para este grupo
              const preservarContadorGrupo = gData.preservarContador === true;
              
              // Enhanced filtering (apenas se preserva√ß√£o n√£o estiver ativada)
              if (!preservarContadorGrupo) {
                gData.contador = oldContador.filter(user => {
                  try {
                    if (!user || !user.id) {
                      invalidInGroup++;
                      totalInvalid++;
                      return false;
                    }
                    
                    // Check if user is still in the group
                    const isMember = currentMembers.includes(user.id);
                    
                    if (!isMember) {
                      removedInGroup++;
                      totalRemoved++;
                      const userName = getUserName(user.id);
                      console.log(`[LIMPAR RANK GLOBAL] Removed departed user from ${groupId}: ${user.id} (${userName})`);
                      return false;
                    }
                    
                    return true;
                  } catch (e) {
                    console.log(`[LIMPAR RANK GLOBAL] Error processing user ${user?.id} in group ${groupId}:`, e.message);
                    invalidInGroup++;
                    totalInvalid++;
                    return false;
                  }
                });
              } else {
                // Se preserva√ß√£o estiver ativada, apenas conta inv√°lidos, n√£o remove
                oldContador.forEach(user => {
                  if (!user || !user.id) {
                    invalidInGroup++;
                    totalInvalid++;
                  }
                });
              }
              
              // Save updated group data
              try {
                fs.writeFileSync(groupPath, JSON.stringify(gData, null, 2));
              } catch (writeError) {
                console.log(`[LIMPAR RANK GLOBAL] Error writing to group file ${groupId}:`, writeError.message);
                failedGroups.push(`${groupId}: Erro ao salvar arquivo`);
                continue;
              }
              
              // Add to summary if changes were made
              if (removedInGroup > 0 || invalidInGroup > 0) {
                let groupSummary = `${groupId}: `;
                if (removedInGroup > 0) groupSummary += `Removidos ${removedInGroup} usu√°rios ausentes`;
                if (invalidInGroup > 0) {
                  if (removedInGroup > 0) groupSummary += ', ';
                  groupSummary += `${invalidInGroup} entradas inv√°lidas`;
                }
                summary.push(groupSummary);
              }
              
            } catch (groupError) {
              console.log(`[LIMPAR RANK GLOBAL] Error processing group file ${file}:`, groupError.message);
              failedGroups.push(`${file}: Erro inesperado`);
            }
          }
          
          // Prepare response message
          let responseMessage = `üßπ Limpeza de ranks em todos os grupos conclu√≠da!\n\n`;
          responseMessage += `‚úÖ Total de usu√°rios removidos: ${totalRemoved}\n`;
          responseMessage += `‚ö†Ô∏è Entradas inv√°lidas removidas: ${totalInvalid}\n\n`;
          
          if (summary.length > 0) {
            responseMessage += `üìã Detalhes:\n${summary.join('\n')}\n\n`;
          }
          
          if (failedGroups.length > 0) {
            responseMessage += `‚ùå Grupos com problemas (${failedGroups.length}):\n${failedGroups.slice(0, 5).join('\n')}${failedGroups.length > 5 ? '\n... e mais ' + (failedGroups.length - 5) : ''}\n`;
          }
          
          if (summary.length === 0 && totalRemoved === 0 && totalInvalid === 0) {
            responseMessage = `üßπ Limpeza de ranks em todos os grupos conclu√≠da!\n\nNenhum usu√°rio ausente ou entrada inv√°lida encontrada em qualquer grupo.`;
          }
          
          await reply(responseMessage);
          
          // Log the action
          console.log(`[LIMPAR RANK GLOBAL] Cleanup completed. Total removed: ${totalRemoved}, Invalid: ${totalInvalid}, Failed: ${failedGroups.length}`);
          
        } catch (e) {
          console.error('[LIMPAR RANK GLOBAL] Error:', e);
          await reply("‚ùå Ocorreu um erro ao limpar ranks de todos os grupos. Tente novamente mais tarde.");
        }
        break;
      case 'rankativos':
      case 'rankativo':
        try {
          if (!isGroup) return reply("isso so pode ser usado em grupo üíî");
          
          // Verifica se a preserva√ß√£o do contador est√° ativada
          const preservarContadorRankativo = groupData.preservarContador === true;
          
          // Verify current group members first
          let currentMembers = AllgroupMembers;
          let validUsers = [];
          
          // Filter out users who have left the group (apenas se preserva√ß√£o n√£o estiver ativada)
          if (!preservarContadorRankativo) {
            groupData.contador = groupData.contador.filter(user => {
              const userId = user.id;
              const isValidMember = currentMembers.includes(userId);
              
              if (!isValidMember) {
                console.log(`[RANKATIVO] Removed departed user: ${userId} (${getUserName(userId)})`);
                return false;
              }
              
              validUsers.push(user);
              return true;
            });
            
            // Save updated data
            fs.writeFileSync(groupFile, JSON.stringify(groupData, null, 2));
          } else {
            // Se preserva√ß√£o estiver ativada, apenas filtra para validUsers sem remover do contador
            validUsers = (groupData.contador || []).filter(user => {
              const userId = user.id;
              return currentMembers.includes(userId);
            });
          }
          
          var blue67;
          blue67 = validUsers.sort((a, b) => (a.figu == undefined ? a.figu = 0 : a.figu + a.msg + a.cmd) < (b.figu == undefined ? b.figu = 0 : b.figu + b.cmd + b.msg) ? 0 : -1);
          var menc;
          menc = [];
          let blad;
          blad = `*üèÜ Rank dos ${blue67.length < 10 ? blue67.length : 10} mais ativos do grupo:*\n`;
          for (i6 = 0; i6 < (blue67.length < 10 ? blue67.length : 10); i6++) {
            if (blue67[i6].id) {
              if (i6 != null) {
                blad += `\n*üèÖ ${i6 + 1}¬∫ Lugar:* @${getUserName(blue67[i6].id)}\n- mensagens encaminhadas: *${blue67[i6].msg}*\n- comandos executados: *${blue67[i6].cmd}*\n- Figurinhas encaminhadas: *${blue67[i6].figu}*\n`;
              }
              if (!groupData.mark) {
                groupData.mark = {};
              }
              if (!['0', 'marca'].includes(groupData.mark[blue67[i6].id])) {
                menc.push(blue67[i6].id);
              }
            }
          }
          await nazu.sendMessage(from, {
            text: blad,
            mentions: menc
          }, {
            quoted: info
          });
        } catch (e) {
          console.error('[RANKATIVO] Erro:', e);
          await reply("‚ùå Ocorreu um erro interno. Tente novamente em alguns minutos.");
        }
        break;
      case 'rankinativos':
      case 'rankinativo':
        try {
          if (!isGroup) return reply("isso so pode ser usado em grupo üíî");
          
          // Verifica se a preserva√ß√£o do contador est√° ativada
          const preservarContador = groupData.preservarContador === true;
          
          // Verify current group members first
          let currentMembers = AllgroupMembers;
          let validUsers = [];
          
          // Filter out users who have left the group (apenas se preserva√ß√£o n√£o estiver ativada)
          if (!preservarContador) {
            groupData.contador = groupData.contador.filter(user => {
              const userId = user.id;
              const isValidMember = currentMembers.includes(userId);
              
              if (!isValidMember) {
                console.log(`[RANKINATIVO] Removed departed user: ${userId} (${getUserName(userId)})`);
                return false;
              }
              
              validUsers.push(user);
              return true;
            });
            
            // Save updated data
            fs.writeFileSync(groupFile, JSON.stringify(groupData, null, 2));
          } else {
            // Se preserva√ß√£o estiver ativada, apenas filtra para validUsers sem remover do contador
            validUsers = (groupData.contador || []).filter(user => {
              const userId = user.id;
              return currentMembers.includes(userId);
            });
          }
          
          var blue67;
          blue67 = validUsers.sort((a, b) => {
            const totalA = (a.figu ?? 0) + a.msg + a.cmd;
            const totalB = (b.figu ?? 0) + b.msg + b.cmd;
            return totalA - totalB;
          });
          var menc;
          menc = [];
          var blad;
          blad = `*üóëÔ∏è Rank dos ${blue67.length < 10 ? blue67.length : 10} mais inativos do grupo:*\n`;
          for (i6 = 0; i6 < (blue67.length < 10 ? blue67.length : 10); i6++) {
            var i6;
            if (i6 != null) {
              var blad;
              blad += `\n*üèÖ ${i6 + 1}¬∫ Lugar:* @${getUserName(blue67[i6].id)}\n- mensagens encaminhadas: *${blue67[i6].msg}*\n- comandos executados: *${blue67[i6].cmd}*\n- Figurinhas encaminhadas: *${blue67[i6].figu}*\n`;
            }
            if (!groupData.mark) {
              groupData.mark = {};
            }
            if (!['0', 'marca'].includes(groupData.mark[blue67[i6].id])) {
              menc.push(blue67[i6].id);
            }
          }
          await nazu.sendMessage(from, {
            text: blad,
            mentions: menc
          }, {
            quoted: info
          });
        } catch (e) {
          console.error('[RANKINATIVO] Erro:', e);
          await reply("‚ùå Ocorreu um erro interno. Tente novamente em alguns minutos.");
        }
        break;
      case 'checkativo':
        try {
          if (!isGroup) return reply("Este comando s√≥ funciona em grupos.");
          
          const mentionedJids = info.message?.extendedTextMessage?.contextInfo?.mentionedJid || [];
          let targetUser = sender;
          
          // Se mencionou algu√©m, usa o mencionado
          if (mentionedJids.length > 0) {
            targetUser = mentionedJids[0];
          }
          
          // Verifica se o usu√°rio est√° no grupo
          if (!AllgroupMembers.includes(targetUser)) {
            return reply("Este usu√°rio n√£o est√° no grupo.");
          }
          
          // Busca os dados do usu√°rio no contador
          const userData = (groupData.contador || []).find(u => u.id === targetUser);
          const userName = getUserName(targetUser);
          
          if (!userData) {
            return reply(`üìä *Atividade de @${userName}*\n\nNenhum dado encontrado no contador deste grupo.`, {
              mentions: [targetUser]
            });
          }
          
          const messages = userData.msg || 0;
          const commands = userData.cmd || 0;
          const stickers = userData.figu || 0;
          const total = messages + commands + stickers;
          
          const lastActivity = userData.lastActivity 
            ? new Date(userData.lastActivity).toLocaleString('pt-BR', {
                timeZone: 'America/Sao_Paulo',
                day: '2-digit',
                month: '2-digit',
                year: 'numeric',
                hour: '2-digit',
                minute: '2-digit'
              })
            : 'N/A';
          
          const checkMessage = `üìä *Atividade de @${userName}*\n\n` +
            `üí¨ *Mensagens:* ${messages}\n` +
            `‚öíÔ∏è *Comandos:* ${commands}\n` +
            `üé® *Figurinhas:* ${stickers}\n` +
            `üìà *Total:* ${total}\n` +
            `üïê *√öltima atividade:* ${lastActivity}`;
          
          await reply(checkMessage, {
            mentions: [targetUser]
          });
        } catch (e) {
          console.error('[CHECKATIVO] Erro:', e);
          await reply("‚ùå Ocorreu um erro ao verificar a atividade. Tente novamente.");
        }
        break;
      case 'atividade':
        try {
          if (!isGroup) return reply("Este comando s√≥ funciona em grupos.");
          
          // Verifica membros atuais do grupo
          const currentMembers = AllgroupMembers;
          
          // Filtra usu√°rios que sa√≠ram do grupo
          groupData.contador = (groupData.contador || []).filter(user => {
            return user && user.id && currentMembers.includes(user.id);
          });
          
          // Salva dados atualizados
          writeJsonFile(groupFile, groupData);
          if (isGroup) {
            optimizer.invalidateGroup(from);
          }
          
          // Verifica se h√° usu√°rios no contador
          if (!groupData.contador || groupData.contador.length === 0) {
            return reply("üìä *Atividade do Grupo*\n\nNenhum usu√°rio no contador ainda.");
          }
          
          // Ordena por atividade total (mensagens + comandos + figurinhas)
          const sortedUsers = [...groupData.contador].sort((a, b) => {
            const totalA = (a.msg || 0) + (a.cmd || 0) + (a.figu || 0);
            const totalB = (b.msg || 0) + (b.cmd || 0) + (b.figu || 0);
            return totalB - totalA;
          });
          
          // Monta a mensagem
          let activityMessage = `üìä *Atividade do Grupo*\n\n`;
          activityMessage += `üë• *Total de usu√°rios:* ${sortedUsers.length}\n\n`;
          
          // Lista todos os usu√°rios com suas estat√≠sticas
          const mentions = [];
          sortedUsers.forEach((user, index) => {
            if (user && user.id) {
              const total = (user.msg || 0) + (user.cmd || 0) + (user.figu || 0);
              
              activityMessage += `${index + 1}¬∫ @${getUserName(user.id)}\n`;
              activityMessage += `   üí¨ Msg: ${user.msg || 0} | ‚öíÔ∏è Cmd: ${user.cmd || 0} | üé® Fig: ${user.figu || 0} | üìà Total: ${total}\n\n`;
              
              mentions.push(user.id);
            }
          });
          
          await nazu.sendMessage(from, {
            text: activityMessage,
            mentions: mentions
          }, {
            quoted: info
          });
        } catch (e) {
          console.error('[ATIVIDADE] Erro:', e);
          await reply("‚ùå Ocorreu um erro ao mostrar a atividade. Tente novamente.");
        }
        break;
      case 'totalcmd':
      case 'totalcomando':
        try {
          fs.readFile(__dirname + '/index.js', 'utf8', async (err, data) => {
            if (err) throw err;
            const comandos = [...data.matchAll(/case [`'"](\w+)[`'"]/g)].map(m => m[1]);
            await nazu.sendMessage(from, {
                text: `‚ï≠„Äî ü§ñ *Meus Comandos* „Äï‚ïÆ\n` + `‚î£ üìå Total: *${comandos.length}* comandos\n` + `‚ï∞‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚ïØ`
              }, {
                quoted: info
              });
          });
        } catch (e) {
          console.error(e);
          await reply("‚ùå Ocorreu um erro interno. Tente novamente em alguns minutos.");
        }
        break;
      case 'meustatus':
        try {
          let groupMessages = 0;
          let groupCommands = 0;
          let groupStickers = 0;
          if (isGroup && groupData.contador && Array.isArray(groupData.contador)) {
            const userData = groupData.contador.find(u => u.id === sender);
            if (userData) {
              groupMessages = userData.msg || 0;
              groupCommands = userData.cmd || 0;
              groupStickers = userData.figu || 0;
            }
          }
          let totalMessages = 0;
          let totalCommands = 0;
          let totalStickers = 0;
          const groupFiles = fs.readdirSync(GRUPOS_DIR).filter(file => file.endsWith('.json'));
          for (const file of groupFiles) {
            try {
              const groupData = JSON.parse(fs.readFileSync(pathz.join(GRUPOS_DIR, file)));
              if (groupData.contador && Array.isArray(groupData.contador)) {
                const userData = groupData.contador.find(u => u.id === sender);
                if (userData) {
                  totalMessages += userData.msg || 0;
                  totalCommands += userData.cmd || 0;
                  totalStickers += userData.figu || 0;
                }
              }
            } catch (e) {
              console.error(`Erro ao ler ${file}:`, e);
            }
          }
          const userName = pushname || getUserName(sender);
          const userStatus = isOwner ? 'Dono' : isPremium ? 'Premium' : isGroupAdmin ? 'Admin' : 'Membro';
          let profilePic = null;
          try {
            profilePic = await nazu.profilePictureUrl(sender, 'image');
          } catch (e) {}
          const statusMessage = `üìä *Meu Status - ${userName}* üìä\n\nüë§ *Nome*: ${userName}\nüì± *N√∫mero*: @${getUserName(sender)}\n‚≠ê *Status*: ${userStatus}\n\n${isGroup ? `\nüìå *No Grupo: ${groupName}*\nüí¨ Mensagens: ${groupMessages}\n‚öíÔ∏è Comandos: ${groupCommands}\nüé® Figurinhas: ${groupStickers}\n` : ''}\n\nüåê *Geral (Todos os Grupos)*\nüí¨ Mensagens: ${totalMessages}\n‚öíÔ∏è Comandos: ${totalCommands}\nüé® Figurinhas: ${totalStickers}\n\n‚ú® *Bot*: ${nomebot} by ${nomedono} ‚ú®`;
          if (profilePic) {
            await nazu.sendMessage(from, {
              image: {
                url: profilePic
              },
              caption: statusMessage,
              mentions: [sender]
            }, {
              quoted: info
            });
          } else {
            await nazu.sendMessage(from, {
              text: statusMessage,
              mentions: [sender]
            }, {
              quoted: info
            });
          }
        } catch (e) {
          console.error(e);
          await reply("‚ùå Ocorreu um erro interno. Tente novamente em alguns minutos.");
        }
        break;
      case 'infoserver':
        if (!isOwner) {
          await reply('üö´ *Ops! Voc√™ n√£o tem permiss√£o!* üòÖ\n\nüå∏ *Este comando √© s√≥ para o dono*\nInforma√ß√µes do servidor s√£o confidenciais! ‚ú®');
          break;
        }
        const serverUptime = process.uptime();
        const serverUptimeFormatted = formatUptime(serverUptime, true);
        const serverMemUsage = process.memoryUsage();
        const serverMemUsed = (serverMemUsage.heapUsed / 1024 / 1024).toFixed(2);
        const serverMemTotal = (serverMemUsage.heapTotal / 1024 / 1024).toFixed(2);
        const serverMemRss = (serverMemUsage.rss / 1024 / 1024).toFixed(2);
        const serverMemExternal = (serverMemUsage.external / 1024 / 1024).toFixed(2);
        const serverCpuUsage = process.cpuUsage();
        const serverCpuUser = (serverCpuUsage.user / 1000000).toFixed(2);
        const serverCpuSystem = (serverCpuUsage.system / 1000000).toFixed(2);
        const serverOsInfo = {
          platform: os.platform(),
          arch: os.arch(),
          release: os.release(),
          hostname: os.hostname(),
          type: os.type(),
          endianness: os.endianness()
        };
        const serverFreeMemory = (os.freemem() / 1024 / 1024 / 1024).toFixed(2);
        const serverTotalMemory = (os.totalmem() / 1024 / 1024 / 1024).toFixed(2);
        const serverLoadAvg = os.loadavg();
        const serverCpuCount = os.cpus().length;
        const serverCpuModel = os.cpus()[0]?.model || 'Desconhecido';
        const serverNetworkInterfaces = os.networkInterfaces();
        const serverInterfaces = Object.keys(serverNetworkInterfaces).length;
        const currentServerTime = new Date().toLocaleString('pt-BR', {
          timeZone: 'America/Sao_Paulo',
          day: '2-digit',
          month: '2-digit',
          year: 'numeric',
          hour: '2-digit',
          minute: '2-digit',
          second: '2-digit'
        });
        const nodeVersion = process.version;
        const osUptime = (os.uptime() / 3600).toFixed(2);
        let networkDetails = '';
        for (const [name, interfaces] of Object.entries(serverNetworkInterfaces)) {
          interfaces.forEach(iface => {
            networkDetails += `‚îú ${name} (${iface.family}): ${iface.address}\n`;
          });
        }
        let diskInfo = {
          totalGb: 0,
          freeGb: 0,
          usedGb: 0,
          percentUsed: 0
        };
        try {
          diskInfo = await getDiskSpaceInfo();
        } catch (error) {
          console.error('Erro ao obter informa√ß√µes de disco:', error);
        }
        const diskFree = diskInfo.freeGb;
        const diskTotal = diskInfo.totalGb;
        const diskUsed = diskInfo.usedGb;
        const diskUsagePercent = diskInfo.percentUsed;
        const startUsage = process.cpuUsage();
        await new Promise(resolve => setTimeout(resolve, 1000));
        const endUsage = process.cpuUsage(startUsage);
        const cpuPercent = ((endUsage.user + endUsage.system) / 10000).toFixed(1);
        const startTime = Date.now();
        const endTime = Date.now();
        const latency = endTime - startTime;
        let networkLatency = 'N/A';
        try {
          const startNetworkTest = Date.now();
          await new Promise((resolve, reject) => {
            const req = https.get('https://www.google.com', res => {
              res.on('data', () => {});
              res.on('end', () => resolve());
            });
            req.on('error', err => reject(err));
            req.setTimeout(5000, () => reject(new Error('Timeout')));
          });
          const endNetworkTest = Date.now();
          networkLatency = `${endNetworkTest - startNetworkTest}ms`;
        } catch (error) {
          networkLatency = 'Erro ao testar';
          console.error('Erro ao testar lat√™ncia de rede:', error);
        }
        let infoServerMessage = `üå∏ ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê üå∏\n`;
        
        infoServerMessage += `    *INFORMA√á√ïES DO SERVIDOR*\n`;
        
        infoServerMessage += `üå∏ ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê üå∏\n\n`;
        
        infoServerMessage += `üñ•Ô∏è *Sistema Operacional:* üè†\n`;
        
        infoServerMessage += `‚îú üü¢ Node.js: ${nodeVersion}\n`;
        
        infoServerMessage += `‚îú üíª Plataforma: ${serverOsInfo.platform}\n`;
        
        infoServerMessage += `‚îú üèóÔ∏è Arquitetura: ${serverOsInfo.arch}\n`;
        
        infoServerMessage += `‚îú üîß Tipo: ${serverOsInfo.type}\n`;
        
        infoServerMessage += `‚îú üìã Release: ${serverOsInfo.release}\n`;
        
        infoServerMessage += `‚îú üè∑Ô∏è Hostname: ${serverOsInfo.hostname}\n`;
        
        infoServerMessage += `‚îú üîÑ Endianness: ${serverOsInfo.endianness}\n`;
        
        infoServerMessage += `‚îú ‚è≥ Sistema online h√°: ${osUptime} horas\n`;
        
        infoServerMessage += `‚îî üìÖ Hora atual: ${currentServerTime}\n\n`;
        
        infoServerMessage += `‚ö° *Processador (CPU):* üß†\n`;
        
        infoServerMessage += `‚îú üî¢ N√∫cleos: ${serverCpuCount}\n`;
        
        infoServerMessage += `‚îú üè∑Ô∏è Modelo: ${serverCpuModel}\n`;
        
        infoServerMessage += `‚îú üë§ Tempo usu√°rio: ${serverCpuUser}s\n`;
        
        infoServerMessage += `‚îú ‚öôÔ∏è Tempo sistema: ${serverCpuSystem}s\n`;
        
        infoServerMessage += `‚îú üìà Uso CPU atual: ${cpuPercent}%\n`;
        
        infoServerMessage += `‚îú üìä Load 1min: ${serverLoadAvg[0].toFixed(2)}\n`;
        
        infoServerMessage += `‚îú üìà Load 5min: ${serverLoadAvg[1].toFixed(2)}\n`;
        
        infoServerMessage += `‚îî üìâ Load 15min: ${serverLoadAvg[2].toFixed(2)}\n\n`;
        const memoryUsagePercent = ((serverTotalMemory - serverFreeMemory) / serverTotalMemory * 100).toFixed(1);
        const memoryEmoji = memoryUsagePercent > 80 ? '‚ö†Ô∏è' : '‚úÖ';
        const memoryBar = '‚ñà'.repeat(memoryUsagePercent / 10) + '-'.repeat(10 - memoryUsagePercent / 10);
        
        infoServerMessage += `üíæ *Mem√≥ria do Sistema:* üß†\n`;
        
        infoServerMessage += `‚îú üÜì RAM Livre: ${serverFreeMemory} GB\n`;
        
        infoServerMessage += `‚îú üìä RAM Total: ${serverTotalMemory} GB\n`;
        
        infoServerMessage += `‚îú üìà RAM Usada: ${(serverTotalMemory - serverFreeMemory).toFixed(2)} GB\n`;
        
        infoServerMessage += `‚îî ${memoryEmoji} Uso: [${memoryBar}] ${memoryUsagePercent}%\n\n`;
        const botMemoryUsagePercent = (serverMemUsed / serverMemTotal * 100).toFixed(1);
        const botMemoryEmoji = botMemoryUsagePercent > 80 ? '‚ö†Ô∏è' : '‚úÖ';
        const botMemoryBar = '‚ñà'.repeat(botMemoryUsagePercent / 10) + '-'.repeat(10 - botMemoryUsagePercent / 10);
        
        infoServerMessage += `ü§ñ *Mem√≥ria da ${nomebot}:* üíñ\n`;
        
        infoServerMessage += `‚îú üß† Heap Usado: ${serverMemUsed} MB\n`;
        
        infoServerMessage += `‚îú üì¶ Heap Total: ${serverMemTotal} MB\n`;
        
        infoServerMessage += `‚îú üè† RSS: ${serverMemRss} MB\n`;
        
        infoServerMessage += `‚îú üîó Externo: ${serverMemExternal} MB\n`;
        
        infoServerMessage += `‚îî ${botMemoryEmoji} Efici√™ncia: [${botMemoryBar}] ${botMemoryUsagePercent}%\n\n`;
        
        infoServerMessage += `üåê *Rede e Conectividade:* üîó\n`;
        
        infoServerMessage += `‚îú üîå Interfaces: ${serverInterfaces}\n`;
        
        infoServerMessage += networkDetails;
        
        infoServerMessage += `‚îú üì° Status: Online\n`;
        
        infoServerMessage += `‚îú ‚è±Ô∏è Lat√™ncia de Rede: ${networkLatency}\n`;
        
        infoServerMessage += `‚îî üõ°Ô∏è Firewall: Ativo\n\n`;
        const diskEmoji = diskUsagePercent > 80 ? '‚ö†Ô∏è' : '‚úÖ';
        const diskBar = '‚ñà'.repeat(diskUsagePercent / 10) + '-'.repeat(10 - diskUsagePercent / 10);
        
        infoServerMessage += `üíΩ *Armazenamento:* üíø\n`;
        
        infoServerMessage += `‚îú üÜì Livre: ${diskFree} GB\n`;
        
        infoServerMessage += `‚îú üìä Total: ${diskTotal} GB\n`;
        
        infoServerMessage += `‚îú üìà Usado: ${diskUsed} GB\n`;
        
        infoServerMessage += `‚îî ${diskEmoji} Uso: [${diskBar}] ${diskUsagePercent}%\n\n`;
        
        infoServerMessage += `‚è∞ *Tempo e Lat√™ncia:* üïê\n`;
        
        infoServerMessage += `‚îú ‚è±Ô∏è Lat√™ncia do Bot: ${latency}ms\n`;
        
        infoServerMessage += `‚îî üöÄ Bot online h√°: ${serverUptimeFormatted}\n`;
        await reply(infoServerMessage);
        break;
      case 'statusbot':
      case 'infobot':
      case 'botinfo':
        try {
          const botUptime = formatUptime(process.uptime(), true);
          const botMemUsage = process.memoryUsage();
          const memUsed = (botMemUsage.heapUsed / 1024 / 1024).toFixed(2);
          const memTotal = (botMemUsage.heapTotal / 1024 / 1024).toFixed(2);
          const allGroups = await nazu.groupFetchAllParticipating();
          const totalGroups = Object.keys(allGroups).length;
          let totalUsers = 0;
          Object.values(allGroups).forEach(group => {
            totalUsers += group.participants.length;
          });
          const botStatus = botState.status === 'on' ? '‚úÖ Online' : '‚ùå Offline';
          const rentalMode = isRentalModeActive() ? '‚úÖ Ativo' : '‚ùå Desativo';
          const nodeVersion = process.version;
          const platform = os.platform();
          let totalCommands = 0;
          try {
            const indexContent = fs.readFileSync(__dirname + '/index.js', 'utf-8');
            const comandos = [...indexContent.matchAll(/case [`'"](\w+)[`'"]/g)].map(m => m[1]);
            totalCommands = comandos.length;
          } catch (e) {
            totalCommands = 'N/A';
          }
          const premiumUsers = Object.keys(premiumListaZinha).filter(key => isUserId(key)).length;
          const premiumGroups = Object.keys(premiumListaZinha).filter(key => key.includes('@g.us')).length;
          const blockedUsers = Object.keys(globalBlocks.users || {}).length;
          const blockedCommands = Object.keys(globalBlocks.commands || {}).length;
          const currentTime = new Date().toLocaleString('pt-BR', {
            timeZone: 'America/Sao_Paulo'
          });
          const lines = ["‚ï≠‚îÄ‚îÄ‚îÄü§ñ STATUS DO BOT ‚îÄ‚îÄ‚îÄ‚ïÆ", `‚îä üè∑Ô∏è Nome: ${nomebot}`, `‚îä üë®‚Äçüíª Dono: ${nomedono}`, `‚îä üÜö Vers√£o: ${botVersion}`, `‚îä üü¢ Status: ${botStatus}`, `‚îä ‚è∞ Online h√°: ${botUptime}`, `‚îä üñ•Ô∏è Plataforma: ${platform}`, `‚îä üü¢ Node.js: ${nodeVersion}`, "‚îä", "‚îä üìä *Estat√≠sticas:*", `‚îä ‚Ä¢ üë• Grupos: ${totalGroups}`, `‚îä ‚Ä¢ üë§ Usu√°rios: ${totalUsers}`, `‚îä ‚Ä¢ ‚öíÔ∏è Comandos: ${totalCommands}`, `‚îä ‚Ä¢ üíé Users Premium: ${premiumUsers}`, `‚îä ‚Ä¢ üíé Grupos Premium: ${premiumGroups}`, "‚îä", "‚îä üõ°Ô∏è *Seguran√ßa:*", `‚îä ‚Ä¢ üö´ Users Bloqueados: ${blockedUsers}`, `‚îä ‚Ä¢ üö´ Cmds Bloqueados: ${blockedCommands}`, `‚îä ‚Ä¢ üè† Modo Aluguel: ${rentalMode}`, "‚îä", "‚îä üíæ *Sistema:*", `‚îä ‚Ä¢ üß† RAM Usada: ${memUsed}MB`, `‚îä ‚Ä¢ üì¶ RAM Total: ${memTotal}MB`, `‚îä ‚Ä¢ üïê Hora Atual: ${currentTime}`, "‚ï∞‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚ïØ"].join("\n");
          await reply(lines);
        } catch (e) {
          console.error("Erro em statusbot:", e);
          await reply("‚ùå Ocorreu um erro interno. Tente novamente em alguns minutos.");
        }
        break;
      case 'iaclear':
      case 'limparhist':
        if (!isOwnerOrSub) return reply("üö´ Apenas donos e subdonos podem limpar o hist√≥rico!");
        try {
          ia.clearOldHistorico(0);
          reply("‚úÖ *Hist√≥rico do assistente limpo!*\n\nüóëÔ∏è Todas as conversas antigas foram removidas da mem√≥ria.");
        } catch (e) {
          console.error("Erro em iaclear:", e);
          reply("‚ùå Erro ao limpar hist√≥rico.");
        }
        break;
      case 'topcmd':
      case 'topcmds':
      case 'comandosmaisusados':
        try {
          if (!commandStats || typeof commandStats.getMostUsedCommands !== 'function') {
            console.warn('[COMMANDSTATS] getMostUsedCommands not available');
            return reply("Sistema de estat√≠sticas temporariamente indispon√≠vel.");
          }
          const topCommands = await commandStats.getMostUsedCommands(10);
          const menuVideoPath = __dirname + '/../midias/menu.mp4';
          const menuImagePath = __dirname + '/../midias/menu.jpg';
          const useVideo = fs.existsSync(menuVideoPath);
          const mediaPath = useVideo ? menuVideoPath : menuImagePath;
          const mediaBuffer = fs.readFileSync(mediaPath);
          const menuText = await menuTopCmd(prefix, nomebot, pushname, topCommands);
          await nazu.sendMessage(from, {
            [useVideo ? 'video' : 'image']: mediaBuffer,
            caption: menuText,
            gifPlayback: useVideo,
            mimetype: useVideo ? 'video/mp4' : 'image/jpeg'
          }, {
            quoted: info
          });
        } catch (e) {
          console.error(e);
          await reply("‚ùå Ocorreu um erro interno. Tente novamente em alguns minutos.");
        }
        break;
      case 'cmdinfo':
      case 'comandoinfo':
        try {
          if (!q) return reply(`üìä *Estat√≠sticas de Comandos*\n\nüìù *Como usar:*\n‚Ä¢ Especifique o comando ap√≥s o comando\n‚Ä¢ Ex: ${prefix}cmdinfo menu\n‚Ä¢ Ex: ${prefix}cmdinfo ping\n\nüìà Visualize estat√≠sticas detalhadas de uso do comando!`);
          const cmdName = q.startsWith(prefix) ? q.slice(prefix.length) : q;
          if (!commandStats || typeof commandStats.getCommandStats !== 'function') {
            console.warn('[COMMANDSTATS] getCommandStats not available');
            return reply("Sistema de estat√≠sticas temporariamente indispon√≠vel.");
          }
          const stats = await commandStats.getCommandStats(cmdName);
          if (!stats) {
            return reply(`‚ùå Comando *${cmdName}* n√£o encontrado ou nunca foi usado.`);
          }
          const topUsersText = stats.topUsers.length > 0 ? stats.topUsers.map((user, index) => {
            return `${index + 1}¬∫ @${getUserName(user.userId)} - ${user.count} usos`;
          }).join('\n') : 'Nenhum usu√°rio registrado';
          const lastUsed = new Date(stats.lastUsed).toLocaleString('pt-BR', { timeZone: 'America/Sao_Paulo' });
          const infoMessage = `üìä *Estat√≠sticas do Comando: ${prefix}${stats.name}* üìä\n\n` + `üìà *Total de Usos*: ${stats.count}\n` + `üë• *Usu√°rios √önicos*: ${stats.uniqueUsers}\n` + `üïí *√öltimo Uso*: ${lastUsed}\n\n` + `üèÜ *Top Usu√°rios*:\n${topUsersText}\n\n` + `‚ú® *Bot*: ${nomebot} by ${nomedono} ‚ú®`;
          await nazu.sendMessage(from, {
            text: infoMessage,
            mentions: stats.topUsers.map(u => u.userId)
          }, {
            quoted: info
          });
        } catch (e) {
          console.error(e);
          await reply("‚ùå Ocorreu um erro interno. Tente novamente em alguns minutos.");
        }
        break;
      case 'statusgp':
      case 'dadosgp':
        try {
          if (!isGroup) return reply("‚ùå Este comando s√≥ funciona em grupos!");
          const meta = await getCachedGroupMetadata(from);
          const subject = meta.subject || "‚Äî";
          const desc = meta.desc?.toString() || "Sem descri√ß√£o";
          const createdAt = meta.creation ? new Date(meta.creation * 1000).toLocaleString('pt-BR', { timeZone: 'America/Sao_Paulo' }) : "Desconhecida";
          const ownerJid = meta.owner || meta.participants.find(p => p.admin && p.isCreator)?.lid || meta.participants.find(p => p.admin && p.isCreator)?.id || "Desconhecido";
          const ownerTag = ownerJid !== "Desconhecido" ? `@${getUserName(ownerJid)}` : "Desconhecido";
          const totalMembers = meta.participants.length;
          const totalAdmins = groupAdmins.length;
          let totalMsgs = 0,
            totalCmds = 0,
            totalFigs = 0;
          (groupData.contador || []).forEach(u => {
            totalMsgs += u.msg || 0;
            totalCmds += u.cmd || 0;
            totalFigs += u.figu || 0;
          });
          const rentGlob = isRentalModeActive();
          const rentInfo = getGroupRentalStatus(from);
          const rentStatus = rentGlob ? rentInfo.active ? `‚úÖ Ativo at√© ${rentInfo.permanent ? 'Permanente' : new Date(rentInfo.expiresAt).toLocaleDateString('pt-BR')}` : "‚ùå Expirado" : "‚ùå Desativado";
          const isPremGp = !!premiumListaZinha[from] ? "‚úÖ" : "‚ùå";
          const secFlags = [
            ["Antiporn", !!isAntiPorn],
            ["AntiLink GP", !!isAntiLinkGp],
            ["AntiLink Canal", !!isAntiLinkCanal],
            ["AntiLinkHard", !!groupData.antilinkhard],
            ["AntiLinkSoft", !!groupData.antilinksoft],
            ["AntiDoc", !!groupData.antidoc],
            ["AntiLoc", !!groupData.antiloc],
            ["AntiBtn", !!groupData.antibtn],
            ["AntiStatus", !!groupData.antistatus],
            ["AntiDelete", !!groupData.antidel],
            ["AntiSticker", !!(groupData.antifig && groupData.antifig.enabled)],
          ];
          const resFlags = [
            ["AutoDL", !!groupData.autodl],
            ["AutoSticker", !!groupData.autoSticker],
            ["Assistente", !!groupData.assistente],
            ["AutoRepo", !!groupData.autorepo],
            ["Leveling", !!groupData.levelingEnabled],
            ["Bem-vindo", !!groupData.bemvindo],
            ["X9 (promo/rebaix)", !!groupData.x9],
            ["Modo Lite", !!isModoLite],
            ["Modo Brincadeira", !!isModoBn],
            ["Modo RPG", !!groupData.modorpg]
          ];
          const admFlags = [["S√≥ Admins", !!groupData.soadm]];
          const toLines = (pairs) => pairs.filter(([_, v]) => typeof v === 'boolean').map(([k, v]) => `‚îä   ${v ? '‚úÖ' : '‚ùå'} ${k}`);
          const configsSection = [
            "‚îä",
            "‚îä ‚öôÔ∏è *Configura√ß√µes:*",
            "‚îä üîí Seguran√ßa:",
            ...toLines(secFlags),
            "‚îä üß∞ Recursos:",
            ...toLines(resFlags),
            "‚îä üõ†Ô∏è Administra√ß√£o:",
            ...toLines(admFlags)
          ].join('\n');
          const schedule = groupData.schedule || {};
          const openTime = schedule.openTime ? schedule.openTime : '‚Äî';
          const closeTime = schedule.closeTime ? schedule.closeTime : '‚Äî';
          const lastOpen = formatScheduleLastRun(schedule.lastRun?.open);
          const lastClose = formatScheduleLastRun(schedule.lastRun?.close);
          const linesHeader = [
            "‚ï≠‚îÄ‚îÄ‚îÄüìä STATUS DO GRUPO ‚îÄ‚îÄ‚îÄ‚ïÆ",
            `‚îä üìù Nome: ${subject}`,
            `‚îä üÜî ID: ${getUserName(from)}`,
            `‚îä üëë Dono: ${ownerTag}`,
            `‚îä üìÖ Criado: ${createdAt}`,
            `‚îä üìÑ Desc: ${desc.slice(0, 35)}${desc.length > 35 ? '...' : ''}`,
            `‚îä üë• Membros: ${totalMembers}`,
            `‚îä üëÆ Admins: ${totalAdmins}`,
            `‚îä üíé Premium: ${isPremGp}`,
            `‚îä üè† Aluguel: ${rentStatus}`,
            "‚îä",
            "‚îä üìä *Estat√≠sticas:*",
            `‚îä ‚Ä¢ üí¨ Mensagens: ${totalMsgs}`,
            `‚îä ‚Ä¢ ‚öíÔ∏è Comandos: ${totalCmds}`,
            `‚îä ‚Ä¢ üé® Figurinhas: ${totalFigs}`,
            "‚ï∞‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚ïØ"
          ].join('\n');
          const extrasLines = [
            "\n‚ï≠‚îÄ‚îÄ‚îÄüìå REGRAS E OUTROS ‚îÄ‚îÄ‚îÄ‚ïÆ",
            `‚îä üß© Prefixo: ${groupPrefix}`,
            `‚îä üß± Min Legenda: ${groupData.minMessage ? `‚úÖ ON (min ${groupData.minMessage.minDigits}, a√ß√£o: ${groupData.minMessage.action})` : '‚ùå OFF'}`,
            `‚îä üìâ Limite Msg: ${groupData.messageLimit?.enabled ? `‚úÖ ON (${groupData.messageLimit.limit}/${groupData.messageLimit.interval}s, a√ß√£o: ${groupData.messageLimit.action})` : '‚ùå OFF'}`,
            `‚îä ü§ù Parcerias: ${parceriasData?.active ? `‚úÖ ON (${Object.keys(parceriasData.partners||{}).length} parceiros)` : '‚ùå OFF'}`,
            `‚îä ‚õî Cmds bloqueados: ${groupData.blockedCommands ? Object.values(groupData.blockedCommands).filter(Boolean).length : 0}`,
            `‚îä üö´ Usu√°rios bloqueados: ${groupData.blockedUsers ? Object.keys(groupData.blockedUsers).length : 0}`,
            `‚îä üò¥ AFKs ativos: ${groupData.afkUsers ? Object.keys(groupData.afkUsers).length : 0}`,
            `‚îä üßë‚Äç‚öñÔ∏è Moderadores: ${Array.isArray(groupData.moderators) ? groupData.moderators.length : 0}`,
            "‚ï∞‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚ïØ"
          ].join('\n');
          const lines = [linesHeader, configsSection].join('\n');
          const schedLines = [
            "\n‚ï≠‚îÄ‚îÄ‚îÄ‚è∞ AGENDAMENTOS ‚îÄ‚îÄ‚îÄ‚ïÆ",
            `‚îä üîì Abrir: ${openTime}`,
            `‚îä üîí Fechar: ${closeTime}`,
            `‚îä üóìÔ∏è √ölt. abrir: ${lastOpen}`,
            `‚îä üóìÔ∏è √ölt. fechar: ${lastClose}`,
            "‚ï∞‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚ïØ"
          ].join('\n');
          const fullCaption = (lines + schedLines + '\n' + extrasLines).trim();

          await reply(fullCaption, { mentions: ownerJid !== "Desconhecido" ? [ownerJid] : [] });
        } catch (e) {
          console.error("Erro em statusgp:", e);
          await reply("‚ùå Ocorreu um erro interno. Tente novamente em alguns minutos.");
        }
        break;
      case 'dono':
        try {
          const numeroDonoFormatado = numerodono ? String(numerodono).replace(/\D/g, '') : 'N√£o configurado';
          const TextinDonoInfo = `‚ï≠‚îÅ‚îÅ‚îÅ‚ä± üëë *DONO DO BOT* üëë ‚ä±‚îÅ‚îÅ‚îÅ‚ïÆ
‚îÇ
‚îÇ üë§ *Nome:* ${nomedono}
‚îÇ üì± *Contato:* wa.me/${numeroDonoFormatado}
‚îÇ
‚ï∞‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚ïØ`;
          await reply(TextinDonoInfo);
        } catch (e) {
          console.error(e);
          await reply("‚ùå Ocorreu um erro interno. Tente novamente em alguns minutos.");
        }
        break;

      case 'criador':
        try {
          const TextinCriadorInfo = `‚ï≠‚îÅ‚îÅ‚îÅ‚ä± üë®‚Äçüíª *CRIADOR* üë®‚Äçüíª ‚ä±‚îÅ‚îÅ‚îÅ‚ïÆ
‚îÇ
‚îÇ üíé *Nome:* Ryo
‚îÇ üì± *WhatsApp:* wa.me/5532984495464
‚îÇ
‚ï∞‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚ïØ`;
          await reply(TextinCriadorInfo);
        } catch (e) {
          console.error(e);
          await reply("‚ùå Ocorreu um erro interno. Tente novamente em alguns minutos.");
        }
        break;
      
      case 'diagnosticrpg':
      case 'repairdb':
      case 'fixdb': {
        if (!isOwner && !isCreator) return reply('‚ö†Ô∏è Apenas o dono pode usar este comando!');
        
        try {
          const econ = loadEconomy();
          
          await reply('üîç Iniciando diagn√≥stico do database...');
          
          const report = diagnosticDatabase(econ);
          
          // Salva as corre√ß√µes
          saveEconomy(econ);
          
          let text = `‚ï≠‚îÅ‚îÅ‚îÅ‚ä± üîß *DIAGN√ìSTICO RPG* üîß ‚ä±‚îÅ‚îÅ‚îÅ‚ïÆ\n`;
          text += `‚îÇ\n`;
          text += `‚îÇ üìä *ESTAT√çSTICAS:*\n`;
          text += `‚îÇ ‚îî‚îÄ Total de usu√°rios: ${report.totalUsers}\n`;
          text += `‚îÇ ‚îî‚îÄ Usu√°rios migrados: ${report.usersMigrated}\n`;
          text += `‚îÇ ‚îî‚îÄ Pets corrigidos: ${report.petsFixed}\n`;
          text += `‚îÇ\n`;
          
          if (report.fieldsAdded.length > 0) {
            text += `‚îÇ ‚úÖ *ADICIONADO:*\n`;
            report.fieldsAdded.forEach(field => {
              text += `‚îÇ ‚îî‚îÄ ${field}\n`;
            });
            text += `‚îÇ\n`;
          }
          
          if (report.warnings.length > 0) {
            text += `‚îÇ ‚ö†Ô∏è *AVISOS:*\n`;
            report.warnings.forEach(warn => {
              text += `‚îÇ ‚îî‚îÄ ${warn}\n`;
            });
            text += `‚îÇ\n`;
          }
          
          if (report.errors.length > 0) {
            text += `‚îÇ ‚ùå *ERROS:*\n`;
            report.errors.forEach(err => {
              text += `‚îÇ ‚îî‚îÄ ${err}\n`;
            });
            text += `‚îÇ\n`;
          }
          
          const totalFixed = report.usersMigrated + report.petsFixed;
          if (totalFixed > 0) {
            text += `‚îÇ üéâ *${totalFixed} corre√ß√µes aplicadas!*\n`;
          } else {
            text += `‚îÇ ‚úÖ *Database OK - Sem problemas!*\n`;
          }
          
          text += `‚îÇ\n`;
          text += `‚ï∞‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚ïØ\n\n`;
          text += `üíæ Mudan√ßas salvas automaticamente!\n`;
          text += `üîÑ Sistema de auto-reparo est√° ativo.`;
          
          return reply(text);
        } catch (error) {
          console.error('Erro no diagn√≥stico:', error);
          return reply(`‚ùå Erro ao executar diagn√≥stico:\n${error.message}`);
        }
        break;
      }
      
      case 'ping':
        try {
          const timestamp = Date.now();
          const speedConverted = (timestamp - info.messageTimestamp * 1000) / 1000;
          const uptimeBot = formatUptime(process.uptime());
          
          let statusEmoji = 'üü¢';
          let statusTexto = 'Excelente';
          let statusCor = 'üü©';
          if (speedConverted > 2) {
            statusEmoji = 'üü°';
            statusTexto = 'Bom';
            statusCor = 'üü®';
          }
          if (speedConverted > 5) {
            statusEmoji = 'üü†';
            statusTexto = 'M√©dio';
            statusCor = 'üüß';
          }
          if (speedConverted > 8) {
            statusEmoji = 'üî¥';
            statusTexto = 'Ruim';
            statusCor = 'üü•';
          }
          
          const bannerUrl = `https://nazu-banner.vercel.app/api/banner?theme=miku&num=${speedConverted.toFixed(3)}`;
          
          await nazu.sendMessage(from, {
            image: { url: bannerUrl },
            caption: `‚ï≠‚ä± ‚ö° *STATUS DA CONEX√ÉO* ‚ö° ‚ä±‚ïÆ
‚îÇ
‚îÇ üì° *Informa√ß√µes de Lat√™ncia*
‚îÇ ‚îú‚îÄ ${statusEmoji} Velocidade: *${speedConverted.toFixed(3)}s*
‚îÇ ‚îú‚îÄ ${statusCor} Qualidade: *${statusTexto}*
‚îÇ ‚îî‚îÄ üìä Status: *${speedConverted <= 2 ? '√ìtima' : speedConverted <= 5 ? 'Boa' : speedConverted <= 8 ? 'Regular' : 'Precisa Melhorar'}*
‚îÇ
‚îÇ ‚è±Ô∏è *Informa√ß√µes do Sistema*
‚îÇ ‚îú‚îÄ üü¢ Tempo Online: *${uptimeBot}*
‚îÇ ‚îú‚îÄ üìà Resposta: *${speedConverted <= 1 ? 'Instant√¢nea' : speedConverted <= 3 ? 'R√°pida' : 'Lenta'}*
‚îÇ ‚îî‚îÄ üåê Servidor: *Online*
‚îÇ
‚ï∞‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚ïØ`
          }, { quoted: info });
        } catch (e) {
          console.error("Erro no comando ping:", e);
          await reply("‚ùå Ocorreu um erro ao processar o comando ping");
        }
        break;
      case 'toimg':
        if (!isQuotedSticker) return reply(`‚ï≠‚îÅ‚îÅ‚îÅ‚ä± üñºÔ∏è *CONVERTER* üñºÔ∏è ‚ä±‚îÅ‚îÅ‚îÅ‚ïÆ
‚îÇ
‚îÇ ‚ùå Marque uma figurinha para
‚îÇ    converter em imagem!
‚îÇ
‚îÇ üí° Responda uma figurinha com:
‚îÇ ${prefix}toimg
‚îÇ
‚ï∞‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚ïØ`);
        try {
          var buff;
          buff = await getFileBuffer(info.message.extendedTextMessage.contextInfo.quotedMessage.stickerMessage, 'sticker');
          await nazu.sendMessage(from, {
            image: buff
          }, {
            quoted: info
          });
        } catch (error) {
          await reply("‚ùå Ocorreu um erro interno. Tente novamente em alguns minutos.");
        }
        break;
      case 'rmbg':
      case 'sbg':
      case 'sfundo':
        try {
          const imgMsg = quotedMessageContent?.imageMessage ||
            quotedMessageContent?.viewOnceMessage?.message?.imageMessage ||
            quotedMessageContent?.viewOnceMessageV2?.message?.imageMessage ||
            info.message?.imageMessage ||
            info.message?.viewOnceMessage?.message?.imageMessage ||
            info.message?.viewOnceMessageV2?.message?.imageMessage;

          if (!imgMsg) {
            return reply(`‚ùå Marque uma imagem para remover o fundo.\n\nüí° Uso: ${prefix}${command}`);
          }

          reply('‚è≥ Removendo fundo, aguarde...');

          const imageBuffer = await getFileBuffer(imgMsg, 'image');
          const imageUrl = await upload(imageBuffer, true);
          
          if (!imageUrl) throw new Error('Falha ao fazer upload da imagem.');
          
          const bgResult = await removeBg(imageUrl);
          
          if (!bgResult.ok) {
            throw new Error(bgResult.msg || 'N√£o foi poss√≠vel remover o fundo da imagem.');
          }
          
          const resultUrl = bgResult.result?.download;

          if (command === 'sbg' || command === 'sfundo') {
            return sendSticker(nazu, from, {
              sticker: { url: resultUrl },
              author: `${pushname}\n${nomebot}\n${nomedono}`,
              packname: 'Nazuna Bot - Stickers',
              type: 'image'
            }, {
              quoted: info
            });
          }

          return nazu.sendMessage(from, { image: { url: resultUrl } }, { quoted: info });
        } catch (e) {
          console.error(e);
          return reply('‚ùå Ocorreu um erro interno. Tente novamente em alguns minutos.');
        }
        break;
      case 'upscale':
        try {
          const upscaleImgMsg = quotedMessageContent?.imageMessage ||
            quotedMessageContent?.viewOnceMessage?.message?.imageMessage ||
            quotedMessageContent?.viewOnceMessageV2?.message?.imageMessage ||
            info.message?.imageMessage ||
            info.message?.viewOnceMessage?.message?.imageMessage ||
            info.message?.viewOnceMessageV2?.message?.imageMessage;

          if (!upscaleImgMsg) {
            return reply(`‚ùå Marque uma imagem para melhorar a qualidade.\n\nüí° Uso: ${prefix}${command}`);
          }

          reply('‚è≥ Melhorando a imagem, aguarde...');

          const imageBuffer = await getFileBuffer(upscaleImgMsg, 'image');
          const imageUrl = await upload(imageBuffer, true);
          
          if (!imageUrl) throw new Error('Falha ao fazer upload da imagem.');
          
          const upscaleResult = await upscale(imageUrl, 2);
          
          if (!upscaleResult.ok) {
            throw new Error(upscaleResult.msg || 'N√£o foi poss√≠vel melhorar a imagem.');
          }
          
          const resultUrl = upscaleResult.result?.download;

          return nazu.sendMessage(from, { image: { url: resultUrl } }, { quoted: info });
        } catch (e) {
          console.error(e);
          return reply('‚ùå Ocorreu um erro interno. Tente novamente em alguns minutos.');
        }
        break;
      case 'qc':
        try {
          if (!q) return reply('Falta o texto.');
          let ppimg = "";
          try {
            ppimg = await nazu.profilePictureUrl(sender, 'image');
          } catch {
            ppimg = 'https://telegra.ph/file/b5427ea4b8701bc47e751.jpg';
          }
          const json = {
            "type": "quote",
            "format": "png",
            "backgroundColor": "#FFFFFF",
            "width": 512,
            "height": 768,
            "scale": 2,
            "messages": [{
              "entities": [],
              "avatar": true,
              "from": {
                "id": 1,
                "name": pushname,
                "photo": {
                  "url": ppimg
                }
              },
              "text": q,
              "replyMessage": {}
            }]
          };
          var res;
          res = await axios.post('https://cognima-quote.onrender.com/generate', json, {
            headers: {
              'Content-Type': 'application/json'
            }
          });
          await sendSticker(nazu, from, {
            sticker: Buffer.from(res.data.result.image, 'base64'),
            author: `„Äé${pushname}„Äè\n„Äé${nomebot}„Äè\n„Äé${nomedono}„Äè\n„Äécognima.com.br„Äè`,
            packname: 'üë§ Usuario(a)·ÆÄ€ü‚ùÅ‚ÄôÔø´\nü§ñ Bot·ÆÄ€ü‚ùÅ‚ÄôÔø´\nüëë Dono·ÆÄ€ü‚ùÅ‚ÄôÔø´\nüåê Site·ÆÄ€ü‚ùÅ‚ÄôÔø´',
            type: 'image'
          }, {
            quoted: info
          });
        } catch (e) {
          console.error(e);
          await reply("‚ùå Ocorreu um erro interno. Tente novamente em alguns minutos.");
        }
        break;
      case 'emojimix':
        try {
          var emoji1;
          emoji1 = q.split(`/`)[0];
          var emoji2;
          emoji2 = q.split(`/`)[1];
          if (!q || !emoji1 || !emoji2) return reply(`Formato errado, utilize:\n${prefix}${command} emoji1/emoji2\nEx: ${prefix}${command} ü§ì/üôÑ`);
          var datzc;
          datzc = await emojiMix(emoji1, emoji2);
          await sendSticker(nazu, from, {
            sticker: {
              url: datzc
            },
            author: `„Äé${pushname}„Äè\n„Äé${nomebot}„Äè\n„Äé${nomedono}„Äè\n„Äécognima.com.br„Äè`,
            packname: 'üë§ Usuario(a)·ÆÄ€ü‚ùÅ‚ÄôÔø´\nü§ñ Bot·ÆÄ€ü‚ùÅ‚ÄôÔø´\nüëë Dono·ÆÄ€ü‚ùÅ‚ÄôÔø´\nüåê Site·ÆÄ€ü‚ùÅ‚ÄôÔø´',
            type: 'image'
          }, {
            quoted: info
          });
        } catch (e) {
          console.error(e);
          await reply("‚ùå Ocorreu um erro interno. Tente novamente em alguns minutos.");
        }
        break;
      case 'ttp':
        try {
          if (!q) return reply('Cad√™ o texto?');
          var cor;
          cor = ["f702ff", "ff0202", "00ff2e", "efff00", "00ecff", "3100ff", "ffb400", "ff00b0", "00ff95", "efff00"];
          var fonte;
          fonte = ["Days%20One", "Domine", "Exo", "Fredoka%20One", "Gentium%20Basic", "Gloria%20Hallelujah", "Great%20Vibes", "Orbitron", "PT%20Serif", "Pacifico"];
          var cores;
          cores = cor[Math.floor(Math.random() * cor.length)];
          var fontes;
          fontes = fonte[Math.floor(Math.random() * fonte.length)];
          
          // Fun√ß√£o para quebrar texto em linhas
          function breakText(text, maxCharsPerLine = 20) {
            const words = text.split(' ');
            const lines = [];
            let currentLine = '';
            
            for (const word of words) {
              if ((currentLine + word).length <= maxCharsPerLine) {
                currentLine += (currentLine ? ' ' : '') + word;
              } else {
                if (currentLine) lines.push(currentLine);
                currentLine = word;
              }
            }
            if (currentLine) lines.push(currentLine);
            
            return lines.join('%0A'); // %0A = quebra de linha na URL
          }
          
          // Aplicar quebra de linha para textos longos
          let processedText = q.length > 20 ? breakText(q, 20) : q;
          
          await sendSticker(nazu, from, {
            sticker: {
              url: `https://huratera.sirv.com/PicsArt_08-01-10.00.42.png?profile=Example-Text&text.0.text=${encodeURIComponent(processedText)}&text.0.outline.color=000000&text.0.outline.blur=0&text.0.outline.opacity=55&text.0.color=${cores}&text.0.font.family=${fontes}&text.0.font.weight=bold&text.0.background.color=ff0000`
            },
            author: `„Äé${pushname}„Äè\n„Äé${nomebot}„Äè\n„Äé${nomedono}„Äè\n„Äécognima.com.br„Äè`,
            packname: 'üë§ Usuario(a)·ÆÄ€ü‚ùÅ‚ÄôÔø´\nü§ñ Bot·ÆÄ€ü‚ùÅ‚ÄôÔø´\nüëë Dono·ÆÄ€ü‚ùÅ‚ÄôÔø´\nüåê Site·ÆÄ€ü‚ùÅ‚ÄôÔø´',
            type: 'image'
          }, {
            quoted: info
          });
        } catch (e) {
          console.error(e);
          await reply("‚ùå Ocorreu um erro interno. Tente novamente em alguns minutos.");
        }
        break;
      case 'attp':
        try {
          if (!q) return reply('Cad√™ o texto?');
          
          const fs = await import('fs');
          const path = await import('path');
          const axios = (await import('axios')).default;
          const { exec } = await import('child_process');
          const { promisify } = await import('util');
          const execAsync = promisify(exec);
          
          // Fun√ß√£o para quebrar texto em linhas
          function breakText(text, maxCharsPerLine = 20) {
            const words = text.split(' ');
            const lines = [];
            let currentLine = '';
            
            for (const word of words) {
              if ((currentLine + word).length <= maxCharsPerLine) {
                currentLine += (currentLine ? ' ' : '') + word;
              } else {
                if (currentLine) lines.push(currentLine);
                currentLine = word;
              }
            }
            if (currentLine) lines.push(currentLine);
            
            return lines.join('%0A');
          }
          
          // Processar texto
          let processedText = q.length > 20 ? breakText(q, 20) : q;
          
          // Cores dispon√≠veis
          const cores = ["f702ff", "ff0202", "00ff2e", "efff00", "00ecff", "3100ff", "ffb400", "ff00b0", "00ff95", "9d00ff", "ff6b00", "00fff7", "ff00d4", "a8ff00", "ff0062", "00b3ff", "d4ff00", "ff009d"];
          
          // Selecionar uma fonte aleat√≥ria
          const fontes = ["Days%20One", "Domine", "Exo", "Fredoka%20One", "Gentium%20Basic", "Gloria%20Hallelujah", "Great%20Vibes", "Orbitron", "PT%20Serif", "Pacifico"];
          const fonteEscolhida = fontes[Math.floor(Math.random() * fontes.length)];
          
          // Diret√≥rio tempor√°rio
          const tempDir = path.join(__dirname, '../midias/temp_attp_' + Date.now());
          if (!fs.existsSync(tempDir)) {
            fs.mkdirSync(tempDir, { recursive: true });
          }
          
          await reply('‚è≥ Gerando sticker animado... aguarde!');
          
          // Baixar 18 imagens com cores diferentes
          const numFrames = 18;
          const downloadPromises = [];
          
          for (let i = 0; i < numFrames; i++) {
            const cor = cores[i % cores.length];
            const imageUrl = `https://huratera.sirv.com/PicsArt_08-01-10.00.42.png?profile=Example-Text&text.0.text=${encodeURIComponent(processedText)}&text.0.outline.color=000000&text.0.outline.blur=0&text.0.outline.opacity=55&text.0.color=${cor}&text.0.font.family=${fonteEscolhida}&text.0.font.weight=bold&text.0.background.color=ff0000`;
            const imagePath = path.join(tempDir, `frame_${String(i).padStart(3, '0')}.png`);
            
            downloadPromises.push(
              axios({
                url: imageUrl,
                method: 'GET',
                responseType: 'arraybuffer'
              }).then(response => {
                fs.writeFileSync(imagePath, response.data);
              })
            );
          }
          
          // Aguardar download de todas as imagens
          await Promise.all(downloadPromises);
          
          // Criar v√≠deo com ffmpeg
          const outputVideo = path.join(tempDir, 'output.mp4');
          const ffmpegCmd = `ffmpeg -framerate 10 -i ${path.join(tempDir, 'frame_%03d.png')} -vf "scale=512:512:force_original_aspect_ratio=decrease,pad=512:512:(ow-iw)/2:(oh-ih)/2:color=white" -c:v libx264 -pix_fmt yuv420p -t 2 ${outputVideo}`;
          
          await execAsync(ffmpegCmd);
          
          // Converter para webp animado
          const outputWebp = path.join(tempDir, 'output.webp');
          const webpCmd = `ffmpeg -i ${outputVideo} -vcodec libwebp -filter:v fps=fps=15 -lossless 0 -compression_level 6 -q:v 50 -loop 0 -preset picture -an -vsync 0 ${outputWebp}`;
          
          await execAsync(webpCmd);
          
          // Enviar sticker
          await sendSticker(nazu, from, {
            sticker: fs.readFileSync(outputWebp),
            author: `„Äé${pushname}„Äè\n„Äé${nomebot}„Äè\n„Äé${nomedono}„Äè\n„Äécognima.com.br„Äè`,
            packname: `üë§ Usuario(a)·ÆÄ€ü‚ùÅ'Ôø´\nü§ñ Bot·ÆÄ€ü‚ùÅ'Ôø´\nüëë Dono·ÆÄ€ü‚ùÅ'Ôø´\nüåê Site·ÆÄ€ü‚ùÅ'Ôø´`,
            type: 'image'
          }, {
            quoted: info
          });
          
          // Limpar arquivos tempor√°rios
          try {
            fs.rmSync(tempDir, { recursive: true, force: true });
          } catch (cleanupError) {
            console.error('Erro ao limpar arquivos tempor√°rios:', cleanupError);
          }
          
        } catch (e) {
          console.error(e);
          await reply("‚ùå Ocorreu um erro ao criar o sticker animado. Tente novamente em alguns minutos.");
        }
        break;
      case 'st':
      case 'stk':
      case 'sticker':
      case 's':
        try {
          var RSM = info.message?.extendedTextMessage?.contextInfo?.quotedMessage;
          var boij2 = RSM?.imageMessage || info.message?.imageMessage || RSM?.viewOnceMessageV2?.message?.imageMessage || info.message?.viewOnceMessageV2?.message?.imageMessage || info.message?.viewOnceMessage?.message?.imageMessage || RSM?.viewOnceMessage?.message?.imageMessage;
          var boij = RSM?.videoMessage || info.message?.videoMessage || RSM?.viewOnceMessageV2?.message?.videoMessage || info.message?.viewOnceMessageV2?.message?.videoMessage || info.message?.viewOnceMessage?.message?.videoMessage || RSM?.viewOnceMessage?.message?.videoMessage;
          if (!boij && !boij2) return reply(`Marque uma imagem ou um v√≠deo de at√© 9.9 segundos para fazer figurinha, com o comando: ${prefix + command} (mencionando a m√≠dia)`);
          var isVideo2 = !!boij;
          if (isVideo2 && boij.seconds > 9.9) return reply(`O v√≠deo precisa ter no m√°ximo 9.9 segundos para ser convertido em figurinha.`);
          var buffer = await getFileBuffer(isVideo2 ? boij : boij2, isVideo2 ? 'video' : 'image');
          await sendSticker(nazu, from, {
            sticker: buffer,
            author: `„Äé${pushname}„Äè\n„Äé${nomebot}„Äè\n„Äé${nomedono}„Äè\n„Äécognima.com.br„Äè`,
            packname: 'üë§ Usuario(a)·ÆÄ€ü‚ùÅ‚ÄôÔø´\nü§ñ Bot·ÆÄ€ü‚ùÅ‚ÄôÔø´\nüëë Dono·ÆÄ€ü‚ùÅ‚ÄôÔø´\nüåê Site·ÆÄ€ü‚ùÅ‚ÄôÔø´',
            type: isVideo2 ? 'video' : 'image',
            forceSquare: true
          }, {
            quoted: info
          });
        } catch (e) {
          console.error(e);
          await reply("‚ùå Ocorreu um erro interno. Tente novamente em alguns minutos.");
        }
        break;
      case 'st2':
      case 'stk2':
      case 'sticker2':
      case 's2':
        try {
          var RSM = info.message?.extendedTextMessage?.contextInfo?.quotedMessage;
          var boij2 = RSM?.imageMessage || info.message?.imageMessage || RSM?.viewOnceMessageV2?.message?.imageMessage || info.message?.viewOnceMessageV2?.message?.imageMessage || info.message?.viewOnceMessage?.message?.imageMessage || RSM?.viewOnceMessage?.message?.imageMessage;
          var boij = RSM?.videoMessage || info.message?.videoMessage || RSM?.viewOnceMessageV2?.message?.videoMessage || info.message?.viewOnceMessageV2?.message?.videoMessage || info.message?.viewOnceMessage?.message?.videoMessage || RSM?.viewOnceMessage?.message?.videoMessage;
          if (!boij && !boij2) return reply(`Marque uma imagem ou um v√≠deo de at√© 9.9 segundos para fazer figurinha, com o comando: ${prefix + command} (mencionando a m√≠dia)`);
          var isVideo2 = !!boij;
          if (isVideo2 && boij.seconds > 9.9) return reply(`O v√≠deo precisa ter no m√°ximo 9.9 segundos para ser convertido em figurinha.`);
          var buffer = await getFileBuffer(isVideo2 ? boij : boij2, isVideo2 ? 'video' : 'image');
          await sendSticker(nazu, from, {
            sticker: buffer,
            author: `„Äé${pushname}„Äè\n„Äé${nomebot}„Äè\n„Äé${nomedono}„Äè\n„Äécognima.com.br„Äè`,
            packname: 'üë§ Usuario(a)·ÆÄ€ü‚ùÅ‚ÄôÔø´\nü§ñ Bot·ÆÄ€ü‚ùÅ‚ÄôÔø´\nüëë Dono·ÆÄ€ü‚ùÅ‚ÄôÔø´\nüåê Site·ÆÄ€ü‚ùÅ‚ÄôÔø´',
            type: isVideo2 ? 'video' : 'image'
          }, {
            quoted: info
          });
        } catch (e) {
          console.error(e);
          await reply("‚ùå Ocorreu um erro interno. Tente novamente em alguns minutos.");
        }
        break;
      case 'figualeatoria':
      case 'randomsticker':
        try {
          await nazu.sendMessage(from, {
            sticker: {
              url: `https://raw.githubusercontent.com/badDevelopper/Testfigu/main/fig (${Math.floor(Math.random() * 8051)}).webp`
            }
          }, {
            quoted: info
          });
        } catch (e) {
          console.error(e);
          await reply("‚ùå Ocorreu um erro interno. Tente novamente em alguns minutos.");
        }
        break;
      case 'rename':
      case 'renomear':
      case 'mudarpack':
  try {
    if (!isQuotedSticker) return reply('Voc√™ usou de forma errada... Marque uma figurinha.');
    let author = "";
    let packname = "";
    if (!q) {
      return reply(`Formato errado, utilize:\n${prefix}${command} Autor/Pack\nEx: ${prefix}${command} By:/Hiudy`);
    }
    if (q.includes("/")) {
      author = q.split("/")[0] || "";
      packname = q.split("/")[1] || "";
    } else {
      packname = q;
      author = "";
    }
    if (!packname) {
      return reply(`Formato errado, utilize:\n${prefix}${command} Autor/Pack\nEx: ${prefix}${command} By:/Hiudy`);
    }
    const encmediats = await getFileBuffer(
      info.message.extendedTextMessage.contextInfo.quotedMessage.stickerMessage,
      'sticker'
    );
    await sendSticker(nazu, from, {
      sticker: `data:image/jpeg;base64,${encmediats.toString('base64')}`,
      author: packname,
      packname: author,
      rename: true
    }, {
      quoted: info
    });
  } catch (e) {
    console.error(e);
    await reply("‚ùå Ocorreu um erro interno. Tente novamente em alguns minutos.");
  }
  break;
      case 'rgtake':
  try {
    let author = "";
    let pack = "";
    if (!q) {
      return reply(`Formato errado, utilize:\n${prefix}${command} Autor/Pack\nEx: ${prefix}${command} By:/Hiudy`);
    }
    if (q.includes("/")) {
      author = q.split("/")[0] || "";
      pack = q.split("/")[1] || "";
    } else {
      pack = q;
      author = "";
    }
    if (!pack) {
      return reply(`Formato errado, utilize:\n${prefix}${command} Autor/Pack\nEx: ${prefix}${command} By:/Hiudy`);
    }
  const filePath = pathz.join(USERS_DIR, 'take.json');
    const dataTake = fs.existsSync(filePath) ? JSON.parse(fs.readFileSync(filePath, 'utf-8')) : {};
    dataTake[sender] = { author, pack };
    fs.writeFileSync(filePath, JSON.stringify(dataTake, null, 2), 'utf-8');
    reply(`Autor e pacote salvos com sucesso!\nAutor: ${author || "(vazio)"}\nPacote: ${pack}`);
  } catch (e) {
    console.error(e);
    await reply("‚ùå Ocorreu um erro interno. Tente novamente em alguns minutos.");
  }
  break;
      case 'take':
        try {
          if (!isQuotedSticker) return reply('Voc√™ usou de forma errada... Marque uma figurinha.');
          const filePath = pathz.join(USERS_DIR, 'take.json');
          if (!fs.existsSync(filePath)) return reply('Nenhum autor e pacote salvos. Use o comando *rgtake* primeiro.');
          const dataTake = JSON.parse(fs.readFileSync(filePath, 'utf-8'));
          if (!dataTake[sender]) return reply('Voc√™ n√£o tem autor e pacote salvos. Use o comando *rgtake* primeiro.');
          const {
            author,
            pack
          } = dataTake[sender];
          const encmediats = await getFileBuffer(info.message.extendedTextMessage.contextInfo.quotedMessage.stickerMessage, 'sticker');
          await sendSticker(nazu, from, {
            sticker: `data:image/jpeg;base64,${encmediats.toString('base64')}`,
            author: pack,
            packname: author,
            rename: true
          }, {
            quoted: info
          });
        } catch (e) {
          console.error(e);
          await reply("‚ùå Ocorreu um erro interno. Tente novamente em alguns minutos.");
        }
        break;

      case 'figurinhas':
      case 'stickerpack':
      case 'packfig':
        try {
          if (!q) return reply(`üé® *Gerador de Figurinhas*\n\nüî¢ *Como usar:*\n‚Ä¢ Escolha quantas figurinhas deseja (1-15)\n‚Ä¢ Ex: ${prefix}figurinhas 10\n‚Ä¢ Ex: ${prefix}figurinhas 5\n\n‚ú® As figurinhas ser√£o enviadas uma por uma!\n${isGroup ? 'üì¨ *Nota:* Em grupos, as figurinhas ser√£o enviadas no seu privado!' : ''}`);
          
          const quantidade = parseInt(q);
          
          if (isNaN(quantidade) || quantidade < 1 || quantidade > 15) {
            return reply('‚ùå N√∫mero inv√°lido! Escolha entre 1 e 15 figurinhas.');
          }
          
          // Destino: PV se for grupo, ou o pr√≥prio chat se for PV
          const destino = isGroup ? sender : from;
          
          if (isGroup) {
            await reply(`üì¨ Enviando ${quantidade} figurinha${quantidade > 1 ? 's' : ''} no seu privado...\n‚è≥ Aguarde um momento!`);
          } else {
            await reply(`üé® Enviando ${quantidade} figurinha${quantidade > 1 ? 's' : ''}...\n‚è≥ Aguarde um momento!`);
          }
          
          const usedNumbers = new Set();
          let successCount = 0;
          let failCount = 0;
          
          for (let i = 0; i < quantidade; i++) {
            try {
              // Gerar n√∫mero √∫nico
              let randomNum;
              do {
                randomNum = Math.floor(Math.random() * 8051);
              } while (usedNumbers.has(randomNum));
              
              usedNumbers.add(randomNum);
              
              // Buscar a figurinha
              const stickerUrl = `https://raw.githubusercontent.com/badDevelopper/Testfigu/main/fig (${randomNum}).webp`;
              const stickerResponse = await axios.get(stickerUrl, {
                responseType: 'arraybuffer',
                timeout: 120000
              });
              
              const stickerBuffer = Buffer.from(stickerResponse.data);
              
              // Enviar figurinha
              await nazu.sendMessage(destino, {
                sticker: stickerBuffer
              });
              
              successCount++;
              
              // Pequeno delay para n√£o sobrecarregar
              await new Promise(resolve => setTimeout(resolve, 800));
              
            } catch (stickerError) {
              console.error(`Erro ao enviar figurinha ${i + 1}:`, stickerError.message);
              failCount++;
            }
          }
          
          // Mensagem final
          const finalMsg = `‚úÖ Pronto!\n\nüìä *Resultado:*\n‚Ä¢ Enviadas: ${successCount} figurinha${successCount !== 1 ? 's' : ''}\n${failCount > 0 ? `‚Ä¢ Falhas: ${failCount}\n` : ''}`;
          
          await nazu.sendMessage(destino, {
            text: finalMsg
          });
          
        } catch (e) {
          console.error('Erro no comando figurinhas:', e);
          await reply("üêù Oh n√£o! Aconteceu um errinho ao enviar as figurinhas. Tente de novo daqui a pouquinho, por favor! ü•∫");
        }
        break;

      case 'mention':
        try {
          if (!isGroup) return reply("isso so pode ser usado em grupo üíî");
          if (!q) return reply(`üì¢ *Configura√ß√£o de Marca√ß√µes*\n\nüîß Escolha como deseja ser mencionado:\n\n‚úÖ *${prefix}mention all* ‚Üí Marcado em tudo (marca√ß√µes e jogos).\nüì¢ *${prefix}mention marca* ‚Üí Apenas em marca√ß√µes de administradores.\nüéÆ *${prefix}mention games* ‚Üí Somente em jogos do bot.\nüö´ *${prefix}mention 0* ‚Üí N√£o ser√° mencionado em nenhuma ocasi√£o.`);
          let options = {
            all: '‚ú® Voc√™ agora ser√° mencionado em todas as intera√ß√µes do bot, incluindo marca√ß√µes de administradores e os jogos!',
            marca: 'üì¢ A partir de agora, voc√™ ser√° mencionado apenas quando um administrador marcar.',
            games: 'üéÆ Voc√™ optou por ser mencionado somente em jogos do bot.',
            0: 'üîï Sil√™ncio ativado! Voc√™ n√£o ser√° mais mencionado pelo bot, nem em marca√ß√µes nem em jogos.'
          };
          if (options[q.toLowerCase()] !== undefined) {
            if (!groupData.mark) {
              groupData.mark = {};
            }
            groupData.mark[sender] = q.toLowerCase();
            fs.writeFileSync(buildGroupFilePath(from), JSON.stringify(groupData, null, 2));
            return reply(`*${options[q.toLowerCase()]}*`);
          }
          reply(`‚ùå Op√ß√£o inv√°lida! Use *${prefix}mention* para ver as op√ß√µes.`);
        } catch (e) {
          console.error(e);
          reply("ocorreu um erro üíî");
        }
        break;
      case 'deletar':
      case 'delete':
      case 'del':
      case 'd':
        if (!isGroupAdmin) return reply("Comando restrito a Administradores ou Moderadores com permiss√£o. üíî");
        if (!menc_prt) return reply("Marque uma mensagem.");
        let stanzaId, participant;
        if (info.message.extendedTextMessage) {
          stanzaId = info.message.extendedTextMessage.contextInfo.stanzaId;
          participant = info.message.extendedTextMessage.contextInfo.participant || menc_prt;
        } else if (info.message.viewOnceMessage) {
          stanzaId = info.key.id;
          participant = info.key.participant || menc_prt;
        }
        try {
          await nazu.sendMessage(from, {
            delete: {
              remoteJid: from,
              fromMe: false,
              id: stanzaId,
              participant: participant
            }
          });
        } catch (error) {
          reply("ocorreu um erro üíî");
        }
        break;
      case 'blockuser':
        if (!isGroup) return reply("isso so pode ser usado em grupo üíî");
        if (!isGroupAdmin) return reply("voc√™ precisa ser adm üíî");
        try {
          if (!menc_os2) return reply("Marque algu√©m üôÑ");
          var reason;
          reason = q ? q.includes('@') ? q.includes(' ') ? q.split(' ').slice(1).join(' ') : "N√£o informado" : q : 'N√£o informado';
          var menc_os3;
          menc_os3 = (menc_os2 && menc_os2.includes(' ')) ? menc_os2.split(' ')[0] : menc_os2;
          if (!menc_os3) return reply("Erro ao processar usu√°rio mencionado");
          groupData.blockedUsers = groupData.blockedUsers || {};
          groupData.blockedUsers[menc_os3] = {
            reason,
            timestamp: Date.now()
          };
          fs.writeFileSync(groupFile, JSON.stringify(groupData, null, 2));
          await reply(`‚úÖ Usu√°rio @${getUserName(menc_os3)} bloqueado no grupo!\nMotivo: ${reason}`, {
            mentions: [menc_os3]
          });
        } catch (e) {
          console.error(e);
          await reply("‚ùå Ocorreu um erro interno. Tente novamente em alguns minutos.");
        }
        break;
      case 'unblockuser':
        if (!isGroup) return reply("isso so pode ser usado em grupo üíî");
        if (!isGroupAdmin) return reply("voc√™ precisa ser adm üíî");
        try {
          if (!menc_os2) return reply("Marque algu√©m üôÑ");
          if (!groupData.blockedUsers) {
            return reply(`‚ÑπÔ∏è N√£o h√° usu√°rios bloqueados neste grupo.`);
          }
          const userToUnblock = groupData.blockedUsers[menc_os2] ? menc_os2 :
                               groupData.blockedUsers[getUserName(menc_os2)] ? getUserName(menc_os2) : null;
          if (!userToUnblock) {
            return reply(`‚ùå O usu√°rio @${getUserName(menc_os2)} n√£o est√° bloqueado no grupo!`, {
              mentions: [menc_os2]
            });
          }
          delete groupData.blockedUsers[userToUnblock];
          fs.writeFileSync(groupFile, JSON.stringify(groupData, null, 2));
          await reply(`‚úÖ Usu√°rio @${getUserName(menc_os2)} desbloqueado no grupo!`, {
            mentions: [menc_os2]
          });
        } catch (e) {
          console.error(e);
          await reply("‚ùå Ocorreu um erro interno. Tente novamente em alguns minutos.");
        }
        break;
      case 'listblocksgp':
      case 'blocklist':
        if (!isGroup) return reply("isso so pode ser usado em grupo üíî");
        if (!isGroupAdmin) return reply("voc√™ precisa ser adm üíî");
        try {
          const blockedUsers = groupData.blockedUsers ? Object.entries(groupData.blockedUsers).map(([user, data]) => `üë§ *${getUserName(user)}* - Motivo: ${data.reason}`).join('\n') : 'Nenhum usu√°rio bloqueado no grupo.';
          const message = `üîí *Usu√°rios Bloqueados no Grupo - ${groupName}* üîí\n\n${blockedUsers}`;
          await reply(message);
        } catch (e) {
          console.error(e);
          await reply("‚ùå Ocorreu um erro interno. Tente novamente em alguns minutos.");
        }
        break;
      case 'banir':
      case 'ban':
      case 'b':
      case 'kick':
        try {
          if (!isGroup) return reply("isso so pode ser usado em grupo üíî");
          if (!isGroupAdmin) return reply("Comando restrito a Administradores ou Moderadores com permiss√£o. üíî");
          if (!isBotAdmin) return reply("Eu preciso ser adm üíî");
          if (!menc_os2) return reply("Marque algu√©m üôÑ");
          if (menc_os2 === nmrdn) return reply("‚ùå N√£o posso banir o dono do bot.");
          if (menc_os2 === botNumber) return reply("‚ùå Ops! Eu fa√ßo parte da bagun√ßa, n√£o d√° pra me remover üíî");
          await nazu.groupParticipantsUpdate(from, [menc_os2], 'remove');
          
          // Notifica√ß√£o X9 para banimento
          if (groupData.x9) {
            const reason = q && q.length > 0 ? `\nüìù Motivo: ${q}` : '';
            await nazu.sendMessage(from, {
              text: `üö™ *X9 Report:* @${menc_os2.split('@')[0]} foi removido(a) do grupo por @${sender.split('@')[0]}.${reason}`,
              mentions: [menc_os2, sender],
            }).catch(err => console.error(`‚ùå Erro ao enviar X9: ${err.message}`));
          }
          
          reply(`‚úÖ Usu√°rio banido com sucesso!${q && q.length > 0 ? '\n\nMotivo: ' + q : ''}`);
        } catch (e) {
          console.error(e);
          reply("ocorreu um erro üíî");
        }
        break;

      case 'ban2':
      case 'banir2':
        try {
          if (!isGroup) return reply("isso so pode ser usado em grupo üíî");
          if (!isGroupAdmin) return reply("Comando restrito a Administradores ou Moderadores com permiss√£o. üíî");
          if (!isBotAdmin) return reply("Eu preciso ser adm üíî");
          if (!menc_os2) return reply("Marque algu√©m üôÑ");
          if (menc_os2 === nmrdn) return reply("‚ùå N√£o posso banir o dono do bot.");
          if (menc_os2 === botNumber) return reply("‚ùå Ops! Eu fa√ßo parte da bagun√ßa, n√£o d√° pra me remover üíî");
          
          // Aviso com contagem regressiva
          await nazu.sendMessage(from, {
            text: `‚ö†Ô∏è *√öLTIMAS PALAVRAS!*\n\n@${menc_os2.split('@')[0]}, voc√™ tem *10 segundos* para dizer suas √∫ltimas palavras antes de ser banido! ‚è∞`,
            mentions: [menc_os2]
          });
          
          // Aguarda 10 segundos
          await new Promise(resolve => setTimeout(resolve, 10000));
          
          // Remove o usu√°rio
          await nazu.groupParticipantsUpdate(from, [menc_os2], 'remove');
          
          // Notifica√ß√£o X9 para banimento
          if (groupData.x9) {
            const reason = q && q.length > 0 ? `\nüìù Motivo: ${q}` : '';
            await nazu.sendMessage(from, {
              text: `üö™ *X9 Report:* @${menc_os2.split('@')[0]} foi removido(a) do grupo por @${sender.split('@')[0]}.${reason}`,
              mentions: [menc_os2, sender],
            }).catch(err => console.error(`‚ùå Erro ao enviar X9: ${err.message}`));
          }
          
          await nazu.sendMessage(from, {
            text: `üëã @${menc_os2.split('@')[0]} foi banido! Adeus! üö™${q && q.length > 0 ? '\n\nüìù Motivo: ' + q : ''}`,
            mentions: [menc_os2]
          });
        } catch (e) {
          console.error(e);
          reply("ocorreu um erro üíî");
        }
        break;

      case 'bam':
      case 'banfake':
        if (!isGroup) return reply("isso so pode ser usado em grupo üíî");
        if (!isGroupAdmin) return reply("Comando restrito a Administradores ou Moderadores com permiss√£o. üíî");
        if (!menc_os2) return reply("Marque algu√©m üôÑ");
        if (menc_os2 === nmrdn) return reply("‚ùå N√£o posso banir o dono do bot.");
        if (menc_os2 === botNumber) return reply("‚ùå Ops! Eu fa√ßo parte da bagun√ßa, n√£o d√° pra me remover üíî");
        
        try {
          await nazu.sendMessage(from, {
            text: `‚ö†Ô∏è *√öLTIMAS PALAVRAS!*\n\n@${menc_os2.split('@')[0]}, voc√™ tem *10 segundos* para dizer suas √∫ltimas palavras antes de ser banido! ‚è∞`,
            mentions: [menc_os2]
          });
          
          await new Promise(resolve => setTimeout(resolve, 10000));
          
          const defaultMemeMsg = `üòÇ *ERA MEME!*\n\n@${menc_os2.split('@')[0]}, relaxa, era s√≥ uma brincadeira! ü§£\n\nVoc√™ n√£o vai ser banido... dessa vez! üòé`;
          const customMemeMsg = groupData.bamMessage || defaultMemeMsg;
          
          await nazu.sendMessage(from, {
            text: customMemeMsg.replace(/#user#/g, `@${menc_os2.split('@')[0]}`),
            mentions: [menc_os2]
          });
        } catch (e) {
          console.error('Erro no bam:', e);
          reply("ocorreu um erro üíî");
        }
        break;

      case 'setbammsg':
      case 'editarbam':
        if (!isGroup) return reply("isso so pode ser usado em grupo üíî");
        if (!isGroupAdmin) return reply("Comando restrito a Administradores üíî");
        
        if (!q) {
          return reply(`üìù *Configurar Mensagem do Bam*\n\nUse: ${prefix}setbammsg <mensagem>\n\n*Vari√°vel dispon√≠vel:*\n#user# - Ser√° substitu√≠do pelo nome do usu√°rio\n\n*Exemplo:*\n${prefix}setbammsg üòÇ Era s√≥ uma pegadinha #user#!\n\nPara ver a mensagem atual: ${prefix}verbammsg\nPara resetar: ${prefix}resetbammsg`);
        }
        
        try {
          groupData.bamMessage = q;
          persistGroupData();
          await reply(`‚úÖ *Mensagem do bam configurada!*\n\nüìù Nova mensagem:\n${q}\n\nüí° Use #user# para mencionar o usu√°rio marcado.`);
        } catch (e) {
          console.error('Erro no setbammsg:', e);
          reply("ocorreu um erro üíî");
        }
        break;

      case 'verbammsg':
      case 'verbam':
        if (!isGroup) return reply("isso so pode ser usado em grupo üíî");
        
        try {
          const defaultMsg = `üòÇ *ERA MEME!*\n\n#user#, relaxa, era s√≥ uma brincadeira! ü§£\n\nVoc√™ n√£o vai ser banido... dessa vez! üòé`;
          const currentMsg = groupData.bamMessage || defaultMsg;
          await reply(`üìù *Mensagem Atual do Bam:*\n\n${currentMsg}\n\n${!groupData.bamMessage ? '‚ö†Ô∏è Usando mensagem padr√£o\n\n' : ''}Para editar: ${prefix}setbammsg <nova_mensagem>`);
        } catch (e) {
          console.error('Erro no verbammsg:', e);
          reply("ocorreu um erro üíî");
        }
        break;

      case 'resetbammsg':
      case 'resetarbam':
        if (!isGroup) return reply("isso so pode ser usado em grupo üíî");
        if (!isGroupAdmin) return reply("Comando restrito a Administradores üíî");
        
        try {
          delete groupData.bamMessage;
          persistGroupData();
          await reply(`‚úÖ Mensagem do bam resetada para o padr√£o!\n\nUse ${prefix}verbammsg para ver a mensagem padr√£o.`);
        } catch (e) {
          console.error('Erro no resetbammsg:', e);
          reply("ocorreu um erro üíî");
        }
        break;

      case 'linkgp':
      case 'linkgroup':
        try {
          if (!isGroup) return reply("isso so pode ser usado em grupo üíî");
          if (!isGroupAdmin) return reply("Comando restrito a Administradores ou Moderadores com permiss√£o. üíî");
          if (!isBotAdmin) return reply("Eu preciso ser adm üíî");
          var linkgc;
          linkgc = await nazu.groupInviteCode(from);
          await reply('https://chat.whatsapp.com/' + linkgc);
        } catch (e) {
          console.error(e);
          await reply("‚ùå Ocorreu um erro interno. Tente novamente em alguns minutos.");
        }
        break;
      case 'solicitacoes':
      case 'pendentes':
      case 'requests':
        try {
          if (!isGroup) return reply("Isso s√≥ pode ser usado em grupo üíî");
          if (!isGroupAdmin) return reply("Comando restrito a Administradores üíî");
          if (!isBotAdmin) return reply("Eu preciso ser adm üíî");
          
          // Fun√ß√£o para obter solicita√ß√µes pendentes (compat√≠vel com vers√µes antigas do Baileys)
          let requests = [];
          try {
            // Tenta o m√©todo padr√£o se existir
            if (typeof nazu.groupGetRequestParticipants === 'function') {
              requests = await nazu.groupGetRequestParticipants(from);
            } else if (typeof nazu.groupRequestParticipantsList === 'function') {
              requests = await nazu.groupRequestParticipantsList(from);
            } else {
              // Fallback: fazer a query manualmente
              const result = await nazu.query({
                tag: 'iq',
                attrs: {
                  type: 'get',
                  xmlns: 'w:g2',
                  to: from
                },
                content: [{ tag: 'membership_approval_requests', attrs: {} }]
              });
              
              // Extrair participantes do resultado
              const requestsNode = result?.content?.find(n => n.tag === 'membership_approval_requests');
              if (requestsNode && requestsNode.content) {
                requests = requestsNode.content
                  .filter(n => n.tag === 'membership_approval_request')
                  .map(n => ({ jid: n.attrs.jid }));
              }
            }
          } catch (queryErr) {
            console.error('Erro ao buscar solicita√ß√µes:', queryErr);
            return reply('‚ùå Este recurso n√£o est√° dispon√≠vel na vers√£o atual do WhatsApp ou n√£o h√° solicita√ß√µes pendentes.');
          }
          
          if (!requests || requests.length === 0) {
            return reply('üì≠ N√£o h√° solicita√ß√µes pendentes neste grupo.');
          }
          
          let msg = `üì® *Solicita√ß√µes Pendentes* (${requests.length})\n\n`;
          requests.forEach((req, index) => {
            const number = req.jid.split('@')[0];
            msg += `${index + 1}. @${number}\n`;
          });
          msg += `\nüí° Comandos dispon√≠veis:\n`;
          msg += `‚Ä¢ ${prefix}aprovar @usuario - Aceitar uma solicita√ß√£o\n`;
          msg += `‚Ä¢ ${prefix}aprovar all - Aceitar TODAS\n`;
          msg += `‚Ä¢ ${prefix}recusarsolic @usuario - Recusar solicita√ß√£o`;
          
          await reply(msg, { mentions: requests.map(r => r.jid) });
        } catch (e) {
          console.error(e);
          await reply("‚ùå Erro ao buscar solicita√ß√µes. Verifique se h√° solicita√ß√µes pendentes.");
        }
        break;
      case 'aprovar':
      case 'aceitar':
      case 'approve':
        try {
          if (!isGroup) return reply("Isso s√≥ pode ser usado em grupo üíî");
          if (!isGroupAdmin) return reply("Comando restrito a Administradores üíî");
          if (!isBotAdmin) return reply("Eu preciso ser adm üíî");
          
          // Verificar se √© "all" para aceitar todos
          if (q && q.toLowerCase().trim() === 'all') {
            // Fun√ß√£o para obter solicita√ß√µes pendentes (compat√≠vel com vers√µes antigas do Baileys)
            let allRequests = [];
            try {
              if (typeof nazu.groupGetRequestParticipants === 'function') {
                allRequests = await nazu.groupGetRequestParticipants(from);
              } else if (typeof nazu.groupRequestParticipantsList === 'function') {
                allRequests = await nazu.groupRequestParticipantsList(from);
              } else {
                const result = await nazu.query({
                  tag: 'iq',
                  attrs: { type: 'get', xmlns: 'w:g2', to: from },
                  content: [{ tag: 'membership_approval_requests', attrs: {} }]
                });
                const requestsNode = result?.content?.find(n => n.tag === 'membership_approval_requests');
                if (requestsNode && requestsNode.content) {
                  allRequests = requestsNode.content
                    .filter(n => n.tag === 'membership_approval_request')
                    .map(n => ({ jid: n.attrs.jid }));
                }
              }
            } catch (queryErr) {
              console.error('Erro ao buscar solicita√ß√µes:', queryErr);
              return reply('‚ùå Erro ao buscar solicita√ß√µes pendentes.');
            }
            
            if (!allRequests || allRequests.length === 0) {
              return reply('üì≠ N√£o h√° solicita√ß√µes pendentes para aprovar.');
            }
            
            const approved = [];
            const failed = [];
            
            for (const req of allRequests) {
              try {
                await nazu.groupRequestParticipantsUpdate(from, [req.jid], 'approve');
                approved.push(req.jid);
              } catch (err) {
                failed.push(req.jid);
                console.error(`Erro ao aprovar ${req.jid}:`, err);
              }
            }
            
            // Notifica√ß√£o X9 para aprova√ß√£o em massa
            if (groupData.x9 && approved.length > 0) {
              await nazu.sendMessage(from, {
                text: `‚úÖ *X9 Report:* ${approved.length} solicita√ß√µes foram aprovadas em massa por @${sender.split('@')[0]}.`,
                mentions: [sender],
              }).catch(err => console.error(`‚ùå Erro ao enviar X9: ${err.message}`));
            }
            
            let responseMsg = `‚úÖ *Aprova√ß√£o em Massa Conclu√≠da!*\n\n`;
            responseMsg += `‚úÖ Aprovados: ${approved.length}\n`;
            if (failed.length > 0) responseMsg += `‚ùå Falhas: ${failed.length}\n`;
            
            return reply(responseMsg);
          }
          
          if (!menc_jid2 || menc_jid2.length === 0) {
            return reply(`‚ùå Marque algu√©m ou use "all" para aprovar todos.\n\nüí° Exemplos:\n‚Ä¢ ${prefix}aprovar @usuario\n‚Ä¢ ${prefix}aprovar all\n\nUse ${prefix}solicitacoes para ver pendentes.`);
          }
          
          const usersToApprove = menc_jid2;
          const approved = [];
          const failed = [];
          
          for (const user of usersToApprove) {
            try {
              await nazu.groupRequestParticipantsUpdate(from, [user], 'approve');
              approved.push(user);
              
              // Notifica√ß√£o X9 para aprova√ß√£o de solicita√ß√£o
              if (groupData.x9) {
                await nazu.sendMessage(from, {
                  text: `‚úÖ *X9 Report:* Solicita√ß√£o de @${user.split('@')[0]} foi aprovada por @${sender.split('@')[0]}.`,
                  mentions: [user, sender],
                }).catch(err => console.error(`‚ùå Erro ao enviar X9: ${err.message}`));
              }
            } catch (err) {
              failed.push(user);
              console.error(`Erro ao aprovar ${user}:`, err);
            }
          }
          
          let responseMsg = '';
          if (approved.length > 0) {
            responseMsg += `‚úÖ *Solicita√ß√µes aprovadas:* (${approved.length})\n`;
            approved.forEach(u => responseMsg += `‚Ä¢ @${u.split('@')[0]}\n`);
          }
          if (failed.length > 0) {
            responseMsg += `\n‚ùå *Falhas:* (${failed.length})\n`;
            failed.forEach(u => responseMsg += `‚Ä¢ @${u.split('@')[0]}\n`);
          }
          
          await reply(responseMsg, { mentions: [...approved, ...failed] });
        } catch (e) {
          console.error(e);
          await reply("‚ùå Erro ao aprovar solicita√ß√µes.");
        }
        break;
      case 'recusarsolic':
      case 'recusarsolicitacao':
      case 'reject':
        try {
          if (!isGroup) return reply("Isso s√≥ pode ser usado em grupo üíî");
          if (!isGroupAdmin) return reply("Comando restrito a Administradores üíî");
          if (!isBotAdmin) return reply("Eu preciso ser adm üíî");
          
          if (!menc_jid2 || menc_jid2.length === 0) {
            return reply(`‚ùå Marque algu√©m ou mencione n√∫meros.\n\nüí° Exemplo: ${prefix}recusarsolic @usuario\n\nUse ${prefix}solicitacoes para ver pendentes.`);
          }
          
          const usersToReject = menc_jid2;
          const rejected = [];
          const failed = [];
          
          for (const user of usersToReject) {
            try {
              await nazu.groupRequestParticipantsUpdate(from, [user], 'reject');
              rejected.push(user);
              
              // Notifica√ß√£o X9 para recusa de solicita√ß√£o
              if (groupData.x9) {
                await nazu.sendMessage(from, {
                  text: `‚ùå *X9 Report:* Solicita√ß√£o de @${user.split('@')[0]} foi recusada por @${sender.split('@')[0]}.`,
                  mentions: [user, sender],
                }).catch(err => console.error(`‚ùå Erro ao enviar X9: ${err.message}`));
              }
            } catch (err) {
              failed.push(user);
              console.error(`Erro ao recusar ${user}:`, err);
            }
          }
          
          let responseMsg = '';
          if (rejected.length > 0) {
            responseMsg += `‚ùå *Solicita√ß√µes recusadas:* (${rejected.length})\n`;
            rejected.forEach(u => responseMsg += `‚Ä¢ @${u.split('@')[0]}\n`);
          }
          if (failed.length > 0) {
            responseMsg += `\n‚ö†Ô∏è *Falhas:* (${failed.length})\n`;
            failed.forEach(u => responseMsg += `‚Ä¢ @${u.split('@')[0]}\n`);
          }
          
          await reply(responseMsg, { mentions: [...rejected, ...failed] });
        } catch (e) {
          console.error(e);
          await reply("‚ùå Erro ao recusar solicita√ß√µes.");
        }
        break;
      case 'autoaceitarsolic':
      case 'autoaprovar':
      case 'autoacceptr':
        try {
          if (!isGroup) return reply("Isso s√≥ pode ser usado em grupo üíî");
          if (!isGroupAdmin) return reply("Comando restrito a Administradores üíî");
          
          groupData.autoAcceptRequests = !groupData.autoAcceptRequests;
          fs.writeFileSync(groupFile, JSON.stringify(groupData, null, 2));
          
          const status = groupData.autoAcceptRequests ? 'ativado' : 'desativado';
          const emoji = groupData.autoAcceptRequests ? '‚úÖ' : '‚ùå';
          
          let msg = `${emoji} *Auto-Aceitar Solicita√ß√µes ${status}!*\n\n`;
          
          if (groupData.autoAcceptRequests) {
            msg += `ü§ñ O bot agora ir√° aprovar automaticamente todas as solicita√ß√µes de entrada no grupo.\n\n`;
            if (groupData.captchaEnabled) {
              msg += `üîê *Captcha ativo:* Novos membros precisar√£o resolver uma conta no PV antes de serem aceitos.\n\n`;
            } else {
              msg += `üí° Quer adicionar seguran√ßa? Use ${prefix}captchasolic para ativar verifica√ß√£o por captcha.\n\n`;
            }
          } else {
            msg += `üìù Solicita√ß√µes precisar√£o ser aprovadas manualmente pelos administradores.`;
          }
          
          await reply(msg);
        } catch (e) {
          console.error(e);
          await reply("‚ùå Ocorreu um erro ao configurar auto-aceitar.");
        }
        break;
      case 'captchasolic':
      case 'captcha':
      case 'captcharequests':
        try {
          if (!isGroup) return reply("Isso s√≥ pode ser usado em grupo üíî");
          if (!isGroupAdmin) return reply("Comando restrito a Administradores üíî");
          
          groupData.captchaEnabled = !groupData.captchaEnabled;
          fs.writeFileSync(groupFile, JSON.stringify(groupData, null, 2));
          
          const status = groupData.captchaEnabled ? 'ativado' : 'desativado';
          const emoji = groupData.captchaEnabled ? 'üîê' : '‚ùå';
          
          let msg = `${emoji} *Captcha para Solicita√ß√µes ${status}!*\n\n`;
          
          if (groupData.captchaEnabled) {
            msg += `üîí Quando algu√©m solicitar entrar no grupo:\n`;
            msg += `1Ô∏è‚É£ Receber√° uma conta matem√°tica no PV\n`;
            msg += `2Ô∏è‚É£ Ter√° 5 minutos para responder\n`;
            msg += `3Ô∏è‚É£ Se acertar, ser√° aprovado\n`;
            msg += `4Ô∏è‚É£ Se errar ou n√£o responder, ser√° recusado\n\n`;
            
            if (!groupData.autoAcceptRequests) {
              msg += `‚ö†Ô∏è *Aten√ß√£o:* Para o captcha funcionar automaticamente, ative tamb√©m:\n${prefix}autoaceitarsolic`;
            } else {
              msg += `‚úÖ Auto-aceitar j√° est√° ativo! O captcha ser√° usado automaticamente.`;
            }
          } else {
            msg += `üìù Captcha desativado. ${groupData.autoAcceptRequests ? 'Solicita√ß√µes ser√£o aprovadas automaticamente sem verifica√ß√£o.' : 'Solicita√ß√µes precisar√£o ser aprovadas manualmente.'}`;
          }
          
          await reply(msg);
        } catch (e) {
          console.error(e);
          await reply("‚ùå Ocorreu um erro ao configurar captcha.");
        }
        break;
      case 'promover':
      case 'promote':
        try {
          if (!isGroup) return reply("isso so pode ser usado em grupo üíî");
          if (!isGroupAdmin) return reply("Comando restrito a Administradores ou Moderadores com permiss√£o. üíî");
          if (!isBotAdmin) return reply("Eu preciso ser adm üíî");
          if (!menc_os2) return reply("Marque algu√©m üôÑ");
          await nazu.groupParticipantsUpdate(from, [menc_os2], 'promote');
          
          // Notifica√ß√£o X9 para promo√ß√£o
          if (groupData.x9) {
            await nazu.sendMessage(from, {
              text: `‚¨ÜÔ∏è *X9 Report:* @${menc_os2.split('@')[0]} foi promovido(a) a ADM por @${sender.split('@')[0]}.`,
              mentions: [menc_os2, sender],
            }).catch(err => console.error(`‚ùå Erro ao enviar X9: ${err.message}`));
          }
          
          reply(`‚úÖ Usu√°rio promovido a administrador!`);
        } catch (e) {
          console.error(e);
          reply("ocorreu um erro üíî");
        }
        break;
      case 'rebaixar':
      case 'demote':
        try {
          if (!isGroup) return reply("isso so pode ser usado em grupo üíî");
          if (!isGroupAdmin) return reply("Comando restrito a Administradores ou Moderadores com permiss√£o. üíî");
          if (!isBotAdmin) return reply("Eu preciso ser adm üíî");
          if (!menc_os2) return reply("Marque algu√©m üôÑ");
          await nazu.groupParticipantsUpdate(from, [menc_os2], 'demote');
          
          // Notifica√ß√£o X9 para rebaixamento
          if (groupData.x9) {
            await nazu.sendMessage(from, {
              text: `‚¨áÔ∏è *X9 Report:* @${menc_os2.split('@')[0]} foi rebaixado(a) de ADM por @${sender.split('@')[0]}.`,
              mentions: [menc_os2, sender],
            }).catch(err => console.error(`‚ùå Erro ao enviar X9: ${err.message}`));
          }
          
          reply(`‚úÖ Usu√°rio rebaixado com sucesso!`);
        } catch (e) { 
          console.error(e);
          reply("ocorreu um erro üíî");
        }
        break;
      case 'setname':
      case 'nomegp':
      case 'mudarnome':
      case 'alterarnome':
      case 'renomeargrupo':
        try {
          if (!isGroup) return reply("isso so pode ser usado em grupo üíî");
          if (!isGroupAdmin) return reply("Comando restrito a Administradores ou Moderadores com permiss√£o. üíî");
          if (!isBotAdmin) return reply("Eu preciso ser adm üíî");
          const newName = q.trim();
          if (!newName) return reply('‚ùå Digite um novo nome para o grupo.\n\nüìù *Uso:* ' + groupPrefix + 'nomegp Nome do Grupo');
          
          const oldName = groupMetadata?.subject || 'Nome anterior';
          await nazu.groupUpdateSubject(from, newName);
          
          // Notifica√ß√£o X9 para mudan√ßa de nome
          if (groupData.x9) {
            await nazu.sendMessage(from, {
              text: `‚úèÔ∏è *X9 Report:* Nome do grupo alterado por @${sender.split('@')[0]}\n\nüîπ Anterior: *${oldName}*\nüî∏ Novo: *${newName}*`,
              mentions: [sender],
            }).catch(err => console.error(`‚ùå Erro ao enviar X9: ${err.message}`));
          }
          
          reply(`‚úÖ Nome do grupo alterado para: *${newName}*`);
        } catch (e) {
          console.error(e);
          reply("ocorreu um erro üíî");
        }
        break;
      case 'setdesc':
      case 'descgrupo':
      case 'mudardesc':
      case 'alterardesc':
      case 'descricao':
        try {
          if (!isGroup) return reply("isso so pode ser usado em grupo üíî");
          if (!isGroupAdmin) return reply("Comando restrito a Administradores ou Moderadores com permiss√£o. üíî");
          if (!isBotAdmin) return reply("Eu preciso ser adm üíî");
          const newDesc = q.trim();
          if (!newDesc) return reply('‚ùå Digite uma nova descri√ß√£o para o grupo.\n\nüìù *Uso:* ' + groupPrefix + 'descgrupo Descri√ß√£o do grupo aqui');
          await nazu.groupUpdateDescription(from, newDesc);
          
          // Notifica√ß√£o X9 para mudan√ßa de descri√ß√£o
          if (groupData.x9) {
            await nazu.sendMessage(from, {
              text: `üìù *X9 Report:* Descri√ß√£o do grupo alterada por @${sender.split('@')[0]}`,
              mentions: [sender],
            }).catch(err => console.error(`‚ùå Erro ao enviar X9: ${err.message}`));
          }
          
          reply(`‚úÖ Descri√ß√£o do grupo alterada!`);
        } catch (e) {
          console.error(e);
          reply("ocorreu um erro üíî");
        }
        break;
      case 'setfoto':
      case 'fotogrupo':
      case 'mudarfoto':
      case 'alterarfoto':
      case 'fotogp':
        try {
          if (!isGroup) return reply("isso so pode ser usado em grupo üíî");
          if (!isGroupAdmin) return reply("Comando restrito a Administradores ou Moderadores com permiss√£o. üíî");
          if (!isBotAdmin) return reply("Eu preciso ser adm üíî");
          if (!isQuotedImage && !isImage) return reply('‚ùå Envie ou marque uma imagem para definir como foto do grupo.\n\nüìù *Uso:* Envie uma imagem com o comando ou responda uma imagem com ' + groupPrefix + 'fotogrupo');
          
          const messageToUse = isQuotedImage ? quotedMessageContent : info.message;
          const mediaInfo = getMediaInfo(messageToUse);
          if (!mediaInfo || mediaInfo.type !== 'image') return reply('‚ùå M√≠dia inv√°lida. Envie uma imagem.');
          
          const imageBuffer = await getFileBuffer(mediaInfo.media, 'image');
          
          try {
            // Processa a imagem com ffmpeg antes de atualizar
            const processedBuffer = await processImageForProfile(imageBuffer);
            await nazu.updateProfilePicture(from, processedBuffer);
            
            // Notifica√ß√£o X9 para mudan√ßa de foto
            if (groupData.x9) {
              await nazu.sendMessage(from, {
                text: `üì∏ *X9 Report:* Foto do grupo alterada por @${sender.split('@')[0]}`,
                mentions: [sender],
              }).catch(err => console.error(`‚ùå Erro ao enviar X9: ${err.message}`));
            }
            
            reply('‚úÖ Foto do grupo alterada com sucesso!');
          } catch (updateError) {
            console.error('Erro ao alterar foto do grupo:', updateError);
            reply('‚ùå Ocorreu um erro ao alterar a foto do grupo. Verifique se o ffmpeg est√° instalado e a imagem √© v√°lida.');
          }
        } catch (e) {
          console.error('Erro no comando fotogrupo:', e);
          reply("‚ùå Ocorreu um erro ao alterar a foto do grupo üíî");
        }
        break;
      case 'marcar':
      case 'mark':
        if (!isGroup) return reply("isso so pode ser usado em grupo üíî");
        if (!isGroupAdmin) return reply("Comando restrito a Administradores ou Moderadores com permiss√£o. üíî");
        if (!isBotAdmin) return reply("Eu preciso ser adm üíî");
        try {
          // Prote√ß√£o Anti-Ban: Verifica rate limit para grupos grandes
          const massMentionCheck = checkMassMentionLimit(from, AllgroupMembers.length);
          if (!massMentionCheck.allowed) {
            return reply(massMentionCheck.message);
          }
          
          let path = pathz.join(GRUPOS_DIR, `${from}.json`);
          // Otimiza√ß√£o: Usar cache para leitura de arquivo
          let data = await optimizer.loadJsonWithCache(path, { mark: {} });
          if (!data.mark) {
            data.mark = {};
          }
          let membros = AllgroupMembers.filter(m => !['0', 'games'].includes(data.mark[m]));
          if (!membros.length) return reply('‚ùå Nenhum membro para mencionar.');
          
          // Registra uso para grupos grandes (prote√ß√£o anti-ban) se estiver ativa
          const configMarcar = loadMassMentionConfig();
          if (configMarcar[from]?.enabled && AllgroupMembers.length >= MASS_MENTION_THRESHOLD) {
            registerMassMentionUse(from);
          }
          
          let msg = `üì¢ *Membros mencionados:* ${q ? `\nüí¨ *Mensagem:* ${q}` : ''}\n\n`;
          await nazu.sendMessage(from, {
            text: msg + membros.map(m => `‚û§ @${getUserName(m)}`).join('\n'),
            mentions: membros
          });
        } catch (e) {
          console.error(e);
          reply("ocorreu um erro üíî");
        }
        break;
      case 'grupo':
      case 'gp':
      case 'group':
        try {
          if (!isGroup) return reply("isso so pode ser usado em grupo üíî");
          if (!isGroupAdmin) return reply("Comando restrito a Administradores ou Moderadores com permiss√£o. üíî");
          if (!isBotAdmin) return reply("Eu preciso ser adm üíî");
          if (q.toLowerCase() === 'a' || q.toLowerCase() === 'o' || q.toLowerCase() === 'open' || q.toLowerCase() === 'abrir') {
            await nazu.groupSettingUpdate(from, 'not_announcement');
            
            // Notifica√ß√£o X9 para abertura do grupo
            if (groupData.x9) {
              await nazu.sendMessage(from, {
                text: `üîì *X9 Report:* Grupo aberto por @${sender.split('@')[0]}. Agora todos podem enviar mensagens.`,
                mentions: [sender],
              }).catch(err => console.error(`‚ùå Erro ao enviar X9: ${err.message}`));
            }
            
            await reply('Grupo aberto.');
          } else if (q.toLowerCase() === 'f' || q.toLowerCase() === 'c' || q.toLowerCase() === 'close' || q.toLowerCase() === 'fechar') {
            await nazu.groupSettingUpdate(from, 'announcement');
            
            // Notifica√ß√£o X9 para fechamento do grupo
            if (groupData.x9) {
              await nazu.sendMessage(from, {
                text: `üîí *X9 Report:* Grupo fechado por @${sender.split('@')[0]}. Apenas ADMs podem enviar mensagens.`,
                mentions: [sender],
              }).catch(err => console.error(`‚ùå Erro ao enviar X9: ${err.message}`));
            }
            
            await reply('Grupo fechado.');
          }
        } catch (e) {
          console.error(e);
          await reply("‚ùå Ocorreu um erro interno. Tente novamente em alguns minutos.");
        }
        break;
      case 'opengp':
      case  'abrirgp':
        try {
          if (!isGroup) return reply('Este comando s√≥ pode ser usado em grupos üíî');
          if (!isGroupAdmin) return reply('Apenas administradores podem usar este comando üíî');
          if (!q) return reply(`Uso: ${groupPrefix}${command} HH:MM (24h)\nExemplos: ${groupPrefix}${command} 07:00 | ${groupPrefix}${command} off`);
          const rawArg = q.trim();
          const argLower = rawArg.toLowerCase();
          const groupFilePath = pathz.join(GRUPOS_DIR, `${from}.json`);
          let data = fs.existsSync(groupFilePath) ? JSON.parse(fs.readFileSync(groupFilePath, 'utf-8')) : {};
          data.schedule = data.schedule || {};
          
          // Handle disabling the schedule
          if (argLower === 'off' || argLower === 'desativar' || argLower === 'remove' || argLower === 'rm') {
            delete data.schedule.openTime;
            if (data.schedule?.lastRun) {
              delete data.schedule.lastRun.open;
              if (Object.keys(data.schedule.lastRun).length === 0) {
                delete data.schedule.lastRun;
              }
            }
            writeJsonFile(groupFilePath, data);
            // Remove cron job in memory (se houver)
            try { unscheduleGroupJob(from, 'open'); } catch (e) {}
            return reply('‚úÖ Agendamento di√°rio para ABRIR o grupo foi removido.');
          }
          
          // Validate time format with enhanced validation
          const timeValidation = validateTimeFormat(rawArg);
          if (!timeValidation.valid) {
            return reply(`‚è∞ ${timeValidation.error}\nExemplo: ${prefix}opengp 07:30`);
          }
          const normalizedTime = normalizeScheduleTime(rawArg);
          if (!normalizedTime) {
            return reply(`‚è∞ N√£o consegui entender o hor√°rio informado. Use o formato HH:MM, por exemplo ${prefix}opengp 07:30`);
          }
          
          // Save the schedule
          data.schedule.openTime = normalizedTime;
          if (data.schedule.lastRun && typeof data.schedule.lastRun === 'object') {
            delete data.schedule.lastRun.open;
            if (Object.keys(data.schedule.lastRun).length === 0) {
              delete data.schedule.lastRun;
            }
          }
          writeJsonFile(groupFilePath, data);

          // (Re)agendar job em mem√≥ria
          try { scheduleGroupJob(from, 'open', normalizedTime, nazu); } catch (e) { console.error('Erro ao agendar open cron:', e); }
          
          let msg = `‚úÖ Agendamento salvo! O grupo ser√° ABERTO todos os dias √†s ${normalizedTime} (hor√°rio de S√£o Paulo).`;
          if (!isBotAdmin) msg += '\n‚ö†Ô∏è Observa√ß√£o: Eu preciso ser administrador para efetivar a abertura no hor√°rio.';
          await reply(msg);
        } catch (e) {
          console.error('Erro no opengp:', e);
          await reply('Ocorreu um erro ao salvar o agendamento üíî');
        }
        break;
      case 'closegp':
      case 'fechargp':
        try {
          if (!isGroup) return reply('Este comando s√≥ pode ser usado em grupos üíî');
          if (!isGroupAdmin) return reply('Apenas administradores podem usar este comando üíî');
          if (!q) return reply(`Uso: ${groupPrefix}${command} HH:MM (24h)\nExemplos: ${groupPrefix}${command} 22:30 | ${groupPrefix}${command} off`);
          const rawArg = q.trim();
          const argLower = rawArg.toLowerCase();
          const groupFilePath = pathz.join(GRUPOS_DIR, `${from}.json`);
          let data = fs.existsSync(groupFilePath) ? JSON.parse(fs.readFileSync(groupFilePath, 'utf-8')) : {};
          data.schedule = data.schedule || {};
          
          // Handle disabling the schedule
          if (argLower === 'off' || argLower === 'desativar' || argLower === 'remove' || argLower === 'rm') {
            delete data.schedule.closeTime;
            if (data.schedule?.lastRun) {
              delete data.schedule.lastRun.close;
              if (Object.keys(data.schedule.lastRun).length === 0) {
                delete data.schedule.lastRun;
              }
            }
            writeJsonFile(groupFilePath, data);
            // Remove cron job in memory (se houver)
            try { unscheduleGroupJob(from, 'close'); } catch (e) {}
            return reply('‚úÖ Agendamento di√°rio para FECHAR o grupo foi removido.');
          }
          
          // Validate time format with enhanced validation
          const timeValidation = validateTimeFormat(rawArg);
          if (!timeValidation.valid) {
            return reply(`‚è∞ ${timeValidation.error}\nExemplo: ${prefix}closegp 22:30`);
          }
          const normalizedTime = normalizeScheduleTime(rawArg);
          if (!normalizedTime) {
            return reply(`‚è∞ N√£o consegui entender o hor√°rio informado. Use o formato HH:MM, por exemplo ${prefix}closegp 22:30`);
          }
          
          // Save the schedule
          data.schedule.closeTime = normalizedTime;
          if (data.schedule.lastRun && typeof data.schedule.lastRun === 'object') {
            delete data.schedule.lastRun.close;
            if (Object.keys(data.schedule.lastRun).length === 0) {
              delete data.schedule.lastRun;
            }
          }
          writeJsonFile(groupFilePath, data);

          // (Re)agendar job em mem√≥ria
          try { scheduleGroupJob(from, 'close', normalizedTime, nazu); } catch (e) { console.error('Erro ao agendar close cron:', e); }
          
          let msg = `‚úÖ Agendamento salvo! O grupo ser√° FECHADO todos os dias √†s ${normalizedTime} (hor√°rio de S√£o Paulo).`;
          if (!isBotAdmin) msg += '\n‚ö†Ô∏è Observa√ß√£o: Eu preciso ser administrador para efetivar o fechamento no hor√°rio.';
          await reply(msg);
        } catch (e) {
          console.error('Erro no closegp:', e);
          await reply('Ocorreu um erro ao salvar o agendamento üíî');
        }
        break;
      case 'automsg':
        try {
          if (!isGroup) return reply('Este comando s√≥ pode ser usado em grupos üíî');
          if (!isGroupAdmin) return reply('Apenas administradores podem usar este comando üíî');
          
          const subCommand = args[0]?.toLowerCase();
          
          if (!subCommand) {
            return reply(`üì® *Auto Mensagens*

Use os subcomandos:
‚Ä¢ ${groupPrefix}automsg add - Adicionar mensagem
‚Ä¢ ${groupPrefix}automsg list - Listar mensagens
‚Ä¢ ${groupPrefix}automsg del [id] - Remover mensagem
‚Ä¢ ${groupPrefix}automsg on [id] - Ativar mensagem
‚Ä¢ ${groupPrefix}automsg off [id] - Desativar mensagem`);
          }
          
          const groupFilePath = pathz.join(GRUPOS_DIR, `${from}.json`);
          let data = fs.existsSync(groupFilePath) ? JSON.parse(fs.readFileSync(groupFilePath, 'utf-8')) : {};
          data.autoMessages = data.autoMessages || [];
          
          switch (subCommand) {
            case 'add':
              if (!q.includes('|')) {
                return reply(`üì® *Adicionar Auto Mensagem*

Para adicionar, responda a uma mensagem (texto, imagem, v√≠deo, documento, figurinha ou √°udio) e use:

${groupPrefix}automsg add HH:MM | descri√ß√£o

Exemplos:
‚Ä¢ ${groupPrefix}automsg add 08:00 | Bom dia!
‚Ä¢ ${groupPrefix}automsg add 20:00 | Boa noite!

A mensagem ser√° enviada todos os dias no hor√°rio especificado.`);
              }
              
              const [timeStr, ...descParts] = args.slice(1).join(' ').split('|').map(s => s.trim());
              const description = descParts.join('|').trim() || 'Sem descri√ß√£o';
              
              // Validar hor√°rio
              const timeValidation = validateTimeFormat(timeStr);
              if (!timeValidation.valid) {
                return reply(`‚è∞ ${timeValidation.error}\nExemplo: ${groupPrefix}automsg add 08:00 | Bom dia!`);
              }
              
              const normalizedTime = normalizeScheduleTime(timeStr);
              if (!normalizedTime) {
                return reply(`‚è∞ Hor√°rio inv√°lido. Use o formato HH:MM`);
              }
              
              // Verificar se h√° mensagem respondida ou texto
              let msgConfig = {
                id: Date.now().toString(),
                time: normalizedTime,
                description: description,
                enabled: true,
                createdAt: new Date().toISOString(),
                createdBy: sender
              };
              
              if (quotedMessageContent) {
                // Processar m√≠dia respondida
                if (isQuotedImage || isQuotedVisuU || isQuotedVisuU2) {
                  const mediaMsg = quotedMessageContent.imageMessage || 
                                  quotedMessageContent.viewOnceMessage?.message?.imageMessage ||
                                  quotedMessageContent.viewOnceMessageV2?.message?.imageMessage;
                  
                  const buffer = await getFileBuffer(mediaMsg, 'image');
                  const autoMsgDir = pathz.join(__dirname, '..', 'midias', 'automsg', from);
                  ensureDirectoryExists(autoMsgDir);
                  
                  const fileName = `${msgConfig.id}.jpg`;
                  const filePath = pathz.join(autoMsgDir, fileName);
                  fs.writeFileSync(filePath, buffer);
                  
                  msgConfig.type = 'image';
                  msgConfig.mediaPath = filePath;
                  msgConfig.caption = mediaMsg.caption || description;
                  
                } else if (isQuotedVideo) {
                  const buffer = await getFileBuffer(quotedMessageContent.videoMessage, 'video');
                  const autoMsgDir = pathz.join(__dirname, '..', 'midias', 'automsg', from);
                  ensureDirectoryExists(autoMsgDir);
                  
                  const fileName = `${msgConfig.id}.mp4`;
                  const filePath = pathz.join(autoMsgDir, fileName);
                  fs.writeFileSync(filePath, buffer);
                  
                  msgConfig.type = 'video';
                  msgConfig.mediaPath = filePath;
                  msgConfig.caption = quotedMessageContent.videoMessage.caption || description;
                  
                } else if (isQuotedDocument || isQuotedDocW) {
                  const docMsg = quotedMessageContent.documentMessage || 
                                quotedMessageContent.documentWithCaptionMessage?.message?.documentMessage;
                  const buffer = await getFileBuffer(docMsg, 'document');
                  const autoMsgDir = pathz.join(__dirname, '..', 'midias', 'automsg', from);
                  ensureDirectoryExists(autoMsgDir);
                  
                  const ext = docMsg.fileName?.split('.').pop() || 'pdf';
                  const fileName = `${msgConfig.id}.${ext}`;
                  const filePath = pathz.join(autoMsgDir, fileName);
                  fs.writeFileSync(filePath, buffer);
                  
                  msgConfig.type = 'document';
                  msgConfig.mediaPath = filePath;
                  msgConfig.fileName = docMsg.fileName || 'documento.pdf';
                  msgConfig.caption = docMsg.caption || description;
                  
                } else if (isQuotedSticker) {
                  const buffer = await getFileBuffer(quotedMessageContent.stickerMessage, 'sticker');
                  const autoMsgDir = pathz.join(__dirname, '..', 'midias', 'automsg', from);
                  ensureDirectoryExists(autoMsgDir);
                  
                  const fileName = `${msgConfig.id}.webp`;
                  const filePath = pathz.join(autoMsgDir, fileName);
                  fs.writeFileSync(filePath, buffer);
                  
                  msgConfig.type = 'sticker';
                  msgConfig.mediaPath = filePath;
                  
                } else if (isQuotedAudio) {
                  const buffer = await getFileBuffer(quotedMessageContent.audioMessage, 'audio');
                  const autoMsgDir = pathz.join(__dirname, '..', 'midias', 'automsg', from);
                  ensureDirectoryExists(autoMsgDir);
                  
                  const fileName = `${msgConfig.id}.mp3`;
                  const filePath = pathz.join(autoMsgDir, fileName);
                  fs.writeFileSync(filePath, buffer);
                  
                  msgConfig.type = 'audio';
                  msgConfig.mediaPath = filePath;
                  
                } else if (isQuotedMsg || isQuotedMsg2) {
                  const text = quotedMessageContent.conversation || 
                              quotedMessageContent.extendedTextMessage?.text;
                  msgConfig.type = 'text';
                  msgConfig.content = text;
                } else {
                  return reply('‚ùå Tipo de mensagem n√£o suportado. Use texto, imagem, v√≠deo, documento, figurinha ou √°udio.');
                }
              } else {
                // Usar descri√ß√£o como texto
                if (!description || description === 'Sem descri√ß√£o') {
                  return reply('‚ùå Voc√™ precisa responder a uma mensagem ou fornecer um texto ap√≥s o hor√°rio.');
                }
                msgConfig.type = 'text';
                msgConfig.content = description;
              }
              
              // Adicionar √† lista
              data.autoMessages.push(msgConfig);
              writeJsonFile(groupFilePath, data);
              
              // Agendar
              scheduleAutoMessage(from, msgConfig, nazu);
              
              await reply(`‚úÖ Mensagem autom√°tica adicionada!

üÜî ID: ${msgConfig.id}
‚è∞ Hor√°rio: ${normalizedTime}
üìù Tipo: ${msgConfig.type}
üìã Descri√ß√£o: ${description}

A mensagem ser√° enviada todos os dias √†s ${normalizedTime} (hor√°rio de S√£o Paulo).`);
              break;
              
            case 'list':
            case 'lista':
              if (data.autoMessages.length === 0) {
                return reply('üì≠ Nenhuma mensagem autom√°tica configurada.');
              }
              
              let listMsg = 'üì® *Auto Mensagens Configuradas*\n\n';
              data.autoMessages.forEach((msg, idx) => {
                const status = msg.enabled ? '‚úÖ' : '‚ùå';
                listMsg += `${status} *${idx + 1}.* ID: ${msg.id}\n`;
                listMsg += `   ‚è∞ Hor√°rio: ${msg.time}\n`;
                listMsg += `   üìù Tipo: ${msg.type}\n`;
                listMsg += `   üìã Descri√ß√£o: ${msg.description}\n\n`;
              });
              
              await reply(listMsg);
              break;
              
            case 'del':
            case 'delete':
            case 'remover':
              const msgId = args[1];
              if (!msgId) {
                return reply(`‚ùå Forne√ßa o ID da mensagem.\nUso: ${groupPrefix}automsg del [id]`);
              }
              
              const msgIndex = data.autoMessages.findIndex(m => m.id === msgId);
              if (msgIndex === -1) {
                return reply('‚ùå Mensagem n√£o encontrada. Use automsg list para ver os IDs.');
              }
              
              const removedMsg = data.autoMessages[msgIndex];
              
              // Remover arquivo de m√≠dia se existir
              if (removedMsg.mediaPath && fs.existsSync(removedMsg.mediaPath)) {
                try {
                  fs.unlinkSync(removedMsg.mediaPath);
                } catch (e) {
                  console.error('Erro ao remover arquivo de m√≠dia:', e);
                }
              }
              
              // Desagendar
              unscheduleAutoMessage(from, msgId);
              
              // Remover da lista
              data.autoMessages.splice(msgIndex, 1);
              writeJsonFile(groupFilePath, data);
              
              await reply(`‚úÖ Mensagem autom√°tica removida!

üÜî ID: ${msgId}
‚è∞ Hor√°rio: ${removedMsg.time}`);
              break;
              
            case 'on':
            case 'ativar':
              const onMsgId = args[1];
              if (!onMsgId) {
                return reply(`‚ùå Forne√ßa o ID da mensagem.\nUso: ${groupPrefix}automsg on [id]`);
              }
              
              const onMsg = data.autoMessages.find(m => m.id === onMsgId);
              if (!onMsg) {
                return reply('‚ùå Mensagem n√£o encontrada. Use automsg list para ver os IDs.');
              }
              
              onMsg.enabled = true;
              writeJsonFile(groupFilePath, data);
              
              // Reagendar
              scheduleAutoMessage(from, onMsg, nazu);
              
              await reply(`‚úÖ Mensagem autom√°tica ativada!\n\nüÜî ID: ${onMsgId}`);
              break;
              
            case 'off':
            case 'desativar':
              const offMsgId = args[1];
              if (!offMsgId) {
                return reply(`‚ùå Forne√ßa o ID da mensagem.\nUso: ${groupPrefix}automsg off [id]`);
              }
              
              const offMsg = data.autoMessages.find(m => m.id === offMsgId);
              if (!offMsg) {
                return reply('‚ùå Mensagem n√£o encontrada. Use automsg list para ver os IDs.');
              }
              
              offMsg.enabled = false;
              writeJsonFile(groupFilePath, data);
              
              // Desagendar
              unscheduleAutoMessage(from, offMsgId);
              
              await reply(`‚úÖ Mensagem autom√°tica desativada!\n\nüÜî ID: ${offMsgId}`);
              break;
              
            default:
              return reply(`‚ùå Subcomando inv√°lido. Use: add, list, del, on ou off`);
          }
        } catch (e) {
          console.error('Erro no automsg:', e);
          await reply('‚ùå Ocorreu um erro ao processar o comando de auto mensagem.');
        }
        break;
      case 'chaveamento':
        try {
          if (!isGroup) return reply("Este comando s√≥ pode ser usado em grupos üíî");
          let participantes = [];
          if (q) {
            participantes = q.split(',').map(n => n.trim()).filter(n => n);
            if (participantes.length !== 16) {
              return reply(`‚ùå Forne√ßa exatamente 16 nomes! Voc√™ forneceu ${participantes.length}. Exemplo: ${prefix}${command} nome1,nome2,...,nome16`);
            }
          } else {
            return reply(`‚ùå Forne√ßa exatamente 16 nomes! Voc√™ forneceu 0. Exemplo: ${prefix}${command} nome1,nome2,...,nome16`);
          }
          participantes = participantes.sort(() => Math.random() - 0.5);
          const grupo1 = participantes.slice(0, 8);
          const grupo2 = participantes.slice(8, 16);
          const confrontosGrupo1 = [[grupo1[0], grupo1[1]], [grupo1[2], grupo1[3]], [grupo1[4], grupo1[5]], [grupo1[6], grupo1[7]]];
          const confrontosGrupo2 = [[grupo2[0], grupo2[1]], [grupo2[2], grupo2[3]], [grupo2[4], grupo2[5]], [grupo2[6], grupo2[7]]];
          let mensagem = `üèÜ *Chaveamento do Torneio* üèÜ\n\n`;
          
          mensagem += `üìå *Grupo 1*\n`;
          grupo1.forEach((p, i) => {
            
            mensagem += `  ${i + 1}. ${p.includes('@') ? `@${getUserName(p)}` : p}\n`;
          });
          
          mensagem += `\n*Confrontos do Grupo 1*:\n`;
          confrontosGrupo1.forEach((confronto, i) => {
            const p1 = confronto[0].includes('@') ? `@${getUserName(confronto[0])}` : confronto[0];
            const p2 = confronto[1].includes('@') ? `@${getUserName(confronto[1])}` : confronto[1];
            
            mensagem += `  ü•ä Partida ${i + 1}: ${p1} vs ${p2}\n`;
          });
          
          mensagem += `\nüìå *Grupo 2*\n`;
          grupo2.forEach((p, i) => {
            
            mensagem += `  ${i + 1}. ${p.includes('@') ? `@${getUserName(p)}` : p}\n`;
          });
          
          mensagem += `\n*Confrontos do Grupo 2*:\n`;
          confrontosGrupo2.forEach((confronto, i) => {
            const p1 = confronto[0].includes('@') ? `@${getUserName(confronto[0])}` : confronto[0];
            const p2 = confronto[1].includes('@') ? `@${getUserName(confronto[1])}` : confronto[1];
            
            mensagem += `  ü•ä Partida ${i + 1}: ${p1} vs ${p2}\n`;
          });
          await reply(mensagem);
        } catch (e) {
          console.error('Erro no comando chaveamento:', e);
          await reply("‚ùå Ocorreu um erro interno. Tente novamente em alguns minutos.");
        }
        break;
      case 'sorteionum':
        try {
          if (!q) return reply(`Por favor, forne√ßa um intervalo de n√∫meros. Exemplo: ${prefix}sorteionum 1-50`);
          const [min, max] = q.split('-').map(n => parseInt(n.trim()));
          if (isNaN(min) || isNaN(max) || min >= max) return reply('‚ùå Intervalo inv√°lido! Use o formato: min-max (ex.: 1-50).');
          const numeroSorteado = Math.floor(Math.random() * (max - min + 1)) + min;
          await reply(`üé≤ *Sorteio de N√∫mero* üé≤\n\nN√∫mero sorteado: *${numeroSorteado}*`);
        } catch (e) {
          console.error('Erro no comando sorteionum:', e);
          await reply("‚ùå Ocorreu um erro interno. Tente novamente em alguns minutos.");
        }
        break;
      case 'sorteionome':
        try {
          if (!q) return reply(`Por favor, forne√ßa os nomes para o sorteio. Exemplo: ${prefix}sorteionome 4/nick1,nick2,nick3,... ou ${prefix}sorteionome nick1,nick2,nick3,...`);
          let numVencedores = 1;
          let numGrupos = 1;
          let nomes = [];
          if (q.includes('/')) {
            const [config, listaNomes] = q.split('/').map(s => s.trim());
            const [vencedores, grupos] = config.includes('-') ? config.split('-').map(n => parseInt(n.trim())) : [parseInt(config), 1];
            numVencedores = vencedores || 1;
            numGrupos = grupos || 1;
            nomes = listaNomes.split(',').map(n => n.trim()).filter(n => n);
          } else {
            nomes = q.split(',').map(n => n.trim()).filter(n => n);
          }
          if (nomes.length < numVencedores * numGrupos) return reply(`‚ùå N√£o h√° nomes suficientes! Voc√™ precisa de pelo menos ${numVencedores * numGrupos} nomes para sortear ${numVencedores} vencedor${numVencedores > 1 ? 'es' : ''}${numGrupos > 1 ? ` em ${numGrupos} grupos` : ''}.`);
          if (numVencedores < 1 || numGrupos < 1) return reply('‚ùå Quantidade de vencedores ou grupos inv√°lida! Use n√∫meros positivos.');
          let resultado = `üéâ *Resultado do Sorteio de Nomes* üéâ\n\n`;
          let nomesDisponiveis = [...nomes];
          if (numGrupos === 1) {
            let vencedores = [];
            for (let i = 0; i < numVencedores; i++) {
              if (nomesDisponiveis.length === 0) break;
              const indice = Math.floor(Math.random() * nomesDisponiveis.length);
              vencedores.push(nomesDisponiveis[indice]);
              nomesDisponiveis.splice(indice, 1);
            }
            resultado += vencedores.map((v, i) => `üèÜ *#${i + 1}* - ${v}`).join('\n');
          } else {
            for (let g = 1; g <= numGrupos; g++) {
              resultado += `üìå *Grupo ${g}*:\n`;
              let vencedores = [];
              for (let i = 0; i < numVencedores; i++) {
                if (nomesDisponiveis.length === 0) break;
                const indice = Math.floor(Math.random() * nomesDisponiveis.length);
                vencedores.push(nomesDisponiveis[indice]);
                nomesDisponiveis.splice(indice, 1);
              }
              resultado += vencedores.map((v, i) => `  üèÜ *#${i + 1}* - ${v}`).join('\n') + '\n\n';
            }
          }
          await reply(resultado);
        } catch (e) {
          console.error('Erro no comando sorteionome:', e);
          await reply("‚ùå Ocorreu um erro interno. Tente novamente em alguns minutos.");
        }
        break;
      case 'sorteio':
        try {
          if (!isGroup) return reply("Este comando s√≥ pode ser usado em grupos üíî");
          if (!isGroup) return reply("isso so pode ser usado em grupo üíî");
          let path = pathz.join(GRUPOS_DIR, `${from}.json`);
          // Otimiza√ß√£o: Usar cache para leitura de arquivo
          let data = await optimizer.loadJsonWithCache(path, { mark: {} });
          let membros = AllgroupMembers.filter(m => !['0', 'marca'].includes(data.mark[m]));
          if (membros.length < 2) return reply('‚ùå Preciso de pelo menos 2 membros v√°lidos no grupo para realizar o sorteio!');
          let numVencedores = parseInt(q) || 1;
          if (numVencedores < 1) return reply('‚ùå O n√∫mero de vencedores deve ser maior que 0!');
          if (numVencedores > membros.length) return reply(`‚ùå N√£o h√° membros suficientes! O grupo tem apenas ${membros.length} membros v√°lidos.`);
          let vencedores = [];
          let membrosDisponiveis = [...membros];
          for (let i = 0; i < numVencedores; i++) {
            if (membrosDisponiveis.length === 0) break;
            const indice = Math.floor(Math.random() * membrosDisponiveis.length);
            vencedores.push(membrosDisponiveis[indice]);
            membrosDisponiveis.splice(indice, 1);
          }
          const vencedoresText = vencedores.map((v, i) => `üèÜ *#${i + 1}* - @${getUserName(v)}`).join('\n');
          await reply(`üéâ *Resultado do Sorteio* üéâ\n\n${vencedoresText}`, {
            mentions: vencedores
          });
        } catch (e) {
          console.error('Erro no comando sorteio:', e);
          await reply("‚ùå Ocorreu um erro interno. Tente novamente em alguns minutos.");
        }
        break;
      case 'totag':
      case 'cita':
      case 'hidetag':
        try {
          if (!isGroup) return reply("isso so pode ser usado em grupo üíî");
          if (!isGroupAdmin) return reply("Comando restrito a Administradores ou Moderadores com permiss√£o. üíî");
          if (!isBotAdmin) return reply("Eu preciso ser adm üíî");
          
          // Prote√ß√£o Anti-Ban: Verifica rate limit para grupos grandes
          const massMentionCheckHidetag = checkMassMentionLimit(from, AllgroupMembers.length);
          if (!massMentionCheckHidetag.allowed) {
            return reply(massMentionCheckHidetag.message);
          }
          
          var DFC4 = "";
          var rsm4 = info.message?.extendedTextMessage?.contextInfo?.quotedMessage;
          
          // Para mensagens marcadas, precisa baixar a m√≠dia
          if (isQuotedMsg && rsm4) {
            const quotedMsg = info.message?.extendedTextMessage?.contextInfo;
            
            // Se for m√≠dia marcada, baixa primeiro
            if (isQuotedImage || isQuotedVideo || isQuotedAudio || isQuotedDocument || isQuotedDocW || isQuotedSticker) {
              try {
                const buffer = await downloadContentBuffer(quotedMsg, 
                  isQuotedImage ? 'image' : 
                  isQuotedVideo ? 'video' : 
                  isQuotedAudio ? 'audio' :
                  isQuotedSticker ? 'sticker' : 'document'
                );
                
                // Atualiza as mensagens para incluir o buffer baixado
                if (isQuotedImage && rsm4.imageMessage) {
                  rsm4.imageMessage.buffer = buffer;
                } else if (isQuotedVideo && rsm4.videoMessage) {
                  rsm4.videoMessage.buffer = buffer;
                } else if (isQuotedAudio && rsm4.audioMessage) {
                  rsm4.audioMessage.buffer = buffer;
                } else if (isQuotedSticker && rsm4.stickerMessage) {
                  rsm4.stickerMessage.buffer = buffer;
                } else if (isQuotedDocument && rsm4.documentMessage) {
                  rsm4.documentMessage.buffer = buffer;
                } else if (isQuotedDocW && rsm4.documentWithCaptionMessage?.message?.documentMessage) {
                  rsm4.documentWithCaptionMessage.message.documentMessage.buffer = buffer;
                }
              } catch (err) {
                console.error('Erro ao baixar m√≠dia marcada para hidetag:', err);
                return reply('‚ùå Erro ao baixar a m√≠dia marcada. Tente novamente.');
              }
            }
          }
          
          var pink4 = isQuotedImage ? rsm4?.imageMessage : info.message?.imageMessage;
          var blue4 = isQuotedVideo ? rsm4?.videoMessage : info.message?.videoMessage;
          var purple4 = isQuotedDocument ? rsm4?.documentMessage : info.message?.documentMessage;
          var yellow4 = isQuotedDocW ? rsm4?.documentWithCaptionMessage?.message?.documentMessage : info.message?.documentWithCaptionMessage?.message?.documentMessage;
          var aud_d4 = isQuotedAudio ? rsm4.audioMessage : "";
          var figu_d4 = isQuotedSticker ? rsm4.stickerMessage : "";
          var red4 = isQuotedMsg && !aud_d4 && !figu_d4 && !pink4 && !blue4 && !purple4 && !yellow4 ? rsm4.conversation : info.message?.conversation;
          var green4 = rsm4?.extendedTextMessage?.text || info?.message?.extendedTextMessage?.text;
          let path = pathz.join(GRUPOS_DIR, `${from}.json`);
          // Otimiza√ß√£o: Usar cache para leitura de arquivo
          let data = await optimizer.loadJsonWithCache(path, { mark: {} });
          if (!data.mark) {
            data.mark = {};
          }
          var MRC_TD4 = AllgroupMembers.filter(m => !['0', 'games'].includes(data.mark[m]));
          if (pink4 && !aud_d4 && !purple4) {
            var DFC4 = pink4;
            
            pink4.caption = q.length > 1 ? q : pink4.caption?.replace(new RegExp(prefix + command, "gi"), ` `) || '';

            // Se tiver buffer (m√≠dia baixada), usa ele. Sen√£o usa URL
            if (pink4.buffer) {
              pink4.image = pink4.buffer;
              delete pink4.buffer;
              delete pink4.url;
            } else {
              pink4.image = {
                url: pink4.url
              };
            }
            
            pink4.mentions = MRC_TD4;
          } else if (blue4 && !aud_d4 && !purple4) {
            var DFC4 = blue4;
            
            blue4.caption = q.length > 1 ? q.trim() : blue4.caption?.replace(new RegExp(prefix + command, "gi"), ` `).trim() || '';
            
            // Se tiver buffer (m√≠dia baixada), usa ele. Sen√£o usa URL
            if (blue4.buffer) {
              blue4.video = blue4.buffer;
              delete blue4.buffer;
              delete blue4.url;
            } else {
              blue4.video = {
                url: blue4.url
              };
            }
            
            blue4.mentions = MRC_TD4;
          } else if (red4 && !aud_d4 && !purple4) {
            var black4 = {};
            
            black4.text = red4.replace(new RegExp(prefix + command, "gi"), ` `).trim();
            
            black4.mentions = MRC_TD4;
            var DFC4 = black4;
          } else if (!aud_d4 && !figu_d4 && green4 && !purple4) {
            var brown4 = {};
            
            brown4.text = green4.replace(new RegExp(prefix + command, "gi"), ` `).trim();
            
            brown4.mentions = MRC_TD4;
            var DFC4 = brown4;
          } else if (purple4) {
            var DFC4 = purple4;
            
            // Se tiver buffer (m√≠dia baixada), usa ele. Sen√£o usa URL
            if (purple4.buffer) {
              purple4.document = purple4.buffer;
              delete purple4.buffer;
              delete purple4.url;
            } else {
              purple4.document = {
                url: purple4.url
              };
            }
            
            purple4.mentions = MRC_TD4;
          } else if (yellow4 && !aud_d4) {
            var DFC4 = yellow4;
            
            yellow4.caption = q.length > 1 ? q.trim() : yellow4.caption?.replace(new RegExp(prefix + command, "gi"), `${pushname}\n\n`).trim() || '';
            
            // Se tiver buffer (m√≠dia baixada), usa ele. Sen√£o usa URL
            if (yellow4.buffer) {
              yellow4.document = yellow4.buffer;
              delete yellow4.buffer;
              delete yellow4.url;
            } else {
              yellow4.document = {
                url: yellow4.url
              };
            }
            
            yellow4.mentions = MRC_TD4;
          } else if (figu_d4 && !aud_d4) {
            var DFC4 = figu_d4;
            
            // Se tiver buffer (m√≠dia baixada), usa ele. Sen√£o usa URL
            if (figu_d4.buffer) {
              figu_d4.sticker = figu_d4.buffer;
              delete figu_d4.buffer;
              delete figu_d4.url;
            } else {
              figu_d4.sticker = {
                url: figu_d4.url
              };
            }
            
            figu_d4.mentions = MRC_TD4;
          } else if (aud_d4) {
            var DFC4 = aud_d4;
            
            // Se tiver buffer (m√≠dia baixada), usa ele. Sen√£o usa URL
            if (aud_d4.buffer) {
              aud_d4.audio = aud_d4.buffer;
              delete aud_d4.buffer;
              delete aud_d4.url;
            } else {
              aud_d4.audio = {
                url: aud_d4.url
              };
            }
            
            aud_d4.mentions = MRC_TD4;
            
            aud_d4.ptt = true;
          }
          
          // Registra uso para grupos grandes (prote√ß√£o anti-ban) se estiver ativa
          const configHidetag = loadMassMentionConfig();
          if (configHidetag[from]?.enabled && AllgroupMembers.length >= MASS_MENTION_THRESHOLD) {
            registerMassMentionUse(from);
          }
          
          await nazu.sendMessage(from, DFC4).catch(error => {});
        } catch (e) {
          console.error(e);
          await reply("‚ùå Ocorreu um erro interno. Tente novamente em alguns minutos.");
        }
        break;
      case 'antilinkhard':
        try {
          if (!isGroup) return reply("Isso s√≥ pode ser usado em grupo üíî");
          if (!isGroupAdmin) return reply("Voc√™ precisa ser adm üíî");
          if (!isBotAdmin) return reply("Eu preciso ser adm para isso üíî");
          groupData.antilinkhard = !groupData.antilinkhard;
          fs.writeFileSync(groupFile, JSON.stringify(groupData, null, 2));
          await reply(`‚úÖ Antilinkhard ${groupData.antilinkhard ? 'ativado' : 'desativado'}! Qualquer link enviado resultar√° em banimento.`);
        } catch (e) {
          console.error(e);
          await reply("Ocorreu um erro üíî");
        }
        break;

      case 'divdono':
        try {
          if (!isOwner) return reply("Apenas o dono do bot pode usar este comando.");

          const sub = (args[0] || '').toLowerCase();
          const rest = args.slice(1).join(' ').trim();
          const config = loadDonoDivulgacao();
          const groups = Array.isArray(config.groups) ? config.groups : [];

          const helpText = `üì£ *DIVULGA√á√ÉO DO DONO (NOVO)*\n\n` +
            `‚Ä¢ ${prefix}divdono add [id] (no grupo ou com ID)\n` +
            `‚Ä¢ ${prefix}divdono rem <id>\n` +
            `‚Ä¢ ${prefix}divdono list\n` +
            `‚Ä¢ ${prefix}divdono msg <texto>\n` +
            `‚Ä¢ ${prefix}divdono send [texto] (usa msg salva)\n` +
            `‚Ä¢ ${prefix}divdono time <HH:MM|off>\n` +
            `‚Ä¢ ${prefix}divdono status`;

          if (!sub || sub === 'help') {
            return reply(helpText);
          }

          if (sub === 'add' || sub === 'registrar' || sub === 'register') {
            let targetGroupId = rest;
            if (!targetGroupId && isGroup) targetGroupId = from;
            if (!targetGroupId) return reply(`üí° Use: ${prefix}divdono add [id_do_grupo]`);

            if (!targetGroupId.includes('@g.us')) {
              targetGroupId += '@g.us';
            }
            if (!isGroupId(targetGroupId)) {
              return reply('‚ùå ID de grupo inv√°lido! Deve terminar com @g.us');
            }

            if (!groups.includes(targetGroupId)) {
              groups.push(targetGroupId);
              config.groups = groups;
              saveDonoDivulgacao(config);
              return reply(`‚úÖ Grupo registrado para divulga√ß√£o.\nüìå Total: ${groups.length}`);
            }
            return reply('‚ö†Ô∏è Este grupo j√° est√° registrado.');
          }

          if (sub === 'rem' || sub === 'remove' || sub === 'del') {
            if (!rest) return reply(`üí° Use: ${prefix}divdono rem <id_do_grupo>`);
            let targetGroupId = rest.trim();
            if (!targetGroupId.includes('@g.us')) {
              targetGroupId += '@g.us';
            }
            const newGroups = groups.filter(id => id !== targetGroupId);
            if (newGroups.length === groups.length) {
              return reply('‚ö†Ô∏è Grupo n√£o encontrado na lista.');
            }
            config.groups = newGroups;
            saveDonoDivulgacao(config);
            return reply(`‚úÖ Grupo removido da divulga√ß√£o.\nüìå Total: ${newGroups.length}`);
          }

          if (sub === 'list' || sub === 'lista') {
            if (!groups.length) return reply('‚ö†Ô∏è Nenhum grupo registrado para divulga√ß√£o.');

            let text = `üì£ *GRUPOS REGISTRADOS (${groups.length})*\n`;
            let index = 1;
            for (const groupId of groups) {
              let groupName = null;
              try {
                const meta = await nazu.groupMetadata(groupId).catch(() => null);
                groupName = meta?.subject || null;
              } catch (e) {}
              text += `\n${index}. ${groupName ? groupName + ' - ' : ''}${groupId}`;
              index++;
              if (index > 30) {
                text += `\n\n...e mais ${groups.length - 30} grupo(s).`;
                break;
              }
            }
            return reply(text);
          }

          if (sub === 'msg' || sub === 'mensagem') {
            if (!rest) {
              const current = (config.message || '').trim() || 'Nenhuma mensagem salva.';
              return reply(`üìù *Mensagem atual:*\n${current}`);
            }
            config.message = rest;
            saveDonoDivulgacao(config);
            return reply('‚úÖ Mensagem de divulga√ß√£o salva com sucesso.');
          }

          if (sub === 'send' || sub === 'enviar') {
            const customText = rest || null;
            const result = await runDonoDivulgacaoSend(nazu, customText, 'manual');
            if (!result.success) return reply(result.message);
            return reply(`‚úÖ Divulga√ß√£o enviada.\nüì® Enviadas: ${result.sent}\n‚ö†Ô∏è Falhas: ${result.failed}`);
          }

          if (sub === 'time' || sub === 'hora' || sub === 'agendar') {
            if (!rest) {
              const status = config.schedule?.enabled ? 'ativado' : 'desativado';
              const time = config.schedule?.time || '‚Äî';
              return reply(`‚è∞ *Agendamento:* ${status}\nüïí Hor√°rio: ${time}\nüí° Use ${prefix}divdono time HH:MM ou off`);
            }

            if (['off', 'desligar', 'desativar'].includes(rest.toLowerCase())) {
              config.schedule = config.schedule || {};
              config.schedule.enabled = false;
              config.schedule.time = null;
              config.schedule.lastRun = null;
              saveDonoDivulgacao(config);
              unscheduleDonoDivulgacaoJob();
              return reply('‚úÖ Agendamento di√°rio desativado.');
            }

            const normalized = normalizeScheduleTime(rest);
            if (!normalized) {
              return reply('‚ùå Formato inv√°lido. Use HH:MM (ex: 09:30).');
            }

            config.schedule = config.schedule || {};
            config.schedule.enabled = true;
            config.schedule.time = normalized;
            config.schedule.lastRun = null;
            saveDonoDivulgacao(config);
            scheduleDonoDivulgacaoJob(normalized, nazu);

            return reply(`‚úÖ Agendamento di√°rio definido para ${normalized} (hor√°rio de S√£o Paulo).`);
          }

          if (sub === 'status') {
            const schedule = config.schedule || {};
            const status = schedule.enabled ? 'ativado' : 'desativado';
            const time = schedule.time || '‚Äî';
            const msgPreview = (config.message || '').trim();
            const lastAuto = config.stats?.lastAuto ? new Date(config.stats.lastAuto).toLocaleString('pt-BR') : '‚Äî';
            const lastManual = config.stats?.lastManual ? new Date(config.stats.lastManual).toLocaleString('pt-BR') : '‚Äî';

            let text = `üì£ *STATUS DIVULGA√á√ÉO DO DONO*\n\n`;
            text += `üìå Grupos: ${groups.length}\n`;
            text += `üïí Agendamento: ${status}\n`;
            text += `‚è∞ Hor√°rio: ${time}\n`;
            text += `üßæ Mensagem: ${msgPreview ? msgPreview.slice(0, 120) + (msgPreview.length > 120 ? '...' : '') : 'Nenhuma'}\n`;
            text += `üì® Total enviado: ${config.stats?.totalSent || 0}\n`;
            text += `üóìÔ∏è √öltimo manual: ${lastManual}\n`;
            text += `ü§ñ √öltimo autom√°tico: ${lastAuto}`;
            return reply(text);
          }

          return reply(helpText);
        } catch (e) {
          console.error('Erro no comando divdono:', e);
          await reply('üíî Ocorreu um erro ao processar o comando.');
        }
        break;

      case 'setdiv':
        try {
          if (!isOwner) return reply("Apenas o dono do bot pode usar este comando.");

          if (!q) {
            // Otimiza√ß√£o: Cache de divulgacao
            const config = await optimizer.memoize(
              'divulgacao:config',
              () => Promise.resolve(loadDivulgacao()),
              30000 // 30 segundos
            );
            const currentMessage = config.savedMessage || "Nenhuma mensagem salva.";
            return reply(`*Mensagem de divulga√ß√£o atual:*\n${currentMessage}`);
          }

          if (saveDivulgacao({ savedMessage: q })) {
            // Invalida cache ap√≥s salvar
            optimizer.clearStatic('divulgacao:config');
            await reply(`‚úÖ Mensagem de divulga√ß√£o salva:\n\n${q}`);
          } else {
            await reply("üíî Ocorreu um erro ao salvar a mensagem.");
          }
        } catch (e) {
          console.error('Erro no comando setdiv:', e);
          await reply("üíî Ocorreu um erro geral ao processar o comando.");
        }
        break;

case 'div':
case 'divulgar':
    try {
        if (!isGroup) return reply("Este comando s√≥ pode ser usado em grupos.");
        if (!isOwner) return reply("Apenas o dono do bot pode usar este comando.");

        const delay = 500;
        const maxCount = 50;
        const markAll = args[args.length - 1]?.toLowerCase() === 'all';
        if (markAll) args.pop();
        const count = parseInt(args.pop());
        let messageText = args.join(' ').trim();

        if (!messageText) messageText = loadDivulgacao().savedMessage;
        
        if (!messageText) return reply(`‚ùå Nenhuma mensagem para divulgar.`);
        if (isNaN(count) || count <= 0 || count > maxCount) return reply(`‚ùå Quantidade inv√°lida.`);

        // Prote√ß√£o Anti-Ban: Verifica rate limit para grupos grandes (apenas se markAll estiver ativo)
        if (markAll) {
          const massMentionCheckDiv = checkMassMentionLimit(from, AllgroupMembers.length);
          if (!massMentionCheckDiv.allowed) {
            return reply(massMentionCheckDiv.message);
          }
          
          // Registra uso para grupos grandes (prote√ß√£o anti-ban) se estiver ativa
          const configDiv = loadMassMentionConfig();
          if (configDiv[from]?.enabled && AllgroupMembers.length >= MASS_MENTION_THRESHOLD) {
            registerMassMentionUse(from);
          }
        }

        const contextInfo = markAll ? { contextInfo: { mentionedJid: AllgroupMembers } } : {};

        const processarProxima = async (index, falhas) => {
            if (index >= count) {
                if (falhas > 0) await reply(`- Falhas: ${falhas}`);
                return;
            }
            try {
                const paymentObject = {
                    requestPaymentMessage: {
                        currencyCodeIso4217: 'BRL', amount1000: '0', requestFrom: sender,
                        noteMessage: { extendedTextMessage: { text: messageText, ...contextInfo } },
                        amount: { value: '0', offset: 1000, currencyCode: 'BRL' },
                        expiryTimestamp: Math.floor(Date.now() / 1000) + 86400
                    }
                };
                const msg = await generateWAMessageFromContent(from, paymentObject, { userJid: nazu?.user?.id });
                await nazu.relayMessage(from, msg.message, { messageId: msg.key.id });
            } catch (e) {
                console.error(`Falha ao enviar mensagem ${index + 1}:`, e);
                falhas++;
            }
            setTimeout(() => processarProxima(index + 1, falhas), delay);
        };

        processarProxima(0, 0);
    } catch (e) {
        console.error("Erro no comando 'divulgar':", e);
        await reply("üíî Ocorreu um erro ao iniciar a divulga√ß√£o.");
    }
    break;

      case 'antibotao':
      case 'antibtn':
        try {
          if (!isGroup) return reply("Isso s√≥ pode ser usado em grupo üíî");
          if (!isGroupAdmin) return reply("Voc√™ precisa ser adm üíî");
          if (!isBotAdmin) return reply("Eu preciso ser adm para isso üíî");
          groupData.antibtn = !groupData.antibtn;
          fs.writeFileSync(groupFile, JSON.stringify(groupData, null, 2));
          await reply(`‚úÖ Anti Bot√£o ${groupData.antibtn ? 'ativado' : 'desativado'}!`);
        } catch (e) {
          console.error(e);
          await reply("Ocorreu um erro üíî");
        }
        break;
      case 'antistatus':
        try {
          if (!isGroup) return reply("Isso s√≥ pode ser usado em grupo üíî");
          if (!isGroupAdmin) return reply("Voc√™ precisa ser adm üíî");
          if (!isBotAdmin) return reply("Eu preciso ser adm para isso üíî");

          groupData.antistatus = !groupData.antistatus;
          fs.writeFileSync(groupFile, JSON.stringify(groupData, null, 2));
          await reply(`‚úÖ Anti Status ${groupData.antistatus ? 'ativado' : 'desativado'}!`);
        } catch (e) {
          console.error(e);
          await reply("Ocorreu um erro üíî");
        }
        break;
      case 'antidelete':
        try {
          if (!isGroup) return reply("Isso s√≥ pode ser usado em grupo üíî");
          if (!isGroupAdmin) return reply("Voc√™ precisa ser adm üíî");
          if (!isBotAdmin) return reply("Eu preciso ser adm para isso üíî");
          
          groupData.antidel = !groupData.antidel;
          fs.writeFileSync(groupFile, JSON.stringify(groupData, null, 2));
          await reply(`‚úÖ Antidelete ${groupData.antidel ? 'ativado' : 'desativado'}!`);
        } catch (e) {
          console.error(e);
          await reply("Ocorreu um erro üíî");
        }
        break;
      case 'autodl':
      case 'autodown':
        try {
          if (!isGroup) return reply("Isso s√≥ pode ser usado em grupo üíî");
          if (!isGroupAdmin) return reply("Voc√™ precisa ser adm üíî");
          
          groupData.autodl = !groupData.autodl;
          fs.writeFileSync(groupFile, JSON.stringify(groupData, null, 2));
          
          const platforms = [
            'üé• YouTube',
            'üì± TikTok', 
            'üì∏ Instagram',
            'üìò Facebook',
            'üìå Pinterest',
            'üéµ Spotify',
            'üîä SoundCloud'
          ];
          
          const statusMsg = groupData.autodl 
            ? `‚úÖ *AutoDL Ativado!*\n\nüì• Links das seguintes plataformas ser√£o baixados automaticamente:\n\n${platforms.join('\n')}\n\nüí° Basta enviar o link que eu baixo para voc√™!`
            : `‚ùå *AutoDL Desativado*\n\n‚è∏Ô∏è Links n√£o ser√£o mais baixados automaticamente.`;
          
          await reply(statusMsg);
        } catch (e) {
          console.error(e);
          await reply("Ocorreu um erro üíî");
        }
        break;
      case 'antidoc':
        try {
          if (!isGroup) return reply("Isso s√≥ pode ser usado em grupo üíî");
          if (!isGroupAdmin) return reply("Voc√™ precisa ser adm üíî");
          if (!isBotAdmin) return reply("Eu preciso ser adm para isso üíî");
          
          groupData.antidoc = !groupData.antidoc;
          fs.writeFileSync(groupFile, JSON.stringify(groupData, null, 2));
          await reply(`‚úÖ Antidoc ${groupData.antidoc ? 'ativado' : 'desativado'}! Documentos enviados resultar√£o em banimento.`);
        } catch (e) {
          console.error(e);
          await reply("Ocorreu um erro üíî");
        }
        break;
      case 'limitmessage':
        try {
          if (!isGroup) return reply("Este comando s√≥ funciona em grupos üíî");
          if (!isGroupAdmin) return reply("Apenas administradores podem usar este comando üö´");
          if (!q) {
            return reply(`üìù Configure o limite de mensagens! Exemplo: ${prefix}limitmessage 5 1m ban\n` + `Formato: ${prefix}limitmessage <quantidade> <tempo> <a√ß√£o>\n` + `Tempo: s (segundos), m (minutos), h (horas)\n` + `A√ß√£o: ban (banimento direto) ou adv (advert√™ncias)`);
          }
          if (args.length !== 3) {
            return reply("  ‚ùå Formato inv√°lido! Use: " + `${prefix}limitmessage <quantidade> <tempo> <a√ß√£o>`);
          }
          const limit = parseInt(args[0]);
          const timeInput = args[1].toLowerCase();
          const action = args[2].toLowerCase();
          if (!['ban', 'adv'].includes(action)) {
            return reply("‚ùå A√ß√£o inv√°lida! Use 'ban' para banimento direto ou 'adv' para advert√™ncias.");
          }
          let intervalSeconds;
          const timeMatch = timeInput.match(/^(\d+)(s|m|h)$/);
          if (!timeMatch) {
            return reply("‚ùå Tempo inv√°lido! Use formatos como 20s, 1m ou 2h.");
          }
          const timeValue = parseInt(timeMatch[1]);
          const timeUnit = timeMatch[2];
          if (timeUnit === 's') {
            intervalSeconds = timeValue;
          } else if (timeUnit === 'm') {
            intervalSeconds = timeValue * 60;
          } else if (timeUnit === 'h') {
            intervalSeconds = timeValue * 3600;
          }
          if (isNaN(limit) || limit <= 0) {
            return reply("‚ùå Quantidade de mensagens deve ser um n√∫mero positivo!");
          }
          
          groupData.messageLimit = {
            enabled: true,
            limit: limit,
            interval: intervalSeconds,
            action: action,
            warnings: groupData.messageLimit?.warnings || {},
            users: groupData.messageLimit?.users || {}
          };
          fs.writeFileSync(groupFile, JSON.stringify(groupData, null, 2));
          const actionText = action === 'ban' ? 'banimento direto' : 'advert√™ncias (ban ap√≥s 3)';
          await reply(`‚úÖ Limite de mensagens configurado: ${limit} mensagens a cada ${timeInput} com ${actionText}!`);
        } catch (e) {
          console.error('Erro no comando limitmessage:', e);
          await reply("‚ùå Ocorreu um erro interno. Tente novamente em alguns minutos.");
        }
        break;
      case 'dellimitmessage':
        try {
          if (!isGroup) return reply("Este comando s√≥ funciona em grupos üíî");
          if (!isGroupAdmin) return reply("Apenas administradores podem usar este comando üö´");
          if (!groupData.messageLimit?.enabled) {
            return reply("üì¥ O limite de mensagens n√£o est√° ativo neste grupo.");
          }
          delete groupData.messageLimit;
          fs.writeFileSync(groupFile, JSON.stringify(groupData, null, 2));
          await reply("üóëÔ∏è Sistema de limite de mensagens desativado com sucesso!");
        } catch (e) {
          console.error('Erro no comando dellimitmessage:', e);
          await reply("‚ùå Ocorreu um erro interno. Tente novamente em alguns minutos.");
        }
        break;
      case 'setprefix':
        try {
          if (!isGroup) return reply("Este comando s√≥ funciona em grupos.");
          if (!isGroupAdmin) return reply("Apenas administradores podem alterar o prefixo.");
          if (!q) return reply(`Por favor, forne√ßa o novo prefixo. Exemplo: ${groupPrefix}setprefix !`);
          let newPrefix = q.trim();
          
          // Bloqueia o uso de $ como prefixo e converte automaticamente para /
          if (newPrefix === '$') {
            newPrefix = '/';
            await reply(`‚ö†Ô∏è O s√≠mbolo "$" √© reservado e n√£o pode ser usado como prefixo.\n‚úÖ Prefixo alterado automaticamente para "/" neste grupo!`);
          }
          
          if (newPrefix.length > 1) {
            return reply("ü§î O prefixo deve ter no m√°ximo 1 digito.");
          }
          if (newPrefix.includes(' ')) {
            return reply("ü§î O prefixo n√£o pode conter espa√ßos.");
          }
          
          groupData.customPrefix = newPrefix;
          fs.writeFileSync(groupFile, JSON.stringify(groupData, null, 2));
          
          // Se n√£o foi convertido, envia mensagem normal
          if (newPrefix !== '/') {
            await reply(`‚úÖ Prefixo do bot alterado para "${newPrefix}" neste grupo!`);
          }
        } catch (e) {
          console.error('Erro no comando setprefix:', e);
          await reply("Ocorreu um erro ao alterar o prefixo üíî");
        }
        break;
      case 'antiflood':
        try {
          if (!isGroup) return reply("Isso s√≥ pode ser usado em grupo üíî");
          if (!isGroupAdmin) return reply("Voc√™ precisa ser adm üíî");
          if (!q) return reply(`Digite o intervalo em segundos ou "off" para desativar.\nExemplo: ` + prefix + `antiflood 5`);
          antifloodData[from] = antifloodData[from] || {
            users: {}
          };
          if (q.toLowerCase() === 'off') {
            antifloodData[from].enabled = false;
            delete antifloodData[from].interval;
          } else {
            const interval = parseInt(q);
            if (isNaN(interval) || interval < 1) return reply('Intervalo inv√°lido! Use um n√∫mero maior que 0 ou "off".');
            antifloodData[from].enabled = true;
            antifloodData[from].interval = interval;
          }
          fs.writeFileSync(pathz.join(DATABASE_DIR, 'antiflood.json'), JSON.stringify(antifloodData, null, 2));
          await reply(`‚úÖ Antiflood ${antifloodData[from].enabled ? `ativado com intervalo de ${antifloodData[from].interval} segundos` : 'desativado'}!`);
        } catch (e) {
          console.error(e);
          await reply("Ocorreu um erro üíî");
        }
        break;
      case 'antispamcmd':
        try {
          if (!isOwner) return reply('Somente o dono pode usar este comando.');
          const filePath = DATABASE_DIR + '/antispam.json';
          const cfg = antiSpamGlobal || {};
          const usage = `Uso:
${prefix}antispamcmd on <limite> <intervalo_s> <bloqueio_s>
${prefix}antispamcmd off
${prefix}antispamcmd status
Exemplos:
‚Ä¢ ${prefix}antispamcmd on 5 10 600
‚Ä¢ ${prefix}antispamcmd off`;
          if (!q) return reply(usage);
          const parts = q.trim().split(/\s+/);
          const sub = parts[0].toLowerCase();
          if (sub === 'status') {
            const enabled = cfg.enabled ? '‚úÖ ON' : '‚ùå OFF';
            const limit = cfg.limit || 5; const interval = cfg.interval || 10; const block = cfg.blockTime || 600;
            const blockedNow = Object.values(cfg.blocks||{}).filter(b=>Date.now() < (b.until||0)).length;
            return reply(`üõ°Ô∏è AntiSpam Global: ${enabled}
‚Ä¢ Limite: ${limit} cmds
‚Ä¢ Janela: ${interval}s
‚Ä¢ Bloqueio: ${Math.floor(block/60)}m
‚Ä¢ Bloqueados agora: ${blockedNow}`);
          }
          if (sub === 'off') {
            cfg.enabled = false;
            writeJsonFile(filePath, cfg);
            return reply('‚úÖ AntiSpam Global desativado.');
          }
          if (sub === 'on') {
            const limit = parseInt(parts[1]);
            const interval = parseInt(parts[2]);
            const block = parseInt(parts[3]);
            if ([limit, interval, block].some(v => isNaN(v) || v <= 0)) {
              return reply('Valores inv√°lidos. ' + usage);
            }
            cfg.enabled = true;
            cfg.limit = limit;
            cfg.interval = interval;
            cfg.blockTime = block;
            cfg.users = cfg.users || {};
            cfg.blocks = cfg.blocks || {};
            writeJsonFile(filePath, cfg);
            return reply(`‚úÖ AntiSpam Global ativado!
‚Ä¢ Limite: ${limit} cmds em ${interval}s
‚Ä¢ Bloqueio: ${Math.floor(block/60)} min`);
          }
          return reply('Op√ß√£o inv√°lida.\n' + usage);
        } catch (e) {
          console.error('Erro em antispamcmd:', e);
          await reply('Ocorreu um erro ao configurar o AntiSpam.');
        }
        break;
      case 'antiloc':
        try {
          if (!isGroup) return reply("Isso s√≥ pode ser usado em grupo üíî");
          if (!isGroupAdmin) return reply("Voc√™ precisa ser adm üíî");
          if (!isBotAdmin) return reply("Eu preciso ser adm para isso üíî");
          
          groupData.antiloc = !groupData.antiloc;
          writeJsonFile(groupFile, groupData);
  // Otimiza√ß√£o: Invalida cache quando groupData √© salvo
  if (isGroup) {
    optimizer.invalidateGroup(from);
  }
          await reply(`‚úÖ Antiloc ${groupData.antiloc ? 'ativado' : 'desativado'}! Localiza√ß√µes enviadas resultar√£o em banimento.`);
        } catch (e) {
          console.error(e);
          await reply("Ocorreu um erro üíî");
        }
        break;
      case 'modobrincadeira':
      case 'modobrincadeiras':
      case 'modobn':
      case 'gamemode':
        try {
          if (!isGroup) return reply("isso so pode ser usado em grupo üíî");
          if (!isGroupAdmin) return reply("voc√™ precisa ser adm üíî");
          const groupFilePath = buildGroupFilePath(from);
          if (!groupData.modobrincadeira || groupData.modobrincadeira === undefined) {
            
            groupData.modobrincadeira = true;
          } else {
            
            groupData.modobrincadeira = !groupData.modobrincadeira;
          }
          writeJsonFile(groupFilePath, groupData);
          if (groupData.modobrincadeira) {
            await reply('üéâ *Modo de Brincadeiras ativado!* Agora o grupo est√° no modo de brincadeiras. Divirta-se!');
          } else {
            await reply('‚ö†Ô∏è *Modo de Brincadeiras desativado!* O grupo n√£o est√° mais no modo de brincadeiras.');
          }
        } catch (e) {
          console.error(e);
          await reply("‚ùå Ocorreu um erro interno. Tente novamente em alguns minutos.");
        }
        break;
      case 'bemvindo':
      case 'bv':
      case 'boasvindas':
      case 'welcome':
        try {
          if (!isGroup) return reply("isso so pode ser usado em grupo üíî");
          if (!isGroupAdmin) return reply("voc√™ precisa ser adm üíî");
          const groupFilePath = buildGroupFilePath(from);
          if (!groupData.bemvindo || groupData.bemvindo === undefined) {
            
            groupData.bemvindo = true;
          } else {
            
            groupData.bemvindo = !groupData.bemvindo;
          }
          writeJsonFile(groupFilePath, groupData);
          if (groupData.bemvindo) {
            await reply(`‚úÖ *Boas-vindas ativadas!* Agora, novos membros ser√£o recebidos com uma mensagem personalizada.\nüìù Para configurar a mensagem, use: *${prefixo}legendabv*`);
          } else {
            await reply('‚ö†Ô∏è *Boas-vindas desativadas!* O grupo n√£o enviar√° mais mensagens para novos membros.');
          }
        } catch (e) {
          console.error(e);
          await reply("‚ùå Ocorreu um erro interno. Tente novamente em alguns minutos.");
        }
        break;
      case 'banghost':  //corrigido por kauan revil
        try {
          if (!isGroup) return reply("‚ùå S√≥ pode ser usado em grupos.");
          if (!isGroupAdmin) return reply("‚ùå Apenas administradores.");
          if (!isBotAdmin) return reply("‚ùå Preciso ser administrador.");
          const limite = parseInt(q);
          if (isNaN(limite) || limite < 0) return reply("‚ö†Ô∏è Use um n√∫mero v√°lido. Ex: " + prefix + "banghost 1");
          const arquivoGrupo = `${GRUPOS_DIR}/${from}.json`;
          if (!fs.existsSync(arquivoGrupo)) return reply("üìÇ Sem dados de mensagens.");
          let dados = JSON.parse(fs.readFileSync(arquivoGrupo))
          let contador = dados.contador
          if (!Array.isArray(contador)) return reply("‚ö†Ô∏è Contador n√£o dispon√≠vel.")
          const currentMembers = AllgroupMembers
          const contadorMap = new Map()
          contador.forEach(user => contadorMap.set(user.id, user))
          let updatedContador = []
          let validUsers = []
          const now = new Date().toISOString()
          currentMembers.forEach(memberId => {
            if (contadorMap.has(memberId)) {
              const existingUser = contadorMap.get(memberId);
              validUsers.push(existingUser);
              updatedContador.push(existingUser);
            } else {
              const newUser = {
                id: memberId,
                msg: 0,
                cmd: 0,
                figu: 0,
                pushname: 'null', 
                firstSeen: now,
                lastActivity: now
              };
              validUsers.push(newUser);
              updatedContador.push(newUser);
            }
          });
          const admins = groupAdmins || [];
          const fantasmas = validUsers.filter(u => (u.msg || 0) <= limite && !admins.includes(u.id) && u.id !== botNumber && u.id !== sender && u.id !== nmrdn).map(u => u.id)
          if (!fantasmas.length) return reply(`üéâ Nenhum fantasma com at√© ${limite} msg.`);
          
          let removidos = 0;
          try {
            await nazu.groupParticipantsUpdate(from, fantasmas, 'remove');
            removidos = fantasmas.length;
            
            // Atualiza o contador removendo os usu√°rios banidos
            dados.contador = updatedContador.filter(u => !fantasmas.includes(u.id));
            fs.writeFileSync(arquivoGrupo, JSON.stringify(dados, null, 2));
          } catch (e) {
            console.error("Erro ao remover:", e);
          }
          
          reply(removidos === 0 ? `‚ö†Ô∏è Nenhum fantasma p√¥de ser removido com at√© ${limite} msg.` : `‚úÖ ${removidos} fantasma(s) removido(s).`);
        } catch (e) {
          console.error("Erro no banghost:", e);
          reply("üí• Erro ao tentar remover fantasmas.");
        }
        break;
      case 'fotobv':
      case 'welcomeimg':
        {
          if (!isGroup) return reply("isso so pode ser usado em grupo üíî");
          if (!isGroupAdmin) return reply("voc√™ precisa ser adm üíî");
          if (!isQuotedImage && !isImage) return reply(`‚ùå Marque uma imagem ou envie uma imagem com o comando.`);
          try {
            if (isQuotedImage || isImage) {
              const imgMessage = isQuotedImage ? info.message.extendedTextMessage.contextInfo.quotedMessage.imageMessage : info.message.imageMessage;
              const media = await getFileBuffer(imgMessage, 'image');
              const uploadResult = await upload(media);
              if (!uploadResult) throw new Error('Falha ao fazer upload da imagem');
              if (!groupData.welcome) {
                
                groupData.welcome = {};
              }
              
              groupData.welcome.image = uploadResult;
                writeJsonFile(buildGroupFilePath(from), groupData);
              await reply('‚úÖ Foto de boas-vindas configurada com sucesso!');
            } else if (q.trim().toLowerCase().normalize('NFD').replace(/[\u0300-\u036f]/g, '') === 'banner') {
              if (!groupData.welcome) {
                
                groupData.welcome = {};
              }
              
                groupData.welcome.image = 'banner';
                writeJsonFile(buildGroupFilePath(from), groupData);
              await reply('‚úÖ Foto de boas-vindas configurada com sucesso!');
            } else {
              await reply(`‚ùå Marque uma imagem ou envie uma imagem com o comando.`);
            }
          } catch (error) {
            console.error(error);
            reply("ocorreu um erro üíî");
          }
        }
        break;
      case 'fotosaida':
      case 'fotosaiu':
      case 'imgsaiu':
      case 'exitimg':
        {
          if (!isGroup) return reply("isso so pode ser usado em grupo üíî");
          if (!isGroupAdmin) return reply("voc√™ precisa ser adm üíî");
          if (!isQuotedImage && !isImage) return reply('‚ùå Marque uma imagem ou envie uma imagem com o comando!');
          try {
            const media = await getFileBuffer(isQuotedImage ? info.message.extendedTextMessage.contextInfo.quotedMessage.imageMessage : info.message.imageMessage, 'image');
            const uploadResult = await upload(media);
            if (!uploadResult) throw new Error('Falha ao fazer upload da imagem');
            if (!groupData.exit) {
              
              groupData.exit = {};
            }
            
            groupData.exit.image = uploadResult;
            writeJsonFile(buildGroupFilePath(from), groupData);
            await reply('‚úÖ Foto de sa√≠da configurada com sucesso!');
          } catch (error) {
            console.error(error);
            reply("ocorreu um erro üíî");
          }
        }
        break;
      case 'limpar':
      case 'clean':
        try {
          if (!isGroup) return reply("Isso s√≥ pode ser usado em grupo üíî");
          if (!isGroupAdmin) return reply("Voc√™ precisa ser adm üíî");
          if (!isBotAdmin) return reply("Eu preciso ser adm para isso üíî");
          const linhasEmBranco = Array(500).fill('‚Äé ').join('\n');
          const mensagem = `${linhasEmBranco}\nüßπ Limpeza conclu√≠da!`;
          await reply(mensagem);
        } catch (e) {
          console.error(e);
          await reply("Ocorreu um erro ao limpar o chat üíî");
        }
        break;
      case 'antibanmarcar':
      case 'protecaomarcar':
        try {
          if (!isOwner) return reply(OWNER_ONLY_MESSAGE);
          if (!isGroup) return reply("Isso s√≥ pode ser usado em grupo üíî");
          
          const config = loadMassMentionConfig();
          const args = q.split(' ');
          const action = args[0]?.toLowerCase();
          
          if (action === 'on' || action === 'ativar' || action === '1') {
            if (!config[from]) config[from] = {};
            config[from].enabled = true;
            saveMassMentionConfig(config);
            reply(`‚úÖ *Prote√ß√£o Anti-Ban ativada!*\n\nComandos de marca√ß√£o em massa (marcar, hidetag, etc) agora ter√£o limite de ${MASS_MENTION_MAX_USES} usos a cada 5 horas neste grupo.\n\nüí° Isso ajuda a evitar banimento do n√∫mero pela Meta em grupos com 150+ membros.`);
          } else if (action === 'off' || action === 'desativar' || action === '0') {
            if (config[from]) {
              config[from].enabled = false;
              saveMassMentionConfig(config);
              reply('‚úÖ *Prote√ß√£o Anti-Ban desativada!*\n\nComandos de marca√ß√£o em massa voltaram ao normal.');
            } else {
              reply('‚ùå A prote√ß√£o j√° est√° desativada.');
            }
          } else if (action === 'status' || action === 'ver') {
            const isEnabled = config[from]?.enabled || false;
            const memberCount = AllgroupMembers?.length || 0;
            let statusMsg = `üìä *Status da Prote√ß√£o Anti-Ban*\n\n`;
            statusMsg += `üîí Status: ${isEnabled ? '‚úÖ Ativa' : '‚ùå Desativada'}\n`;
            statusMsg += `üë• Membros no grupo: ${memberCount}\n`;
            statusMsg += `‚ö†Ô∏è Limite aplicado: ${memberCount >= MASS_MENTION_THRESHOLD ? 'Sim (150+ membros)' : 'N√£o (menos de 150)'}\n\n`;
            
            if (isEnabled && memberCount >= MASS_MENTION_THRESHOLD) {
              const limitData = loadMassMentionLimit();
              if (limitData[from]?.uses?.length > 0) {
                const usesLeft = MASS_MENTION_MAX_USES - limitData[from].uses.length;
                statusMsg += `üìù Usos restantes: ${usesLeft}/${MASS_MENTION_MAX_USES}\n`;
              } else {
                statusMsg += `üìù Usos restantes: ${MASS_MENTION_MAX_USES}/${MASS_MENTION_MAX_USES}\n`;
              }
            }
            
            statusMsg += `\nüí° Comandos afetados: marcar, hidetag, divulgar, etc.`;
            reply(statusMsg);
          } else {
            reply(`‚ùå Uso incorreto!\n\n*Op√ß√µes:*\n‚Ä¢ ${prefix}antibanmarcar on - Ativar prote√ß√£o\n‚Ä¢ ${prefix}antibanmarcar off - Desativar prote√ß√£o\n‚Ä¢ ${prefix}antibanmarcar status - Ver status`);
          }
        } catch (e) {
          console.error(e);
          reply("Ocorreu um erro üíî");
        }
        break;
      case 'removerfotobv':
      case 'rmfotobv':
      case 'delfotobv':
      case 'rmwelcomeimg':
        try {
          if (!isGroup) return reply("Isso s√≥ pode ser usado em grupo üíî");
          if (!isGroupAdmin) return reply("Voc√™ precisa ser administrador üíî");
          const groupFilePath = buildGroupFilePath(from);
          let groupData = fs.existsSync(groupFilePath) ? JSON.parse(fs.readFileSync(groupFilePath)) : {
            welcome: {}
          };
          if (!groupData.welcome?.image) return reply("‚ùå N√£o h√° imagem de boas-vindas configurada.");
          delete groupData.welcome.image;
          fs.writeFileSync(groupFilePath, JSON.stringify(groupData, null, 2));
          reply("‚úÖ A imagem de boas-vindas foi removida com sucesso!");
        } catch (e) {
          console.error(e);
          reply("Ocorreu um erro üíî");
        }
        break;
      case 'removerfotosaiu':
      case 'rmfotosaiu':
      case 'delfotosaiu':
      case 'rmexitimg':
        try {
          if (!isGroup) return reply("Isso s√≥ pode ser usado em grupo üíî");
          if (!isGroupAdmin) return reply("Voc√™ precisa ser administrador üíî");
          const groupFilePath = buildGroupFilePath(from);
          let groupData = fs.existsSync(groupFilePath) ? JSON.parse(fs.readFileSync(groupFilePath)) : {
            exit: {}
          };
          if (!groupData.exit?.image) return reply("‚ùå N√£o h√° imagem de sa√≠da configurada.");
          delete groupData.exit.image;
          fs.writeFileSync(groupFilePath, JSON.stringify(groupData, null, 2));
          reply("‚úÖ A imagem de sa√≠da foi removida com sucesso!");
        } catch (e) {
          console.error(e);
          reply("Ocorreu um erro üíî");
        }
        break;
      case 'configsaida':
      case 'textsaiu':
      case 'legendasaiu':
      case 'exitmsg':
        {
          if (!isGroup) return reply("isso so pode ser usado em grupo üíî");
          if (!isGroupAdmin) return reply("voc√™ precisa ser adm üíî");
          if (!q) return reply(`üìù Para configurar a mensagem de sa√≠da, use:\n${prefix}${command} <mensagem>\n\nVoc√™ pode usar:\n#numerodele# - Menciona quem saiu\n#nomedogp# - Nome do grupo\n#membros# - Total de membros\n#desc# - Descri√ß√£o do grupo`);
          try {
            if (!groupData.exit) {
              
              groupData.exit = {};
            }
            
            groupData.exit.enabled = true;
            
            groupData.exit.text = q;
            fs.writeFileSync(buildGroupFilePath(from), JSON.stringify(groupData, null, 2));
            await reply('‚úÖ Mensagem de sa√≠da configurada com sucesso!\n\nüìù Mensagem definida como:\n' + q);
          } catch (error) {
            console.error(error);
            await reply("‚ùå Ocorreu um erro interno. Tente novamente em alguns minutos.");
          }
        }
        break;
      case 'saida':
      case 'exit':
        {
          if (!isGroup) return reply("isso so pode ser usado em grupo üíî");
          if (!isGroupAdmin) return reply("voc√™ precisa ser adm üíî");
          try {
            if (!groupData.exit) {
              
              groupData.exit = {};
            }
            
            groupData.exit.enabled = !groupData.exit.enabled;
            fs.writeFileSync(buildGroupFilePath(from), JSON.stringify(groupData, null, 2));
            await reply(groupData.exit.enabled ? '‚úÖ Mensagens de sa√≠da ativadas!' : '‚ùå Mensagens de sa√≠da desativadas!');
          } catch (error) {
            console.error(error);
            await reply("‚ùå Ocorreu um erro interno. Tente novamente em alguns minutos.");
          }
        }
        break;
      case 'parcerias':
      case 'partnerships':
        try {
          if (!isGroup) return reply("Este comando s√≥ funciona em grupos.");
          if (!isGroupAdmin) return reply("Apenas administradores podem usar este comando.");
          if (!parceriasData.active) {
            return reply("O sistema de parcerias n√£o est√° ativo neste grupo.");
          }
          if (Object.keys(parceriasData.partners).length === 0) {
            return reply("N√£o h√° parcerias ativas neste grupo.");
          }
          let message = "üìã *Lista de Parcerias Ativas* üìã\n\n";
          for (const [userId, data] of Object.entries(parceriasData.partners)) {
            
            message += `üë§ @${getUserName(userId)} - Limite: ${data.limit} links | Enviados: ${data.count}\n`;
          }
          await reply(message, {
            mentions: Object.keys(parceriasData.partners)
          });
        } catch (e) {
          console.error('Erro no comando parcerias:', e);
          await reply("Ocorreu um erro ao listar as parcerias üíî");
        }
        break;
      case 'addparceria':
      case 'addpartnership':
        try {
          if (!isGroup) return reply("Este comando s√≥ funciona em grupos.");
          if (!isGroupAdmin) return reply("Apenas administradores podem usar este comando.");
          if (!q) return reply(`Uso: ${prefix}addparceria @usu√°rio limite ou marcando uma mensagem com ${prefix}addparceria limite`);
          let userId, limit;
          if (menc_os2) {
            
            userId = menc_os2;
            
            limit = parseInt(args[1]);
          } else if (isQuotedMsg) {
            
            userId = info.message.extendedTextMessage.contextInfo.participant;
            
            limit = parseInt(q);
          } else {
            return reply("Por favor, marque um usu√°rio ou responda a uma mensagem.");
          }
          if (!userId || isNaN(limit) || limit < 1) {
            return reply("Uso inv√°lido. Certifique-se de marcar um usu√°rio e especificar um limite v√°lido (n√∫mero maior que 0).");
          }
          // Normaliza o ID do usu√°rio para LID antes de salvar (aceita JID ou LID)
          const userIdLid = await getLidFromJidCached(nazu, userId);
          if (!AllgroupMembers.includes(userIdLid)) {
            return reply(`@${getUserName(userId)} n√£o est√° no grupo.`, {
              mentions: [userId]
            });
          }
          parceriasData.partners[userIdLid] = {
            limit,
            count: 0
          };
          saveParceriasData(from, parceriasData);
          await reply(`‚úÖ @${getUserName(userId)} foi adicionado como parceiro com limite de ${limit} links de grupos.`, {
            mentions: [userIdLid]
          });
        } catch (e) {
          console.error('Erro no comando addparceria:', e);
          await reply("Ocorreu um erro ao adicionar a parceria üíî");
        }
        break;
      case 'delparceria':
      case 'delpartnership':
        try {
          if (!isGroup) return reply("Este comando s√≥ funciona em grupos.");
          if (!isGroupAdmin) return reply("Apenas administradores podem usar este comando.");
          let userId;
          if (menc_os2) {
            userId = menc_os2;
          } else if (isQuotedMsg) {
            userId = info.message.extendedTextMessage.contextInfo.participant;
          } else {
            return reply("Por favor, marque um usu√°rio ou responda a uma mensagem.");
          }
          // Normaliza para LID e busca no map
          const userIdLid = await getLidFromJidCached(nazu, userId);
          if (!parceriasData.partners[userIdLid]) {
            return reply(`@${getUserName(userId)} n√£o √© um parceiro.`, {
              mentions: [userIdLid]
            });
          }
          delete parceriasData.partners[userId];
          saveParceriasData(from, parceriasData);
          await reply(`‚úÖ @${getUserName(userId)} n√£o √© mais um parceiro.`, {
            mentions: [userIdLid]
          });
        } catch (e) {
          console.error('Erro no comando delparceria:', e);
          await reply("Ocorreu um erro ao remover a parceria üíî");
        }
        break;
      case 'modoparceria':
        try {
          if (!isGroup) return reply("Este comando s√≥ funciona em grupos.");
          if (!isGroupAdmin) return reply("Apenas administradores podem usar este comando.");
          parceriasData.active = !parceriasData.active;
          saveParceriasData(from, parceriasData);
          await reply(`‚úÖ Sistema de parcerias ${parceriasData.active ? 'ativado' : 'desativado'} com sucesso!`);
        } catch (e) {
          console.error('Erro no comando modoparceria:', e);
          await reply("Ocorreu um erro ao alterar o modo de parcerias üíî");
        }
        break;
      case 'antifig':
        try {
          if (!isGroup) return reply("Este comando s√≥ funciona em grupos.");
          if (!isGroupAdmin) return reply("Apenas administradores podem gerenciar o antifig.");
          
          groupData.antifig = groupData.antifig || {};
          
          groupData.antifig.enabled = !groupData.antifig.enabled;
          fs.writeFileSync(groupFile, JSON.stringify(groupData, null, 2));
          const status = groupData.antifig.enabled ? "ativado" : "desativado";
          await reply(`‚úÖ Antifig ${status}! Figurinhas ${groupData.antifig.enabled ? "ser√£o apagadas e o remetente receber√° advert√™ncias" : "agora s√£o permitidas"}.`);
        } catch (e) {
          console.error('Erro no comando antifig:', e);
          await reply("Ocorreu um erro ao gerenciar o antifig üíî");
        }
        break;
      case 'addblacklist':
      case 'blacklist':
        try {
          if (!isGroup) return reply("Isso s√≥ pode ser usado em grupo üíî");
          if (!isGroupAdmin) return reply("Voc√™ precisa ser administrador üíî");
          let targetUser = menc_os2 || null;
          if (!targetUser && q && q.trim()) {
            const firstArg = q.trim().split(/\s+/)[0];
            if ((isValidJid(firstArg) || isValidLid(firstArg)) && firstArg.includes('@')) {
              targetUser = firstArg;
            } else {
              const cleanNumber = firstArg.replace(/\D/g, '');
              if (cleanNumber.length >= 10) {
                const candidateJid = buildUserId(cleanNumber, config);
                if (groupMetadata?.participants) {
                  const participant = groupMetadata.participants.find(p => p.id === candidateJid || p.lid === candidateJid || (p.lid && p.lid.includes(cleanNumber)));
                  if (participant?.lid) targetUser = participant.lid;
                  else if (participant?.id) targetUser = participant.id;
                }
                if (!targetUser) {
                  try {
                    const lid = await getLidFromJidCached(nazu, candidateJid);
                    targetUser = lid && lid.includes('@lid') ? lid : candidateJid;
                  } catch (err) {
                    targetUser = candidateJid;
                  }
                }
              }
            }
          }
          if (!targetUser) return reply(`Marque o usu√°rio ou forne√ßa o n√∫mero (ex: ${prefix}addblacklist 5511999998888 motivo).`);
          const reason = args.length > 1 ? args.slice(1).join(' ') : "Motivo n√£o informado";
          const groupFilePath = buildGroupFilePath(from);
          let groupData = fs.existsSync(groupFilePath) ? JSON.parse(fs.readFileSync(groupFilePath)) : {
            blacklist: {}
          };
          
          groupData.blacklist = groupData.blacklist || {};
          if (groupData.blacklist[targetUser]) return reply("‚ùå Este usu√°rio j√° est√° na blacklist.");
          
          groupData.blacklist[targetUser] = {
            reason,
            timestamp: Date.now()
          };
          fs.writeFileSync(groupFilePath, JSON.stringify(groupData, null, 2));
          reply(`‚úÖ @${getUserName(targetUser)} foi adicionado √† blacklist.\nMotivo: ${reason}`, {
            mentions: [targetUser]
          });
        } catch (e) {
          console.error(e);
          reply("Ocorreu um erro üíî");
        }
        break;
      case 'delblacklist':
      case 'unblacklist':
        try {
          if (!isGroup) return reply("Isso s√≥ pode ser usado em grupo üíî");
          if (!isGroupAdmin) return reply("Voc√™ precisa ser administrador üíî");
          let targetUser = menc_os2 || null;
          if (!targetUser && q && q.trim()) {
            const firstArg = q.trim().split(/\s+/)[0];
            if ((isValidJid(firstArg) || isValidLid(firstArg)) && firstArg.includes('@')) {
              targetUser = firstArg;
            } else {
              const cleanNumber = firstArg.replace(/\D/g, '');
              if (cleanNumber.length >= 10) {
                const candidateJid = buildUserId(cleanNumber, config);
                if (groupMetadata?.participants) {
                  const participant = groupMetadata.participants.find(p => p.id === candidateJid || p.lid === candidateJid || (p.lid && p.lid.includes(cleanNumber)));
                  if (participant?.lid) targetUser = participant.lid;
                  else if (participant?.id) targetUser = participant.id;
                }
                if (!targetUser) {
                  try {
                    const lid = await getLidFromJidCached(nazu, candidateJid);
                    targetUser = lid && lid.includes('@lid') ? lid : candidateJid;
                  } catch (err) {
                    targetUser = candidateJid;
                  }
                }
              }
            }
          }
          if (!targetUser) return reply(`Marque o usu√°rio ou forne√ßa o n√∫mero (ex: ${prefix}delblacklist 5511999998888).`);
          const groupFilePath = buildGroupFilePath(from);
          let groupData = fs.existsSync(groupFilePath) ? JSON.parse(fs.readFileSync(groupFilePath)) : {
            blacklist: {}
          };
          
          groupData.blacklist = groupData.blacklist || {};
          if (!groupData.blacklist[targetUser]) return reply("‚ùå Este usu√°rio n√£o est√° na blacklist.");
          delete groupData.blacklist[targetUser];
          fs.writeFileSync(groupFilePath, JSON.stringify(groupData, null, 2));
          reply(`‚úÖ @${getUserName(targetUser)} foi removido da blacklist.`, {
            mentions: [targetUser]
          });
        } catch (e) {
          console.error(e);
          reply("Ocorreu um erro üíî");
        }
        break;
      case 'listblacklist':
        try {
          if (!isGroup) return reply("Isso s√≥ pode ser usado em grupo üíî");
          if (!isGroupAdmin) return reply("Voc√™ precisa ser administrador üíî");
          const groupFilePath = buildGroupFilePath(from);
          let groupData = fs.existsSync(groupFilePath) ? JSON.parse(fs.readFileSync(groupFilePath)) : {
            blacklist: {}
          };
          
          groupData.blacklist = groupData.blacklist || {};
          if (Object.keys(groupData.blacklist).length === 0) return reply("üìã A blacklist est√° vazia.");
          let text = "üìã *Lista de Usu√°rios na Blacklist*\n\n";
          for (const [user, data] of Object.entries(groupData.blacklist)) {
            text += `üë§ @${getUserName(user)}\nüìù Motivo: ${data.reason}\nüïí Adicionado em: ${new Date(data.timestamp).toLocaleString('pt-BR', { timeZone: 'America/Sao_Paulo' })}\n\n`;
          }
          reply(text, {
            mentions: Object.keys(groupData.blacklist)
          });
        } catch (e) {
          console.error(e);
          reply("Ocorreu um erro üíî");
        }
        break;
      case 'adv':
      case 'advertir':
      case 'warning':
        try {
          if (!isGroup) return reply("Isso s√≥ pode ser usado em grupo üíî");
          if (!isGroupAdmin) return reply("Voc√™ precisa ser administrador üíî");
          if (!menc_os2) return reply("Marque um usu√°rio üôÑ");
          if (menc_os2 === botNumber) return reply("‚ùå N√£o posso advertir a mim mesma!");
          const reason = q.includes(' ') ? q.split(' ').slice(1).join(' ') : "Motivo n√£o informado";
          const groupFilePath = buildGroupFilePath(from);
          let groupData = fs.existsSync(groupFilePath) ? JSON.parse(fs.readFileSync(groupFilePath)) : {
            warnings: {}
          };
          
          groupData.warnings = groupData.warnings || {};
          
          groupData.warnings[menc_os2] = groupData.warnings[menc_os2] || [];
          groupData.warnings[menc_os2].push({
            reason,
            timestamp: Date.now(),
            issuer: sender
          });
          const warningCount = groupData.warnings[menc_os2].length;
          fs.writeFileSync(groupFilePath, JSON.stringify(groupData, null, 2));
          if (warningCount >= 3) {
            await nazu.groupParticipantsUpdate(from, [menc_os2], 'remove');
            delete groupData.warnings[menc_os2];
            fs.writeFileSync(groupFilePath, JSON.stringify(groupData, null, 2));
            reply(`üö´ @${getUserName(menc_os2)} recebeu 3 advert√™ncias e foi banido!\n√öltima advert√™ncia: ${reason}`, {
              mentions: [menc_os2]
            });
          } else {
            reply(`‚ö†Ô∏è @${getUserName(menc_os2)} recebeu uma advert√™ncia (${warningCount}/3).\nMotivo: ${reason}`, {
              mentions: [menc_os2]
            });
          }
        } catch (e) {
          console.error(e);
          reply("Ocorreu um erro üíî");
        }
        break;
      case 'removeradv':
      case 'rmadv':
      case 'unwarning':
        try {
          if (!isGroup) return reply("Isso s√≥ pode ser usado em grupo üíî");
          if (!isGroupAdmin) return reply("Voc√™ precisa ser administrador üíî");
          if (!menc_os2) return reply("Marque um usu√°rio üôÑ");
          const groupFilePath = buildGroupFilePath(from);
          let groupData = fs.existsSync(groupFilePath) ? JSON.parse(fs.readFileSync(groupFilePath)) : {
            warnings: {}
          };
          
          groupData.warnings = groupData.warnings || {};
          if (!groupData.warnings[menc_os2] || groupData.warnings[menc_os2].length === 0) return reply("‚ùå Este usu√°rio n√£o tem advert√™ncias.");
          groupData.warnings[menc_os2].pop();
          if (groupData.warnings[menc_os2].length === 0) delete groupData.warnings[menc_os2];
          fs.writeFileSync(groupFilePath, JSON.stringify(groupData, null, 2));
          reply(`‚úÖ Uma advert√™ncia foi removida de @${getUserName(menc_os2)}. Advert√™ncias restantes: ${groupData.warnings[menc_os2]?.length || 0}/3`, {
            mentions: [menc_os2]
          });
        } catch (e) {
          console.error(e);
          reply("Ocorreu um erro üíî");
        }
        break;
      case 'listadv':
      case 'warninglist':
        try {
          if (!isGroup) return reply("Isso s√≥ pode ser usado em grupo üíî");
          if (!isGroupAdmin) return reply("Voc√™ precisa ser administrador üíî");
          const groupFilePath = buildGroupFilePath(from);
          let groupData = fs.existsSync(groupFilePath) ? JSON.parse(fs.readFileSync(groupFilePath)) : {
            warnings: {}
          };
          
          groupData.warnings = groupData.warnings || {};
          if (Object.keys(groupData.warnings).length === 0) return reply("üìã N√£o h√° advert√™ncias ativas no grupo.");
          let text = "üìã *Lista de Advert√™ncias*\n\n";
          for (const [user, warnings] of Object.entries(groupData.warnings)) {
            try {
              if (Array.isArray(warnings)) {
                text += `üë§ @${getUserName(user)} (${warnings.length}/3)\n`;
                warnings.forEach((warn, index) => {
                  text += `  ${index + 1}. Motivo: ${warn.reason}\n`;
                  text += `     Por: @${getUserName(warn.issuer)}\n`;
                  text += `     Em: ${new Date(warn.timestamp).toLocaleString('pt-BR', { timeZone: 'America/Sao_Paulo' })}\n`;
                });
                text += "\n";
              }
            } catch (e) {}
          }
          reply(text, {
            mentions: [...Object.keys(groupData.warnings), ...Object.values(groupData.warnings).flatMap(w => Array.isArray(w) ? w.map(warn => warn.issuer) : [])]
          });
        } catch (e) {
          console.error(e);
          reply("Ocorreu um erro üíî");
        }
        break;
      case 'suporte':
      case 'ticketsuporte':
      case 'suporteticket':
      case 'ticket':
        try {
          if (!isGroup) return reply('Use este comando no grupo para abrir um ticket.');

          const action = (args[0] || '').toLowerCase();
          const enableActions = ['on', 'ativar', 'ligar', 'enable'];
          const disableActions = ['off', 'desativar', 'desligar', 'disable'];

          if (enableActions.includes(action)) {
            if (!isGroupAdmin) return reply('Voc√™ precisa ser administrador üíî');
            setSupportMode(from, true);
            return reply('‚úÖ *Modo suporte ativado!* Agora membros podem solicitar tickets.');
          }

          if (disableActions.includes(action)) {
            if (!isGroupAdmin) return reply('Voc√™ precisa ser administrador üíî');
            setSupportMode(from, false);
            return reply('‚ö†Ô∏è *Modo suporte desativado!*');
          }

          const reason = q?.trim() || '';
          const createResult = createSupportTicket({
            groupId: from,
            groupName: groupName || null,
            userId: sender,
            userName: getUserName(sender),
            message: reason
          });

          if (!createResult.success) {
            if (createResult.existingTicket?.id) {
              return reply(`‚ö†Ô∏è Voc√™ j√° tem um ticket pendente: *${createResult.existingTicket.id}*`);
            }
            return reply(`‚ö†Ô∏è ${createResult.message || 'N√£o foi poss√≠vel criar o ticket.'}`);
          }

          const { ticket, ahead } = createResult;
          const aheadText = ahead > 0 ? `H√° ${ahead} ticket(s) na fila na sua frente.` : 'Voc√™ √© o pr√≥ximo da fila.';
          await reply(`‚úÖ Ticket criado! ID: *${ticket.id}*\n${aheadText}\nUm admin vai falar com voc√™ no privado.`);

          const userMention = `@${String(ticket.userId).split('@')[0]}`;
          const adminMessage =
            `üßæ *Novo Ticket de Suporte*\n\n` +
            `ID: *${ticket.id}*\n` +
            `Grupo: ${groupName || from}\n` +
            `Usu√°rio: ${userMention}\n` +
            (reason ? `Mensagem: ${reason}\n` : '') +
            `Fila: ${ahead} na frente\n\n` +
            `Para aceitar, envie no meu PV:\n${prefix}ticketaceitar ${ticket.id}`;

          const adminsToNotify = Array.isArray(groupAdmins) ? groupAdmins : [];
          for (const adminId of adminsToNotify) {
            await nazu.sendMessage(adminId, { text: adminMessage, mentions: [ticket.userId] }).catch(err => {
              console.error(`Erro ao notificar admin ${adminId}:`, err.message || err);
            });
          }
        } catch (e) {
          console.error(e);
          reply('Ocorreu um erro üíî');
        }
        break;
      case 'ticketaceitar':
      case 'aceitarticket':
      case 'suporteaceitar':
      case 'ticket.aceitar':
        try {
          if (isGroup) return reply('Use este comando no meu privado.');
          if (!q) return reply('Informe o ID do ticket.');

          const ticketId = q.trim().split(/\s+/)[0];
          const found = findSupportTicketById(ticketId);
          if (!found || !found.ticket) return reply('‚ùå Ticket n√£o encontrado.');

          const ticket = found.ticket;
          const groupMeta = await getCachedGroupMetadata(ticket.groupId).catch(() => null);
          if (!groupMeta || !groupMeta.participants) {
            return reply('‚ùå N√£o consegui validar o grupo deste ticket.');
          }

          const rawAdmins = groupMeta.participants
            .filter(p => p.admin === 'admin' || p.admin === 'superadmin' || p.admin === true)
            .map(p => p.lid || p.id)
            .filter(Boolean);

          const adminIds = await convertIdsToLid(nazu, rawAdmins);
          const isTicketAdmin = idInArray(sender, adminIds) || isOwner || isSubOwner;
          if (!isTicketAdmin) return reply('‚ùå Apenas admins do grupo podem aceitar este ticket.');

          const acceptResult = acceptSupportTicket(ticketId, sender);
          if (!acceptResult.success) {
            if (acceptResult.alreadyAccepted && acceptResult.ticket?.acceptedBy) {
              const acceptedBy = acceptResult.ticket.acceptedBy;
              const acceptedByMention = `@${String(acceptedBy).split('@')[0]}`;
              return reply(
                `‚ö†Ô∏è Ticket j√° aceito por ${acceptedByMention}.`,
                { mentions: [acceptedBy] }
              );
            }
            return reply(`‚ö†Ô∏è ${acceptResult.message || 'N√£o foi poss√≠vel aceitar o ticket.'}`);
          }

          const acceptedMention = `@${String(ticket.userId).split('@')[0]}`;
          return reply(
            `‚úÖ Ticket *${ticketId}* aceito!\n` +
            `Entre em contato manualmente com ${acceptedMention}.`,
            { mentions: [ticket.userId] }
          );
        } catch (e) {
          console.error(e);
          reply('Ocorreu um erro üíî');
        }
        break;
      case 'soadm':
      case 'onlyadm':
      case 'soadmin':
        try {
          if (!isGroup) return reply("isso so pode ser usado em grupo üíî");
          if (!isGroupAdmin) return reply("voc√™ precisa ser adm üíî");
          const groupFilePath = buildGroupFilePath(from);
          if (!groupData.soadm || groupData.soadm === undefined) {
            
            groupData.soadm = true;
          } else {
            
            groupData.soadm = !groupData.soadm;
          }
          fs.writeFileSync(groupFilePath, JSON.stringify(groupData));
          if (groupData.soadm) {
            await reply(`‚úÖ *Modo apenas adm ativado!* Agora apenas administrdores do grupo poderam utilizar o bot*`);
          } else {
            await reply('‚ö†Ô∏è *Modo apenas adm desativado!* Agora todos os membros podem utilizar o bot novamente.');
          }
        } catch (e) {
          console.error(e);
          reply("ocorreu um erro üíî");
        }
        break;
      case 'modolite':
      case 'litemode':
        try {
          if (!isGroup) return reply("Isso s√≥ pode ser usado em grupo üíî");
          if (!isGroupAdmin) return reply("Voc√™ precisa ser administrador üíî");
          const groupFilePath = buildGroupFilePath(from);
          if (!groupData.modolite) {
            
            groupData.modolite = true;
            if (groupData.hasOwnProperty('modoliteOff')) {
              delete groupData.modoliteOff;
            }
          } else {
            
            groupData.modolite = !groupData.modolite;
            if (!groupData.modolite) {
              
              groupData.modoliteOff = true;
            } else if (groupData.hasOwnProperty('modoliteOff')) {
              delete groupData.modoliteOff;
            }
          }
          fs.writeFileSync(groupFilePath, JSON.stringify(groupData, null, 2));
          if (groupData.modolite) {
            await reply('üë∂ *Modo Lite ativado!* O conte√∫do inapropriado para crian√ßas ser√° filtrado neste grupo.');
          } else {
            await reply('üîû *Modo Lite desativado!* O conte√∫do do menu de brincadeiras ser√° exibido completamente.');
          }
        } catch (e) {
          console.error(e);
          await reply("Ocorreu um erro üíî");
        }
        break;
      case 'modoliteglobal':
        try {
          if (!isOwner) return reply("Este comando √© apenas para o meu dono üíî");
          const modoLiteFile = MODO_LITE_FILE;
          modoLiteGlobal.status = !modoLiteGlobal.status;
          if (!modoLiteGlobal.status) {
            modoLiteGlobal.forceOff = true;
          } else if (modoLiteGlobal.hasOwnProperty('forceOff')) {
            delete modoLiteGlobal.forceOff;
          }
          fs.writeFileSync(modoLiteFile, JSON.stringify(modoLiteGlobal, null, 2));
          if (modoLiteGlobal.status) {
            await reply('üë∂ *Modo Lite ativado globalmente!* O conte√∫do inapropriado para crian√ßas ser√° filtrado em todos os grupos (a menos que seja explicitamente desativado em algum grupo).');
          } else {
            await reply('üîû *Modo Lite desativado globalmente!* O conte√∫do do menu de brincadeiras ser√° exibido completamente (a menos que seja explicitamente ativado em algum grupo).');
          }
        } catch (e) {
          console.error(e);
          await reply("Ocorreu um erro üíî");
        }
        break;
      case 'antilinkgp':
        try {
          if (!isGroup) return reply("isso so pode ser usado em grupo üíî");
          if (!isGroupAdmin) return reply("voc√™ precisa ser adm üíî");
          if (!isBotAdmin) return reply("Eu preciso ser adm üíî");
          const groupFilePath = __dirname + `/../database/grupos/${from}.json`;
          let groupData = fs.existsSync(groupFilePath) ? JSON.parse(fs.readFileSync(groupFilePath)) : {
            antilinkgp: false
          };
          
          groupData.antilinkgp = !groupData.antilinkgp;
          fs.writeFileSync(groupFilePath, JSON.stringify(groupData));
          const message = groupData.antilinkgp ? `‚úÖ *Antilinkgp foi ativado com sucesso!*\n\nAgora, se algu√©m enviar links de outros grupos, ser√° banido automaticamente. Mantenha o grupo seguro! üõ°Ô∏è` : `‚úÖ *Antilinkgp foi desativado.*\n\nLinks de outros grupos n√£o ser√£o mais bloqueados. Use com cuidado! ‚ö†Ô∏è`;
          reply(`${message}`);
        } catch (e) {
          console.error(e);
          reply("ocorreu um erro üíî");
        }
        break;
      case 'antilinkcanal':
      case 'antilinkch':
        try {
          if (!isGroup) return reply("isso so pode ser usado em grupo üíî");
          if (!isGroupAdmin) return reply("voc√™ precisa ser adm üíî");
          if (!isBotAdmin) return reply("Eu preciso ser adm üíî");
          const groupFilePath = __dirname + `/../database/grupos/${from}.json`;
          let groupData = fs.existsSync(groupFilePath) ? JSON.parse(fs.readFileSync(groupFilePath)) : {
            antilinkcanal: false
          };
          
          groupData.antilinkcanal = !groupData.antilinkcanal;
          fs.writeFileSync(groupFilePath, JSON.stringify(groupData));
          const message = groupData.antilinkcanal ? `‚úÖ *Antilinkcanal foi ativado com sucesso!*\n\nAgora, se algu√©m enviar links de canais do WhatsApp, ser√° banido automaticamente. Mantenha o grupo seguro! üõ°Ô∏è` : `‚úÖ *Antilinkcanal foi desativado.*\n\nLinks de canais n√£o ser√£o mais bloqueados. Use com cuidado! ‚ö†Ô∏è`;
          reply(`${message}`);
        } catch (e) {
          console.error(e);
          reply("ocorreu um erro üíî");
        }
        break;
      case 'antilinksoft':
        try {
          if (!isGroup) return reply("isso so pode ser usado em grupo üíî");
          if (!isGroupAdmin) return reply("voc√™ precisa ser adm üíî");
          const groupFilePath = __dirname + `/../database/grupos/${from}.json`;
          let groupData = fs.existsSync(groupFilePath) ? JSON.parse(fs.readFileSync(groupFilePath)) : {
            antilinksoft: false
          };
          
          groupData.antilinksoft = !groupData.antilinksoft;
          fs.writeFileSync(groupFilePath, JSON.stringify(groupData));
          const message = groupData.antilinksoft ? `‚úÖ *Antilinksoft foi ativado com sucesso!*\n\nAgora, se algu√©m enviar links, a mensagem ser√° apagada automaticamente (sem banir o usu√°rio).` : `‚úÖ *Antilinksoft foi desativado.*\n\nLinks n√£o ser√£o mais bloqueados.`;
          reply(`${message}`);
        } catch (e) {
          console.error(e);
          reply("ocorreu um erro üíî");
        }
        break;
      case 'antiporn':
        try {
          if (!isGroup) return reply("isso so pode ser usado em grupo üíî");
          if (!isGroupAdmin) return reply("voc√™ precisa ser adm üíî");
          if (!isBotAdmin) return reply("Eu preciso ser adm üíî");
          const groupFilePath = __dirname + `/../database/grupos/${from}.json`;
          let groupData = fs.existsSync(groupFilePath) ? JSON.parse(fs.readFileSync(groupFilePath)) : {
            antiporn: false
          };
          
          groupData.antiporn = !groupData.antiporn;
          fs.writeFileSync(groupFilePath, JSON.stringify(groupData));
          const message = groupData.antiporn ? `‚úÖ *Antiporn foi ativado com sucesso!*\n\nAgora, se algu√©m enviar conte√∫do adulto (NSFW), ser√° banido automaticamente. Mantenha o grupo seguro e adequado! üõ°Ô∏è` : `‚úÖ *Antiporn foi desativado.*\n\nConte√∫do adulto n√£o ser√° mais bloqueado. Use com responsabilidade! ‚ö†Ô∏è`;
          reply(`${message}`);
        } catch (e) {
          console.error(e);
          reply("ocorreu um erro üíî");
        }
        break;
      case 'autosticker':
        try {
          if (!isGroup) return reply("Isso s√≥ pode ser usado em grupo üíî");
          if (!isGroupAdmin) return reply("Voc√™ precisa ser administrador üíî");
          const groupFilePath = __dirname + `/../database/grupos/${from}.json`;
          let groupData = fs.existsSync(groupFilePath) ? JSON.parse(fs.readFileSync(groupFilePath)) : {};
          
          groupData.autoSticker = !groupData.autoSticker;
          fs.writeFileSync(groupFilePath, JSON.stringify(groupData, null, 2));
          reply(`‚úÖ Auto figurinhas ${groupData.autoSticker ? 'ativadas' : 'desativadas'}! ${groupData.autoSticker ? 'Todas as imagens e v√≠deos ser√£o convertidos em figurinhas.' : ''}`);
        } catch (e) {
          console.error(e);
          reply("Ocorreu um erro üíî");
        }
        break;
      case 'autorepo':
      case 'autoresposta':
        try {
          if (!isGroup) return reply("Isso s√≥ pode ser usado em grupo üíî");
          if (!isGroupAdmin) return reply("Voc√™ precisa ser administrador üíî");
          const groupFilePath = __dirname + `/../database/grupos/${from}.json`;
          let groupData = fs.existsSync(groupFilePath) ? JSON.parse(fs.readFileSync(groupFilePath)) : {};
          
          groupData.autorepo = !groupData.autorepo;
          fs.writeFileSync(groupFilePath, JSON.stringify(groupData, null, 2));
          reply(`‚úÖ Auto resposta ${groupData.autorepo ? 'ativada' : 'desativada'}!`);
        } catch (e) {
          console.error(e);
          reply("Ocorreu um erro üíî");
        }
        break;
      case 'assistente':
      case 'assistent':
        try {
          
          if (!isGroup) return reply("Isso s√≥ pode ser usado em grupo üíî");
          if (!isGroupAdmin) return reply("Voc√™ precisa ser administrador üíî");
          
          const groupFilePath = __dirname + `/../database/grupos/${from}.json`;
          let groupData = fs.existsSync(groupFilePath) ? JSON.parse(fs.readFileSync(groupFilePath)) : {};
          
          // Se n√£o tem argumento, apenas ativa/desativa
          if (!q) {
            groupData.assistente = !groupData.assistente;
            if (!groupData.assistente) {
              // Se desativar, remove a personalidade
              delete groupData.assistentePersonality;
            } else {
              // Se ativar sem especificar, usa padr√£o
              groupData.assistentePersonality = groupData.assistentePersonality || 'nazuna';
            }
            fs.writeFileSync(groupFilePath, JSON.stringify(groupData, null, 2));
            
            const statusMsg = groupData.assistente 
              ? `‚úÖ *Assistente ativada com sucesso!*\n\n` +
                `ü§ñ *Personalidade atual:* ${groupData.assistentePersonality === 'nazuna' ? 'Nazuna (Padr√£o)' : groupData.assistentePersonality === 'humana' ? 'Humana' : groupData.assistentePersonality === 'pro' ? 'Pro (Comandos)' : 'IA Normal'}\n\n` +
                `üí° *Trocar personalidade:*\n` +
                `‚Ä¢ ${prefix}assistente nazuna - Personalidade padr√£o Nazuna\n` +
                `‚Ä¢ ${prefix}assistente humana - Age 100% como humana\n` +
                `‚Ä¢ ${prefix}assistente ia - IA normal sem personalidade\n` +
                `‚Ä¢ ${prefix}assistente pro - Interpreta comandos em linguagem natural\n\n` +
                `üß† A IA aprende com base nos padr√µes de conversa para oferecer respostas mais relevantes.`
              : `‚ùå *Assistente desativada!*`;
            
            return reply(statusMsg);
          }
          
          // Se tem argumento, define a personalidade
          const personality = q.toLowerCase().trim();
          
          if (!['nazuna', 'humana', 'ia', 'pro'].includes(personality)) {
            return reply(`‚ùå *Personalidade inv√°lida!*\n\n` +
              `Escolha uma das op√ß√µes:\n` +
              `‚Ä¢ ${prefix}assistente nazuna - Personalidade padr√£o Nazuna (vampira tsundere)\n` +
              `‚Ä¢ ${prefix}assistente humana - Age 100% como uma pessoa real\n` +
              `‚Ä¢ ${prefix}assistente ia - IA normal e objetiva\n` +
              `‚Ä¢ ${prefix}assistente pro - Interpreta comandos em linguagem natural`);
          }
          
          groupData.assistente = true;
          groupData.assistentePersonality = personality;
          fs.writeFileSync(groupFilePath, JSON.stringify(groupData, null, 2));
          
          const personalityNames = {
            'nazuna': 'üåô *Nazuna* - Vampira moderna com personalidade tsundere',
            'humana': 'üë§ *Humana* - Age como uma pessoa real, nunca admite ser IA',
            'ia': 'ü§ñ *IA Normal* - Assistente objetiva e direta',
            'pro': '‚ö° *Pro* - Interpreta comandos em linguagem natural (n√£o responde, s√≥ executa)'
          };
          
          reply(`‚úÖ *Personalidade alterada!*\n\n` +
            `${personalityNames[personality]}\n\n` +
            `üí¨ A assistente agora responder√° com essa personalidade.\n` +
            `üß† Cada personalidade mant√©m mem√≥rias separadas.`);
            
        } catch (e) {
          console.error(e);
          reply("Ocorreu um erro üíî");
        }
        break;
      case 'antigore':
        try {
          if (!isGroup) return reply("isso so pode ser usado em grupo üíî");
          if (!isGroupAdmin) return reply("voc√™ precisa ser adm üíî");
          if (!isBotAdmin) return reply("Eu preciso ser adm üíî");
          const groupFilePath = __dirname + `/../database/grupos/${from}.json`;
          let groupData = fs.existsSync(groupFilePath) ? JSON.parse(fs.readFileSync(groupFilePath)) : {
            antigore: false
          };
          
          groupData.antigore = !groupData.antigore;
          fs.writeFileSync(groupFilePath, JSON.stringify(groupData));
          const message = groupData.antigore ? `‚úÖ *Antigore foi ativado com sucesso!*\n\nAgora, se algu√©m enviar conte√∫do gore, ser√° banido automaticamente. Mantenha o grupo seguro e saud√°vel! üõ°Ô∏è` : `‚úÖ *Antigore foi desativado.*\n\nConte√∫do gore n√£o ser√° mais bloqueado. Use com cuidado! ‚ö†Ô∏è`;
          reply(`${message}`);
        } catch (e) {
          console.error(e);
          reply("ocorreu um erro üíî");
        }
        break;
      case 'legendabv':
      case 'textbv':
      case 'welcomemsg':
        try {
          if (!isGroup) return reply("isso so pode ser usado em grupo üíî");
          if (!isGroupAdmin) return reply("voc√™ precisa ser adm üíî");
          const groupFilePath = __dirname + `/../database/grupos/${from}.json`;
          if (!q) return reply(`üìù *Configura√ß√£o da Mensagem de Boas-Vindas*\n\nPara definir uma mensagem personalizada, digite o comando seguido do texto desejado. Voc√™ pode usar as seguintes vari√°veis:\n\n- *#numerodele#* ‚Üí Marca o novo membro.\n- *#nomedogp#* ‚Üí Nome do grupo.\n- *#desc#* ‚Üí Descri√ß√£o do grupo.\n- *#membros#* ‚Üí N√∫mero total de membros no grupo.\n\nüìå *Exemplo:*\n${prefixo}legendabv Bem-vindo(a) #numerodele# ao grupo *#nomedogp#*! Agora somos #membros# membros. Leia a descri√ß√£o: #desc#`);
          
          groupData.textbv = q;
          fs.writeFileSync(groupFilePath, JSON.stringify(groupData));
          reply(`‚úÖ *Mensagem de boas-vindas configurada com sucesso!*\n\nüìå Nova mensagem:\n"${groupData.textbv}"`);
        } catch (e) {
          console.error(e);
          await reply("‚ùå Ocorreu um erro interno. Tente novamente em alguns minutos.");
        }
        break;
      case 'mute':
      case 'mutar':
        try {
          if (!isGroup) return reply("isso so pode ser usado em grupo üíî");
          if (!isGroupAdmin) return reply("voc√™ precisa ser adm üíî");
          if (!isBotAdmin) return reply("Eu preciso ser adm üíî");
          if (!menc_os2) return reply("Marque algu√©m üôÑ");
          const groupFilePath = __dirname + `/../database/grupos/${from}.json`;
          let groupData = fs.existsSync(groupFilePath) ? JSON.parse(fs.readFileSync(groupFilePath)) : {
            mutedUsers: {}
          };
          
          groupData.mutedUsers = groupData.mutedUsers || {};
          const targetId = await normalizeUserId(nazu, menc_os2);
          groupData.mutedUsers[targetId] = true;
          if (targetId !== menc_os2) {
            groupData.mutedUsers[menc_os2] = true;
          }
          fs.writeFileSync(groupFilePath, JSON.stringify(groupData));
          await nazu.sendMessage(from, {
            text: `‚úÖ @${getUserName(menc_os2)} foi mutado. Se enviar mensagens, ser√° banido.`,
            mentions: [menc_os2]
          }, {
            quoted: info
          });
        } catch (e) {
          console.error(e);
          reply("ocorreu um erro üíî");
        }
        break;
      case 'desmute':
      case 'desmutar':
      case 'unmute':
        try {
          if (!isGroup) return reply("isso so pode ser usado em grupo üíî");
          if (!isGroupAdmin) return reply("voc√™ precisa ser adm üíî");
          if (!menc_os2) return reply("Marque algu√©m üôÑ");
          const groupFilePath = __dirname + `/../database/grupos/${from}.json`;
          let groupData = fs.existsSync(groupFilePath) ? JSON.parse(fs.readFileSync(groupFilePath)) : {
            mutedUsers: {}
          };
          
          groupData.mutedUsers = groupData.mutedUsers || {};
          const targetId = await normalizeUserId(nazu, menc_os2);
          const removed = removeUserFromMap(groupData.mutedUsers, targetId) || removeUserFromMap(groupData.mutedUsers, menc_os2);
          if (removed) {
            fs.writeFileSync(groupFilePath, JSON.stringify(groupData));
            await nazu.sendMessage(from, {
              text: `‚úÖ @${getUserName(menc_os2)} foi desmutado e pode enviar mensagens novamente.`,
              mentions: [menc_os2]
            }, {
              quoted: info
            });
          } else {
            reply('‚ùå Este usu√°rio n√£o est√° mutado.');
          }
        } catch (e) {
          console.error(e);
          reply("ocorreu um erro üíî");
        }
        break;
      case 'mute2':
      case 'mutar2':
        try {
          if (!isGroup) return reply("isso so pode ser usado em grupo üíî");
          if (!isGroupAdmin) return reply("voc√™ precisa ser adm üíî");
          if (!menc_os2) return reply("Marque algu√©m üôÑ");
          const groupFilePath = __dirname + `/../database/grupos/${from}.json`;
          let groupData = fs.existsSync(groupFilePath) ? JSON.parse(fs.readFileSync(groupFilePath)) : {
            mutedUsers2: {}
          };
          
          groupData.mutedUsers2 = groupData.mutedUsers2 || {};
          const targetId = await normalizeUserId(nazu, menc_os2);
          groupData.mutedUsers2[targetId] = true;
          if (targetId !== menc_os2) {
            groupData.mutedUsers2[menc_os2] = true;
          }
          fs.writeFileSync(groupFilePath, JSON.stringify(groupData));
          await nazu.sendMessage(from, {
            text: `‚úÖ @${getUserName(menc_os2)} foi mutado. Suas mensagens ser√£o apagadas automaticamente.`,
            mentions: [menc_os2]
          }, {
            quoted: info
          });
        } catch (e) {
          console.error(e);
          reply("ocorreu um erro üíî");
        }
        break;
      case 'desmute2':
      case 'desmutar2':
      case 'unmute2':
        try {
          if (!isGroup) return reply("isso so pode ser usado em grupo üíî");
          if (!isGroupAdmin) return reply("voc√™ precisa ser adm üíî");
          if (!menc_os2) return reply("Marque algu√©m üôÑ");
          const groupFilePath = __dirname + `/../database/grupos/${from}.json`;
          let groupData = fs.existsSync(groupFilePath) ? JSON.parse(fs.readFileSync(groupFilePath)) : {
            mutedUsers2: {}
          };
          
          groupData.mutedUsers2 = groupData.mutedUsers2 || {};
          const targetId = await normalizeUserId(nazu, menc_os2);
          const removed = removeUserFromMap(groupData.mutedUsers2, targetId) || removeUserFromMap(groupData.mutedUsers2, menc_os2);
          if (removed) {
            fs.writeFileSync(groupFilePath, JSON.stringify(groupData));
            await nazu.sendMessage(from, {
              text: `‚úÖ @${getUserName(menc_os2)} foi desmutado e pode enviar mensagens novamente.`,
              mentions: [menc_os2]
            }, {
              quoted: info
            });
          } else {
            reply('‚ùå Este usu√°rio n√£o est√° mutado.');
          }
        } catch (e) {
          console.error(e);
          reply("ocorreu um erro üíî");
        }
        break;
      case 'blockcmd':
        try {
          if (!isGroup) return reply("isso so pode ser usado em grupo üíî");
          if (!isGroupAdmin) return reply("voc√™ precisa ser adm üíî");
          if (!q) return reply(`‚ùå Digite o comando que deseja bloquear. Exemplo: ${prefix}blockcmd sticker`);
          const groupFilePath = __dirname + `/../database/grupos/${from}.json`;
          let groupData = fs.existsSync(groupFilePath) ? JSON.parse(fs.readFileSync(groupFilePath)) : {
            blockedCommands: {}
          };
          
          groupData.blockedCommands = groupData.blockedCommands || {};
          
          groupData.blockedCommands[q.trim().toLowerCase().normalize('NFD').replace(/[\u0300-\u036f]/g, '').replaceAll(prefix, '')] = true;
          fs.writeFileSync(groupFilePath, JSON.stringify(groupData));
          reply(`‚úÖ O comando *${q.trim()}* foi bloqueado e s√≥ pode ser usado por administradores.`);
        } catch (e) {
          console.error(e);
          reply("ocorreu um erro üíî");
        }
        break;
      case 'unblockcmd':
        try {
          if (!isGroup) return reply("isso so pode ser usado em grupo üíî");
          if (!isGroupAdmin) return reply("voc√™ precisa ser adm üíî");
          if (!q) return reply(`‚ùå Digite o comando que deseja desbloquear. Exemplo: ${prefix}unblockcmd sticker`);
          const groupFilePath = __dirname + `/../database/grupos/${from}.json`;
          let groupData = fs.existsSync(groupFilePath) ? JSON.parse(fs.readFileSync(groupFilePath)) : {
            blockedCommands: {}
          };
          
          groupData.blockedCommands = groupData.blockedCommands || {};
          if (groupData.blockedCommands[q.trim().toLowerCase().normalize('NFD').replace(/[\u0300-\u036f]/g, '').replaceAll(prefix, '')]) {
            delete groupData.blockedCommands[q.trim().toLowerCase().normalize('NFD').replace(/[\u0300-\u036f]/g, '').replaceAll(prefix, '')];
            fs.writeFileSync(groupFilePath, JSON.stringify(groupData));
            reply(`‚úÖ O comando *${q.trim()}* foi desbloqueado e pode ser usado por todos.`);
          } else {
            reply('‚ùå Este comando n√£o est√° bloqueado.');
          }
        } catch (e) {
          console.error(e);
          reply("ocorreu um erro üíî");
        }
        break;
      case 'ttt':
      case 'jogodavelha':
      case 'tictactoe':
        {
          if (!isGroup) return reply("isso so pode ser usado em grupo üíî");
          if (!menc_os2) return reply("Marque algu√©m üôÑ");
          if (!tictactoe || typeof tictactoe.invitePlayer !== 'function') {
            console.warn('[TICTACTOE] invitePlayer not available');
            return reply("Sistema de jogo da velha temporariamente indispon√≠vel.");
          }
          const result = await tictactoe.invitePlayer(from, sender, menc_os2);
          await nazu.sendMessage(from, {
            text: result.message,
            mentions: result.mentions
          });
          break;
        }

      // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
      // CONNECT 4 - Jogo de 4 em linha
      // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
      case 'connect4':
      case 'c4':
      case 'ligue4':
        {
          if (!isGroup) return reply("‚ùå Este comando s√≥ pode ser usado em grupos!");
          if (!connect4 || typeof connect4.invitePlayer !== 'function') {
            return reply("Sistema Connect4 temporariamente indispon√≠vel.");
          }
          if (!menc_os2) return reply(`‚ùå Marque algu√©m para desafiar!\n\nUso: ${prefix}connect4 @usuario`);
          const result = await connect4.invitePlayer(from, sender, menc_os2);
          await nazu.sendMessage(from, { text: result.message, mentions: result.mentions });
          break;
        }

      // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
      // UNO - Jogo de cartas
      // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
      case 'uno':
        if (!isGroup) return reply("‚ùå Este comando s√≥ pode ser usado em grupos!");
        if (!uno) return reply("Sistema UNO temporariamente indispon√≠vel.");
        
        const subCmdUno = normalizeCommand(args[0]);
        
        if (!subCmdUno || subCmdUno === 'help' || subCmdUno === 'ajuda') {
            return reply(`üé¥ *UNO - Comandos*

${prefix}uno criar - Cria uma nova partida
${prefix}uno entrar - Entra em uma partida
${prefix}uno iniciar - Inicia a partida (criador)
${prefix}uno jogar <n¬∞> - Joga uma carta pelo n√∫mero
${prefix}uno jogar <n¬∞> <cor> - Joga coringa com cor
${prefix}uno comprar - Compra uma carta
${prefix}uno mao - Ver sua m√£o (envia no PV)
${prefix}uno uno - Grita UNO!
${prefix}uno status - Ver status da partida
${prefix}uno cancelar - Cancela a partida (host/admin)
${prefix}uno sair - Sair da partida

*Cores:* vermelho/azul/verde/amarelo
*Especiais:* +2, reverso, pular, coringa, +4

‚ö†Ô∏è *Timeout:* 1 minuto por turno
üö® 3 timeouts = expuls√£o!`);
          }
          
          // Verifica√ß√£o autom√°tica de timeout antes de processar comandos
          const timeoutCheck = uno.checkTimeout(from);
          if (timeoutCheck && timeoutCheck.success) {
            nazu.sendMessage(from, { 
              text: timeoutCheck.message, 
              mentions: timeoutCheck.mentions || [] 
            });
            // Se o jogo terminou por timeout, n√£o processar mais comandos
            if (timeoutCheck.finished) return;
          }
          
          switch (subCmdUno) {
            case 'criar':
            case 'create': {
              const result = uno.createGame(from, sender, pushname);
              return reply(result.message, result.mentions ? { mentions: result.mentions } : undefined);
            }
            case 'entrar':
            case 'join': {
              const result = uno.joinGame(from, sender, pushname);
              return reply(result.message, result.mentions ? { mentions: result.mentions } : undefined);
            }
            case 'iniciar':
            case 'start': {
              const result = uno.startGame(from, sender);
              if (result.success) {
                await reply(result.message, result.mentions ? { mentions: result.mentions } : undefined);
                // Envia m√£o para cada jogador no PV
                for (const [playerId, hand] of Object.entries(result.hands)) {
                  try {
                    await nazu.sendMessage(playerId, { text: `üé¥ *Sua m√£o inicial:*\n${hand}` });
                  } catch (e) { console.error('Erro ao enviar m√£o:', e); }
                }
              } else {
                return reply(result.message, result.mentions ? { mentions: result.mentions } : undefined);
              }
              break;
            }
            case 'jogar':
            case 'play': {
              const cartaArg = args.slice(1).join(' ').trim();
              if (!cartaArg) return reply(`‚ùå Especifique a carta!\n\nUso: ${prefix}uno jogar <n√∫mero>\nExemplo: ${prefix}uno jogar 3\n\nUse "m√£o" no PV para ver suas cartas numeradas.`);
              
              // Parse: pode ser s√≥ n√∫mero ou n√∫mero + cor (para coringas)
              const parts = cartaArg.split(/\s+/);
              const cardIndex = parseInt(parts[0]);
              const chosenColor = parts[1]?.toLowerCase();
              
              if (isNaN(cardIndex)) return reply(`‚ùå Use o n√∫mero da carta!\n\nExemplo: ${prefix}uno jogar 3`);
              
              const result = uno.playCard(from, sender, cardIndex, chosenColor);
              if (result.success) {
                await nazu.sendMessage(from, { text: result.message, mentions: result.mentions || [] });
                // Envia nova m√£o no PV
                const newHand = uno.getPlayerHand(from, sender);
                if (newHand) {
                  try {
                    await nazu.sendMessage(sender, { text: `üé¥ *Sua m√£o:*\n${newHand}` });
                  } catch (e) {}
                }
              } else {
                return reply(result.message, result.mentions ? { mentions: result.mentions } : undefined);
              }
              break;
            }
            case 'comprar':
            case 'draw': {
              const result = uno.drawCard(from, sender);
              if (result.success) {
                await reply(result.message, result.mentions ? { mentions: result.mentions } : undefined);
                if (result.newHand) {
                  try {
                    await nazu.sendMessage(sender, { text: `üé¥ *Sua m√£o:*\n${result.newHand}` });
                  } catch (e) {}
                }
              } else {
                return reply(result.message, result.mentions ? { mentions: result.mentions } : undefined);
              }
              break;
            }
            case 'uno': {
              const result = uno.callUno(from, sender);
              return reply(result.message, result.mentions ? { mentions: result.mentions } : undefined);
            }
            case 'status': {
              const result = uno.getStatus(from);
              return reply(result.message, result.mentions ? { mentions: result.mentions } : undefined);
            }
            case 'mao':
            case 'hand':
            case 'cartas': {
              const hand = uno.getPlayerHand(from, sender);
              if (hand) {
                try {
                  await nazu.sendMessage(sender, { text: `üé¥ *Sua m√£o atual:*\n\n${hand}` });
                  return reply('‚úÖ Sua m√£o foi enviada no seu PV!');
                } catch (e) {
                  return reply('‚ùå N√£o consegui enviar no seu PV. Voc√™ me bloqueou?');
                }
              } else {
                return reply('‚ùå Voc√™ n√£o est√° em uma partida de UNO!');
              }
            }
            case 'sair':
            case 'leave': {
              const result = uno.leaveGame(from, sender);
              return reply(result.message, result.mentions ? { mentions: result.mentions } : undefined);
            }
            case 'cancelar':
            case 'parar':
            case 'cancel': {
              const result = uno.cancelGame(from, sender, isGroupAdmin);
              return reply(result.message, result.mentions ? { mentions: result.mentions } : undefined);
            }
            case 'checktimeout': {
              // Comando oculto para verificar timeout manualmente
              const result = uno.checkTimeout(from);
              if (result) {
                return reply(result.message, result.mentions ? { mentions: result.mentions } : undefined);
              }
              return reply('‚úÖ Nenhum timeout detectado.');
            }
            default:
              return reply(`‚ùå Subcomando desconhecido. Use ${prefix}uno ajuda`);
          }
          break;

      // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
      // MEM√ìRIA - Jogo da mem√≥ria
      // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
      case 'memoria':
      case 'memory':
        if (!isGroup) return reply("‚ùå Este comando s√≥ pode ser usado em grupos!");
        if (!memoria) return reply("Sistema de mem√≥ria temporariamente indispon√≠vel.");
        
        const subCmdMemory = args[0]?.toLowerCase();
        
        if (subCmdMemory === 'ranking' || subCmdMemory === 'rank') {
            const ranking = memoria.getRanking(10);
            return reply(ranking);
          }
          
          // Verifica se tem jogo ativo
          if (memoria.hasActiveGame(from)) {
            // Tentar jogar
            const pos = parseInt(args[0]);
            if (!isNaN(pos)) {
              const result = memoria.makeMove(from, sender, pos);
              return reply(result.message);
            }
          return reply(`üéÆ Jogo em andamento! Use um n√∫mero de 1-16 para revelar uma carta.\nOu ${prefix}memoria sair para desistir.`);
        }
        
        if (subCmdMemory === 'sair') {
          const resultEnd = memoria.endGame(from);
          return reply(resultEnd.message);
        }
          
        // Criar novo jogo
        const resultStart = memoria.startGame(from, sender, pushname);
        return reply(resultStart.message);
        break;

      // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
      // CONQUISTAS - Sistema de achievements (modo brincadeira)
      // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
      case 'conquistasbn':
      case 'achievementsbn':
      case 'medalhasbn':
        if (!achievements) return reply("Sistema de conquistas temporariamente indispon√≠vel.");
        const list = achievements.formatAchievementsList(sender);
        return reply(list);
        break;

      // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
      // PRESENTES - Sistema de caixas e presentes
      // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
      case 'caixa':
      case 'box':
        if (!gifts) return reply("Sistema de presentes temporariamente indispon√≠vel.");
        
        const tipoBox = args[0]?.toLowerCase();
        if (!tipoBox) {
          return reply(`üéÅ *Sistema de Caixas*

${prefix}caixa diaria - Abre caixa di√°ria gr√°tis
${prefix}caixa rara - Abre caixa rara (500 gold)
${prefix}caixa lendaria - Abre caixa lend√°ria (2000 gold)

Use ${prefix}inventario para ver seus itens!`);
        }
        
        // Precisa do sistema de economia para caixas pagas
        const userEco = getEcoUser(sender);
        
        let resultBox;
        if (tipoBox === 'diaria' || tipoBox === 'daily') {
          resultBox = gifts.openDailyBox(sender);
        } else if (tipoBox === 'rara' || tipoBox === 'rare') {
          if (userEco.gold < 500) return reply("‚ùå Voc√™ precisa de 500 gold para abrir uma caixa rara!");
          resultBox = gifts.openBox(sender, 'rara');
          if (resultBox.success) {
            userEco.gold -= 500;
            saveEconomy();
          }
        } else if (tipoBox === 'lendaria' || tipoBox === 'legendary') {
          if (userEco.gold < 2000) return reply("‚ùå Voc√™ precisa de 2000 gold para abrir uma caixa lend√°ria!");
          resultBox = gifts.openBox(sender, 'lendaria');
          if (resultBox.success) {
            userEco.gold -= 2000;
            saveEconomy();
          }
        } else {
          return reply(`‚ùå Tipo inv√°lido! Use: diaria, rara ou lendaria`);
        }
        
        return reply(resultBox.message);
        break;

      case 'presentebn':
      case 'giftbn':
        if (!gifts) return reply("Sistema de presentes temporariamente indispon√≠vel.");
        if (!menc_os2) return reply(`‚ùå Marque algu√©m para enviar um presente!\n\nUso: ${prefix}presente @user <tipo>\nTipos: rosa, chocolate, anel, coracao, estrela...`);
        
        const tipoGift = args[1]?.toLowerCase();
        if (!tipoGift) {
          const tipos = gifts.getGiftTypes();
          return reply(`üéÅ *Tipos de Presente*\n\n${tipos}\n\nUso: ${prefix}presente @user <tipo>`);
        }
        
        const resultGift = gifts.sendGift(sender, menc_os2, tipoGift);
        if (resultGift.success) {
          await nazu.sendMessage(from, { text: resultGift.message, mentions: [sender, menc_os2] });
        } else {
          return reply(resultGift.message);
        }
        break;

      case 'inventario':
      case 'inventory':
        if (!gifts) return reply("Sistema de presentes temporariamente indispon√≠vel.");
        const inv = gifts.getInventory(sender);
        return reply(inv);
        break;

      // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
      // REPUTA√á√ÉO - Sistema de rep e den√∫ncias (modo brincadeira)
      // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
      case 'repbn':
      case 'reputacaobn':
        if (!reputation) return reply("Sistema de reputa√ß√£o temporariamente indispon√≠vel.");
        
        const actionRep = args[0]?.toLowerCase();
        
        if (!actionRep || (!menc_os2 && actionRep !== '+' && actionRep !== '-')) {
          // Ver pr√≥pria reputa√ß√£o ou de algu√©m
          const target = menc_os2 || sender;
          const rep = reputation.getReputation(target);
          const name = menc_os2 ? `@${menc_os2.split('@')[0]}` : pushname;
          return nazu.sendMessage(from, {
            text: `‚≠ê *Reputa√ß√£o de ${name}*\n\n${rep}`,
            mentions: menc_os2 ? [menc_os2] : []
          });
        }
        
        if ((actionRep === '+' || actionRep === 'mais') && menc_os2) {
          const resultRepPlus = reputation.giveRep(sender, menc_os2, true);
          return reply(resultRepPlus.message);
        }
        
        if ((actionRep === '-' || actionRep === 'menos') && menc_os2) {
          const resultRepMinus = reputation.giveRep(sender, menc_os2, false);
          return reply(resultRepMinus.message);
        }
        
        return reply(`‚ùå Uso: ${prefix}rep + @user ou ${prefix}rep - @user`);
        break;

      case 'toprep':
      case 'rankrep':
        if (!reputation) return reply("Sistema de reputa√ß√£o temporariamente indispon√≠vel.");
        const ranking = reputation.getRepRanking(10);
        return reply(ranking);
        break;

      case 'denunciar':
      case 'report':
        if (!reputation) return reply("Sistema de reputa√ß√£o temporariamente indispon√≠vel.");
        if (!menc_os2) return reply(`‚ùå Marque quem voc√™ quer denunciar!\n\nUso: ${prefix}denunciar @user <motivo>`);
        
        const motivoDenuncia = args.slice(1).join(' ');
        if (!motivoDenuncia) return reply("‚ùå Informe o motivo da den√∫ncia!");
        
        const resultReport = reputation.reportUser(sender, menc_os2, from, motivoDenuncia);
        return reply(resultReport.message);
        break;

      case 'denuncias':
      case 'reports':
        if (!reputation) return reply("Sistema de reputa√ß√£o temporariamente indispon√≠vel.");
        if (!isGroupAdmin && !isOwnerOrSub) return reply("‚ùå Apenas admins podem ver den√∫ncias!");
        
        const reportsData = reputation.getReports(from);
        return reply(reportsData);
        break;

      // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
      // QR CODE - Gerar e ler (modo brincadeira)
      // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
      case 'qrcodebn':
      case 'gerarqrbn':
        if (!qrcode) return reply("Sistema de QR Code temporariamente indispon√≠vel.");
        if (!q) return reply(`‚ùå Digite o texto/link para gerar o QR Code!\n\nUso: ${prefix}qrcode <texto ou link>`);
        
        const resultQRCode = await qrcode.generateQRCode(q, 300, prefix);
        if (resultQRCode.success) {
          await nazu.sendMessage(from, {
            image: { url: resultQRCode.url },
            caption: `üì± *QR Code gerado!*\n\nConte√∫do: ${q}`
          }, { quoted: info });
        } else {
          return reply(resultQRCode.message);
        }
        break;

      case 'lerqr':
      case 'readqr':
      case 'scanqr':
        if (!qrcode) return reply("Sistema de QR Code temporariamente indispon√≠vel.");
        
        const quotedMsgQR = info.message?.extendedTextMessage?.contextInfo?.quotedMessage;
        const hasImageQR = type === 'imageMessage' || quotedMsgQR?.imageMessage;
        
        if (!hasImageQR) return reply("‚ùå Responda a uma imagem com QR Code para ler!");
        
        try {
          const mediaMsgQR = quotedMsgQR?.imageMessage || info.message?.imageMessage;
          const bufferQR = await downloadContentFromMessage(mediaMsgQR, 'image');
          const chunksQR = [];
          for await (const chunk of bufferQR) chunksQR.push(chunk);
          const imageBufferQR = Buffer.concat(chunksQR);
          
          const resultQR = await qrcode.readQRCode(imageBufferQR);
          return reply(resultQR.message);
        } catch (e) {
          console.error('Erro ao ler QR:', e);
          return reply("‚ùå Erro ao processar a imagem!");
        }
        break;

      // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
      // NOTAS - Sistema de notas pessoais
      // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
      case 'nota':
      case 'note':
        if (!notes) return reply("Sistema de notas temporariamente indispon√≠vel.");
        
        const subCmdNote = args[0]?.toLowerCase();
        
        if (!subCmdNote) {
          return reply(`üìù *Sistema de Notas*

${prefix}nota add <texto> - Adiciona uma nota
${prefix}notas - Lista suas notas
${prefix}nota ver <id> - Ver nota espec√≠fica
${prefix}nota del <id> - Deleta uma nota
${prefix}nota fixar <id> - Fixa/desfixa nota
${prefix}nota buscar <termo> - Busca nas notas`);
        }
        
        switch (subCmdNote) {
          case 'add':
          case 'criar': {
            const texto = args.slice(1).join(' ');
            if (!texto) return reply("‚ùå Digite o texto da nota!");
            const resultNoteAdd = notes.addNote(sender, texto, null, prefix);
            return reply(resultNoteAdd.message);
          }
          case 'ver':
          case 'view': {
            const id = parseInt(args[1]);
            if (isNaN(id)) return reply("‚ùå Informe o ID da nota!");
            const resultNoteView = notes.getNote(sender, id, prefix);
            return reply(resultNoteView.message);
          }
          case 'del':
          case 'deletar':
          case 'delete': {
            const id = parseInt(args[1]);
            if (isNaN(id)) return reply("‚ùå Informe o ID da nota!");
            const resultNoteDel = notes.deleteNote(sender, id);
            return reply(resultNoteDel.message);
          }
          case 'fixar':
          case 'pin': {
            const id = parseInt(args[1]);
            if (isNaN(id)) return reply("‚ùå Informe o ID da nota!");
            const resultNotePin = notes.togglePin(sender, id);
            return reply(resultNotePin.message);
          }
          case 'buscar':
          case 'search': {
            const termo = args.slice(1).join(' ');
            if (!termo) return reply("‚ùå Digite o termo de busca!");
            const resultNoteSearch = notes.searchNotes(sender, termo);
            return reply(resultNoteSearch.message);
          }
          default:
            return reply(`‚ùå Subcomando desconhecido. Use ${prefix}nota para ver ajuda.`);
        }
        break;

      case 'notas':
      case 'notes':
        if (!notes) return reply("Sistema de notas temporariamente indispon√≠vel.");
        const pageNotes = parseInt(args[0]) || 1;
        const resultNotes = notes.listNotes(sender, pageNotes, 10, prefix);
        return reply(resultNotes.message);
        break;

      // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
      // CALCULADORA - C√°lculos matem√°ticos
      // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
      case 'calc':
      case 'calcular':
      case 'calculadora':
        if (!calculator) return reply("Sistema de calculadora temporariamente indispon√≠vel.");
          
          if (!q) {
            return reply(`üßÆ *Calculadora Cient√≠fica*

${prefix}calc <express√£o> - Calcula express√£o
${prefix}calc converter <valor> <de> <para>

*Operadores:* + - * / ^ % !
*Fun√ß√µes:* sin, cos, tan, sqrt, log, abs, ceil, floor
*Constantes:* pi, e, phi

*Exemplos:*
${prefix}calc 2+2*3
${prefix}calc sqrt(144)
${prefix}calc sin(45)
${prefix}calc 5!
${prefix}calc converter 100 km mi`);
          }
          
          if (args[0]?.toLowerCase() === 'converter' || args[0]?.toLowerCase() === 'convert') {
            const valor = parseFloat(args[1]);
            const de = args[2]?.toLowerCase();
            const para = args[3]?.toLowerCase();
            if (isNaN(valor) || !de || !para) {
              return reply(`‚ùå Uso: ${prefix}calc converter <valor> <de> <para>\nExemplo: ${prefix}calc converter 100 km mi`);
            }
            const result = calculator.convert(valor, de, para);
            return reply(result.message);
          }
        
        const resultCalc = calculator.calculate(q, prefix);
        return reply(resultCalc.message);
        break;

      // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
      // EDI√á√ÉO DE √ÅUDIO - Cortar, velocidade, etc
      // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
      case 'cortaraudio':
      case 'cutaudio':
        if (!audioEdit) return reply("Sistema de edi√ß√£o de √°udio temporariamente indispon√≠vel.");
        
        const quotedMsgCut = info.message?.extendedTextMessage?.contextInfo?.quotedMessage;
        const hasAudioCut = type === 'audioMessage' || quotedMsgCut?.audioMessage;
        
        if (!hasAudioCut) return reply("‚ùå Responda a um √°udio para cortar!");
        
        const inicioCut = args[0];
        const fimCut = args[1];
        if (!inicioCut || !fimCut) return reply(`‚ùå Informe in√≠cio e fim!\n\nUso: ${prefix}cortaraudio <inicio> <fim>\nExemplo: ${prefix}cortaraudio 0:10 0:30`);
        
        try {
          const mediaMsgCut = quotedMsgCut?.audioMessage || info.message?.audioMessage;
          const bufferCut = await downloadContentFromMessage(mediaMsgCut, 'audio');
          const chunksCut = [];
          for await (const chunk of bufferCut) chunksCut.push(chunk);
          const audioBufferCut = Buffer.concat(chunksCut);
          
          const resultCut = await audioEdit.cutAudio(audioBufferCut, inicioCut, fimCut, prefix);
          if (resultCut.success) {
            await nazu.sendMessage(from, {
              audio: resultCut.buffer,
              mimetype: 'audio/mpeg',
              ptt: false
            }, { quoted: info });
          } else {
            return reply(resultCut.message);
          }
        } catch (e) {
          console.error('Erro ao cortar √°udio:', e);
          return reply("‚ùå Erro ao processar o √°udio!");
        }
        break;

      case 'velocidade':
      case 'speed':
        if (!audioEdit) return reply("Sistema de edi√ß√£o de √°udio temporariamente indispon√≠vel.");
        
        const quotedMsgSpeed = info.message?.extendedTextMessage?.contextInfo?.quotedMessage;
        const hasAudioSpeed = type === 'audioMessage' || quotedMsgSpeed?.audioMessage;
        
        if (!hasAudioSpeed) return reply("‚ùå Responda a um √°udio para alterar velocidade!");
        
        const vel = parseFloat(args[0]);
        if (isNaN(vel) || vel < 0.5 || vel > 3) return reply(`‚ùå Velocidade inv√°lida!\n\nUso: ${prefix}velocidade <0.5-3.0>\nExemplo: ${prefix}velocidade 1.5`);
        
        try {
          const mediaMsgSpeed = quotedMsgSpeed?.audioMessage || info.message?.audioMessage;
          const bufferSpeed = await downloadContentFromMessage(mediaMsgSpeed, 'audio');
          const chunksSpeed = [];
          for await (const chunk of bufferSpeed) chunksSpeed.push(chunk);
          const audioBufferSpeed = Buffer.concat(chunksSpeed);
          
          const resultSpeed = await audioEdit.changeSpeed(audioBufferSpeed, vel);
          if (resultSpeed.success) {
            await nazu.sendMessage(from, {
              audio: resultSpeed.buffer,
              mimetype: 'audio/mpeg',
              ptt: false
            }, { quoted: info });
          } else {
            return reply(resultSpeed.message);
          }
        } catch (e) {
          console.error('Erro ao alterar velocidade:', e);
          return reply("‚ùå Erro ao processar o √°udio!");
        }
        break;

      case 'reversobn':
      case 'reversebn':
        if (!audioEdit) return reply("Sistema de edi√ß√£o de √°udio temporariamente indispon√≠vel.");
        
        const quotedMsgReverse = info.message?.extendedTextMessage?.contextInfo?.quotedMessage;
        const hasAudioReverse = type === 'audioMessage' || quotedMsgReverse?.audioMessage;
        
        if (!hasAudioReverse) return reply("‚ùå Responda a um √°udio para reverter!");
        
        try {
          const mediaMsgReverse = quotedMsgReverse?.audioMessage || info.message?.audioMessage;
          const bufferReverse = await downloadContentFromMessage(mediaMsgReverse, 'audio');
          const chunksReverse = [];
          for await (const chunk of bufferReverse) chunksReverse.push(chunk);
          const audioBufferReverse = Buffer.concat(chunksReverse);
          
          const resultReverse = await audioEdit.reverseAudio(audioBufferReverse);
          if (resultReverse.success) {
            await nazu.sendMessage(from, {
              audio: resultReverse.buffer,
              mimetype: 'audio/mpeg',
              ptt: false
            }, { quoted: info });
          } else {
            return reply(resultReverse.message);
          }
        } catch (e) {
          console.error('Erro ao reverter √°udio:', e);
          return reply("‚ùå Erro ao processar o √°udio!");
        }
        break;

      case 'bassbn':
      case 'bassboostbn':
        if (!audioEdit) return reply("Sistema de edi√ß√£o de √°udio temporariamente indispon√≠vel.");
        
        const quotedMsgBass = info.message?.extendedTextMessage?.contextInfo?.quotedMessage;
        const hasAudioBass = type === 'audioMessage' || quotedMsgBass?.audioMessage;
        
        if (!hasAudioBass) return reply("‚ùå Responda a um √°udio para adicionar bass!");
        
        const levelBass = parseInt(args[0]) || 10;
        if (levelBass < 1 || levelBass > 20) return reply(`‚ùå N√≠vel de bass inv√°lido!\n\nUso: ${prefix}bass <1-20>\nExemplo: ${prefix}bass 15`);
        
        try {
          const mediaMsgBass = quotedMsgBass?.audioMessage || info.message?.audioMessage;
          const bufferBass = await downloadContentFromMessage(mediaMsgBass, 'audio');
          const chunksBass = [];
          for await (const chunk of bufferBass) chunksBass.push(chunk);
          const audioBufferBass = Buffer.concat(chunksBass);
          
          const resultBass = await audioEdit.bassBoost(audioBufferBass, levelBass);
          if (resultBass.success) {
            await nazu.sendMessage(from, {
              audio: resultBass.buffer,
              mimetype: 'audio/mpeg',
              ptt: false
            }, { quoted: info });
          } else {
            return reply(resultBass.message);
          }
        } catch (e) {
          console.error('Erro ao adicionar bass:', e);
          return reply("‚ùå Erro ao processar o √°udio!");
        }
        break;

      case 'normalizar':
      case 'normalize':
        if (!audioEdit) return reply("Sistema de edi√ß√£o de √°udio temporariamente indispon√≠vel.");
        
        const quotedMsgNorm = info.message?.extendedTextMessage?.contextInfo?.quotedMessage;
        const hasAudioNorm = type === 'audioMessage' || quotedMsgNorm?.audioMessage;
        
        if (!hasAudioNorm) return reply("‚ùå Responda a um √°udio para normalizar!");
        
        try {
          const mediaMsgNorm = quotedMsgNorm?.audioMessage || info.message?.audioMessage;
          const bufferNorm = await downloadContentFromMessage(mediaMsgNorm, 'audio');
          const chunksNorm = [];
          for await (const chunk of bufferNorm) chunksNorm.push(chunk);
          const audioBufferNorm = Buffer.concat(chunksNorm);
          
          const resultNorm = await audioEdit.normalizeAudio(audioBufferNorm);
          if (resultNorm.success) {
            await nazu.sendMessage(from, {
              audio: resultNorm.buffer,
              mimetype: 'audio/mpeg',
              ptt: false
            }, { quoted: info });
          } else {
            return reply(resultNorm.message);
          }
        } catch (e) {
          console.error('Erro ao normalizar √°udio:', e);
          return reply("‚ùå Erro ao processar o √°udio!");
        }
        break;

      // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
      // EDI√á√ÉO DE V√çDEO - Cortar v√≠deo
      // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
      case 'cortarvideo':
      case 'cortarvid':
      case 'cutvideo':
        try {
          const quotedMsgVideoCut = info.message?.extendedTextMessage?.contextInfo?.quotedMessage;
          const hasVideoCut = type === 'videoMessage' || quotedMsgVideoCut?.videoMessage;
          
          if (!hasVideoCut) return reply("‚ùå Responda a um v√≠deo para cortar!");
          
          const inicioVid = args[0];
          const fimVid = args[1];
          if (!inicioVid || !fimVid) {
            return reply(`‚ùå Informe in√≠cio e fim!\n\nUso: ${prefix}cortarvideo <inicio> <fim>\nExemplo: ${prefix}cortarvideo 0:10 0:30`);
          }
          
          await reply('üé¨ Cortando v√≠deo... Por favor, aguarde alguns segundos.');
          
          const encmediaVideoCut = quotedMsgVideoCut?.videoMessage || info.message.videoMessage;
          const raneVideoCut = __dirname + `/../database/tmp/${Math.random()}.mp4`;
          const buffimgVideoCut = await getFileBuffer(encmediaVideoCut, 'video');
          fs.writeFileSync(raneVideoCut, buffimgVideoCut);
          
          const ranVideoCut = __dirname + `/../database/tmp/${Math.random()}_cut.mp4`;
          // Recodifica o v√≠deo para garantir que a imagem seja preservada
          const ffmpegCmdCut = `ffmpeg -ss ${inicioVid} -i ${raneVideoCut} -to ${fimVid} -c:v libx264 -preset fast -crf 23 -c:a aac -b:a 128k ${ranVideoCut}`;
          
          exec(ffmpegCmdCut, async (err) => {
            await fs.unlinkSync(raneVideoCut);
            if (err) {
              console.error('FFMPEG Error (Cortar V√≠deo):', err);
              return reply('‚ùå Erro ao cortar v√≠deo! Verifique o formato de tempo (HH:MM:SS ou MM:SS).');
            }
            
            const bufferVideoCut = fs.readFileSync(ranVideoCut);
            await nazu.sendMessage(from, {
              video: bufferVideoCut,
              mimetype: 'video/mp4'
            }, { quoted: info });
            await fs.unlinkSync(ranVideoCut);
          });
        } catch (e) {
          console.error('Erro ao cortar v√≠deo:', e);
          return reply("‚ùå Erro ao processar o v√≠deo!");
        }
        break;

      // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
      // HOR√ìSCOPO - Previs√µes por signo
      // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
      case 'horoscopo':
      case 'signo':
        if (!iaExpanded) return reply("Sistema de hor√≥scopo temporariamente indispon√≠vel.");
        if (!ia || !KeyCog) return reply("‚ùå Sistema de IA n√£o dispon√≠vel no momento.");
        
        const signoHoroscopo = args[0]?.toLowerCase();
        if (!signoHoroscopo) {
          return reply(`üîÆ *Hor√≥scopo - Signos*

${prefix}horoscopo <signo>

*Signos dispon√≠veis:*
‚ôà √Åries | ‚ôâ Touro | ‚ôä G√™meos
‚ôã C√¢ncer | ‚ôå Le√£o | ‚ôç Virgem
‚ôé Libra | ‚ôè Escorpi√£o | ‚ôê Sagit√°rio
‚ôë Capric√≥rnio | ‚ôí Aqu√°rio | ‚ôì Peixes`);
        }
        
        reply("üîÆ Consultando as estrelas...");
        
        // Fun√ß√£o wrapper para a IA
        const aiFunctionHoroscope = (prompt) => {
          return ia.makeCognimaRequest('qwen/qwen3-235b-a22b', prompt, null)
            .then(response => response?.data?.choices?.[0]?.message?.content || '');
        };
        
        iaExpanded.generateHoroscope(signoHoroscopo, aiFunctionHoroscope, prefix).then(resultHoroscope => {
          reply(resultHoroscope.message);
        }).catch(err => {
          reply('‚ùå Erro ao gerar hor√≥scopo. Tente novamente!');
        });
        break;

      case 'signos':
        return reply(`üîÆ *Signos do Zod√≠aco*

‚ôà *√Åries* (21/03 - 19/04)
‚ôâ *Touro* (20/04 - 20/05)
‚ôä *G√™meos* (21/05 - 20/06)
‚ôã *C√¢ncer* (21/06 - 22/07)
‚ôå *Le√£o* (23/07 - 22/08)
‚ôç *Virgem* (23/08 - 22/09)
‚ôé *Libra* (23/09 - 22/10)
‚ôè *Escorpi√£o* (23/10 - 21/11)
‚ôê *Sagit√°rio* (22/11 - 21/12)
‚ôë *Capric√≥rnio* (22/12 - 19/01)
‚ôí *Aqu√°rio* (20/01 - 18/02)
‚ôì *Peixes* (19/02 - 20/03)

Use ${prefix}horoscopo <signo> para ver a previs√£o!`);
        break;

      // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
      // DEBATER - Gerador de argumentos
      // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
      case 'debater':
      case 'debate':
        if (!iaExpanded) return reply("Sistema de debate temporariamente indispon√≠vel.");
        if (!ia || !KeyCog) return reply("‚ùå Sistema de IA n√£o dispon√≠vel no momento.");
        if (!q) return reply(`üí¨ *Debater*\n\nUso: ${prefix}debater <tema>\n\nExemplo: ${prefix}debater redes sociais fazem bem ou mal`);
        
        reply("üí¨ Analisando argumentos...");
        
        // Fun√ß√£o wrapper para a IA
        const aiFunctionDebate = (prompt) => {
          return ia.makeCognimaRequest('qwen/qwen3-235b-a22b', prompt, null)
            .then(response => response?.data?.choices?.[0]?.message?.content || '');
        };
        
        iaExpanded.generateDebate(q, aiFunctionDebate, prefix).then(resultDebate => {
          reply(resultDebate.message);
        }).catch(err => {
          reply('‚ùå Erro ao gerar debate. Tente novamente!');
        });
        break;

      // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
      // HIST√ìRIA INTERATIVA - Aventura por escolhas
      // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
      case 'historiainterativa':
      case 'storyinteractive':
      case 'aventura':
        if (!iaExpanded) return reply("Sistema de hist√≥ria temporariamente indispon√≠vel.");
        if (!ia || !KeyCog) return reply("‚ùå Sistema de IA n√£o dispon√≠vel no momento.");
        
        const subCmdStory = args[0]?.toLowerCase();
        
        // Fun√ß√£o wrapper para a IA
        const aiFunctionStory = (prompt) => {
          return ia.makeCognimaRequest('qwen/qwen3-235b-a22b', prompt, null)
            .then(response => response?.data?.choices?.[0]?.message?.content || '');
        };
        
        if (!subCmdStory) {
          return reply(`üìñ *Hist√≥ria Interativa*

${prefix}aventura <g√™nero> - Inicia uma hist√≥ria
${prefix}aventura escolha <1/2/3> - Faz uma escolha
${prefix}aventura status - Ver status atual
${prefix}aventura sair - Abandona a hist√≥ria

*G√™neros:* fantasia, terror, romance, aventura, fic√ß√£o, mist√©rio`);
        }
        
        switch (subCmdStory) {
          case 'escolha':
          case 'choice': {
            const escolha = parseInt(args[1]);
            if (isNaN(escolha) || escolha < 1 || escolha > 3) {
              return reply("‚ùå Escolha inv√°lida! Use 1, 2 ou 3.");
            }
            reply("üìñ Continuando a hist√≥ria...");
            iaExpanded.continueStory(sender, escolha, aiFunctionStory).then(resultStory => {
              reply(resultStory.message);
            }).catch(err => {
              reply('‚ùå Erro ao continuar hist√≥ria. Tente novamente!');
            });
            break;
          }
          case 'status': {
            const resultStatus = iaExpanded.getStoryStatus(sender);
            return reply(resultStatus.message);
          }
          case 'sair':
          case 'quit': {
            const resultQuit = iaExpanded.cancelStory(sender);
            return reply(resultQuit.message);
          }
          default: {
            // Tenta iniciar hist√≥ria com o g√™nero
            const generos = ['fantasia', 'terror', 'romance', 'aventura', 'fic√ß√£o', 'ficcao', 'mist√©rio', 'misterio'];
            const genero = subCmdStory;
            if (!generos.some(g => g.startsWith(genero))) {
              return reply(`‚ùå G√™nero inv√°lido!\n\nG√™neros: fantasia, terror, romance, aventura, fic√ß√£o, mist√©rio`);
            }
            reply("üìñ Criando sua hist√≥ria...");
            iaExpanded.startStory(sender, genero, aiFunctionStory, prefix).then(resultStory => {
              reply(resultStory.message);
            }).catch(err => {
              reply('‚ùå Erro ao criar hist√≥ria. Tente novamente!');
            });
            break;
          }
        }
        break;

      // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
      // ANTITOXIC - Configura√ß√£o (apenas admins)
      // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
      case 'antitoxic':
      case 'antit√≥xico':
        if (!isGroup) return reply("‚ùå Este comando s√≥ pode ser usado em grupos!");
        if (!isGroupAdmin) return reply("‚ùå Apenas admins podem configurar o antitoxic!");
        if (!antitoxic) return reply("Sistema antitoxic temporariamente indispon√≠vel.");
        
        const subCmdToxic = args[0]?.toLowerCase();
        
        if (!subCmdToxic || subCmdToxic === 'on') {
            const result = antitoxic.enableAntitoxic(from);
            return reply(result.message);
          }
        
        if (subCmdToxic === 'off') {
            const result = antitoxic.disableAntitoxic(from);
            return reply(result.message);
          }
        
        if (subCmdToxic === 'config') {
            const acao = args[1]?.toLowerCase();
            if (!acao || !['avisar', 'apagar', 'mute'].includes(acao)) {
              return reply(`‚ùå A√ß√£o inv√°lida!\n\nUso: ${prefix}antitoxic config <avisar/apagar/mute>`);
            }
            const result = antitoxic.setAntitoxicAction(from, acao);
            return reply(result.message);
          }
        
        if (subCmdToxic === 'sensibilidade' || subCmdToxic === 'threshold') {
          const nivel = parseInt(args[1]);
          if (isNaN(nivel) || nivel < 0 || nivel > 100) {
            return reply(`‚ùå N√≠vel inv√°lido!\n\nUso: ${prefix}antitoxic sensibilidade <0-100>\nMenor = mais sens√≠vel`);
          }
          const result = antitoxic.setAntitoxicThreshold(from, nivel);
          return reply(result.message);
        }
        
        return reply(`‚ö†Ô∏è *Antitoxic - Configura√ß√£o*

${prefix}antitoxic on - Ativa
${prefix}antitoxic off - Desativa
${prefix}antitoxic config <a√ß√£o> - Define a√ß√£o (avisar/apagar/mute)
${prefix}antitoxic sensibilidade <0-100> - Define sensibilidade

‚ö†Ô∏è Este sistema usa IA e pode cometer erros!`);
        break;

      // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
      // ANTIPALAVRA - Sistema de blacklist de palavras (apenas admins)
      // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
      case 'antipalavra':
      case 'antiword':
        if (!isGroup) return reply("‚ùå Este comando s√≥ pode ser usado em grupos!");
        if (!isGroupAdmin) return reply("‚ùå Apenas administradores podem usar este comando!");
        if (!antipalavra) return reply("‚ùå Sistema antipalavra temporariamente indispon√≠vel.");
        
        const subCmdAntipalavra = args[0]?.toLowerCase();
        
        // Ativa o sistema
        if (subCmdAntipalavra === 'on' || subCmdAntipalavra === 'ativar') {
          const result = antipalavra.enableAntipalavra(from);
          return reply(result.message);
        }
        
        // Desativa o sistema
        if (subCmdAntipalavra === 'off' || subCmdAntipalavra === 'desativar') {
          const result = antipalavra.disableAntipalavra(from);
          return reply(result.message);
        }
        
        // Adiciona palavra √† blacklist
        if (subCmdAntipalavra === 'add' || subCmdAntipalavra === 'adicionar') {
            const palavra = args.slice(1).join(' ').trim();
            if (!palavra) {
              return reply(`‚ùå Voc√™ precisa especificar a palavra!\n\nUso: ${prefix}antipalavra add <palavra>`);
            }
            const result = antipalavra.addPalavraBlacklist(from, palavra);
            return reply(result.message);
          }
          
        // Remove palavra da blacklist
        if (subCmdAntipalavra === 'del' || subCmdAntipalavra === 'remover' || subCmdAntipalavra === 'remove') {
          const palavra = args.slice(1).join(' ').trim();
            if (!palavra) {
            return reply(`‚ùå Voc√™ precisa especificar a palavra!\n\nUso: ${prefix}antipalavra del <palavra>`);
          }
          const result = antipalavra.removePalavraBlacklist(from, palavra);
          return reply(result.message);
        }
        
        // Lista todas as palavras
        if (subCmdAntipalavra === 'list' || subCmdAntipalavra === 'lista' || subCmdAntipalavra === 'listar') {
          const result = antipalavra.listPalavrasBlacklist(from);
          return reply(result.message);
        }
        
        // Limpa a blacklist
        if (subCmdAntipalavra === 'clear' || subCmdAntipalavra === 'limpar') {
          const result = antipalavra.clearBlacklist(from);
          return reply(result.message);
        }
        
        // Estat√≠sticas
        if (subCmdAntipalavra === 'stats' || subCmdAntipalavra === 'estatisticas') {
          const stats = antipalavra.getStats(from);
          let msg = `üìä *ANTIPALAVRA - ESTAT√çSTICAS*\n`;
          msg += `‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ\n`;
          msg += `üìä Status: ${stats.enabled ? '‚úÖ Ativo' : '‚ùå Desativado'}\n`;
          msg += `üî¢ Palavras na blacklist: ${stats.totalWords}\n`;
          msg += `üö´ Total de bans: ${stats.totalBans}\n`;
          msg += `üîç Total de detec√ß√µes: ${stats.totalDetections}\n`;
          
          if (stats.topWords && stats.topWords.length > 0) {
            msg += `\nüîù *Top 5 palavras mais detectadas:*\n`;
            stats.topWords.forEach((item, index) => {
              msg += `${index + 1}. "${item.palavra}" - ${item.detections}x\n`;
            });
          }
          
          return reply(msg);
        }
        
        // Menu de ajuda
        return reply(`üö´ *ANTIPALAVRA - SISTEMA DE BLACKLIST*

*Comandos dispon√≠veis:*

${prefix}antipalavra on
‚îî Ativa o sistema

${prefix}antipalavra off
‚îî Desativa o sistema

${prefix}antipalavra add <palavra>
‚îî Adiciona palavra √† blacklist

${prefix}antipalavra del <palavra>
‚îî Remove palavra da blacklist

${prefix}antipalavra list
‚îî Lista todas as palavras

${prefix}antipalavra clear
‚îî Limpa toda a blacklist

${prefix}antipalavra stats
‚îî Mostra estat√≠sticas

‚ö†Ô∏è *IMPORTANTE:*
Membros que falarem palavras da blacklist ser√£o BANIDOS AUTOMATICAMENTE do grupo!

üí° *Dica:* O sistema ignora acentos e mai√∫sculas/min√∫sculas na detec√ß√£o.`);
        break;

      case 'chance':
        try {
          if (!isGroup) return reply("üéÆ Ops! Esse comando s√≥ funciona em grupos! Chama a galera! üë•ÔøΩ");
          if (!isModoBn) return reply('‚ùå O modo brincadeira est√° off nesse grupo! Pede pro admin ativar a divers√£o! üéâ');
          if (!q) return reply(`üé≤ Me conta algo para eu calcular as chances! üìä

üìù *Exemplo:* ${prefix}chance chover pizza hoje
üöÄ *Exemplo:* ${prefix}chance eu virar milion√°rio
üíñ *Exemplo:* ${prefix}chance encontrar o amor`);
          const chance = Math.floor(Math.random() * 101);
          const emojis = ['üéØ', 'üìä', 'üé≤', '‚ú®', 'üîÆ', 'üçÄ', 'üéÜ'];
          const emoji = emojis[Math.floor(Math.random() * emojis.length)];
          const comentarios = [
            'As estrelas sussurraram...', 'Minha bola de cristal revelou...', 'Calculei usando matem√°tica qu√¢ntica...', 
            'Consultei os or√°culos...', 'Analisei todas as possibilidades...', 'O universo me contou...'
          ];
          const comentario = comentarios[Math.floor(Math.random() * comentarios.length)];
          await reply(`${emoji} *${comentario}*

üéØ A chance de "${q}" acontecer √©: *${chance}%*!

${chance >= 80 ? 'üöÄ Uau! Apostaria minhas fichas nisso!' : chance >= 60 ? 'üòé Chances promissoras!' : chance >= 40 ? 'ü§î Meio termo, pode rolar!' : chance >= 20 ? 'üòÖ Hmm... complicado!' : 'üòÇ Melhor sonhar com outra coisa!'}`);
        } catch (e) {
          console.error(e);
          await reply("üòµ Minha bola de cristal bugou! Tenta de novo! üîÆÔøΩ");
        }
        break;
      case 'quando':
        try {
          if (!isGroup) return reply("üï∞Ô∏è Esse comando s√≥ funciona em grupos! Vem com a galera! ÔøΩ‚ú®");
          if (!isModoBn) return reply('‚ùå O modo brincadeira est√° dormindo nesse grupo! Acorda ele! üò¥üéâ');
          if (!q) return reply(`üîÆ Me conta o que voc√™ quer que eu preveja! üå†

üìù *Exemplos:*
‚Ä¢ ${prefix}quando vou ficar rico
‚Ä¢ ${prefix}quando vou encontrar o amor
‚Ä¢ ${prefix}quando vou viajar
‚Ä¢ ${prefix}quando vou ser famoso`);
          const tempos = [
            'hoje √† noite üåô', 'amanh√£ de manh√£ üåÖ', 'na pr√≥xima semana üìÖ', 
            'no pr√≥ximo m√™s üåï', 'no pr√≥ximo ano üéÜ', 'em 2025 üöÄ',
            'quando voc√™ menos esperar ‚ú®', 'em uma ter√ßa-feira chuvosa üåßÔ∏è',
            'depois do carnaval üé°', 'nunca üòÖ', 'j√° aconteceu e voc√™ n√£o viu ü§Ø',
            'numa sexta-feira 13 üòà', 'quando os santos ajudarem üòá'
          ];
          const tempo = tempos[Math.floor(Math.random() * tempos.length)];
          const prefixos = [
            'üîÆ Minha vis√£o revela que', '‚ú® As energias indicam que', 'üå† Consultei as estrelas e',
            'üí´ O universo sussurra que', 'üßô‚Äç‚ôÇÔ∏è Pelos poderes que me foram concedidos'
          ];
          const prefixo = prefixos[Math.floor(Math.random() * prefixos.length)];
          await reply(`${prefixo}...

ÔøΩÔ∏è "${q}" vai acontecer: *${tempo}*!

${tempo.includes('nunca') ? 'üòÇ Brincadeira! Nunca desista dos seus sonhos!' : 'üçÄ Boa sorte na espera!'}`);
        } catch (e) {
          console.error(e);
          await reply("üîÆ Minha m√°quina do tempo pifou! Tenta de novo! ‚è∞ÔøΩ");
        }
        break;
      case 'brincadeira': {
        if (!isGroup) {
          await reply('‚ö†Ô∏è Esse pedido s√≥ pode ser feito em grupos.');
          break;
        }
        if (!isModoBn) {
          await reply('‚ùå O modo brincadeira est√° desligado neste grupo.');
          break;
        }
        if (!menc_os2) {
          await reply('‚ùå Marque a pessoa que voc√™ quer chamar para uma brincadeira.');
          break;
        }
        if (menc_os2 === sender) {
          await reply('‚ùå Voc√™ n√£o pode enviar um pedido para voc√™ mesmo.');
          break;
        }
        const requestResult = relationshipManager.createRequest('brincadeira', from, sender, menc_os2);
        if (!requestResult.success) {
          if (requestResult.mentions && requestResult.mentions.length > 0) {
            await nazu.sendMessage(from, {
              text: requestResult.message,
              mentions: requestResult.mentions
            }, { quoted: info });
          } else {
            await reply(requestResult.message);
          }
          break;
        }
        await nazu.sendMessage(from, {
          text: requestResult.message,
          mentions: requestResult.mentions || [sender, menc_os2]
        });
        break;
      }
      case 'namoro':
      case 'namorar': {
        if (!isGroup) {
          await reply('‚ö†Ô∏è Esse pedido s√≥ pode ser feito em grupos.');
          break;
        }
        if (!isModoBn) {
          await reply('‚ùå O modo brincadeira est√° desligado neste grupo.');
          break;
        }
        if (!menc_os2) {
          await reply('‚ùå Marque a pessoa que voc√™ quer pedir em namoro.');
          break;
        }
        if (menc_os2 === sender) {
          await reply('‚ùå Voc√™ n√£o pode enviar um pedido para voc√™ mesmo.');
          break;
        }
        const requestResult = relationshipManager.createRequest('namoro', from, sender, menc_os2);
        if (!requestResult.success) {
          if (requestResult.mentions && requestResult.mentions.length > 0) {
            await nazu.sendMessage(from, {
              text: requestResult.message,
              mentions: requestResult.mentions
            }, { quoted: info });
          } else {
            await reply(requestResult.message);
          }
          break;
        }
        await nazu.sendMessage(from, {
          text: requestResult.message,
          mentions: requestResult.mentions || [sender, menc_os2]
        });
        break;
      }
      case 'casamento':
      case 'casar': {
        if (!isGroup) {
          await reply('‚ö†Ô∏è Esse pedido s√≥ pode ser feito em grupos.');
          break;
        }
        if (!isModoBn) {
          await reply('‚ùå O modo brincadeira est√° desligado neste grupo.');
          break;
        }
        if (!menc_os2) {
          await reply('‚ùå Marque a pessoa que voc√™ quer pedir em casamento.');
          break;
        }
        if (menc_os2 === sender) {
          await reply('‚ùå Voc√™ n√£o pode enviar um pedido para voc√™ mesmo.');
          break;
        }
        const requestResult = relationshipManager.createRequest('casamento', from, sender, menc_os2);
        if (!requestResult.success) {
          if (requestResult.mentions && requestResult.mentions.length > 0) {
            await nazu.sendMessage(from, {
              text: requestResult.message,
              mentions: requestResult.mentions
            }, { quoted: info });
          } else {
            await reply(requestResult.message);
          }
          break;
        }
        await nazu.sendMessage(from, {
          text: requestResult.message,
          mentions: requestResult.mentions || [sender, menc_os2]
        });
        break;
      }
      case 'relacionamento': {
        const mentionedList = Array.isArray(menc_jid2) ? menc_jid2 : [];
        let userOne = null;
        let userTwo = null;

        if (mentionedList.length >= 2) {
          [userOne, userTwo] = mentionedList;
        } else if (menc_os2) {
          userOne = sender;
          userTwo = menc_os2;
        }

        if (!userOne || !userTwo) {
          const activePair = relationshipManager.getActivePairForUser(sender);
          if (!activePair) {
            await reply('‚ùå Voc√™ n√£o marcou ningu√©m e n√£o possui relacionamento ativo no momento.');
            break;
          }
          userOne = sender;
          userTwo = activePair.partnerId;
        }
        if (userOne === userTwo) {
          await reply('‚ùå Selecione pessoas diferentes para consultar.');
          break;
        }

        const summary = relationshipManager.getRelationshipSummary(userOne, userTwo);
        if (!summary.success) {
          await reply(summary.message);
          break;
        }

        await nazu.sendMessage(from, {
          text: summary.message,
          mentions: summary.mentions || [userOne, userTwo]
        }, { quoted: info });
        break;
      }
      
      case 'casais':
      case 'couples':
      case 'listacasais': {
        if (!isGroup) {
          await reply('‚ö†Ô∏è Este comando s√≥ pode ser usado em grupos.');
          break;
        }
        
        const allRelationships = relationshipManager.getAllRelationships ? relationshipManager.getAllRelationships() : [];
        const groupCouples = allRelationships.filter(rel => 
          rel.type === 'casamento' && 
          AllgroupMembers.includes(rel.user1) && 
          AllgroupMembers.includes(rel.user2)
        );
        
        if (groupCouples.length === 0) {
          await reply('üíî N√£o h√° casais neste grupo ainda!\n\nüí° Use ' + prefix + 'casar @pessoa para se casar!');
          break;
        }
        
        let text = `‚ï≠‚îÅ‚îÅ‚îÅ‚ä± üíï *CASAIS DO GRUPO* ‚ä±‚îÅ‚îÅ‚îÅ‚ïÆ\n‚îÇ\n`;
        const mentions = [];
        
        groupCouples.forEach((couple, i) => {
          const user1Name = couple.user1.split('@')[0];
          const user2Name = couple.user2.split('@')[0];
          const startDate = couple.startDate ? new Date(couple.startDate).toLocaleDateString('pt-BR') : 'N/A';
          
          text += `‚îÇ ${i + 1}. @${user1Name} üíç @${user2Name}\n`;
          text += `‚îÇ    üìÖ Desde: ${startDate}\n‚îÇ\n`;
          mentions.push(couple.user1, couple.user2);
        });
        
        text += `‚ï∞‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚ïØ\n`;
        text += `\nüíï Total: ${groupCouples.length} casal(is)`;
        
        await nazu.sendMessage(from, { text, mentions }, { quoted: info });
        break;
      }
      
      case 'divorciar':
      case 'divorcio':
      case 'terminar':
      case 'termino':
      case 'terminarelacionamento': {
        if (!isGroup) {
          await reply('‚ö†Ô∏è Esse comando s√≥ pode ser usado em grupos.');
          break;
        }

        const mentionedList = Array.isArray(menc_jid2) ? menc_jid2 : [];
        let userOne = null;
        let userTwo = null;

        if (mentionedList.length >= 2) {
          [userOne, userTwo] = mentionedList;
        } else if (menc_os2) {
          userOne = sender;
          userTwo = menc_os2;
        } else {
          const activePair = relationshipManager.getActivePairForUser(sender);
          if (!activePair) {
            await reply('‚ùå Voc√™ n√£o marcou ningu√©m e n√£o possui relacionamento ativo para encerrar.');
            break;
          }
          userOne = sender;
          userTwo = activePair.partnerId;
        }

        if (!userOne || !userTwo) {
          await reply('‚ùå Informe o casal que deseja encerrar.');
          break;
        }

        if (userOne === userTwo) {
          await reply('‚ùå Selecione pessoas diferentes para encerrar o relacionamento.');
          break;
        }

        const participants = [userOne, userTwo];
        const isParticipant = participants.includes(sender);
        if (!isParticipant && !isGroupAdmin && !isOwner) {
          await reply('üö´ Apenas os envolvidos ou um administrador podem encerrar o relacionamento de terceiros.');
          break;
        }

        const endResult = relationshipManager.endRelationship(userOne, userTwo, sender);
        if (!endResult.success) {
          await reply(endResult.message);
          break;
        }

        await nazu.sendMessage(from, {
          text: endResult.message,
          mentions: endResult.mentions || participants
        });
        break;
      }

      case 'trair':
      case 'traicao': {
        if (!isGroup) {
          await reply('‚ö†Ô∏è Esse comando s√≥ pode ser usado em grupos.');
          break;
        }
        if (!isModoBn) {
          await reply('‚ùå O modo brincadeira n√£o est√° ativo nesse grupo.');
          break;
        }

        if (!menc_os2) {
          await reply('‚ùå Voc√™ precisa marcar algu√©m para trair! Exemplo: ' + groupPrefix + 'trair @pessoa');
          break;
        }

        if (menc_os2 === sender) {
          await reply('‚ùå Voc√™ n√£o pode trair a si mesmo... isso n√£o faz sentido! ü§®');
          break;
        }

        // Cria pedido de trai√ß√£o (precisa ser aceito pelo alvo)
        const betrayalResult = relationshipManager.createBetrayalRequest(sender, menc_os2, from, groupPrefix);
        if (!betrayalResult.success) {
          await reply(betrayalResult.message, { mentions: betrayalResult.mentions || [] });
          break;
        }

        await nazu.sendMessage(from, {
          text: betrayalResult.message,
          mentions: betrayalResult.mentions || [sender, menc_os2]
        });
        break;
      }

      case 'historicotraicao':
      case 'historicotraicoes':
      case 'historicodetraicao': {
        if (!isGroup) {
          await reply('‚ö†Ô∏è Esse comando s√≥ pode ser usado em grupos.');
          break;
        }
        if (!isModoBn) {
          await reply('‚ùå O modo brincadeira n√£o est√° ativo nesse grupo.');
          break;
        }

        const mentionedList = Array.isArray(menc_jid2) ? menc_jid2 : [];
        let userOne = null;
        let userTwo = null;

        if (mentionedList.length >= 2) {
          [userOne, userTwo] = mentionedList;
        } else if (menc_os2) {
          userOne = sender;
          userTwo = menc_os2;
        } else {
          const activePair = relationshipManager.getActivePairForUser(sender);
          if (!activePair) {
            await reply('‚ùå Voc√™ n√£o marcou ningu√©m e n√£o possui relacionamento ativo para consultar o hist√≥rico.');
            break;
          }
          userOne = sender;
          userTwo = activePair.partnerId;
        }

        if (userOne === userTwo) {
          await reply('‚ùå Selecione pessoas diferentes para consultar o hist√≥rico.');
          break;
        }

        const historyResult = relationshipManager.getBetrayalHistory(userOne, userTwo);
        if (!historyResult.success) {
          await reply(historyResult.message);
          break;
        }

        await nazu.sendMessage(from, {
          text: historyResult.message,
          mentions: historyResult.mentions || [userOne, userTwo]
        });
        break;
      }

      case 'casal':
        try {
          if (!isGroup) return reply("‚ï≠‚îÅ‚îÅ‚îÅ‚ä± üíî *ERRO* üíî ‚ä±‚îÅ‚îÅ‚îÅ‚ïÆ\n‚îÇ\n‚îÇ ‚ùå Este comando s√≥ funciona\n‚îÇ    em grupos!\n‚îÇ\n‚ï∞‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚ïØ");
          if (!isModoBn) return reply('‚ùå O modo brincadeira n√£o est√° ativo nesse grupo.');
          if (AllgroupMembers.length < 2) return reply('‚ùå Preciso de pelo menos 2 membros no grupo!');
          let path = buildGroupFilePath(from);
          // Otimiza√ß√£o: Usar cache para leitura de arquivo
          let data = await optimizer.loadJsonWithCache(path, { mark: {} });
          let membros = AllgroupMembers.filter(m => !['0', 'marca'].includes(data.mark[m]));
          const membro1 = membros[Math.floor(Math.random() * membros.length)];
          let membro2 = membros[Math.floor(Math.random() * membros.length)];
          while (membro2 === membro1) {
            membro2 = membros[Math.floor(Math.random() * membros.length)];
          }
          const shipLevel = Math.floor(Math.random() * 101);
          const chance = Math.floor(Math.random() * 101);
          const comentarios = [
            'Cupido acabou de atirar!', 'O amor est√° no ar!', 'Combina√ß√£o perfeita detectada!',
            'Ship aprovado pela comunidade!', 'Quimica confirmada!', 'Casal goals incoming!'
          ];
          const comentario = comentarios[Math.floor(Math.random() * comentarios.length)];
          const statusShip = shipLevel >= 80 ? 'üî• SHIP INCENDI√ÅRIO!' : 
                           shipLevel >= 60 ? 'üòç Ship promissor!' : 
                           shipLevel >= 40 ? 'üòä Rolou uma qu√≠mica!' : 
                           shipLevel >= 20 ? 'ü§î Meio for√ßado...' : 'üòÖ S√≥ na amizade!';
          await reply(`‚ï≠‚îÅ‚îÅ‚îÅ‚ä± üíò *CASAL* üíò ‚ä±‚îÅ‚îÅ‚îÅ‚ïÆ
‚îÇ
‚îÇ üí´ *${comentario}*
‚îÇ
‚îÇ üëë *CASAL DO MOMENTO*
‚îÇ @${getUserName(membro1)} ‚ù§Ô∏è @${getUserName(membro2)}
‚îÇ
‚îÇ üìä *Estat√≠sticas*
‚îÇ ‚îî‚îÄ üíñ Ship: *${shipLevel}%*
‚îÇ ‚îî‚îÄ üéØ Chance: *${chance}%*
‚îÇ
‚îÇ ${statusShip}
‚îÇ
‚îÇ ${chance >= 70 ? 'üéâ J√° podem marcar o casamento!' : chance >= 50 ? 'üëÄ Vale a pena investir!' : 'üòÇ Melhor ficar s√≥ na amizade!'}
‚îÇ
‚ï∞‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚ïØ`, {
            mentions: [membro1, membro2]
          });
        } catch (e) {
          console.error(e);
          await reply("Ocorreu um erro üíî");
        }
        break;
      case 'shipo':
        try {
          if (!isGroup) return reply("‚ï≠‚îÅ‚îÅ‚îÅ‚ä± üíî *ERRO* üíî ‚ä±‚îÅ‚îÅ‚îÅ‚ïÆ\n‚îÇ\n‚îÇ ‚ùå Este comando s√≥ funciona\n‚îÇ    em grupos!\n‚îÇ\n‚ï∞‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚ïØ");
          if (!isModoBn) return reply('‚ùå O modo brincadeira n√£o est√° ativo nesse grupo.');
          if (!menc_os2) return reply(`‚ï≠‚îÅ‚îÅ‚îÅ‚ä± üíò *SHIPO* üíò ‚ä±‚îÅ‚îÅ‚îÅ‚ïÆ
‚îÇ
‚îÇ ‚ùå Marque algu√©m para
‚îÇ    encontrar um par!
‚îÇ
‚îÇ üí° *Exemplo:*
‚îÇ ${prefix}shipo @fulano
‚îÇ
‚ï∞‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚ïØ`);
          if (AllgroupMembers.length < 2) return reply('‚ùå Preciso de pelo menos 2 membros no grupo!');
          let path = buildGroupFilePath(from);
          // Otimiza√ß√£o: Usar cache para leitura de arquivo
          let data = await optimizer.loadJsonWithCache(path, { mark: {} });
          let membros = AllgroupMembers.filter(m => !['0', 'marca'].includes(data.mark[m]));
          let par = membros[Math.floor(Math.random() * membros.length)];
          while (par === menc_os2) {
            par = membros[Math.floor(Math.random() * membros.length)];
          }
          const shipLevel = Math.floor(Math.random() * 101);
          const chance = Math.floor(Math.random() * 101);
          const nomeShip = `${getUserName(menc_os2).slice(0,3)}${getUserName(par).slice(-3)}`;
          const comentarios = [
            'Encontrei o par perfeito!', 'Match feito no c√©u!', 'Combina√ß√£o aprovada!',
            'Ship name j√° t√° pronto!', 'Quero ver essa dupla!', 'Shippando forte!'
          ];
          const comentario = comentarios[Math.floor(Math.random() * comentarios.length)];
          const emojisShip = ['üíò', 'üíñ', 'üíù', 'üíû', 'üíï', '‚ù§Ô∏è', 'üíì'];
          const emoji = emojisShip[Math.floor(Math.random() * emojisShip.length)];
          const statusShip = shipLevel >= 85 ? 'üî• SHIP LEND√ÅRIO!' : 
                           shipLevel >= 70 ? 'üéÜ Ship de qualidade!' : 
                           shipLevel >= 50 ? 'üòä Tem potencial!' : 
                           shipLevel >= 30 ? 'ü§î Pode rolar...' : 'üòÖ For√ßa demais!';
          await reply(`‚ï≠‚îÅ‚îÅ‚îÅ‚ä± ${emoji} *SHIPO* ${emoji} ‚ä±‚îÅ‚îÅ‚îÅ‚ïÆ
‚îÇ
‚îÇ üí´ *${comentario}*
‚îÇ
‚îÇ üëë *SHIP SELECIONADO*
‚îÇ @${getUserName(menc_os2)} ‚ú® @${getUserName(par)}
‚îÇ
‚îÇ üí´ *Ship name:* ${nomeShip}
‚îÇ
‚îÇ üìä *Estat√≠sticas*
‚îÇ ‚îî‚îÄ üíñ Ship: *${shipLevel}%*
‚îÇ ‚îî‚îÄ üéØ Compatibilidade: *${chance}%*
‚îÇ
‚îÇ ${statusShip}
‚îÇ
‚îÇ ${chance >= 75 ? 'üéâ Relacionamento dos sonhos!' : chance >= 50 ? 'üëÄ Merece uma chance!' : 'üòÇ Melhor s√≥ shippar mesmo!'}
‚îÇ
‚ï∞‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚ïØ`, {
            mentions: [menc_os2, par]
          });
        } catch (e) {
          console.error(e);
          await reply("Ocorreu um erro üíî");
        }
        break;
      case 'sn':
        try {
          if (!isGroup) return reply("üé± Esse comando s√≥ funciona em grupos! Chama todo mundo! ÔøΩ‚ú®");
          if (!isModoBn) return reply('‚ùå O modo brincadeira est√° pausado nesse grupo! Hora de ativar a divers√£o! üéâ');
          if (!q) return reply(`üé± Fa√ßa uma pergunta para o or√°culo! üîÆ

üìù *Exemplos:*
‚Ä¢ ${prefix}sn Vou ganhar na loteria?
‚Ä¢ ${prefix}sn Devo confesar meus sentimentos?
‚Ä¢ ${prefix}sn Vale a pena investir em Bitcoin?
‚Ä¢ ${prefix}sn Vou passar na prova?`);
          const respostasPositivas = [
            'Sim! üéâ', 'Claro que sim! üòé', 'Com certeza! ‚ú®', 'Pode apostar! üéØ',
            'Sem d√∫vida! üëç', 'Obviamente! üòå', '√â isso a√≠! üöÄ', 'Vai dar certo! üçÄ'
          ];
          const respostasNegativas = [
            'N√£o! üòÖ', 'Nem pensar! üòÇ', 'Esquece! ü§≠', 'Nada a ver! üôÑ',
            'De jeito nenhum! üòë', 'Que nada! üòí', 'N√£o rola! üò∂', 'Melhor n√£o! üò¨'
          ];
          const isPositive = Math.random() > 0.5;
          const resposta = isPositive ? 
            respostasPositivas[Math.floor(Math.random() * respostasPositivas.length)] :
            respostasNegativas[Math.floor(Math.random() * respostasNegativas.length)];
          
          const confianca = Math.floor(Math.random() * 30) + 70; // 70-100%
          const emoji = isPositive ? 'üéÜ' : 'üíî';
          
          await reply(`ÔøΩ **OR√ÅCULO RESPONDE** üé±

ü§î *Pergunta:* "${q}"

${emoji} **Resposta:** *${resposta}*

üìä *Confian√ßa:* ${confianca}%

${isPositive ? 'üéâ O destino sorri para voc√™!' : 'üòÖ Mas n√£o desista dos seus sonhos!'}`);
        } catch (e) {
          console.error(e);
          await reply("üé± A bola 8 travou! Tenta de novo! ÔøΩ");
        }
        break;
      case 'sorte':
        try {
          if (!isGroup) return reply("üçÄ Esse comando s√≥ funciona em grupos! Chama a galera pra testar a sorte! ‚ú®üë•");
          if (!isModoBn) return reply('‚ùå O modo brincadeira est√° desativado nesse grupo! Hora de liberar a divers√£o! üéâüé≤');
          
          const usuario = menc_os2 || sender;
          const nome = menc_os2 ? getUserName(menc_os2) : pushname;
          const nivelSorte = Math.floor(Math.random() * 101);
          
          const comentarios = [
            'Os astros foram consultados...', 'A fortuna foi analisada...', 'O destino revelou...',
            'As energias c√≥smicas mostram...', 'O universo sussurrou...', 'A roda da fortuna girou...'
          ];
          const comentario = comentarios[Math.floor(Math.random() * comentarios.length)];
          
          const statusSorte = nivelSorte >= 90 ? 'üåü SORTE LEND√ÅRIA!' : 
                            nivelSorte >= 75 ? 'üçÄ Super sortudo!' : 
                            nivelSorte >= 60 ? '‚ú® Boa sorte!' : 
                            nivelSorte >= 40 ? 'ü§û Sorte m√©dia!' : 
                            nivelSorte >= 20 ? 'üòÖ Sorte baixa...' : 'üíÄ Azar total!';
          
          const dicas = [
            'Aposte na loteria hoje!', 'Evite gatos pretos!', 'Use algo verde!', 'Fa√ßa um pedido!',
            'Procure trevos de 4 folhas!', 'Cuidado com espelhos quebrados!', 'Jogue sal por cima do ombro!',
            'Vista algo amarelo!', 'Evite passar debaixo de escadas!', 'Fa√ßa uma simpatia!'
          ];
          const dica = dicas[Math.floor(Math.random() * dicas.length)];
          
          await reply(`üîÆ *${comentario}*

üçÄ **MEDIDOR DE SORTE** üçÄ
üë§ *Pessoa:* ${nome}

üéØ **N√≠vel de sorte:** *${nivelSorte}%*

${statusSorte}

üí° *Dica do dia:* ${dica}

${nivelSorte >= 70 ? 'üéâ Hoje √© seu dia de sorte!' : nivelSorte >= 40 ? 'ü§î Cuidado com as decis√µes!' : 'üò¨ Melhor ficar em casa hoje!'}`, {
            mentions: menc_os2 ? [menc_os2] : []
          });
        } catch (e) {
          console.error(e);
          await reply("üçÄ O trevo de 4 folhas fugiu! Tenta de novo! üèÉ‚Äç‚ôÇÔ∏èüí®");
        }
        break;
      case 'admins':
      case 'admin':
      case 'adm':
      case 'adms':
        if (!isGroup) return reply("isso so pode ser usado em grupo üíî");
        try {
          let membros = groupAdmins;
          let msg = `üì¢ *Mencionando os admins do grupo:* ${q ? `\nüí¨ *Mensagem:* ${q}` : ''}\n\n`;
          await nazu.sendMessage(from, {
            text: msg + membros.map(m => `‚û§ @${getUserName(m)}`).join('\n'),
            mentions: membros
          });
        } catch (e) {
          console.error(e);
          reply("ocorreu um erro üíî");
        }
        break;
      case 'perfil':
        try {
          const target = sender;
          const targetId = getUserName(target);
          const targetName = `@${targetId}`;
          const levels = {
            puta: Math.floor(Math.random() * 101),
            gado: Math.floor(Math.random() * 101),
            corno: Math.floor(Math.random() * 101),
            sortudo: Math.floor(Math.random() * 101),
            carisma: Math.floor(Math.random() * 101),
            rico: Math.floor(Math.random() * 101),
            gostosa: Math.floor(Math.random() * 101),
            feio: Math.floor(Math.random() * 101)
          };
          const pacoteValue = `R$ ${(Math.random() * 10000 + 1).toFixed(2).replace('.', ',')}`;
          const humors = ['üòé Tranquil√£o', 'üî• No fogo', 'üò¥ Sonolento', 'ü§ì Nerd mode', 'üòú Loucura total', 'üßò Zen'];
          const randomHumor = humors[Math.floor(Math.random() * humors.length)];
          let profilePic = 'https://raw.githubusercontent.com/nazuninha/uploads/main/outros/1747053564257_bzswae.bin';
          try {
            profilePic = await nazu.profilePictureUrl(target, 'image');
          } catch (error) {
            console.warn(`Falha ao obter foto do perfil de ${targetName}:`, error.message);
          }
          let bio = 'Sem bio dispon√≠vel';
          let bioSetAt = '';
          try {
            const statusData = await nazu.fetchStatus(target);
            const status = statusData?.[0]?.status;
            if (status) {
              bio = status.status || bio;
              bioSetAt = new Date(status.setAt).toLocaleString('pt-BR', {
                dateStyle: 'short',
                timeStyle: 'short',
                timeZone: 'America/Sao_Paulo'
              });
            }
          } catch (error) {
            console.warn(`Falha ao obter status/bio de ${targetName}:`, error.message);
          }
          const perfilText = `üìã Perfil de ${targetName} üìã\n\nüë§ *Nome*: ${pushname || 'Desconhecido'}\nüì± *N√∫mero*: ${targetId}\nüìú *Bio*: ${bio}${bioSetAt ? `\nüïí *Bio atualizada em*: ${bioSetAt}` : ''}\nüí∞ *Valor do Pacote*: ${pacoteValue} ü´¶\nüò∏ *Humor*: ${randomHumor}\n\nüé≠ *N√≠veis*:\n  ‚Ä¢ Puta: ${levels.puta}%\n  ‚Ä¢ Gado: ${levels.gado}%\n  ‚Ä¢ Corno: ${levels.corno}%\n  ‚Ä¢ Sortudo: ${levels.sortudo}%\n  ‚Ä¢ Carisma: ${levels.carisma}%\n  ‚Ä¢ Rico: ${levels.rico}%\n  ‚Ä¢ Gostosa: ${levels.gostosa}%\n  ‚Ä¢ Feio: ${levels.feio}%`.trim();
          
          await nazu.sendMessage(from, { image: { url: profilePic }, caption: perfilText, mentions: [target] }, { quoted: info });
        } catch (error) {
          console.error('Erro ao processar comando perfil:', error);
          await reply('Ocorreu um erro ao gerar o perfil üíî');
        }
        break;
      case 'ppt':
        try {
          if (!q) return reply(`üéÆ *Pedra, Papel ou Tesoura*\n\nüí° *Como jogar:*\n‚Ä¢ Escolha sua jogada ap√≥s o comando\n‚Ä¢ Ex: ${prefix}ppt pedra\n‚Ä¢ Ex: ${prefix}ppt papel\n‚Ä¢ Ex: ${prefix}ppt tesoura\n\nüé≤ Vamos ver quem ganha!`);
          const escolhas = ['pedra', 'papel', 'tesoura'];
          if (!escolhas.includes(q.toLowerCase())) return reply('Escolha inv√°lida! Use: pedra, papel ou tesoura.');
          const botEscolha = escolhas[Math.floor(Math.random() * 3)];
          const usuarioEscolha = q.toLowerCase();
          let resultado;
          if (usuarioEscolha === botEscolha) {
            resultado = 'Empate! ü§ù';
          } else if (usuarioEscolha === 'pedra' && botEscolha === 'tesoura' || usuarioEscolha === 'papel' && botEscolha === 'pedra' || usuarioEscolha === 'tesoura' && botEscolha === 'papel') {
            resultado = 'Voc√™ ganhou! üéâ';
          } else {
            resultado = 'Eu ganhei! üòé';
          }
          await reply(`üñêÔ∏è *Pedra, Papel, Tesoura* üñêÔ∏è\n\nVoc√™: ${usuarioEscolha}\nEu: ${botEscolha}\n\n${resultado}`);
        } catch (e) {
          console.error(e);
          await reply("Ocorreu um erro üíî");
        }
        break;
      case 'eununca':
        try {
          if (!isGroup) return reply("isso so pode ser usado em grupo üíî");
          if (!isModoBn) return reply('‚ùå O modo brincadeira n√£o esta ativo nesse grupo');
          
          const pollQuestion = toolsJson().iNever[Math.floor(Math.random() * toolsJson().iNever.length)];
          
          await reply(`üîû *EU NUNCA*\n\n${pollQuestion}\n\nResponda com: *Eu nunca* ou *Eu j√°*`);
        } catch (e) {
          console.error(e);
          await reply("‚ùå Ocorreu um erro interno. Tente novamente em alguns minutos.");
        }
        break;
      case 'vab':
        try {
          if (!isGroup) return reply("isso so pode ser usado em grupo üíî");
          if (!isModoBn) return reply('‚ùå O modo brincadeira n√£o esta ativo nesse grupo');
          
          const vabs = vabJson()[Math.floor(Math.random() * vabJson().length)];
          
          await reply(`ü§î *O QUE VOC√ä PREFERE?*\n\n1Ô∏è‚É£ ${vabs.option1}\n2Ô∏è‚É£ ${vabs.option2}`);
        } catch (e) {
          console.error(e);
          await reply("‚ùå Ocorreu um erro interno. Tente novamente em alguns minutos.");
        }
        break;
      case 'conselho':
        try {
          const conselhos = toolsJson().Conselhos;
          const conselho = conselhos[Math.floor(Math.random() * conselhos.length)];
          await reply(`üí° *Conselho do dia:*\n\n${conselho}`);
        } catch (e) {
          console.error(e);
          await reply("‚ùå Ocorreu um erro ao buscar o conselho.");
        }
        break;
      case 'conselhobiblico':
      case 'versiculo':
      case 'biblia':
        try {
          const conselhosBiblicos = toolsJson().ConselhosBiblicos;
          const conselhoBiblico = conselhosBiblicos[Math.floor(Math.random() * conselhosBiblicos.length)];
          await reply(`üìñ *Conselho B√≠blico:*\n\n${conselhoBiblico}`);
        } catch (e) {
          console.error(e);
          await reply("‚ùå Ocorreu um erro ao buscar o vers√≠culo.");
        }
        break;
      case 'cantada':
      case 'cantadas':
        try {
          const cantadas = toolsJson().Cantadas;
          const cantada = cantadas[Math.floor(Math.random() * cantadas.length)];
          await reply(`üíò *Cantada:*\n\n${cantada}`);
        } catch (e) {
          console.error(e);
          await reply("‚ùå Ocorreu um erro ao buscar a cantada.");
        }
        break;
      case 'piada':
      case 'piadas':
        try {
          const piadas = toolsJson().Piadas;
          const piada = piadas[Math.floor(Math.random() * piadas.length)];
          await reply(`üòÇ *Piada:*\n\n${piada}`);
        } catch (e) {
          console.error(e);
          await reply("‚ùå Ocorreu um erro ao buscar a piada.");
        }
        break;
      case 'charada':
      case 'enigma':
        try {
          const charadas = toolsJson().Charadas;
          const charada = charadas[Math.floor(Math.random() * charadas.length)];
          await reply(`üß© *Charada:*\n\n${charada}`);
        } catch (e) {
          console.error(e);
          await reply("‚ùå Ocorreu um erro ao buscar a charada.");
        }
        break;
      case 'motivacional':
      case 'motivacao':
      case 'frasemotivacional':
        try {
          const motivacionais = toolsJson().FrasesMotivacionais;
          const motivacional = motivacionais[Math.floor(Math.random() * motivacionais.length)];
          await reply(`üöÄ *Frase Motivacional:*\n\n${motivacional}`);
        } catch (e) {
          console.error(e);
          await reply("‚ùå Ocorreu um erro ao buscar a frase.");
        }
        break;
      case 'elogio':
      case 'elogiar':
        try {
          const elogios = toolsJson().Elogios;
          const elogio = elogios[Math.floor(Math.random() * elogios.length)];
          await reply(`üåü *Elogio:*\n\n${elogio}`);
        } catch (e) {
          console.error(e);
          await reply("‚ùå Ocorreu um erro ao buscar o elogio.");
        }
        break;
      case 'reflexao':
      case 'pensamento':
        try {
          const reflexoes = toolsJson().Reflexoes;
          const reflexao = reflexoes[Math.floor(Math.random() * reflexoes.length)];
          await reply(`ü§î *Reflex√£o:*\n\n${reflexao}`);
        } catch (e) {
          console.error(e);
          await reply("‚ùå Ocorreu um erro ao buscar a reflex√£o.");
        }
        break;
      case 'fato':
      case 'fatocurioso':
      case 'curiosidade':
        try {
          const fatos = toolsJson().curiousFacts;
          const fato = fatos[Math.floor(Math.random() * fatos.length)];
          await reply(`üî¨ *Fato Curioso:*\n\n${fato}`);
        } catch (e) {
          console.error(e);
          await reply("‚ùå Ocorreu um erro ao buscar o fato.");
        }
        break;
      case 'surubao':
      case 'suruba':
        try {
          if (isModoLite) return nazu.react('‚ùå', {
            key: info.key
          });
          if (!isGroup) return reply(`Apenas em grupos`);
          if (!isModoBn) return reply('O modo brincadeira nao esta ativo no grupo');
          if (!q) return reply(`Eita, coloque o n√∫mero de pessoas ap√≥s o comando.`);
          if (Number(q) > 15) return reply("Coloque um n√∫mero menor, ou seja, abaixo de *15*.");
          var emojiskk;
          emojiskk = ["ü•µ", "üòà", "ü´£", "üòè"];
          var emojis2;
          emojis2 = emojiskk[Math.floor(Math.random() * emojiskk.length)];
          var frasekk;
          frasekk = [`t√° querendo rela√ß√µes sexuais a ${q}, topa?`, `quer que *${q}* pessoas venham de *chicote, algema e corda de alpinista*.`, `quer que ${q} pessoas der tapa na cara, lhe chame de cachorra e fud3r bem gostosinho...`];
          let path = buildGroupFilePath(from);
          // Otimiza√ß√£o: Usar cache para leitura de arquivo
          let data = await optimizer.loadJsonWithCache(path, { mark: {} });
          let membros = AllgroupMembers.filter(m => !['0', 'marca'].includes(data.mark[m]));
          var context;
          context = frasekk[Math.floor(Math.random() * frasekk.length)];
          var ABC;
          ABC = `${emojis2} @${getUserName(sender)} ${context}\n\n`;
          var mencts;
          mencts = [sender];
          for (var i = 0; i < q; i++) {
            var menb;
            menb = membros[Math.floor(Math.random() * membros.length)];
            var ABC;
            ABC += `@${menb.split("@")[0]}\n`;
            mencts.push(menb);
          }
          await nazu.sendMessage(from, {
            image: {
              url: 'https://raw.githubusercontent.com/nazuninha/uploads/main/outros/1747545773146_rrv7of.bin'
            },
            caption: ABC,
            mentions: mencts
          });
        } catch (e) {
          console.error(e);
          await reply("‚ùå Ocorreu um erro interno. Tente novamente em alguns minutos.");
        }
        break;
      case 'suicidio':
        reply(`*√â uma pena que tenha tomado essa decis√£o ${pushname}, vamos sentir saudades... üòï*`).then(() => {
          setTimeout(() => {
            nazu.groupParticipantsUpdate(from, [sender], "remove").then(() => {
              setTimeout(() => {
                reply(`*Ainda bem que morreu, n√£o aguentava mais essa praga kkkkkk*`);
              }, 1000);
            });
          }, 2000);
        }).catch((e) => {
          console.error(e);
          reply("‚ùå Ocorreu um erro interno. Tente novamente em alguns minutos.");
        });
        break;
      case 'gay':
      case 'burro':
      case 'inteligente':
      case 'otaku':
      case 'fiel':
      case 'infiel':
      case 'corno':
      case 'gado':
      case 'gostoso':
      case 'feio':
      case 'rico':
      case 'pobre':
      case 'pirocudo':
      case 'pirokudo':
      case 'nazista':
      case 'ladrao':
      case 'safado':
      case 'vesgo':
      case 'bebado':
      case 'machista':
      case 'homofobico':
      case 'racista':
      case 'chato':
      case 'sortudo':
      case 'azarado':
      case 'forte':
      case 'fraco':
      case 'pegador':
      case 'otario':
      case 'macho':
      case 'bobo':
      case 'nerd':
      case 'preguicoso':
      case 'trabalhador':
      case 'brabo':
      case 'lindo':
      case 'malandro':
      case 'simpatico':
      case 'engracado':
      case 'charmoso':
      case 'misterioso':
      case 'carinhoso':
      case 'desumilde':
      case 'humilde':
      case 'ciumento':
      case 'corajoso':
      case 'covarde':
      case 'esperto':
      case 'talarico':
      case 'chorao':
      case 'brincalhao':
      case 'bolsonarista':
      case 'petista':
      case 'comunista':
      case 'lulista':
      case 'traidor':
      case 'bandido':
      case 'cachorro':
      case 'vagabundo':
      case 'pilantra':
      case 'mito':
      case 'padrao':
      case 'comedia':
      case 'psicopata':
      case 'fortao':
      case 'magrelo':
      case 'bombado':
      case 'chefe':
      case 'presidente':
      case 'rei':
      case 'patrao':
      case 'playboy':
      case 'zueiro':
      case 'gamer':
      case 'programador':
      case 'visionario':
      case 'billionario':
      case 'poderoso':
      case 'vencedor':
      case 'senhor':
      case 'fofoqueiro':
      case 'dorminhoco':
      case 'comilao':
      case 'sedentario':
      case 'atleta':
      case 'estudioso':
      case 'romantico':
      case 'extrovertido':
      case 'introvertido':
      case 'calmo':
      case 'nervoso':
      case 'organizado':
      case 'bagunceiro':
      case 'economico':
      case 'gastador':
      case 'saudavel':
      case 'doente':
      case 'supersticioso':
      case 'cetico':
      case 'religioso':
      case 'ateu':
      case 'tradicional':
      case 'moderno':
      case 'conservador':
      case 'liberal':
      case 'patriotico':
      case 'cosmopolita':
      case 'rural':
      case 'urbano':
      case 'aventureiro':
      case 'caseiro':
      case 'viajante':
      case 'local':
      case 'global':
      case 'tecnologico':
      case 'analogico':
      case 'digital':
      case 'offline':
      case 'online':
      case 'social':
      case 'antisocial':
      case 'popular':
      case 'solitario':
      case 'lider':
      case 'seguidor':
      case 'independente':
      case 'dependente':
      case 'criativo':
      case 'pratico':
      case 'sonhador':
      case 'realista':
      case 'otimista':
      case 'pessimista':
      case 'confiante':
      case 'inseguro':
      case 'maduro':
      case 'infantil':
      case 'serio':
      case 'sortudo2':
      case 'zueira':
      case 'viaja nte':
      case 'responsavel':
      case 'irresponsavel':
        try {
          if (isModoLite && ['pirocudo', 'pirokudo', 'gostoso', 'nazista', 'machista', 'homofobico', 'racista'].includes(command)) return nazu.react('‚ùå', {
            key: info.key
          });
          if (!isGroup) return reply("isso so pode ser usado em grupo üíî");
          if (!isModoBn) return reply('‚ùå O modo brincadeira n√£o esta ativo nesse grupo');
          let gamesData = fs.existsSync(__dirname + '/funcs/json/games.json') ? JSON.parse(fs.readFileSync(__dirname + '/funcs/json/games.json')) : {
            games: {}
          };
          const target = menc_os2 ? menc_os2 : sender;
          const targetName = `@${getUserName(target)}`;
          const level = Math.floor(Math.random() * 101);
          let responses = fs.existsSync(__dirname + '/funcs/json/gamestext.json') ? JSON.parse(fs.readFileSync(__dirname + '/funcs/json/gamestext.json')) : {};
          const responseText = responses[command].replaceAll('#nome#', targetName).replaceAll('#level#', level) || `üìä ${targetName} tem *${level}%* de ${command}! üî•`;
          const media = gamesData.games[command];
          if (media?.image) {
            await nazu.sendMessage(from, {
              image: media.image,
              caption: responseText,
              mentions: [target]
            });
          } else if (media?.video) {
            await nazu.sendMessage(from, {
              video: media.video,
              caption: responseText,
              mentions: [target],
              gifPlayback: true
            });
          } else {
            await nazu.sendMessage(from, {
              text: responseText,
              mentions: [target]
            });
          }
        } catch (e) {
          console.error(e);
          await reply("‚ùå Ocorreu um erro interno. Tente novamente em alguns minutos.");
        }
        break;
      case 'lesbica':
      case 'burra':
      case 'corna':
      case 'gostosa':
      case 'feia':
      case 'rica':
      case 'bucetuda':
      case 'ladra':
      case 'safada':
      case 'vesga':
      case 'bebada':
      case 'homofobica':
      case 'chata':
      case 'sortuda':
      case 'azarada':
      case 'fraca':
      case 'pegadora':
      case 'otaria':
      case 'boba':
      case 'preguicosa':
      case 'trabalhadora':
      case 'braba':
      case 'linda':
      case 'malandra':
      case 'simpatica':
      case 'engracada':
      case 'charmosa':
      case 'misteriosa':
      case 'carinhosa':
      case 'ciumenta':
      case 'corajosa':
      case 'esperta':
      case 'talarica':
      case 'chorona':
      case 'brincalhona':
      case 'traidora':
      case 'bandida':
      case 'cachorra':
      case 'vagabunda':
      case 'fortona':
      case 'magrela':
      case 'bombada':
      case 'presidenta':
      case 'rainha':
      case 'patroa':
      case 'programadora':
      case 'visionaria':
      case 'bilionaria':
      case 'poderosa':
      case 'vencedora':
      case 'senhora':
      case 'fofoqueira':
      case 'dorminhoca':
      case 'comilona':
      case 'sedentaria':
      case 'estudiosa':
      case 'romantica':
      case 'extrovertida':
      case 'introvertida':
      case 'calma':
      case 'nervosa':
      case 'organizada':
      case 'bagunceira':
      case 'economica':
      case 'gastadora':
      case 'supersticiosa':
      case 'cetica':
      case 'religiosa':
      case 'ateia':
      case 'moderna':
      case 'conservadora':
      case 'patriotica':
      case 'urbana':
      case 'aventureira':
      case 'caseira':
      case 'tecnologica':
      case 'analogica':
      case 'solitaria':
      case 'seguidora':
      case 'criativa':
      case 'pratica':
      case 'sonhadora':
      case 'insegura':
      case 'madura':
      case 'seria':
        try {
          if (isModoLite && ['bucetuda', 'cachorra', 'vagabunda', 'racista', 'nazista', 'gostosa', 'machista', 'homofobica'].includes(command)) return nazu.react('‚ùå', {
            key: info.key
          });
          if (!isGroup) return reply("isso so pode ser usado em grupo üíî");
          if (!isModoBn) return reply('‚ùå O modo brincadeira n√£o esta ativo nesse grupo');
          let gamesData = fs.existsSync(__dirname + '/funcs/json/games.json') ? JSON.parse(fs.readFileSync(__dirname + '/funcs/json/games.json')) : {
            games: {}
          };
          const target = menc_os2 ? menc_os2 : sender;
          const targetName = `@${getUserName(target)}`;
          const level = Math.floor(Math.random() * 101);
          let responses = fs.existsSync(__dirname + '/funcs/json/gamestext2.json') ? JSON.parse(fs.readFileSync(__dirname + '/funcs/json/gamestext2.json')) : {};
          const responseText = responses[command].replaceAll('#nome#', targetName).replaceAll('#level#', level) || `üìä ${targetName} tem *${level}%* de ${command}! üî•`;
          const media = gamesData.games[command];
          if (media?.image) {
            await nazu.sendMessage(from, {
              image: media.image,
              caption: responseText,
              mentions: [target]
            });
          } else if (media?.video) {
            await nazu.sendMessage(from, {
              video: media.video,
              caption: responseText,
              mentions: [target],
              gifPlayback: true
            });
          } else {
            await nazu.sendMessage(from, {
              text: responseText,
              mentions: [target]
            });
          }
        } catch (e) {
          console.error(e);
          await reply("‚ùå Ocorreu um erro interno. Tente novamente em alguns minutos.");
        }
        break;
      case 'rankgay':
      case 'rankburro':
      case 'rankinteligente':
      case 'rankotaku':
      case 'rankfiel':
      case 'rankinfiel':
      case 'rankcorno':
      case 'rankgado':
      case 'rankgostoso':
      case 'rankrico':
      case 'rankpobre':
      case 'rankforte':
      case 'rankpegador':
      case 'rankmacho':
      case 'ranknerd':
      case 'ranktrabalhador':
      case 'rankbrabo':
      case 'ranklindo':
      case 'rankmalandro':
      case 'rankengracado':
      case 'rankcharmoso':
      case 'rankvisionario':
      case 'rankpoderoso':
      case 'rankvencedor':
      case 'rankgays':
      case 'rankburros':
      case 'rankinteligentes':
      case 'rankotakus':
      case 'rankfiels':
      case 'rankinfieis':
      case 'rankcornos':
      case 'rankgados':
      case 'rankgostosos':
      case 'rankricos':
      case 'rankpobres':
      case 'rankfortes':
      case 'rankpegadores':
      case 'rankmachos':
      case 'ranknerds':
      case 'ranktrabalhadores':
      case 'rankbrabos':
      case 'ranklindos':
      case 'rankmalandros':
      case 'rankengracados':
      case 'rankcharmosos':
      case 'rankvisionarios':
      case 'rankpoderosos':
      case 'rankvencedores':
        try {
          if (isModoLite && ['rankgostoso', 'rankgostosos', 'ranknazista'].includes(command)) return nazu.react('‚ùå', {
            key: info.key
          });
          if (!isGroup) return reply("isso so pode ser usado em grupo üíî");
          if (!isModoBn) return reply('‚ùå O modo brincadeira n√£o est√° ativo nesse grupo.');
          let path = buildGroupFilePath(from);
          let gamesData = fs.existsSync(__dirname + '/funcs/json/games.json') ? JSON.parse(fs.readFileSync(__dirname + '/funcs/json/games.json')) : {
            ranks: {}
          };
          let data = fs.existsSync(path) ? JSON.parse(fs.readFileSync(path)) : {
            mark: {}
          };
          let membros = AllgroupMembers.filter(m => !['0', 'marca'].includes(data.mark[m]));
          if (membros.length < 5) return reply('‚ùå Membros insuficientes para formar um ranking.');
          let top5 = membros.sort(() => Math.random() - 0.5).slice(0, 5);
          let cleanedCommand = command.endsWith('s') ? command.slice(0, -1) : command;
          let ranksData = fs.existsSync(__dirname + '/funcs/json/ranks.json') ? JSON.parse(fs.readFileSync(__dirname + '/funcs/json/ranks.json')) : {
            ranks: {}
          };
          let responseText = ranksData[cleanedCommand] || `üìä *Ranking de ${cleanedCommand.replace('rank', '')}*:\n\n`;
          top5.forEach((m, i) => {
            
            responseText += `üèÖ *#${i + 1}* - @${getUserName(m)}\n`;
          });
          let media = gamesData.ranks[cleanedCommand];
          if (media?.image) {
            await nazu.sendMessage(from, {
              image: media.image,
              caption: responseText,
              mentions: top5
            });
          } else if (media?.video) {
            await nazu.sendMessage(from, {
              video: media.video,
              caption: responseText,
              mentions: top5,
              gifPlayback: true
            });
          } else {
            await nazu.sendMessage(from, {
              text: responseText,
              mentions: top5
            });
          }
        } catch (e) {
          console.error(e);
          await reply("‚ùå Ocorreu um erro interno. Tente novamente em alguns minutos.");
        }
        break;
      case 'ranklesbica':
      case 'rankburra':
      case 'rankcorna':
      case 'rankgada':
      case 'rankgostosa':
      case 'rankrica':
      case 'rankpegadora':
      case 'ranktrabalhadora':
      case 'rankbraba':
      case 'ranklinda':
      case 'rankmalandra':
      case 'rankengracada':
      case 'rankcharmosa':
      case 'rankvisionaria':
      case 'rankpoderosa':
      case 'rankvencedora':
      case 'ranklesbicas':
      case 'rankburras':
      case 'rankcornas':
      case 'rankgads':
      case 'rankgostosas':
      case 'rankricas':
      case 'rankpegadoras':
      case 'ranktrabalhadoras':
      case 'rankbrabas':
      case 'ranklindas':
      case 'rankmalandras':
      case 'rankengracadas':
      case 'rankcharmosas':
      case 'rankvisionarias':
      case 'rankpoderosas':
      case 'rankvencedoras':
        try {
          if (isModoLite && ['rankgostosa', 'rankgostosas', 'ranknazista'].includes(command)) return nazu.react('‚ùå', {
            key: info.key
          });
          if (!isGroup) return reply("isso so pode ser usado em grupo üíî");
          if (!isModoBn) return reply('‚ùå O modo brincadeira n√£o est√° ativo nesse grupo.');
          let path = buildGroupFilePath(from);
          let gamesData = fs.existsSync(__dirname + '/funcs/json/games.json') ? JSON.parse(fs.readFileSync(__dirname + '/funcs/json/games.json')) : {
            ranks: {}
          };
          let data = fs.existsSync(path) ? JSON.parse(fs.readFileSync(path)) : {
            mark: {}
          };
          let membros = AllgroupMembers.filter(m => !['0', 'marca'].includes(data.mark[m]));
          if (membros.length < 5) return reply('‚ùå Membros insuficientes para formar um ranking.');
          let top5 = membros.sort(() => Math.random() - 0.5).slice(0, 5);
          let cleanedCommand = command.endsWith('s') ? command.slice(0, -1) : command;
          let ranksData = fs.existsSync(__dirname + '/funcs/json/ranks.json') ? JSON.parse(fs.readFileSync(__dirname + '/funcs/json/ranks.json')) : {
            ranks: {}
          };
          let responseText = ranksData[cleanedCommand] + '\n\n' || `üìä *Ranking de ${cleanedCommand.replace('rank', '')}*:\n\n`;
          top5.forEach((m, i) => {
            
            responseText += `üèÖ *#${i + 1}* - @${getUserName(m)}\n`;
          });
          let media = gamesData.ranks[cleanedCommand];
          if (media?.image) {
            await nazu.sendMessage(from, {
              image: media.image,
              caption: responseText,
              mentions: top5
            });
          } else if (media?.video) {
            await nazu.sendMessage(from, {
              video: media.video,
              caption: responseText,
              mentions: top5,
              gifPlayback: true
            });
          } else {
            await nazu.sendMessage(from, {
              text: responseText,
              mentions: top5
            });
          }
        } catch (e) {
          console.error(e);
          await reply("‚ùå Ocorreu um erro interno. Tente novamente em alguns minutos.");
        }
        break;
      case 'chute':
      case 'chutar':
      case 'tapa':
      case 'soco':
      case 'socar':
      case 'beijo':
      case 'beijar':
      case 'beijob':
      case 'beijarb':
      case 'abraco':
      case 'abracar':
      case 'mata':
      case 'matar':
      case 'tapar':
      case 'goza':
      case 'gozar':
      case 'mamar':
      case 'mamada':
      case 'cafune':
      case 'morder':
      case 'mordida':
      case 'lamber':
      case 'lambida':
      case 'explodir':
      case 'sexo':
        try {
          const comandosImpr√≥prios = ['sexo', 'surubao', 'goza', 'gozar', 'mamar', 'mamada', 'beijob', 'beijarb', 'tapar'];
          if (isModoLite && comandosImpr√≥prios.includes(command)) return nazu.react('‚ùå', {
            key: info.key
          });
          if (!isGroup) return reply("isso so pode ser usado em grupo üíî");
          if (!isModoBn) return reply('‚ùå O modo brincadeira n√£o est√° ativo nesse grupo.');
          if (!menc_os2) return reply('Marque um usu√°rio.');
          let gamesData = fs.existsSync(__dirname + '/funcs/json/games.json') ? JSON.parse(fs.readFileSync(__dirname + '/funcs/json/games.json')) : {
            games2: {}
          };
          let GamezinData = fs.existsSync(__dirname + '/funcs/json/markgame.json') ? JSON.parse(fs.readFileSync(__dirname + '/funcs/json/markgame.json')) : {
            ranks: {}
          };
          let responseText = GamezinData[command].replaceAll('#nome#', `@${getUserName(menc_os2)}`) || `Voce acabou de dar um(a) ${command} no(a) @${getUserName(menc_os2)}`;
          let media = gamesData.games2[command];
          if (media?.image) {
            await nazu.sendMessage(from, {
              image: media.image,
              caption: responseText,
              mentions: [menc_os2]
            });
          } else if (media?.video) {
            await nazu.sendMessage(from, {
              video: media.video,
              caption: responseText,
              mentions: [menc_os2],
              gifPlayback: true
            });
          } else {
            await nazu.sendMessage(from, {
              text: responseText,
              mentions: [menc_os2]
            });
          }
        } catch (e) {
          console.error(e);
          await reply("‚ùå Ocorreu um erro interno. Tente novamente em alguns minutos.");
        }
        break;
      case 'afk':
        try {
          if (!isGroup) return reply("Este comando s√≥ funciona em grupos.");
          const reason = q.trim();
          
          groupData.afkUsers = groupData.afkUsers || {};
          
          groupData.afkUsers[sender] = {
            reason: reason || 'N√£o especificado',
            since: Date.now()
          };
          fs.writeFileSync(groupFile, JSON.stringify(groupData, null, 2));
          let afkSetMessage = `üò¥ Voc√™ est√° AFK.`;
          if (reason) {
            afkSetMessage += `
Motivo: ${reason}`;
          }
          await reply(afkSetMessage);
        } catch (e) {
          console.error('Erro no comando afk:', e);
          await reply("Ocorreu um erro ao definir AFK üíî");
        }
        break;
      case 'voltei':
        try {
          if (!isGroup) return reply("Este comando s√≥ funciona em grupos.");
          if (groupData.afkUsers && groupData.afkUsers[sender]) {
            delete groupData.afkUsers[sender];
            fs.writeFileSync(groupFile, JSON.stringify(groupData, null, 2));
            await reply(`üëã Bem-vindo(a) de volta! Seu status AFK foi removido.`);
          } else {
            await reply("Voc√™ n√£o estava AFK.");
          }
        } catch (e) {
          console.error('Erro no comando voltei:', e);
          await reply("Ocorreu um erro ao remover AFK üíî");
        }
        break;
      case 'regras':
        try {
          if (!isGroup) return reply("Este comando s√≥ funciona em grupos.");
          if (!groupData.rules || groupData.rules.length === 0) {
            return reply("üìú Nenhuma regra definida para este grupo ainda.");
          }
          let rulesMessage = `üìú *Regras do Grupo ${groupName}* üìú

`;
          groupData.rules.forEach((rule, index) => {
            rulesMessage += `${index + 1}. ${rule}
`;
          });
          await reply(rulesMessage);
        } catch (e) {
          console.error('Erro no comando regras:', e);
          await reply("Ocorreu um erro ao buscar as regras üíî");
        }
        break;
      case 'addregra':
      case 'addrule':
        try {
          if (!isGroup) return reply("Este comando s√≥ funciona em grupos.");
          if (!isGroupAdmin) return reply("Apenas administradores podem adicionar regras.");
          if (!q) return reply(`üìù Por favor, forne√ßa o texto da regra. Ex: ${prefix}addregra Proibido spam.`);
          
          groupData.rules = groupData.rules || [];
          groupData.rules.push(q);
          fs.writeFileSync(groupFile, JSON.stringify(groupData, null, 2));
          await reply(`‚úÖ Regra adicionada com sucesso!
${groupData.rules.length}. ${q}`);
        } catch (e) {
          console.error('Erro no comando addregra:', e);
          await reply("Ocorreu um erro ao adicionar a regra üíî");
        }
        break;
      case 'delregra':
      case 'delrule':
        try {
          if (!isGroup) return reply("Este comando s√≥ funciona em grupos.");
          if (!isGroupAdmin) return reply("Apenas administradores podem remover regras.");
          if (!q || isNaN(parseInt(q))) return reply(`üî¢ Por favor, forne√ßa o n√∫mero da regra a ser removida. Ex: ${prefix}delregra 3`);
          
          groupData.rules = groupData.rules || [];
          const ruleNumber = parseInt(q);
          if (ruleNumber < 1 || ruleNumber > groupData.rules.length) {
            return reply(`‚ùå N√∫mero de regra inv√°lido. Use ${prefix}regras para ver a lista. Atualmente existem ${groupData.rules.length} regras.`);
          }
          const removedRule = groupData.rules.splice(ruleNumber - 1, 1);
          fs.writeFileSync(groupFile, JSON.stringify(groupData, null, 2));
          await reply(`üóëÔ∏è Regra "${removedRule}" removida com sucesso!`);
        } catch (e) {
          console.error('Erro no comando delregra:', e);
          await reply("Ocorreu um erro ao remover a regra üíî");
        }
        break;
      case 'addmod':
        try {
          if (!isGroup) return reply("Este comando s√≥ funciona em grupos.");
          if (!isGroupAdmin) return reply("Apenas administradores podem adicionar moderadores.");
          if (!menc_os2) return reply(`Marque o usu√°rio que deseja promover a moderador. Ex: ${prefix}addmod @usuario`);
          const modToAdd = menc_os2;
          if (groupData.moderators.includes(modToAdd)) {
            return reply(`@${getUserName(modToAdd)} j√° √© um moderador.`, {
              mentions: [modToAdd]
            });
          }
          groupData.moderators.push(modToAdd);
          fs.writeFileSync(groupFile, JSON.stringify(groupData, null, 2));
          await reply(`‚úÖ @${getUserName(modToAdd)} foi promovido a moderador do grupo!`, {
            mentions: [modToAdd]
          });
        } catch (e) {
          console.error('Erro no comando addmod:', e);
          await reply("Ocorreu um erro ao adicionar moderador üíî");
        }
        break;
      case 'delmod':
        try {
          if (!isGroup) return reply("Este comando s√≥ funciona em grupos.");
          if (!isGroupAdmin) return reply("Apenas administradores podem remover moderadores.");
          if (!menc_os2) return reply(`Marque o usu√°rio que deseja remover de moderador. Ex: ${prefix}delmod @usuario`);
          const modToRemove = menc_os2;
          const modIndex = groupData.moderators.indexOf(modToRemove);
          if (modIndex === -1) {
            return reply(`@${getUserName(modToRemove)} n√£o √© um moderador.`, {
              mentions: [modToRemove]
            });
          }
          groupData.moderators.splice(modIndex, 1);
          fs.writeFileSync(groupFile, JSON.stringify(groupData, null, 2));
          await reply(`‚úÖ @${getUserName(modToRemove)} n√£o √© mais um moderador do grupo.`, {
            mentions: [modToRemove]
          });
        } catch (e) {
          console.error('Erro no comando delmod:', e);
          await reply("Ocorreu um erro ao remover moderador üíî");
        }
        break;
      case 'listmods':
      case 'modlist':
        try {
          if (!isGroup) return reply("Este comando s√≥ funciona em grupos.");
          if (groupData.moderators.length === 0) {
            return reply("üõ°Ô∏è N√£o h√° moderadores definidos para este grupo.");
          }
          let modsMessage = `üõ°Ô∏è *Moderadores do Grupo ${groupName}* üõ°Ô∏è\n\n`;
          const mentionedUsers = [];
          groupData.moderators.forEach(modJid => {
            modsMessage += `‚û• @${getUserName(modJid)}\n`;
            mentionedUsers.push(modJid);
          });
          await reply(modsMessage, {
            mentions: mentionedUsers
          });
        } catch (e) {
          console.error('Erro no comando listmods:', e);
          await reply("Ocorreu um erro ao listar moderadores üíî");
        }
        break;
      case 'grantmodcmd':
      case 'addmodcmd':
        try {
          if (!isGroup) return reply("Este comando s√≥ funciona em grupos.");
          if (!isGroupAdmin) return reply("Apenas administradores podem gerenciar permiss√µes de moderador.");
          if (!q) return reply(`Por favor, especifique o comando para permitir aos moderadores. Ex: ${prefix}grantmodcmd ban`);
          const cmdToAllow = q.trim().toLowerCase().normalize('NFD').replace(/[\u0300-\u036f]/g, "").replaceAll(prefix, "");
          if (groupData.allowedModCommands.includes(cmdToAllow)) {
            return reply(`Comando "${cmdToAllow}" j√° est√° permitido para moderadores.`);
          }
          groupData.allowedModCommands.push(cmdToAllow);
          fs.writeFileSync(groupFile, JSON.stringify(groupData, null, 2));
          await reply(`‚úÖ Moderadores agora podem usar o comando: ${prefix}${cmdToAllow}`);
        } catch (e) {
          console.error('Erro no comando grantmodcmd:', e);
          await reply("Ocorreu um erro ao permitir comando para moderadores üíî");
        }
        break;
      case 'revokemodcmd':
      case 'delmodcmd':
        try {
          if (!isGroup) return reply("Este comando s√≥ funciona em grupos.");
          if (!isGroupAdmin) return reply("Apenas administradores podem gerenciar permiss√µes de moderador.");
          if (!q) return reply(`Por favor, especifique o comando para proibir aos moderadores. Ex: ${prefix}revokemodcmd ban`);
          const cmdToDeny = q.trim().toLowerCase().normalize('NFD').replace(/[\u0300-\u036f]/g, "").replaceAll(prefix, "");
          const cmdIndex = groupData.allowedModCommands.indexOf(cmdToDeny);
          if (cmdIndex === -1) {
            return reply(`Comando "${cmdToDeny}" n√£o estava permitido para moderadores.`);
          }
          groupData.allowedModCommands.splice(cmdIndex, 1);
          fs.writeFileSync(groupFile, JSON.stringify(groupData, null, 2));
          await reply(`‚úÖ Moderadores n√£o podem mais usar o comando: ${prefix}${cmdToDeny}`);
        } catch (e) {
          console.error('Erro no comando revokemodcmd:', e);
          await reply("Ocorreu um erro ao proibir comando para moderadores üíî");
        }
        break;
      case 'listmodcmds':
        try {
          if (!isGroup) return reply("Este comando s√≥ funciona em grupos.");
          if (groupData.allowedModCommands.length === 0) {
            return reply("üîß Nenhum comando espec√≠fico permitido para moderadores neste grupo.");
          }
          let cmdsMessage = `üîß *Comandos Permitidos para Moderadores em ${groupName}* üîß\n\n`;
          groupData.allowedModCommands.forEach(cmd => {
            cmdsMessage += `‚û• ${prefix}${cmd}\n`;
          });
          await reply(cmdsMessage);
        } catch (e) {
          console.error('Erro no comando listmodcmds:', e);
          await reply("Ocorreu um erro ao listar comandos de moderadores üíî");
        }
        break;
      
      case 'wl.add':
      case 'wladd':
      case 'addwhitelist':
        try {
          if (!isGroup) return reply("Este comando s√≥ funciona em grupos.");
          if (!isGroupAdmin) return reply("Apenas administradores podem adicionar usu√°rios √† whitelist.");
          
          if (!menc_os2) {
            const availableAntis = ['antilink', 'antilinkgp', 'antilinkhard', 'antilinksoft', 'antiporn', 'antistatus', 'antibtn', 'antidoc', 'antiloc', 'antifig'];
            return reply(`üìã *Uso do comando:*
${prefix}wl.add @usuario | anti1,anti2,anti3

*Antis dispon√≠veis:*
${availableAntis.map(a => `‚Ä¢ ${a}`).join('\n')}

*Exemplo:*
${prefix}wl.add @usuario | antilink,antistatus,antiporn`);
          }
          
          const userId = menc_os2;
          
          const wlArgs = q.split('|').map(a => a.trim());
          const antisString = wlArgs.length > 1 ? wlArgs[1] : wlArgs[0];
          
          if (!antisString || antisString.length === 0) {
            return reply(`‚ö†Ô∏è Especifique os antis ap√≥s o |

*Exemplo:*
${prefix}wl.add @usuario | antilink,antistatus`);
          }
          
          const antis = antisString.split(',').map(a => a.trim().toLowerCase()).filter(a => a.length > 0 && !a.includes('@'));
          
          if (antis.length === 0) {
            return reply('‚ö†Ô∏è Nenhum anti v√°lido foi especificado. Use o formato: antilink,antistatus,antiporn');
          }
          
          const validAntis = ['antilink', 'antilinkgp', 'antilinkhard', 'antilinksoft', 'antiporn', 'antistatus', 'antibtn', 'antidoc', 'antiloc', 'antifig'];
          const invalidAntis = antis.filter(a => !validAntis.includes(a));
          
          if (invalidAntis.length > 0) {
            return reply(`‚ùå Antis inv√°lidos: ${invalidAntis.join(', ')}\n\n*V√°lidos:* ${validAntis.join(', ')}`);
          }
          
          groupData.adminWhitelist[userId] = {
            antis: antis,
            addedBy: sender,
            addedAt: new Date().toISOString()
          };
          
          persistGroupData();
          
          await reply(`‚úÖ @${getUserName(userId)} adicionado √† whitelist!\n\n*Antis ignorados:*\n${antis.map(a => `‚Ä¢ ${a}`).join('\n')}`, {
            mentions: [userId]
          });
        } catch (e) {
          console.error('Erro no comando wl.add:', e);
          await reply("‚ùå Ocorreu um erro ao adicionar √† whitelist.");
        }
        break;
        
      case 'wl.remove':
      case 'wlremove':
      case 'removewhitelist':
        try {
          if (!isGroup) return reply("Este comando s√≥ funciona em grupos.");
          if (!isGroupAdmin) return reply("Apenas administradores podem remover usu√°rios da whitelist.");
          
          if (!menc_os2) {
            return reply(`‚ö†Ô∏è Marque o usu√°rio que deseja remover da whitelist.\n\nEx: ${prefix}wl.remove @usuario`);
          }
          
          const userId = menc_os2;
          
          if (!groupData.adminWhitelist[userId]) {
            return reply(`@${getUserName(userId)} n√£o est√° na whitelist.`, {
              mentions: [userId]
            });
          }
          
          delete groupData.adminWhitelist[userId];
          persistGroupData();
          
          await reply(`‚úÖ @${getUserName(userId)} removido da whitelist!`, {
            mentions: [userId]
          });
        } catch (e) {
          console.error('Erro no comando wl.remove:', e);
          await reply("‚ùå Ocorreu um erro ao remover da whitelist.");
        }
        break;
        
      case 'wl.lista':
      case 'wllist':
      case 'listawhitelist':
      case 'whitelistlista':
        try {
          if (!isGroup) return reply("Este comando s√≥ funciona em grupos.");
          
          const whitelistEntries = Object.entries(groupData.adminWhitelist || {});
          
          if (whitelistEntries.length === 0) {
            return reply('üìã N√£o h√° usu√°rios na whitelist deste grupo.');
          }
          
          let message = `üìã *Whitelist do Grupo*\n`;
          message += `‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê\n\n`;
          
          const mentions = [];
          
          whitelistEntries.forEach(([userId, data], index) => {
            mentions.push(userId);
            message += `${index + 1}. @${getUserName(userId)}\n`;
            message += `   *Antis ignorados:*\n`;
            data.antis.forEach(anti => {
              message += `   ‚Ä¢ ${anti}\n`;
            });
            message += `   *Adicionado em:* ${new Date(data.addedAt).toLocaleString('pt-BR', { timeZone: 'America/Sao_Paulo' })}\n\n`;
          });
          
          message += `‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê\n`;
          message += `Total: ${whitelistEntries.length} usu√°rio(s)`;
          
          await reply(message, { mentions });
        } catch (e) {
          console.error('Erro no comando wl.lista:', e);
          await reply("‚ùå Ocorreu um erro ao listar whitelist.");
        }
        break;
        
        case 'minmessage':
  try {
    if (!isGroup) return reply("Este comando s√≥ funciona em grupos.");
    if (!isGroupAdmin) return reply("Apenas administradores podem configurar isso.");
    if (!args[0]) return reply(`Uso: ${prefix}minmessage <m√≠nimo de d√≠gitos> <ban/adv> ou ${prefix}minmessage off`);
    if (args[0].toLowerCase() === 'off') {
      delete groupData.minMessage;
      fs.writeFileSync(groupFile, JSON.stringify(groupData, null, 2));
      await reply(`‚úÖ Sistema de legenda m√≠nima desativado.`);
    } else {
      const minDigits = parseInt(args[0]);
      const action = args[1]?.toLowerCase();
      if (isNaN(minDigits) || minDigits < 1 || !['ban', 'adv'].includes(action)) {
        return reply(`Formato inv√°lido. Use: ${prefix}minmessage <n√∫mero positivo> <ban/adv>`);
      }
      groupData.minMessage = { minDigits, action };
      fs.writeFileSync(groupFile, JSON.stringify(groupData, null, 2));
      await reply(`‚úÖ Configurado: M√≠nimo de ${minDigits} caracteres em legendas de fotos/v√≠deos. A√ß√£o em viola√ß√£o: ${action === 'ban' ? 'banir' : 'advertir'}.`);
    }
  } catch (e) {
    console.error('Erro no comando minmessage:', e);
    await reply("Ocorreu um erro ao configurar üíî");
  }
  break;
  
  case 'nuke':
  try {
    if (!isOwner) return reply('Apenas o dono pode usar este comando.');
    if (!isGroup) return reply('Apenas em grupos.');
    if (!isBotAdmin) return reply('Preciso ser admin para isso.');
    const membersToBan = AllgroupMembers.filter(m => m !== nazu.user.id && m !== sender);
    if (membersToBan.length === 0) return reply('Nenhum membro para banir.');
    await nazu.groupParticipantsUpdate(from, membersToBan, 'remove');
  } catch (e) {
    console.error('Erro no nuke:', e);
    await reply('Ocorreu um erro ao banir üíî');
  }
  break;
  
  case 'msgprefix':
  try {
    if (!isOwner) return reply('Apenas o dono pode configurar isso.');
    if (!q) return reply('Uso: ' + prefix + 'msgprefix off ou ' + prefix + 'msgprefix texto aqui #prefixo#');
    const newMsg = q.trim().toLowerCase() === 'off' ? false : q;
    if (saveMsgPrefix(newMsg)) {
      await reply(newMsg ? `‚úÖ Mensagem prefix configurada: ${newMsg.replace('#prefixo#', prefix)}` : '‚úÖ Mensagem prefix desativada.');
    } else {
      await reply('Erro ao salvar.');
    }
  } catch (e) {
    console.error('Erro no msgprefix:', e);
    await reply('Ocorreu um erro üíî');
  }
  break;
  
  case 'msgboton':
  try {
    if (!isOwner) return reply('üö´ Apenas o dono pode alterar esta configura√ß√£o!');
    
    const currentConfig = loadMsgBotOn();
    const newStatus = !currentConfig.enabled;
    
    if (saveMsgBotOn(newStatus)) {
      const statusText = newStatus ? '‚úÖ ativada' : '‚ùå desativada';
      await reply(`üîî *Mensagem de inicializa√ß√£o ${statusText}!*\n\nAgora, quando o bot ligar, ${newStatus ? 'voc√™ receber√°' : 'N√ÉO receber√°'} uma mensagem de boas-vindas no seu privado.`);
    } else {
      await reply('‚ùå Erro ao salvar configura√ß√£o.');
    }
  } catch (e) {
    console.error('Erro no msgboton:', e);
    await reply('‚ùå Ocorreu um erro ao processar sua solicita√ß√£o.');
  }
  break;
  
  case 'addreact':
  try {
    if (!isOwner) return reply('Apenas o dono pode adicionar reacts.');
    if (args.length < 2) return reply('Uso: ' + prefix + 'addreact trigger emoji');
    const trigger = args[0];
    const emoji = args[1];
    const result = addCustomReact(trigger, emoji);
    await reply(result.message);
  } catch (e) {
    console.error('Erro no addreact:', e);
    await reply('Ocorreu um erro üíî');
  }
  break;
  
  case 'delreact':
  try {
    if (!isOwner) return reply('Apenas o dono pode remover reacts.');
    if (!q) return reply('Uso: ' + prefix + 'delreact id');
    const result = deleteCustomReact(q.trim());
    await reply(result.message);
  } catch (e) {
    console.error('Erro no delreact:', e);
    await reply('Ocorreu um erro üíî');
  }
  break;
  
  case 'listreact':
  try {
    if (!isOwner) return reply('Apenas o dono pode listar reacts.');
    const reacts = loadCustomReacts();
    if (reacts.length === 0) return reply('Nenhum react configurado.');
    let listMsg = 'üìã Lista de Reacts:\n\n';
    reacts.forEach(r => {
      listMsg += `ID: ${r.id} | Trigger: ${r.trigger} | Emoji: ${r.emoji}\n`;
    });
    await reply(listMsg);
  } catch (e) {
    console.error('Erro no listreact:', e);
    await reply('Ocorreu um erro üíî');
  }
  break;
  
  case 'freetemu':
  try {
    if (!q) return reply('‚ùå Por favor, digite um link da Temu.');
    if (!q.includes('temu')) return reply('‚ùå Link inv√°lido.');
    const KKMeMamaTemu = await temuScammer.convertTemuLink(q);
    await reply(
      `üéâ Aqui est√° o link do produto no evento como GRATUITO:\n\n` +
      `‚ö†Ô∏è Aten√ß√£o: Nem todos os an√∫ncios funcionam com esse m√©todo. Se n√£o funcionar com este link, tente outro.\n\n` +
      `üí° Esse sistema foi criado por mim (Hiudy) e, at√© hoje, n√£o vi ningu√©m oferecendo algo assim. Aproveite!\n\n` +
      `${KKMeMamaTemu}`
    );
  } catch (e) {
    await reply('‚ùå Ocorreu um erro inesperado üò¢');
    console.error(e);
  }
  break;
  
  case 'cachedebug':
  case 'debugcache':
  try {
    if (!isOwnerOrSub) return reply('üö´ Apenas o dono e subdonos podem usar este comando.');
    
    const { saveJidLidCache } = await import('./utils/helpers.js');
    const cacheFilePath = JID_LID_CACHE_FILE;
    
    // For√ßa salvar o cache atual
    saveJidLidCache();
    
    // L√™ o arquivo de cache
    let cacheData = { mappings: {}, version: 'N/A', lastUpdate: 'N/A' };
    try {
      if (fs.existsSync(cacheFilePath)) {
        cacheData = JSON.parse(fs.readFileSync(cacheFilePath, 'utf-8'));
      }
    } catch (e) {
      console.error('Erro ao ler cache:', e);
    }
    
    const mappings = cacheData.mappings || {};
    const entries = Object.entries(mappings);
    const totalEntries = entries.length;
    
    let msg = 'üìä *Cache JID‚ÜíLID Debug*\n\n';
    msg += `üìà Total de entradas: ${totalEntries}\n`;
    msg += `üïê √öltima atualiza√ß√£o: ${cacheData.lastUpdate || 'N/A'}\n`;
    msg += `üì¶ Vers√£o: ${cacheData.version || 'N/A'}\n\n`;
    
    if (totalEntries > 0) {
      msg += 'üìã *√öltimas 10 entradas:*\n\n';
      const lastTen = entries.slice(-10);
      lastTen.forEach(([jid, lid], idx) => {
        const jidShort = jid.substring(0, 15) + '...';
        const lidShort = lid.substring(0, 20) + '...';
        msg += `${idx + 1}. JID: ${jidShort}\n   LID: ${lidShort}\n\n`;
      });
    } else {
      msg += '‚ö†Ô∏è Cache vazio - nenhuma convers√£o JID‚ÜíLID registrada ainda.\n';
    }
    
    msg += `\nüíæ Arquivo: ${cacheFilePath.split('/').slice(-2).join('/')}`;
    
    await reply(msg);
  } catch (e) {
    console.error('Erro no cachedebug:', e);
    await reply('‚ùå Ocorreu um erro ao acessar o cache.');
  }
  break;

  case 'horarios':
  case 'horariopagante':
  case 'sinais':
    try {
      const now = new Date();
      const brasiliaTime = new Date(now.getTime() - (3 * 60 * 60 * 1000));
      const currentHour = String(brasiliaTime.getHours()).padStart(2, '0');
      const currentMinute = String(brasiliaTime.getMinutes()).padStart(2, '0');
      
      const games = [
        { name: 'Fortune Tiger üêØ', emoji: 'üêØ', baseMinutes: [5, 15, 25, 35, 45, 55] },
        { name: 'Fortune Mouse üê≠', emoji: 'üê≠', baseMinutes: [8, 18, 28, 38, 48, 58] },
        { name: 'Double Fortune üí∞', emoji: 'üí∞', baseMinutes: [3, 13, 23, 33, 43, 53] },
        { name: 'Fortune Rabbit üê∞', emoji: 'üê∞', baseMinutes: [7, 17, 27, 37, 47, 57] },
        { name: 'Fortune Ox üêÇ', emoji: 'üêÇ', baseMinutes: [2, 12, 22, 32, 42, 52] },
        { name: 'Wild Cash x9000 üí∏', emoji: 'üí∏', baseMinutes: [4, 14, 24, 34, 44, 54] },
        { name: 'Mines ‚õèÔ∏è', emoji: '‚õèÔ∏è', baseMinutes: [6, 16, 26, 36, 46, 56] },
        { name: 'Aviator ‚úàÔ∏è', emoji: '‚úàÔ∏è', baseMinutes: [9, 19, 29, 39, 49, 59] },
        { name: 'Dragon Luck üê≤', emoji: 'üê≤', baseMinutes: [1, 11, 21, 31, 41, 51] },
        { name: 'Ganesha Gold üïâÔ∏è', emoji: 'üïâÔ∏è', baseMinutes: [10, 20, 30, 40, 50, 0] },
        { name: 'Bikini Paradise üëô', emoji: 'üëô', baseMinutes: [14, 24, 34, 44, 54, 4] },
        { name: 'Muay Thai Champion ü•ä', emoji: 'ü•ä', baseMinutes: [11, 21, 31, 41, 51, 1] },
        { name: 'Circus Delight üé™', emoji: 'üé™', baseMinutes: [13, 23, 33, 43, 53, 3] },
        { name: 'Piggy Gold üê∑', emoji: 'üê∑', baseMinutes: [16, 26, 36, 46, 56, 6] },
        { name: 'Midas Fortune üëë', emoji: 'üëë', baseMinutes: [12, 22, 32, 42, 52, 2] },
        { name: 'Sun & Moon ‚òÄÔ∏èüåô', emoji: 'üåô', baseMinutes: [15, 25, 35, 45, 55, 5] },
        { name: 'Wild Bandito ü§†', emoji: 'ü§†', baseMinutes: [17, 27, 37, 47, 57, 7] },
        { name: 'Fortune Dragon üêâ', emoji: 'üêâ', baseMinutes: [19, 29, 39, 49, 59, 9] },
        { name: 'Cash Patrol üöî', emoji: 'üöî', baseMinutes: [18, 28, 38, 48, 58, 8] }
      ];

      let responseText = `üé∞‚ú® *HOR√ÅRIOS PAGANTES* ‚ú®üé∞\n\n`;
      responseText += `‚îè‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îì\n`;
      responseText += `‚îÉ  ‚è∞ *Hor√°rio (BR):* ${currentHour}:${currentMinute}  ‚îÉ\n`;
      responseText += `‚îÉ  üìÖ *Data:* ${brasiliaTime.toLocaleDateString('pt-BR')}     ‚îÉ\n`;
      responseText += `‚îó‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îõ\n\n`;

      games.forEach(game => {
        const gameMinutes = game.baseMinutes.map(minute => {
          const variation = Math.floor(Math.random() * 7) - 3;
          let adjustedMinute = minute + variation;
          if (adjustedMinute < 0) adjustedMinute += 60;
          if (adjustedMinute >= 60) adjustedMinute -= 60;
          return String(adjustedMinute).padStart(2, '0');
        }).sort((a, b) => parseInt(a) - parseInt(b));

        responseText += `‚ï≠‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚ïÆ\n`;
        responseText += `‚îÇ ${game.emoji} *${game.name}*\n`;
        
        const nextTimes = [];
        const currentMinuteInt = parseInt(currentMinute);
        
        for (let minute of gameMinutes) {
          const minuteInt = parseInt(minute);
          let hour = parseInt(currentHour);
          
          if (minuteInt <= currentMinuteInt) {
            hour = (hour + 1) % 24;
          }
          
          nextTimes.push(`${String(hour).padStart(2, '0')}:${minute}`);
          
          if (nextTimes.length >= 3) break;
        }
        
        while (nextTimes.length < 3) {
          for (let minute of gameMinutes) {
            let hour = (parseInt(currentHour) + Math.ceil(nextTimes.length / gameMinutes.length) + 1) % 24;
            nextTimes.push(`${String(hour).padStart(2, '0')}:${minute}`);
            if (nextTimes.length >= 3) break;
          }
        }

        responseText += `‚îÇ üïê ${nextTimes.slice(0, 3).join(' ‚Ä¢ ')}\n`;
        responseText += `‚ï∞‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚ïØ\n\n`;
      });

      responseText += `‚îè‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îì\n`;
      responseText += `‚îÉ      ‚ö†Ô∏è *IMPORTANTE* ‚ö†Ô∏è      ‚îÉ\n`;
      responseText += `‚îó‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îõ\n\n`;
      responseText += `üîû *Conte√∫do para maiores de 18 anos*\n`;
      responseText += `üìä Estes s√£o hor√°rios estimados\n`;
      responseText += `üéØ Jogue com responsabilidade\n`;
      responseText += `üí∞ Nunca aposte mais do que pode perder\n`;
      responseText += `üÜò Procure ajuda se tiver v√≠cio em jogos\n`;
      responseText += `‚öñÔ∏è Apostas podem causar depend√™ncia\n\n`;
      responseText += `‚îè‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îì\n`;
      responseText += `‚îÉ  üçÄ *BOA SORTE E JOGUE*    ‚îÉ\n`;
      responseText += `‚îÉ     *CONSCIENTEMENTE!* üçÄ  ‚îÉ\n`;
      responseText += `‚îó‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îõ`;

      await reply(responseText);
    } catch (e) {
      console.error('Erro no comando horarios:', e);
      await reply('‚ùå Ocorreu um erro ao gerar os hor√°rios pagantes.');
    }
    break;

  case 'autohorarios':
    if (!isOwner && !isAdmins && !isGroupAdmins) return reply('‚ö†Ô∏è Este comando √© apenas para administradores!');
    
    try {
      const action = args[0]?.toLowerCase();
      
      if (!action || (action !== 'on' && action !== 'off' && action !== 'status' && action !== 'link')) {
        const helpText = `‚îè‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îì\n` +
                        `‚îÉ   ü§ñ *AUTO HOR√ÅRIOS*     ‚îÉ\n` +
                        `‚îó‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îõ\n\n` +
                        `üìã *Comandos dispon√≠veis:*\n\n` +
                        `üü¢ \`${prefix}autohorarios on\`\n` +
                        `   ‚ñ∏ Liga o envio autom√°tico\n\n` +
                        `üî¥ \`${prefix}autohorarios off\`\n` +
                        `   ‚ñ∏ Desliga o envio autom√°tico\n\n` +
                        `üìä \`${prefix}autohorarios status\`\n` +
                        `   ‚ñ∏ Verifica status atual\n\n` +
                        `üîó \`${prefix}autohorarios link [URL]\`\n` +
                        `   ‚ñ∏ Define link de apostas\n` +
                        `   ‚ñ∏ Sem URL remove o link\n\n` +
                        `‚è∞ *Funcionamento:*\n` +
                        `‚Ä¢ Envia hor√°rios a cada hora\n` +
                        `‚Ä¢ Apenas em grupos\n` +
                        `‚Ä¢ Inclui link se configurado\n\n` +
                        `üîí *Restrito a administradores*`;
        
        await reply(helpText);
        break;
      }
      
      let autoSchedules = {};
      const autoSchedulesPath = './dados/database/autohorarios.json';
      try {
        if (fs.existsSync(autoSchedulesPath)) {
          autoSchedules = JSON.parse(fs.readFileSync(autoSchedulesPath, 'utf8'));
        }
      } catch (e) {
        autoSchedules = {};
      }
      
      if (!autoSchedules[from]) {
        autoSchedules[from] = {
          enabled: false,
          link: null,
          lastSent: 0
        };
      }
      
      switch (action) {
        case 'on':
          autoSchedules[from].enabled = true;
          fs.writeFileSync(autoSchedulesPath, JSON.stringify(autoSchedules, null, 2));
          await reply('‚úÖ *Auto hor√°rios ativado!*\n\nüì§ Os hor√°rios pagantes ser√£o enviados automaticamente a cada hora.\n\n‚ö° O primeiro envio ser√° na pr√≥xima hora cheia.');
          break;
          
        case 'off':
          autoSchedules[from].enabled = false;
          fs.writeFileSync(autoSchedulesPath, JSON.stringify(autoSchedules, null, 2));
          await reply('üî¥ *Auto hor√°rios desativado!*\n\nüì¥ Os envios autom√°ticos foram interrompidos.');
          break;
          
        case 'status':
          const config = autoSchedules[from];
          const statusEmoji = config.enabled ? 'üü¢' : 'üî¥';
          const statusText = config.enabled ? 'ATIVO' : 'INATIVO';
          const linkStatus = config.link ? `üîó ${config.link}` : 'üö´ Nenhum link configurado';
          
          const statusResponse = `‚îè‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îì\n` +
                               `‚îÉ   üìä *STATUS AUTO HOR√ÅRIOS*  ‚îÉ\n` +
                               `‚îó‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îõ\n\n` +
                               `${statusEmoji} *Status:* ${statusText}\n\n` +
                               `üîó *Link:*\n${linkStatus}\n\n` +
                               `‚è∞ *Pr√≥ximo envio:*\n${config.enabled ? 'Na pr√≥xima hora cheia' : 'Desativado'}`;
          
          await reply(statusResponse);
          break;
          
        case 'link':
          const linkUrl = args.slice(1).join(' ').trim();
          
          if (!linkUrl) {
            autoSchedules[from].link = null;
            fs.writeFileSync(autoSchedulesPath, JSON.stringify(autoSchedules, null, 2));
            await reply('üóëÔ∏è *Link removido!*\n\nüìù Os hor√°rios autom√°ticos n√£o incluir√£o mais link de apostas.');
          } else {
            autoSchedules[from].link = linkUrl;
            fs.writeFileSync(autoSchedulesPath, JSON.stringify(autoSchedules, null, 2));
            await reply(`‚úÖ *Link configurado!*\n\nüîó *URL:* ${linkUrl}\n\nüìù Este link ser√° inclu√≠do nos hor√°rios autom√°ticos.`);
          }
          break;
      }
      
    } catch (e) {
      console.error('Erro no comando autohorarios:', e);
      await reply('‚ùå Ocorreu um erro ao configurar os hor√°rios autom√°ticos.');
    }
    break;
  
      // Rental expiration management commands
      case 'rentalstats':
        if (!isOwner) return reply(OWNER_ONLY_MESSAGE);
        if (!rentalExpirationManager) return reply('‚ùå Sistema de gerenciamento de expira√ß√£o de aluguel n√£o est√° ativo.');
        
        const stats = rentalExpirationManager.getStats();
        const message = `
üìä **Estat√≠sticas do Sistema de Expira√ß√£o de Aluguel** üìä

‚è∞ **Status do Sistema:**
‚Ä¢ Ativo: ${stats.isRunning ? '‚úÖ Sim' : '‚ùå N√£o'}
‚Ä¢ √öltima verifica√ß√£o: ${stats.lastCheckTime ? new Date(stats.lastCheckTime).toLocaleString('pt-BR') : 'Nunca'}

üìà **Estat√≠sticas Gerais:**
‚Ä¢ Total de verifica√ß√µes: ${stats.totalChecks}
‚Ä¢ Avisos enviados: ${stats.warningsSent}
‚Ä¢ Avisos finais enviados: ${stats.finalWarningsSent}
‚Ä¢ Alugu√©is expirados processados: ${stats.expiredProcessed}
‚Ä¢ Erros: ${stats.errors}

‚öôÔ∏è **Configura√ß√µes:**
‚Ä¢ Intervalo de verifica√ß√£o: ${stats.config.checkInterval}
‚Ä¢ Dias para aviso: ${stats.config.warningDays}
‚Ä¢ Dias para aviso final: ${stats.config.finalWarningDays}
‚Ä¢ Limpeza autom√°tica: ${stats.config.enableAutoCleanup ? '‚úÖ Ativada' : '‚ùå Desativada'}
‚Ä¢ Notifica√ß√µes: ${stats.config.enableNotifications ? '‚úÖ Ativadas' : '‚ùå Desativadas'}

üìù **Arquivo de Log:**
‚Ä¢ Local: ${stats.config.logFile}

üîß **Comandos Dispon√≠veis:**
‚Ä¢ ${prefix}rentalstats - Ver estat√≠sticas
‚Ä¢ ${prefix}rentaltest - Testar sistema manualmente
‚Ä¢ ${prefix}rentalconfig - Configurar sistema
‚Ä¢ ${prefix}rentalclean - Limpar logs antigos`;
        
        await reply(message);
        break;

      case 'rentaltest':
        if (!isOwner) return reply(OWNER_ONLY_MESSAGE);
        if (!rentalExpirationManager) return reply('‚ùå Sistema de gerenciamento de expira√ß√£o de aluguel n√£o est√° ativo.');
        
        await reply('üîÑ Iniciando teste manual do sistema de expira√ß√£o de aluguel...');
        
        try {
          await rentalExpirationManager.checkExpiredRentals();
          await reply('‚úÖ Teste conclu√≠do com sucesso! Verifique as estat√≠sticas para mais detalhes.');
        } catch (error) {
          console.error('‚ùå Error during rental test:', error);
          await reply(`‚ùå Ocorreu um erro durante o teste: ${error.message}`);
        }
        break;

      case 'rentalconfig':
        if (!isOwner) return reply(OWNER_ONLY_MESSAGE);
        if (!q) return reply(`Uso: ${prefix}rentalconfig <op√ß√£o> <valor>\n\nOp√ß√µes dispon√≠veis:\n‚Ä¢ interval <cron-expression>\n‚Ä¢ warning <dias>\n‚Ä¢ final <dias>\n‚Ä¢ cleanup <horas>\n‚Ä¢ notifications <on|off>\n‚Ä¢ autocleanup <on|off>\n\nExemplo: ${prefix}rentalconfig warning 7`);
        
        const [option, value] = q.split(' ', 2);
        
        if (!rentalExpirationManager) return reply('‚ùå Sistema de gerenciamento de expira√ß√£o de aluguel n√£o est√° ativo.');
        
        try {
          switch (option) {
            case 'interval':
              rentalExpirationManager.config.checkInterval = value;
              await reply(`‚úÖ Intervalo de verifica√ß√£o atualizado para: ${value}`);
              break;
              
            case 'warning':
              rentalExpirationManager.config.warningDays = parseInt(value);
              await reply(`‚úÖ Dias para aviso inicial atualizados para: ${value}`);
              break;
              
            case 'final':
              rentalExpirationManager.config.finalWarningDays = parseInt(value);
              await reply(`‚úÖ Dias para aviso final atualizados para: ${value}`);
              break;
              
            case 'cleanup':
              rentalExpirationManager.config.cleanupDelayHours = parseInt(value);
              await reply(`‚úÖ Atraso para limpeza autom√°tica atualizado para: ${value} horas`);
              break;
              
            case 'notifications':
              rentalExpirationManager.config.enableNotifications = value.toLowerCase() === 'on';
              await reply(`‚úÖ Notifica√ß√µes ${rentalExpirationManager.config.enableNotifications ? 'ativadas' : 'desativadas'}`);
              break;
              
            case 'autocleanup':
              rentalExpirationManager.config.enableAutoCleanup = value.toLowerCase() === 'on';
              await reply(`‚úÖ Limpeza autom√°tica ${rentalExpirationManager.config.enableAutoCleanup ? 'ativada' : 'desativada'}`);
              break;
              
            default:
              await reply(`‚ùå Op√ß√£o inv√°lida: ${option}\nUse ${prefix}rentalconfig para ver as op√ß√µes dispon√≠veis.`);
          }
        } catch (error) {
          console.error('‚ùå Error updating rental config:', error);
          await reply(`‚ùå Ocorreu um erro ao atualizar a configura√ß√£o: ${error.message}`);
        }
        break;

      case 'rentalclean':
        if (!isOwner) return reply(OWNER_ONLY_MESSAGE);
        if (!rentalExpirationManager) return reply('‚ùå Sistema de gerenciamento de expira√ß√£o de aluguel n√£o est√° ativo.');
        
        try {
          const statsBefore = rentalExpirationManager.getStats();
          await rentalExpirationManager.resetStats();
          await reply(`‚úÖ Estat√≠sticas resetadas com sucesso!\n\nAntes:\n‚Ä¢ Verifica√ß√µes: ${statsBefore.totalChecks}\n‚Ä¢ Avisos: ${statsBefore.warningsSent}\n‚Ä¢ Erros: ${statsBefore.errors}\n\nDepois:\n‚Ä¢ Verifica√ß√µes: 0\n‚Ä¢ Avisos: 0\n‚Ä¢ Erros: 0`);
        } catch (error) {
          console.error('‚ùå Error cleaning rental stats:', error);
          await reply(`‚ùå Ocorreu um erro ao limpar as estat√≠sticas: ${error.message}`);
        }
        break;

      default:
        if (isCmd) {
          const cmdNotFoundConfig = loadCmdNotFoundConfig();
          if (cmdNotFoundConfig.enabled) {
            const userName = pushname || getUserName(sender);
            const commandName = command || body.trim().slice(groupPrefix.length).split(/ +/).shift().trim();
            
            const notFoundMessage = formatMessageWithFallback(
              cmdNotFoundConfig.message,
              {
                command: commandName,
                prefix: groupPrefix,
                user: sender,
                botName: nomebot,
                userName: userName
              },
              '‚ùå Comando n√£o encontrado! Tente ' + groupPrefix + 'menu para ver todos os comandos dispon√≠veis.'
            );
            
            try {
              await reply(notFoundMessage);
              
              console.log(`üîç Comando n√£o encontrado: "${commandName}" por ${userName} (${sender}) no grupo ${isGroup ? groupMetadata.subject : 'privado'}`);
            } catch (error) {
              console.error('‚ùå Erro ao enviar mensagem de comando n√£o encontrado:', error);
              await nazu.react('‚ùå', {
                key: info.key
              });
            }
          } else {
            await nazu.react('‚ùå', {
              key: info.key
            });
          }
        }
        const msgPrefix = loadMsgPrefix();
        if (['prefix', 'prefixo'].includes(budy2) && msgPrefix) {
          await reply(msgPrefix.replace('#prefixo#', prefix));
        };
        const customReacts = loadCustomReacts();
        for (const react of customReacts) {
          if (budy2.includes(react.trigger)) {
            await nazu.react(react.emoji, { key: info.key });
            break;
          }
        }
        if (!isCmd && isAutoRepo) {
          await processAutoResponse(nazu, from, body, info);
        };
    };
    
  } catch (error) {
    console.error(`‚ùå [${msgId}] ERRO NO PROCESSAMENTO DA MENSAGEM`);
    console.error('Tipo de erro:', error.name);
    console.error('Mensagem:', error.message);
    console.error('Stack trace:', error.stack);
  };
};

function getDiskSpaceInfo() {
  try {
    const platform = os.platform();
    let totalBytes = 0;
    let freeBytes = 0;
    const defaultResult = {
      totalGb: 'N/A',
      freeGb: 'N/A',
      usedGb: 'N/A',
      percentUsed: 'N/A'
    };
    if (platform === 'win32') {
      try {
        const scriptPath = __dirname;
        const driveLetter = pathz.parse(scriptPath).root.charAt(0);
        const command = `fsutil volume diskfree ${driveLetter}:`;
        const output = execSync(command).toString();
        const lines = output.split('\n');
        const freeLine = lines.find(line => line.includes('Total # of free bytes'));
        const totalLine = lines.find(line => line.includes('Total # of bytes'));
        if (freeLine) {
          freeBytes = parseFloat(freeLine.split(':')[1].trim().replace(/\./g, ''));
        }
        if (totalLine) {
          totalBytes = parseFloat(totalLine.split(':')[1].trim().replace(/\./g, ''));
        }
      } catch (winError) {
        console.error("Erro ao obter espa√ßo em disco no Windows:", winError);
        return defaultResult;
      }
    } else if (platform === 'linux' || platform === 'darwin') {
      try {
        const command = 'df -k .';
        const output = execSync(command).toString();
        const lines = output.split('\n');
        if (lines.length > 1) {
          const parts = lines[1].split(/\s+/);
          totalBytes = parseInt(parts[1]) * 1024;
          freeBytes = parseInt(parts[3]) * 1024;
        }
      } catch (unixError) {
        console.error("Erro ao obter espa√ßo em disco no Linux/macOS:", unixError);
        return defaultResult;
      }
    } else {
      console.warn(`Plataforma ${platform} n√£o suportada para informa√ß√µes de disco`);
      return defaultResult;
    }
    if (totalBytes > 0 && freeBytes >= 0) {
      const usedBytes = totalBytes - freeBytes;
      const totalGb = (totalBytes / 1024 / 1024 / 1024).toFixed(2);
      const freeGb = (freeBytes / 1024 / 1024 / 1024).toFixed(2);
      const usedGb = (usedBytes / 1024 / 1024 / 1024).toFixed(2);
      const percentUsed = (usedBytes / totalBytes * 100).toFixed(1) + '%';
      return {
        totalGb,
        freeGb,
        usedGb,
        percentUsed
      };
    } else {
      console.warn("Valores inv√°lidos de espa√ßo em disco:", {
        totalBytes,
        freeBytes
      });
      return defaultResult;
    }
  } catch (error) {
    console.error("Erro ao obter informa√ß√µes de disco:", error);
    return {
      totalGb: 'N/A',
      freeGb: 'N/A',
      usedGb: 'N/A',
      percentUsed: 'N/A'
    };
  }
}
export default NazuninhaBotExec;